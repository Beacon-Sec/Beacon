[
    {
        "code": "voidusage(){    error(\"usage: %s -[vq] TIFFfile [rasterfile]\\n\", NULL);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(void){\tint i;\tfor (i = 0; usageMsg[i]; i++)\t\tfprintf(stderr, \"%s\\n\", usageMsg[i]);\texit(-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchAnyArray(TIFF* tif, TIFFDirEntry* dir, double* v){\tint i;\tswitch (dir->tdir_type) {\tcase TIFF_BYTE:\tcase TIFF_SBYTE:\t\tif (!TIFFFetchByteArray(tif, dir, (uint8*) v))\t\t\treturn (0);\t\tif (dir->tdir_type == TIFF_BYTE) {\t\t\tuint8* vp = (uint8*) v;\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\t\t\t\tv[i] = vp[i];\t\t} else {\t\t\tint8* vp = (int8*) v;\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\t\t\t\tv[i] = vp[i];\t\t}\t\tbreak;\tcase TIFF_SHORT:\tcase TIFF_SSHORT:\t\tif (!TIFFFetchShortArray(tif, dir, (uint16*) v))\t\t\treturn (0);\t\tif (dir->tdir_type == TIFF_SHORT) {\t\t\tuint16* vp = (uint16*) v;\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\t\t\t\tv[i] = vp[i];\t\t} else {\t\t\tint16* vp = (int16*) v;\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\t\t\t\tv[i] = vp[i];\t\t}\t\tbreak;\tcase TIFF_LONG:\tcase TIFF_SLONG:\t\tif (!TIFFFetchLongArray(tif, dir, (uint32*) v))\t\t\treturn (0);\t\tif (dir->tdir_type == TIFF_LONG) {\t\t\tuint32* vp = (uint32*) v;\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\t\t\t\tv[i] = vp[i];\t\t} else {\t\t\tint32* vp = (int32*) v;\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\t\t\t\tv[i] = vp[i];\t\t}\t\tbreak;\tcase TIFF_RATIONAL:\tcase TIFF_SRATIONAL:\t\tif (!TIFFFetchRationalArray(tif, dir, (float*) v))\t\t\treturn (0);\t\t{ float* vp = (float*) v;\t\t  for (i = dir->tdir_count-1; i >= 0; i--)\t\t\tv[i] = vp[i];\t\t}\t\tbreak;\tcase TIFF_FLOAT:\t\tif (!TIFFFetchFloatArray(tif, dir, (float*) v))\t\t\treturn (0);\t\t{ float* vp = (float*) v;\t\t  for (i = dir->tdir_count-1; i >= 0; i--)\t\t\tv[i] = vp[i];\t\t}\t\tbreak;\tcase TIFF_DOUBLE:\t\treturn (TIFFFetchDoubleArray(tif, dir, (double*) v));\tdefault:\t\t\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t    \"cannot read TIFF_ANY type %d for field \\\"%s\\\"\",\t\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\t\treturn (0);\t}\treturn (1);}",
        "label": 1,
        "cve": "cve-2006-2024"
    },
    {
        "code": "static void_tiffDummyUnmapProc(thandle_t fd, tdata_t base, toff_t size){}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidsetrow(uint8* row, uint32 nrows, const uint8* rows[]){    uint32 x;    uint32 area = nrows * filterWidth;    for (x = 0; x < tnw; x++) {\tuint32 mask0 = src0[x];\tuint32 fw = src1[x];\tuint32 mask1 = src1[x];\tuint32 off = rowoff[x];\tuint32 acc = 0;\tuint32 y, i;\tfor (y = 0; y < nrows; y++) {\t    const uint8* src = rows[y] + off;\t    acc += bits[*src++ & mask0];\t    switch (fw) {\t    default:\t\tfor (i = fw; i > 8; i--)\t\t    acc += bits[*src++];\t\t\t    case 8: acc += bits[*src++];\t    case 7: acc += bits[*src++];\t    case 6: acc += bits[*src++];\t    case 5: acc += bits[*src++];\t    case 4: acc += bits[*src++];\t    case 3: acc += bits[*src++];\t    case 2: acc += bits[*src++];\t    case 1: acc += bits[*src++];\t    case 0: break;\t    }\t    acc += bits[*src & mask1];\t}\t*row++ = cmap[(255*acc)/area];    }}",
        "label": 1,
        "cve": "cve-2016-3633"
    },
    {
        "code": "voidusage(){\tfprintf(stderr, \"usage: %s [-h] [-o offset] [-m maxitems] file.tif ...\\n\", appname);\texit(-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcheckcmap(TIFF* tif, int n, uint16* r, uint16* g, uint16* b){\twhile (n-- > 0)\t\tif (*r++ >= 256 || *g++ >= 256 || *b++ >= 256)\t\t\treturn (16);\tTIFFWarning(TIFFFileName(tif), \"Assuming 8-bit colormap\");\treturn (8);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidinitCropMasks (struct crop_mask *cps)   {   int i;   cps->crop_mode = CROP_NONE;   cps->res_unit  = RESUNIT_NONE;   cps->edge_ref  = EDGE_TOP;   cps->width = 0;   cps->length = 0;   for (i = 0; i < 4; i++)     cps->margins[i] = 0.0;   cps->bufftotal = (uint32)0;   cps->combined_width = (uint32)0;   cps->combined_length = (uint32)0;   cps->rotation = (uint16)0;   cps->photometric = INVERT_DATA_AND_TAG;   cps->mirror   = (uint16)0;   cps->invert   = (uint16)0;   cps->zones    = (uint32)0;   cps->regions  = (uint32)0;   for (i = 0; i < MAX_REGIONS; i++)     {     cps->corners[i].X1 = 0.0;     cps->corners[i].X2 = 0.0;     cps->corners[i].Y1 = 0.0;     cps->corners[i].Y2 = 0.0;     cps->regionlist[i].x1 = 0;     cps->regionlist[i].x2 = 0;     cps->regionlist[i].y1 = 0;     cps->regionlist[i].y2 = 0;     cps->regionlist[i].width = 0;     cps->regionlist[i].length = 0;     cps->regionlist[i].buffsize = 0;     cps->regionlist[i].buffptr = NULL;     cps->zonelist[i].position = 0;     cps->zonelist[i].total = 0;     }   cps->exp_mode = ONE_FILE_COMPOSITE;   cps->img_mode = COMPOSITE_IMAGES;   }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void*_TIFFmalloc(tmsize_t s){\treturn (malloc((size_t) s));}",
        "label": 1,
        "cve": "CVE-2014-8130"
    },
    {
        "code": "static toff_t_tiffSeekProc(thandle_t fd, toff_t off, int whence){\tlong fpos, size;\tif (GetEOF((short) fd, &size) != noErr)\t\treturn EOF;\t(void) GetFPos((short) fd, &fpos);\tswitch (whence) {\tcase SEEK_CUR:\t\tif (off + fpos > size)\t\t\tSetEOF((short) fd, off + fpos);\t\tif (SetFPos((short) fd, fsFromMark, off) != noErr)\t\t\treturn EOF;\t\tbreak;\tcase SEEK_END:\t\tif (off > 0)\t\t\tSetEOF((short) fd, off + size);\t\tif (SetFPos((short) fd, fsFromStart, off + size) != noErr)\t\t\treturn EOF;\t\tbreak;\tcase SEEK_SET:\t\tif (off > size)\t\t\tSetEOF((short) fd, off);\t\tif (SetFPos((short) fd, fsFromStart, off) != noErr)\t\t\treturn EOF;\t\tbreak;\t}\treturn (toff_t)(GetFPos((short) fd, &fpos) == noErr ? fpos : EOF);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcombineSeparateSamples16bits (uint8 *in[], uint8 *out, uint32 cols,                              uint32 rows, uint16 spp, uint16 bps,  \t                      FILE *dumpfile, int format, int level)  {  int    ready_bits = 0 ;  uint32 src_rowsize, dst_rowsize;   uint32 bit_offset, src_offset;  uint32 row, col, src_byte = 0, src_bit = 0;  uint16 maskbits = 0, matchbits = 0;  uint16 buff1 = 0, buff2 = 0;  uint8  bytebuff = 0;  tsample_t s;  unsigned char *src = in[0];  unsigned char *dst = out;  char           action[8];  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"combineSeparateSamples16bits\",\"Invalid input or output buffer\");    return (1);    }     src_rowsize = ((bps * cols) + 7) / 8;  dst_rowsize = ((bps * cols * spp) + 7) / 8;  maskbits = (uint16)-1 >> (16 - bps);  for (row = 0; row < rows; row++)    {    ready_bits = 0;    buff1 = buff2 = 0;    dst = out + (row * dst_rowsize);    src_offset = row * src_rowsize;    for (col = 0; col < cols; col++)      {            bit_offset = col * bps;      src_byte = bit_offset / 8;      src_bit  = bit_offset % 8;      matchbits = maskbits << (16 - src_bit - bps);       for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)        {\tsrc = in[s] + src_offset + src_byte;        if (little_endian)          buff1 = (src[0] << 8) | src[1];        else          buff1 = (src[1] << 8) | src[0];\tbuff1 = (buff1 & matchbits) << (src_bit);\t\tif (ready_bits >= 8)\t  {\t    bytebuff = (buff2 >> 8);\t    *dst++ = bytebuff;\t    ready_bits -= 8;\t    \t    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\t    strcpy (action, \"Flush\");\t  }\telse\t  { \t    bytebuff = 0;\t    buff2 = (buff2 | (buff1 >> ready_bits));\t    strcpy (action, \"Update\");\t  }\tready_bits += bps;\tif ((dumpfile != NULL) && (level == 3))\t  {\t  dump_info (dumpfile, format, \"\",\t\t       \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\t  dump_short (dumpfile, format, \"Match bits\", matchbits);\t  dump_data  (dumpfile, format, \"Src   bits\", src, 2);\t  dump_short (dumpfile, format, \"Buff1 bits\", buff1);\t  dump_short (dumpfile, format, \"Buff2 bits\", buff2);\t  dump_byte  (dumpfile, format, \"Write byte\", bytebuff);\t  dump_info  (dumpfile, format, \"\",\"Ready bits:  %d, %s\", ready_bits, action); \t  }\t}      }        if (ready_bits > 0)      {      bytebuff = (buff2 >> 8);      *dst++ = bytebuff;      if ((dumpfile != NULL) && (level == 3))\t{\tdump_info (dumpfile, format, \"\",\t\t       \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\t\t       row + 1, col + 1, src_byte, src_bit, dst - out);\tdump_byte (dumpfile, format, \"Final bits\", bytebuff);\t}      }    if ((dumpfile != NULL) && (level == 2))      {      dump_info (dumpfile, format, \"combineSeparateSamples16bits\",\"Output data\");      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));      }    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int dump_buffer (FILE* dumpfile, int format, uint32 rows, uint32 width,                  uint32 row, unsigned char *buff)  {  int j, k;  uint32 i;  unsigned char * dump_ptr;  if (dumpfile == NULL)    {    TIFFError (\"\", \"Invalid FILE pointer for dump file\");    return (1);    }  for (i = 0; i < rows; i++)    {    dump_ptr = buff + (i * width);    if (format == DUMP_TEXT)      dump_info (dumpfile, format, \"\",                  \"Row %4d, %d bytes at offset %d\",\t         row + i + 1, width, row * width);    for (j = 0, k = width; k >= 10; j += 10, k -= 10, dump_ptr += 10)      dump_data (dumpfile, format, \"\", dump_ptr, 10);    if (k > 0)      dump_data (dumpfile, format, \"\", dump_ptr, k);    }  return (0);  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchByteArray(TIFF* tif, TIFFDirEntry* dir, uint16* v){\tif (dir->tdir_count <= 4) {\t\t\t\tif (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {\t\t\tswitch (dir->tdir_count) {\t\t\tcase 4: v[3] = dir->tdir_offset & 0xff;\t\t\tcase 3: v[2] = (dir->tdir_offset >> 8) & 0xff;\t\t\tcase 2: v[1] = (dir->tdir_offset >> 16) & 0xff;\t\t\tcase 1: v[0] = dir->tdir_offset >> 24;\t\t\t}\t\t} else {\t\t\tswitch (dir->tdir_count) {\t\t\tcase 4: v[3] = dir->tdir_offset >> 24;\t\t\tcase 3: v[2] = (dir->tdir_offset >> 16) & 0xff;\t\t\tcase 2: v[1] = (dir->tdir_offset >> 8) & 0xff;\t\t\tcase 1: v[0] = dir->tdir_offset & 0xff;\t\t\t}\t\t}\t\treturn (1);\t} else\t\treturn (TIFFFetchData(tif, dir, (char*) v) != 0);\t}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int  writeCroppedImage(TIFF *in, TIFF *out, struct image_data *image,                   struct dump_opts *dump, uint32 width, uint32 length,                   unsigned char *crop_buff, int pagenum, int total_pages)  {  uint16 bps, spp;  uint16 input_compression, input_photometric;  uint16 input_planar;  struct cpTag* p;  input_compression = image->compression;  input_photometric = image->photometric;  spp = image->spp;  bps = image->bps;  TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);  TIFFSetField(out, TIFFTAG_IMAGELENGTH, length);  TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bps);  TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp);#ifdef DEBUG2  TIFFError(\"writeCroppedImage\", \"Input compression: %s\",\t    (input_compression == COMPRESSION_OJPEG) ? \"Old Jpeg\" :\t    ((input_compression == COMPRESSION_JPEG) ?  \"New Jpeg\" : \"Non Jpeg\"));#endif  if (compression != (uint16)-1)    TIFFSetField(out, TIFFTAG_COMPRESSION, compression);  else    {    if (input_compression == COMPRESSION_OJPEG)      {      compression = COMPRESSION_JPEG;      jpegcolormode = JPEGCOLORMODE_RAW;      TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);      }    else      CopyField(TIFFTAG_COMPRESSION, compression);    }  if (compression == COMPRESSION_JPEG)    {    if ((input_photometric == PHOTOMETRIC_PALETTE) ||          (input_photometric == PHOTOMETRIC_MASK))             {      TIFFError (\"writeCroppedImage\",                 \"JPEG compression cannot be used with %s image data\",      \t        (input_photometric == PHOTOMETRIC_PALETTE) ?                 \"palette\" : \"mask\");      return (-1);      }    if ((input_photometric == PHOTOMETRIC_RGB) &&\t(jpegcolormode == JPEGCOLORMODE_RGB))      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);    else\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);    }  else    {    if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24)      {      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?\t\t\tPHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);      }    else      {      if (input_compression == COMPRESSION_SGILOG ||          input_compression == COMPRESSION_SGILOG24)        {        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?\t\t\t  PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);        }      else        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, image->photometric);      }    }  if (((input_photometric == PHOTOMETRIC_LOGL) ||       (input_photometric ==  PHOTOMETRIC_LOGLUV)) &&      ((compression != COMPRESSION_SGILOG) &&        (compression != COMPRESSION_SGILOG24)))    {    TIFFError(\"writeCroppedImage\",              \"LogL and LogLuv source data require SGI_LOG or SGI_LOG24 compression\");    return (-1);    }  if (fillorder != 0)    TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);  else    CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);    TIFFSetField(out, TIFFTAG_ORIENTATION, image->orientation);    if (outtiled == -1)    outtiled = TIFFIsTiled(in);  if (outtiled) {        if (tilewidth == (uint32) 0)      TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);    if (tilelength == (uint32) 0)      TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);    if (tilewidth == 0 || tilelength == 0)      TIFFDefaultTileSize(out, &tilewidth, &tilelength);    TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);    TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);    } else {       \tif (rowsperstrip == (uint32) 0)          {\t  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))\t    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);          if (compression != COMPRESSION_JPEG)            {  \t    if (rowsperstrip > length)\t      rowsperstrip = length;\t    }\t  }\telse           if (rowsperstrip == (uint32) -1)\t    rowsperstrip = length;\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\t}  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);  if (config != (uint16) -1)    TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);  else    CopyField(TIFFTAG_PLANARCONFIG, config);  if (spp <= 4)    CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);  CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);  switch (compression) {    case COMPRESSION_JPEG:         if (((bps % 8) == 0) || ((bps % 12) == 0))\t   {           TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\t   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);           }         else           {\t   TIFFError(\"writeCroppedImage\",                     \"JPEG compression requires 8 or 12 bits per sample\");           return (-1);           }\t break;   case COMPRESSION_LZW:   case COMPRESSION_ADOBE_DEFLATE:   case COMPRESSION_DEFLATE:\tif (predictor != (uint16)-1)          TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\telse\t  CopyField(TIFFTAG_PREDICTOR, predictor);\tbreak;   case COMPRESSION_CCITTFAX3:   case COMPRESSION_CCITTFAX4:        if (bps != 1)          {\t  TIFFError(\"writeCroppedImage\",            \"Group 3/4 compression is not usable with bps > 1\");          return (-1);\t  }\tif (compression == COMPRESSION_CCITTFAX3) {          if (g3opts != (uint32) -1)\t    TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);\t  else\t    CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\t} else {\t    CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);        }        CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);        CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);        CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);        CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);        CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);        CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);        break;    case COMPRESSION_NONE:         break;    default: break;   }   { uint32 len32;     void** data;     if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))       TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);   }   { uint16 ninks;     const char* inknames;     if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {       TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);       if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {\t int inknameslen = strlen(inknames) + 1;\t const char* cp = inknames;\t while (ninks > 1) {\t   cp = strchr(cp, '\\0');\t   if (cp) {\t     cp++;\t     inknameslen += (strlen(cp) + 1);\t   }\t   ninks--;         }\t TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);       }     }   }   {   unsigned short pg0, pg1;   if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {     TIFFSetField(out, TIFFTAG_PAGENUMBER, pagenum, total_pages);     }   }  for (p = tags; p < &tags[NTAGS]; p++)\t\tCopyTag(p->tag, p->count, p->type);    if (outtiled)    {    if (config == PLANARCONFIG_CONTIG)      {      if (writeBufferToContigTiles (out, crop_buff, length, width, spp, dump))        TIFFError(\"\",\"Unable to write contiguous tile data for page %d\", pagenum);      }    else      {      if (writeBufferToSeparateTiles (out, crop_buff, length, width, spp, dump))        TIFFError(\"\",\"Unable to write separate tile data for page %d\", pagenum);      }    }  else    {    if (config == PLANARCONFIG_CONTIG)      {      if (writeBufferToContigStrips (out, crop_buff, length))        TIFFError(\"\",\"Unable to write contiguous strip data for page %d\", pagenum);      }    else      {      if (writeBufferToSeparateStrips(out, crop_buff, length, width, spp, dump))        TIFFError(\"\",\"Unable to write separate strip data for page %d\", pagenum);      }    }  if (!TIFFWriteDirectory(out))    {    TIFFError(\"\",\"Failed to write IFD for page number %d\", pagenum);    TIFFClose(out);    return (-1);    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPackBitsEncodeChunk(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s){\ttmsize_t rowsize = *(tmsize_t*)tif->tif_data;\twhile (cc > 0) {\t\ttmsize_t chunk = rowsize;\t\t\t\tif( cc < chunk )\t\t    chunk = cc;\t\tif (PackBitsEncode(tif, bp, chunk, s) < 0)\t\t    return (-1);\t\tbp += chunk;\t\tcc -= chunk;\t}\treturn (1);}",
        "label": 1,
        "cve": "CVE-2017-17942"
    },
    {
        "code": "static intTIFFWriteData(TIFF* tif, TIFFDirEntry* dir, char* cp){\ttsize_t cc;\tif (tif->tif_flags & TIFF_SWAB) {\t\tswitch (dir->tdir_type) {\t\tcase TIFF_SHORT:\t\tcase TIFF_SSHORT:\t\t\tTIFFSwabArrayOfShort((uint16*) cp, dir->tdir_count);\t\t\tbreak;\t\tcase TIFF_LONG:\t\tcase TIFF_SLONG:\t\tcase TIFF_FLOAT:\t\t\tTIFFSwabArrayOfLong((uint32*) cp, dir->tdir_count);\t\t\tbreak;\t\tcase TIFF_RATIONAL:\t\tcase TIFF_SRATIONAL:\t\t\tTIFFSwabArrayOfLong((uint32*) cp, 2*dir->tdir_count);\t\t\tbreak;\t\tcase TIFF_DOUBLE:\t\t\tTIFFSwabArrayOfDouble((double*) cp, dir->tdir_count);\t\t\tbreak;\t\t}\t}\tdir->tdir_offset = tif->tif_dataoff;\tcc = dir->tdir_count * TIFFDataWidth(dir->tdir_type);\tif (SeekOK(tif, dir->tdir_offset) &&\t    WriteOK(tif, cp, cc)) {\t\ttif->tif_dataoff += (cc + 1) & ~1;\t\treturn (1);\t}\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error writing data for field \\\"%s\\\"\",\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcpSeparateBufToContigBuf(uint8* out, uint8* in,    uint32 rows, uint32 cols, int outskew, int inskew, tsample_t spp,    int bytes_per_sample){\twhile (rows-- > 0) {\t\tuint32 j = cols;\t\twhile (j-- > 0) {\t\t\tint n = bytes_per_sample;\t\t\twhile( n-- ) {\t\t\t\t*out++ = *in++;\t\t\t}\t\t\tout += (spp-1)*bytes_per_sample;\t\t}\t\tout += outskew;\t\tin += inskew;\t}}",
        "label": 1,
        "cve": "CVE-2018-12900"
    },
    {
        "code": "static toff_t_tiffSizeProc(thandle_t fd){\treturn (lseek((int) fd, SEEK_END, SEEK_SET));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcombineSeparateTileSamples24bits (uint8 *in[], uint8 *out, uint32 cols,                                  uint32 rows, uint32 imagewidth,                                   uint32 tw, uint16 spp, uint16 bps,  \t                          FILE *dumpfile, int format, int level)  {  int    ready_bits = 0;  uint32 src_rowsize, dst_rowsize;   uint32 bit_offset, src_offset;  uint32 row, col, src_byte = 0, src_bit = 0;  uint32 maskbits = 0, matchbits = 0;  uint32 buff1 = 0, buff2 = 0;  uint8  bytebuff1 = 0, bytebuff2 = 0;  tsample_t s;  unsigned char *src = in[0];  unsigned char *dst = out;  char           action[8];  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"combineSeparateTileSamples24bits\",\"Invalid input or output buffer\");    return (1);    }  src_rowsize = ((bps * tw) + 7) / 8;  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;  maskbits =  (uint32)-1 >> ( 32 - bps);  for (row = 0; row < rows; row++)    {    ready_bits = 0;    buff1 = buff2 = 0;    dst = out + (row * dst_rowsize);    src_offset = row * src_rowsize;    for (col = 0; col < cols; col++)      {            bit_offset = col * bps;      src_byte = bit_offset / 8;      src_bit  = bit_offset % 8;      matchbits = maskbits << (32 - src_bit - bps);       for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)        {\tsrc = in[s] + src_offset + src_byte;        if (little_endian)\t  buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];        else\t  buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\tbuff1 = (buff1 & matchbits) << (src_bit);\t\tif (ready_bits >= 16)\t  {\t    bytebuff1 = (buff2 >> 24);\t    *dst++ = bytebuff1;\t    bytebuff2 = (buff2 >> 16);\t    *dst++ = bytebuff2;\t    ready_bits -= 16;\t    \t    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\t    strcpy (action, \"Flush\");\t  }\telse\t  { \t    bytebuff1 = bytebuff2 = 0;\t    buff2 = (buff2 | (buff1 >> ready_bits));\t    strcpy (action, \"Update\");\t  }\tready_bits += bps;\tif ((dumpfile != NULL) && (level == 3))\t  {\t  dump_info (dumpfile, format, \"\",\t\t       \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\t  dump_long (dumpfile, format, \"Match bits \", matchbits);\t  dump_data (dumpfile, format, \"Src   bits \", src, 4);\t  dump_long (dumpfile, format, \"Buff1 bits \", buff1);\t  dump_long (dumpfile, format, \"Buff2 bits \", buff2);\t  dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\t  dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\t  dump_info (dumpfile, format, \"\",\"Ready bits:   %d, %s\", ready_bits, action); \t  }\t}      }        while (ready_bits > 0)      {\tbytebuff1 = (buff2 >> 24);\t*dst++ = bytebuff1;\tbuff2 = (buff2 << 8);\tbytebuff2 = bytebuff1;\tready_bits -= 8;      }    if ((dumpfile != NULL) && (level == 3))      {      dump_info (dumpfile, format, \"\",\t\t   \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\t\t   row + 1, col + 1, src_byte, src_bit, dst - out);      dump_long (dumpfile, format, \"Match bits \", matchbits);      dump_data (dumpfile, format, \"Src   bits \", src, 4);      dump_long (dumpfile, format, \"Buff1 bits \", buff1);      dump_long (dumpfile, format, \"Buff2 bits \", buff2);      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits);       }    if ((dumpfile != NULL) && (level == 2))      {      dump_info (dumpfile, format, \"combineSeparateTileSamples24bits\",\"Output data\");      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));      }    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFmemcpy(void* d, const void* s, tmsize_t c){\tmemcpy(d, s, (size_t) c);}",
        "label": 1,
        "cve": "cve-2016-10269"
    },
    {
        "code": "static int_tiffCloseProc(thandle_t fd){\treturn (close((int) fd));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tsize_t_tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size){\tDWORD dwSizeWritten;\tif (!WriteFile(fd, buf, size, &dwSizeWritten, NULL))\t\treturn(0);\treturn ((tsize_t) dwSizeWritten);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int main(int argc, char** argv){#if !HAVE_DECL_OPTARG\textern char *optarg;\textern int optind;#endif\tconst char *outfilename = NULL;\tT2P *t2p = NULL;\tTIFF *input = NULL, *output = NULL;\tint c, ret = EXIT_SUCCESS;\tt2p = t2p_init();\tif (t2p == NULL){\t\tTIFFError(TIFF2PDF_MODULE, \"Can't initialize context\");\t\tgoto fail;\t}\twhile (argv &&\t       (c = getopt(argc, argv,\t\t\t   \"o:q:u:x:y:w:l:r:p:e:c:a:t:s:k:jzndifbhF\")) != -1){\t\tswitch (c) {\t\t\tcase 'o':\t\t\t\toutfilename = optarg;\t\t\t\tbreak;#ifdef JPEG_SUPPORT\t\t\tcase 'j':  \t\t\t\tt2p->pdf_defaultcompression=T2P_COMPRESS_JPEG;\t\t\t\tbreak;#endif#ifndef JPEG_SUPPORT\t\t\tcase 'j':  \t\t\t\tTIFFWarning(\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\"JPEG support in libtiff required for JPEG compression, ignoring option\");\t\t\t\tbreak;#endif#ifdef ZIP_SUPPORT\t\t\tcase 'z':  \t\t\t\tt2p->pdf_defaultcompression=T2P_COMPRESS_ZIP;\t\t\t\tbreak;#endif#ifndef ZIP_SUPPORT\t\t\tcase 'z':  \t\t\t\tTIFFWarning(\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\"Zip support in libtiff required for Zip compression, ignoring option\");\t\t\t\tbreak;#endif\t\t\tcase 'q': \t\t\t\tt2p->pdf_defaultcompressionquality=atoi(optarg);\t\t\t\tbreak;\t\t\tcase 'n': \t\t\t\tt2p->pdf_nopassthrough=1;\t\t\t\tbreak;\t\t\tcase 'd': \t\t\t\tt2p->pdf_defaultcompression=T2P_COMPRESS_NONE;\t\t\t\tbreak;\t\t\tcase 'u': \t\t\t\tif(optarg[0]=='m'){\t\t\t\t\tt2p->pdf_centimeters=1;\t\t\t\t}\t\t\t\tbreak;\t\t\tcase 'x': \t\t\t\tt2p->pdf_defaultxres = \t\t\t\t\t(float)atof(optarg) / (t2p->pdf_centimeters?2.54F:1.0F);\t\t\t\tbreak;\t\t\tcase 'y': \t\t\t\tt2p->pdf_defaultyres = \t\t\t\t\t(float)atof(optarg) / (t2p->pdf_centimeters?2.54F:1.0F);\t\t\t\tbreak;\t\t\tcase 'w': \t\t\t\tt2p->pdf_overridepagesize=1;\t\t\t\tt2p->pdf_defaultpagewidth = \t\t\t\t\t((float)atof(optarg) * PS_UNIT_SIZE) / (t2p->pdf_centimeters?2.54F:1.0F);\t\t\t\tbreak;\t\t\tcase 'l': \t\t\t\tt2p->pdf_overridepagesize=1;\t\t\t\tt2p->pdf_defaultpagelength = \t\t\t\t\t((float)atof(optarg) * PS_UNIT_SIZE) / (t2p->pdf_centimeters?2.54F:1.0F);\t\t\t\tbreak;\t\t\tcase 'r': \t\t\t\tif(optarg[0]=='o'){\t\t\t\t\tt2p->pdf_overrideres=1;\t\t\t\t}\t\t\t\tbreak;\t\t\tcase 'p': \t\t\t\tif(tiff2pdf_match_paper_size(\t\t\t\t\t&(t2p->pdf_defaultpagewidth), \t\t\t\t\t&(t2p->pdf_defaultpagelength), \t\t\t\t\toptarg)){\t\t\t\t\tt2p->pdf_overridepagesize=1;\t\t\t\t} else {\t\t\t\t\tTIFFWarning(TIFF2PDF_MODULE, \t\t\t\t\t\"Unknown paper size %s, ignoring option\",\t\t\t\t\t\toptarg);\t\t\t\t}\t\t\t\tbreak;\t\t\tcase 'i':\t\t\t\tt2p->pdf_colorspace_invert=1;\t\t\t\tbreak;\t\t\tcase 'F':\t\t\t\tt2p->pdf_image_fillpage = 1;\t\t\t\tbreak;\t\t\tcase 'f': \t\t\t\tt2p->pdf_fitwindow=1;\t\t\t\tbreak;\t\t\tcase 'e':\t\t\t\tif (strlen(optarg) == 0) {\t\t\t\t\tt2p->pdf_datetime[0] = '\\0';\t\t\t\t} else {\t\t\t\t\tt2p->pdf_datetime[0] = 'D';\t\t\t\t\tt2p->pdf_datetime[1] = ':';\t\t\t\t\tstrncpy(t2p->pdf_datetime + 2, optarg,\t\t\t\t\t\tsizeof(t2p->pdf_datetime) - 3);\t\t\t\t\tt2p->pdf_datetime[sizeof(t2p->pdf_datetime) - 1] = '\\0';\t\t\t\t}\t\t\t\tbreak;\t\t\tcase 'c': \t\t\t\tstrncpy(t2p->pdf_creator, optarg, sizeof(t2p->pdf_creator) - 1);\t\t\t\tt2p->pdf_creator[sizeof(t2p->pdf_creator) - 1] = '\\0';\t\t\t\tbreak;\t\t\tcase 'a': \t\t\t\tstrncpy(t2p->pdf_author, optarg, sizeof(t2p->pdf_author) - 1);\t\t\t\tt2p->pdf_author[sizeof(t2p->pdf_author) - 1] = '\\0';\t\t\t\tbreak;\t\t\tcase 't': \t\t\t\tstrncpy(t2p->pdf_title, optarg, sizeof(t2p->pdf_title) - 1);\t\t\t\tt2p->pdf_title[sizeof(t2p->pdf_title) - 1] = '\\0';\t\t\t\tbreak;\t\t\tcase 's': \t\t\t\tstrncpy(t2p->pdf_subject, optarg, sizeof(t2p->pdf_subject) - 1);\t\t\t\tt2p->pdf_subject[sizeof(t2p->pdf_subject) - 1] = '\\0';\t\t\t\tbreak;\t\t\tcase 'k': \t\t\t\tstrncpy(t2p->pdf_keywords, optarg, sizeof(t2p->pdf_keywords) - 1);\t\t\t\tt2p->pdf_keywords[sizeof(t2p->pdf_keywords) - 1] = '\\0';\t\t\t\tbreak;\t\t\tcase 'b':\t\t\t\tt2p->pdf_image_interpolate = 1;\t\t\t\tbreak;\t\t\tcase 'h': \t\t\tcase '?': \t\t\t\ttiff2pdf_usage();\t\t\t\tgoto success;\t\t\t\tbreak;\t\t}\t}\t\tif(argc > optind) {\t\tinput = TIFFOpen(argv[optind++], \"r\");\t\tif (input==NULL) {\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t  \"Can't open input file %s for reading\", \t\t\t\t  argv[optind-1]);\t\t\tgoto fail;\t\t}\t} else {\t\tTIFFError(TIFF2PDF_MODULE, \"No input file specified\"); \t\ttiff2pdf_usage();\t\tgoto fail;\t}\tif(argc > optind) {\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t  \"No support for multiple input files\"); \t\ttiff2pdf_usage();\t\tgoto fail;\t}\t\tt2p->outputdisable = 1;\tif (outfilename) {\t\tt2p->outputfile = fopen(outfilename, \"wb\");\t\tif (t2p->outputfile == NULL) {\t\t\tTIFFError(TIFF2PDF_MODULE,\t\t\t\t  \"Can't open output file %s for writing\",\t\t\t\t  outfilename);\t\t\tgoto fail;\t\t}\t} else {\t\toutfilename = \"-\";\t\tt2p->outputfile = stdout;\t}\toutput = TIFFClientOpen(outfilename, \"w\", (thandle_t) t2p,\t\t\t\tt2p_readproc, t2p_writeproc, t2p_seekproc, \t\t\t\tt2p_closeproc, t2p_sizeproc, \t\t\t\tt2p_mapproc, t2p_unmapproc);\tt2p->outputdisable = 0;\tif (output == NULL) {\t\tTIFFError(TIFF2PDF_MODULE,\t\t\t  \"Can't initialize output descriptor\");\t\tgoto fail;\t}\t\tt2p_validate(t2p);\tt2pSeekFile(output, (toff_t) 0, SEEK_SET);\t\tt2p_write_pdf(t2p, input, output);\tif (t2p->t2p_error != 0) {\t\tTIFFError(TIFF2PDF_MODULE,\t\t\t  \"An error occurred creating output PDF file\");\t\tgoto fail;\t}\tgoto success;fail:\tret = EXIT_FAILURE;success:\tif(input != NULL)\t\tTIFFClose(input);\tif (output != NULL)\t\tTIFFClose(output);\tif (t2p != NULL)\t\tt2p_free(t2p);\treturn ret;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "extern int open(const char* name, int flags, int mode){\t\tos_error* e = (os_error*) 1; \tos_f file = (os_f) -1;\tflags = flags;\tswitch(mode)\t{\t\tcase O_RDONLY:\t\t{\t\t\te = xosfind_openin(SKIP, name, SKIP, &file);\t\t\tbreak;\t\t}\t\tcase O_WRONLY:\t\tcase O_RDWR|O_CREAT:\t\tcase O_RDWR|O_CREAT|O_TRUNC:\t\t{\t\t\te = xosfind_openout(SKIP, name, SKIP, &file);\t\t\tbreak;\t\t}\t\tcase O_RDWR:\t\t{\t\t\te = xosfind_openup(SKIP, name, SKIP, &file);\t\t\tbreak;\t\t}\t}\tif (e)\t{\t\tfile = (os_f) -1;\t}\treturn (file);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFmemset(tdata_t p, int v, size_t c){\tmemset(p, v, (size_t) c);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void*_TIFFCheckRealloc(TIFF* tif, void* buffer,\t\t  tmsize_t nmemb, tmsize_t elem_size, const char* what){\tvoid* cp = NULL;\ttmsize_t bytes = nmemb * elem_size;\t\tif (nmemb && elem_size && bytes / elem_size == nmemb)\t\tcp = _TIFFrealloc(buffer, bytes);\tif (cp == NULL) {\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\t     \"Failed to allocate memory for %s \"\t\t\t     \"(%ld elements of %ld bytes each)\",\t\t\t     what,(long) nmemb, (long) elem_size);\t}\treturn cp;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFmemcpy(tdata_t d, const tdata_t s, tsize_t c){\tmemcpy(d, s, (size_t) c);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int _TIFF_snprintf_f(char* str, size_t size, const char* format, ...){  int count;  va_list ap;  va_start(ap, format);  count = vsnprintf(str, size, format, ap);  va_end(ap);  return count;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intgtStripSeparate(TIFFImageIter* img, void *udata, uint32 w, uint32 h){    TIFF* tif = img->tif;    ImageIterTileSeparateRoutine callback = img->callback.separate;    uint16 orientation;    u_char *buf;    u_char *r, *g, *b, *a;    uint32 row, nrow;    tsize_t scanline;    uint32 rowsperstrip;    uint32 imagewidth = img->width;    tsize_t stripsize;    int32 fromskew;    int alpha = img->alpha;    stripsize = TIFFStripSize(tif);    r = buf = (u_char *)_TIFFmalloc(4*stripsize);    if (buf == 0) {\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for tile buffer\");\treturn (0);    }    g = r + stripsize;    b = g + stripsize;    a = b + stripsize;    if (!alpha)\tmemset(a, 0xff, stripsize);    orientation = img->orientation;    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);    scanline = TIFFScanlineSize(tif);    fromskew = (w < imagewidth ? imagewidth - w : 0);    for (row = 0; row < h; row += rowsperstrip) {\tnrow = (row + rowsperstrip > h ? h - row : rowsperstrip);\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 0),\t    r, nrow*scanline) < 0 && img->stoponerr)\t    break;\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 1),\t    g, nrow*scanline) < 0 && img->stoponerr)\t    break;\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 2),\t    b, nrow*scanline) < 0 && img->stoponerr)\t    break;\tif (alpha &&\t    (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 3),\t    a, nrow*scanline) < 0 && img->stoponerr))\t    break;\t(*callback)(img, udata, 0, row, w, nrow, fromskew, r, g, b, a);    }    _TIFFfree(buf);    return (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int JBIGCopyEncodedData(TIFF* tif, unsigned char* pp, size_t cc, uint16 s){\t(void) s;\twhile (cc > 0)\t{\t\ttmsize_t n = (tmsize_t)cc;\t\tif (tif->tif_rawcc + n > tif->tif_rawdatasize)\t\t{\t\t\tn = tif->tif_rawdatasize - tif->tif_rawcc;\t\t}\t\tassert(n > 0);\t\t_TIFFmemcpy(tif->tif_rawcp, pp, n);\t\ttif->tif_rawcp += n;\t\ttif->tif_rawcc += n;\t\tpp += n;\t\tcc -= (size_t)n;\t\tif (tif->tif_rawcc >= tif->tif_rawdatasize &&\t\t    !TIFFFlushData1(tif))\t\t{\t\t\treturn (-1);\t\t}\t}\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void cleanup_and_exit(void){        TIFFRGBAImageEnd(&img);        if (filelist != NULL)                _TIFFfree(filelist);        if (raster != NULL)                _TIFFfree(raster);        if (tif != NULL)                TIFFClose(tif);        exit(0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intInitCCITTFax3(TIFF* tif){\tFax3BaseState* sp;\t\ttif->tif_data = (tidata_t)\t\t_TIFFmalloc(sizeof (Fax3CodecState));\tif (tif->tif_data == NULL) {\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFInitCCITTFax3\",\t\t    \"%s: No space for state block\", tif->tif_name);\t\treturn (0);\t}\tsp = Fax3State(tif);        sp->rw_mode = tif->tif_mode;\t\t_TIFFMergeFieldInfo(tif, faxFieldInfo, N(faxFieldInfo));\tsp->vgetparent = tif->tif_tagmethods.vgetfield;\ttif->tif_tagmethods.vgetfield = Fax3VGetField; \tsp->vsetparent = tif->tif_tagmethods.vsetfield;\ttif->tif_tagmethods.vsetfield = Fax3VSetField; \ttif->tif_tagmethods.printdir = Fax3PrintDir;   \tsp->groupoptions = 0;\t\tsp->recvparams = 0;\tsp->subaddress = NULL;\tsp->faxdcs = NULL;\tif (sp->rw_mode == O_RDONLY) \t\ttif->tif_flags |= TIFF_NOBITREV; \tDecoderState(tif)->runs = NULL;\tTIFFSetField(tif, TIFFTAG_FAXFILLFUNC, _TIFFFax3fillruns);\tEncoderState(tif)->refline = NULL;\t\ttif->tif_setupdecode = Fax3SetupState;\ttif->tif_predecode = Fax3PreDecode;\ttif->tif_decoderow = Fax3Decode1D;\ttif->tif_decodestrip = Fax3Decode1D;\ttif->tif_decodetile = Fax3Decode1D;\ttif->tif_setupencode = Fax3SetupState;\ttif->tif_preencode = Fax3PreEncode;\ttif->tif_postencode = Fax3PostEncode;\ttif->tif_encoderow = Fax3Encode;\ttif->tif_encodestrip = Fax3Encode;\ttif->tif_encodetile = Fax3Encode;\ttif->tif_close = Fax3Close;\ttif->tif_cleanup = Fax3Cleanup;\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPixarLogSetupDecode(TIFF* tif){\tstatic const char module[] = \"PixarLogSetupDecode\";\tTIFFDirectory *td = &tif->tif_dir;\tPixarLogState* sp = DecoderState(tif);\ttmsize_t tbuf_size;\tassert(sp != NULL);\t\t\t\tif( (sp->state & PLSTATE_INIT) != 0 )\t\treturn 1;\t\ttif->tif_postdecode = _TIFFNoPostDecode;  \t\tsp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?\t    td->td_samplesperpixel : 1);\ttbuf_size = multiply_ms(multiply_ms(multiply_ms(sp->stride, td->td_imagewidth),\t\t\t\t      td->td_rowsperstrip), sizeof(uint16));\t\ttbuf_size = add_ms(tbuf_size, sizeof(uint16) * sp->stride);\tif (tbuf_size == 0)\t\treturn (0);   \tsp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size);\tif (sp->tbuf == NULL)\t\treturn (0);\tsp->tbuf_size = tbuf_size;\tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN)\t\tsp->user_datafmt = PixarLogGuessDataFmt(td);\tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) {                _TIFFfree(sp->tbuf);                sp->tbuf = NULL;                sp->tbuf_size = 0;\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\"PixarLog compression can't handle bits depth/data format combination (depth: %d)\", \t\t\ttd->td_bitspersample);\t\treturn (0);\t}\tif (inflateInit(&sp->stream) != Z_OK) {                _TIFFfree(sp->tbuf);                sp->tbuf = NULL;                sp->tbuf_size = 0;\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s\", sp->stream.msg ? sp->stream.msg : \"(null)\");\t\treturn (0);\t} else {\t\tsp->state |= PLSTATE_INIT;\t\treturn (1);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "uint64_TIFFMultiply64(TIFF* tif, uint64 first, uint64 second, const char* where){\tuint64 bytes = first * second;\tif (second && bytes / second != first) {\t\tTIFFErrorExt(tif->tif_clientdata, where, \"Integer overflow in %s\", where);\t\tbytes = 0;\t}\treturn bytes;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFReadContigStripData(TIFF* tif){\tunsigned char *buf;\ttsize_t scanline = TIFFScanlineSize(tif);\tbuf = (unsigned char *)_TIFFmalloc(TIFFStripSize(tif));\tif (buf) {\t\tuint32 row, h;\t\tuint32 rowsperstrip = (uint32)-1;\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\t\tfor (row = 0; row < h; row += rowsperstrip) {\t\t\tuint32 nrow = (row+rowsperstrip > h ?\t\t\t    h-row : rowsperstrip);\t\t\ttstrip_t strip = TIFFComputeStrip(tif, row, 0);\t\t\tif (TIFFReadEncodedStrip(tif, strip, buf, nrow*scanline) < 0) {\t\t\t\tif (stoponerr)\t\t\t\t\tbreak;\t\t\t} else if (showdata)\t\t\t\tShowStrip(strip, buf, nrow, scanline);\t\t}\t\t_TIFFfree(buf);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff){\tstatic const char module[] = \"TIFFWriteDirectorySec\";\tuint32 ndir;\tTIFFDirEntry* dir;\tuint32 dirsize;\tvoid* dirmem;\tuint32 m;\tif (tif->tif_mode == O_RDONLY)\t\treturn (1);        _TIFFFillStriles( tif );        \t \tif (imagedone)\t{\t\tif (tif->tif_flags & TIFF_POSTENCODE)\t\t{\t\t\ttif->tif_flags &= ~TIFF_POSTENCODE;\t\t\tif (!(*tif->tif_postencode)(tif))\t\t\t{\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\t\t\t\t    \"Error post-encoding before directory write\");\t\t\t\treturn (0);\t\t\t}\t\t}\t\t(*tif->tif_close)(tif);        \t\t \t\tif (tif->tif_rawcc > 0 \t\t    && (tif->tif_flags & TIFF_BEENWRITING) != 0 )\t\t{\t\t    if( !TIFFFlushData1(tif) )                    {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"Error flushing data before directory write\");\t\t\treturn (0);                    }\t\t}\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata)\t\t{\t\t\t_TIFFfree(tif->tif_rawdata);\t\t\ttif->tif_rawdata = NULL;\t\t\ttif->tif_rawcc = 0;\t\t\ttif->tif_rawdatasize = 0;                        tif->tif_rawdataoff = 0;                        tif->tif_rawdataloaded = 0;\t\t}\t\ttif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP);\t}\tdir=NULL;\tdirmem=NULL;\tdirsize=0;\twhile (1)\t{\t\tndir=0;\t\tif (isimage)\t\t{\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGEWIDTH,tif->tif_dir.td_imagewidth))\t\t\t\t\tgoto bad;\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGELENGTH,tif->tif_dir.td_imagelength))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILEWIDTH,tif->tif_dir.td_tilewidth))\t\t\t\t\tgoto bad;\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILELENGTH,tif->tif_dir.td_tilelength))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XRESOLUTION,tif->tif_dir.td_xresolution))\t\t\t\t\tgoto bad;\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YRESOLUTION,tif->tif_dir.td_yresolution))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_POSITION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XPOSITION,tif->tif_dir.td_xposition))\t\t\t\t\tgoto bad;\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YPOSITION,tif->tif_dir.td_yposition))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SUBFILETYPE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_SUBFILETYPE,tif->tif_dir.td_subfiletype))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_BITSPERSAMPLE,tif->tif_dir.td_bitspersample))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_COMPRESSION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_COMPRESSION,tif->tif_dir.td_compression))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PHOTOMETRIC,tif->tif_dir.td_photometric))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_THRESHHOLDING,tif->tif_dir.td_threshholding))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_FILLORDER))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_FILLORDER,tif->tif_dir.td_fillorder))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_ORIENTATION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_ORIENTATION,tif->tif_dir.td_orientation))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_SAMPLESPERPIXEL,tif->tif_dir.td_samplesperpixel))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_ROWSPERSTRIP,tif->tif_dir.td_rowsperstrip))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MINSAMPLEVALUE,tif->tif_dir.td_minsamplevalue))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MAXSAMPLEVALUE,tif->tif_dir.td_maxsamplevalue))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_PLANARCONFIG))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PLANARCONFIG,tif->tif_dir.td_planarconfig))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_RESOLUTIONUNIT,tif->tif_dir.td_resolutionunit))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_PAGENUMBER))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_PAGENUMBER,2,&tif->tif_dir.td_pagenumber[0]))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPBYTECOUNTS))\t\t\t{\t\t\t\tif (!isTiled(tif))\t\t\t\t{\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\t\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\t\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPOFFSETS))\t\t\t{\t\t\t\tif (!isTiled(tif))\t\t\t\t{                                         if (tif->tif_dir.td_stripoffset != NULL &&                        !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))                        goto bad;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\t\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_COLORMAP))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_EXTRASAMPLES))\t\t\t{\t\t\t\tif (tif->tif_dir.td_extrasamples)\t\t\t\t{\t\t\t\t\tuint16 na;\t\t\t\t\tuint16* nb;\t\t\t\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb);\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb))\t\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDEPTH))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_TILEDEPTH,tif->tif_dir.td_tiledepth))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_HALFTONEHINTS,2,&tif->tif_dir.td_halftonehints[0]))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_YCBCRSUBSAMPLING,2,&tif->tif_dir.td_ycbcrsubsampling[0]))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_YCBCRPOSITIONING,tif->tif_dir.td_ycbcrpositioning))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_REFBLACKWHITE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,TIFFTAG_REFERENCEBLACKWHITE,6,tif->tif_dir.td_refblackwhite))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagTransferfunction(tif,&ndir,dir))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_INKNAMES))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir))\t\t\t\t\tgoto bad;\t\t\t}\t\t\t{\t\t\t\tuint32 n;\t\t\t\tfor (n=0; n<tif->tif_nfields; n++) {\t\t\t\t\tconst TIFFField* o;\t\t\t\t\to = tif->tif_fields[n];\t\t\t\t\tif ((o->field_bit>=FIELD_CODEC)&&(TIFFFieldSet(tif,o->field_bit)))\t\t\t\t\t{\t\t\t\t\t\tswitch (o->get_field_type)\t\t\t\t\t\t{\t\t\t\t\t\t\tcase TIFF_SETGET_ASCII:\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tuint32 pa;\t\t\t\t\t\t\t\t\tchar* pb;\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_ASCII);\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE);\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pb);\t\t\t\t\t\t\t\t\tpa=(uint32)(strlen(pb));\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\t\t\t\t\t\t\t\t\t\tgoto bad;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SETGET_UINT16:\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tuint16 p;\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_SHORT);\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p))\t\t\t\t\t\t\t\t\t\tgoto bad;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SETGET_UINT32:\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tuint32 p;\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_LONG);\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p))\t\t\t\t\t\t\t\t\t\tgoto bad;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SETGET_C32_UINT8:\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tuint32 pa;\t\t\t\t\t\t\t\t\tvoid* pb;\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_UNDEFINED);\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE2);\t\t\t\t\t\t\t\t\tassert(o->field_passcount==1);\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pa,&pb);\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\t\t\t\t\t\t\t\t\t\tgoto bad;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tdefault:\t\t\t\t\t\t\t\tassert(0);    \t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\tfor (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++)\t\t{                        uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag;                        uint32 count = tif->tif_dir.td_customValues[m].count;\t\t\tswitch (tif->tif_dir.td_customValues[m].info->field_type)\t\t\t{\t\t\t\tcase TIFF_ASCII:\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_UNDEFINED:\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_BYTE:\t\t\t\t\tif (!TIFFWriteDirectoryTagByteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SBYTE:\t\t\t\t\tif (!TIFFWriteDirectoryTagSbyteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SHORT:\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SSHORT:\t\t\t\t\tif (!TIFFWriteDirectoryTagSshortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_LONG:\t\t\t\t\tif (!TIFFWriteDirectoryTagLongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SLONG:\t\t\t\t\tif (!TIFFWriteDirectoryTagSlongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_LONG8:\t\t\t\t\tif (!TIFFWriteDirectoryTagLong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SLONG8:\t\t\t\t\tif (!TIFFWriteDirectoryTagSlong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_RATIONAL:\t\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SRATIONAL:\t\t\t\t\tif (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_FLOAT:\t\t\t\t\tif (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_DOUBLE:\t\t\t\t\tif (!TIFFWriteDirectoryTagDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_IFD:\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_IFD8:\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdIfd8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tdefault:\t\t\t\t\tassert(0);    \t\t\t\t\tbreak;\t\t\t}\t\t}\t\tif (dir!=NULL)\t\t\tbreak;\t\tdir=_TIFFmalloc(ndir*sizeof(TIFFDirEntry));\t\tif (dir==NULL)\t\t{\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\t\t\tgoto bad;\t\t}\t\tif (isimage)\t\t{\t\t\tif ((tif->tif_diroff==0)&&(!TIFFLinkDirectory(tif)))\t\t\t\tgoto bad;\t\t}\t\telse\t\t\ttif->tif_diroff=(TIFFSeekFile(tif,0,SEEK_END)+1)&(~((toff_t)1));\t\tif (pdiroff!=NULL)\t\t\t*pdiroff=tif->tif_diroff;\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t\t\tdirsize=2+ndir*12+4;\t\telse\t\t\tdirsize=8+ndir*20+8;\t\ttif->tif_dataoff=tif->tif_diroff+dirsize;\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t\t\ttif->tif_dataoff=(uint32)tif->tif_dataoff;\t\tif ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize))\t\t{\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\");\t\t\tgoto bad;\t\t}\t\tif (tif->tif_dataoff&1)\t\t\ttif->tif_dataoff++;\t\tif (isimage)\t\t\ttif->tif_curdir++;\t}\tif (isimage)\t{\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0))\t\t{\t\t\tuint32 na;\t\t\tTIFFDirEntry* nb;\t\t\tfor (na=0, nb=dir; ; na++, nb++)\t\t\t{\t\t\t\tif( na == ndir )                                {                                    TIFFErrorExt(tif->tif_clientdata,module,                                                 \"Cannot find SubIFD tag\");                                    goto bad;                                }\t\t\t\tif (nb->tdir_tag==TIFFTAG_SUBIFD)\t\t\t\t\tbreak;\t\t\t}\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+2+na*12+8;\t\t\telse\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+8+na*20+12;\t\t}\t}\tdirmem=_TIFFmalloc(dirsize);\tif (dirmem==NULL)\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\t\tgoto bad;\t}\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t{\t\tuint8* n;\t\tuint32 nTmp;\t\tTIFFDirEntry* o;\t\tn=dirmem;\t\t*(uint16*)n=(uint16)ndir;\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabShort((uint16*)n);\t\tn+=2;\t\to=dir;\t\tfor (m=0; m<ndir; m++)\t\t{\t\t\t*(uint16*)n=o->tdir_tag;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabShort((uint16*)n);\t\t\tn+=2;\t\t\t*(uint16*)n=o->tdir_type;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabShort((uint16*)n);\t\t\tn+=2;\t\t\tnTmp = (uint32)o->tdir_count;\t\t\t_TIFFmemcpy(n,&nTmp,4);\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabLong((uint32*)n);\t\t\tn+=4;\t\t\t \t\t\t \t\t\t_TIFFmemcpy(n,&o->tdir_offset,4);\t\t\tn+=4;\t\t\to++;\t\t}\t\tnTmp = (uint32)tif->tif_nextdiroff;\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabLong(&nTmp);\t\t_TIFFmemcpy(n,&nTmp,4);\t}\telse\t{\t\tuint8* n;\t\tTIFFDirEntry* o;\t\tn=dirmem;\t\t*(uint64*)n=ndir;\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabLong8((uint64*)n);\t\tn+=8;\t\to=dir;\t\tfor (m=0; m<ndir; m++)\t\t{\t\t\t*(uint16*)n=o->tdir_tag;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabShort((uint16*)n);\t\t\tn+=2;\t\t\t*(uint16*)n=o->tdir_type;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabShort((uint16*)n);\t\t\tn+=2;\t\t\t_TIFFmemcpy(n,&o->tdir_count,8);\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabLong8((uint64*)n);\t\t\tn+=8;\t\t\t_TIFFmemcpy(n,&o->tdir_offset,8);\t\t\tn+=8;\t\t\to++;\t\t}\t\t_TIFFmemcpy(n,&tif->tif_nextdiroff,8);\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabLong8((uint64*)n);\t}\t_TIFFfree(dir);\tdir=NULL;\tif (!SeekOK(tif,tif->tif_diroff))\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\t\tgoto bad;\t}\tif (!WriteOK(tif,dirmem,(tmsize_t)dirsize))\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\t\tgoto bad;\t}\t_TIFFfree(dirmem);\tif (imagedone)\t{\t\tTIFFFreeDirectory(tif);\t\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\t\ttif->tif_flags &= ~TIFF_DIRTYSTRIP;\t\t(*tif->tif_cleanup)(tif);\t\t \t\tTIFFCreateDirectory(tif);\t}\treturn(1);bad:\tif (dir!=NULL)\t\t_TIFFfree(dir);\tif (dirmem!=NULL)\t\t_TIFFfree(dirmem);\treturn(0);}",
        "label": 1,
        "cve": "CVE-2018-5360-1-2"
    },
    {
        "code": "static intOJPEGVSetField(register TIFF *tif,ttag_t tag,va_list ap){    uint32 v32;    register OJPEGState *sp = OJState(tif);#   define td (&tif->tif_dir)    toff_t tiffoff=0;    uint32 bufoff=0;    uint32 code_count=0;    int i2=0;    int k2=0;    switch (tag)      {             case TIFFTAG_REFERENCEBLACKWHITE   : if (td->td_refblackwhite)                                               {                                                 _TIFFfree(td->td_refblackwhite);                                                 td->td_refblackwhite = 0;                                               };        default                            : return                                               (*sp->vsetparent)(tif,tag,ap);             case TIFFTAG_PHOTOMETRIC           :          if (   (v32 = (*sp->vsetparent)(tif,tag,ap))              && td->td_photometric == PHOTOMETRIC_YCBCR             )\t  {            if ( (td->td_refblackwhite = _TIFFmalloc(6*sizeof(float))) )              { register long top = 1 << td->td_bitspersample;                td->td_refblackwhite[0] = 0;                td->td_refblackwhite[1] = td->td_refblackwhite[3] =                td->td_refblackwhite[5] = top - 1;                td->td_refblackwhite[2] = td->td_refblackwhite[4] = top >> 1;              }            else              {                TIFFError(tif->tif_name,                  \"Cannot set default reference black and white levels\");                v32 = 0;              };\t  }          return v32;             case TIFFTAG_SOFTWARE              :        {            char *software;            v32 = (*sp->vsetparent)(tif,tag,ap);            if( TIFFGetField( tif, TIFFTAG_SOFTWARE, &software )                && strstr( software, \"Wang Labs\" ) )                sp->is_WANG = 1;            return v32;        }        case TIFFTAG_JPEGPROC              :        case TIFFTAG_JPEGIFOFFSET          :        case TIFFTAG_JPEGIFBYTECOUNT       :        case TIFFTAG_JPEGRESTARTINTERVAL   :        case TIFFTAG_JPEGLOSSLESSPREDICTORS:        case TIFFTAG_JPEGPOINTTRANSFORM    :        case TIFFTAG_JPEGQTABLES           :        case TIFFTAG_JPEGDCTABLES          :        case TIFFTAG_JPEGACTABLES          :        case TIFFTAG_WANG_PAGECONTROL      :        case TIFFTAG_JPEGCOLORMODE         : ;      };    v32 = va_arg(ap,uint32);         if(v32 !=0){        switch(tag){            case TIFFTAG_JPEGPROC:                sp->jpegproc=v32;                break;            case TIFFTAG_JPEGIFOFFSET:                sp->jpegifoffset=v32;\t\tbreak;            case TIFFTAG_JPEGIFBYTECOUNT:\t\tsp->jpegifbytecount=v32;\t\tbreak;            case TIFFTAG_JPEGRESTARTINTERVAL:\t\tsp->jpegrestartinterval=v32;\t\tbreak;            case TIFFTAG_JPEGLOSSLESSPREDICTORS:\t\tsp->jpeglosslesspredictors_length=v32;\t\tbreak;            case TIFFTAG_JPEGPOINTTRANSFORM:\t\tsp->jpegpointtransform_length=v32;\t\tbreak;            case TIFFTAG_JPEGQTABLES:\t\tsp->jpegqtables_length=v32;\t\tbreak;            case TIFFTAG_JPEGACTABLES:\t\tsp->jpegactables_length=v32;\t\tbreak;            case TIFFTAG_JPEGDCTABLES:\t\tsp->jpegdctables_length=v32;\t\tbreak;            default:\t\tbreak;        }    }     switch (tag)      { JHUFF_TBL **h;             case TIFFTAG_JPEGPROC              :          switch (v32)            {              default               : TIFFError(tif->tif_name,                                        \"Unknown JPEG process\");                                      return 0;#             ifdef C_LOSSLESS_SUPPORTED                         case JPEGPROC_BASELINE: sp->cinfo.d.process = JPROC_SEQUENTIAL;                                      sp->cinfo.d.data_unit = DCTSIZE;                                      break;                         case JPEGPROC_LOSSLESS: sp->cinfo.d.process = JPROC_LOSSLESS;                                      sp->cinfo.d.data_unit = 1;#             else               case JPEGPROC_LOSSLESS: TIFFError(JPEGLib_name,                                        \"Does not support lossless Huffman coding\");                                      return 0;              case JPEGPROC_BASELINE: ;#             endif             };          break;             case TIFFTAG_JPEGIFOFFSET          :          if (v32)            {              sp->src.next_input_byte = tif->tif_base + v32;              break;            };          return 1;        case TIFFTAG_JPEGIFBYTECOUNT       :          sp->src.bytes_in_buffer = v32;          break;                  case TIFFTAG_JPEGRESTARTINTERVAL   :          if (v32)              sp->cinfo.d.restart_interval = v32;              break;             case TIFFTAG_JPEGLOSSLESSPREDICTORS:           if (v32)             {               sp->cinfo.d.Ss = *va_arg(ap,uint16 *);               sp->jpeglosslesspredictors = \t\t    _TIFFmalloc(sp->jpeglosslesspredictors_length\t\t\t\t* sizeof(uint16));               if(sp->jpeglosslesspredictors==NULL){return(0);}               for(i2=0;i2<sp->jpeglosslesspredictors_length;i2++){                ((uint16*)sp->jpeglosslesspredictors)[i2] =\t\t\t((uint16*)sp->cinfo.d.Ss)[i2];               }               sp->jpeglosslesspredictors_length*=sizeof(uint16);               break;             };           return v32;             case TIFFTAG_JPEGPOINTTRANSFORM    :           if (v32)             {               sp->cinfo.d.Al = *va_arg(ap,uint16 *);               sp->jpegpointtransform =\t\t    _TIFFmalloc(sp->jpegpointtransform_length*sizeof(uint16));               if(sp->jpegpointtransform==NULL){return(0);}               for(i2=0;i2<sp->jpegpointtransform_length;i2++) {                ((uint16*)sp->jpegpointtransform)[i2] =\t\t\t((uint16*)sp->cinfo.d.Al)[i2];               }               sp->jpegpointtransform_length*=sizeof(uint16);               break;             }           return v32;             case TIFFTAG_JPEGQTABLES           :          if (v32)            { uint32 *v;              int i;              if (v32 > NUM_QUANT_TBLS)                {                  TIFFError(tif->tif_name,\"Too many quantization tables\");                  return 0;                };              i = 0;              v = va_arg(ap,uint32 *);                sp->jpegqtables=_TIFFmalloc(64*sp->jpegqtables_length);                if(sp->jpegqtables==NULL){return(0);}                tiffoff = TIFFSeekFile(tif, 0, SEEK_CUR);                bufoff=0;                for(i2=0;i2<sp->jpegqtables_length;i2++){                    TIFFSeekFile(tif, v[i2], SEEK_SET);                    TIFFReadFile(tif, &(((u_char*)(sp->jpegqtables))[bufoff]),\t\t\t\t 64);                    bufoff+=64;                }                sp->jpegqtables_length=bufoff;                TIFFSeekFile(tif, tiffoff, SEEK_SET);              do                 { register UINT8 *from = tif->tif_base + *v++;                  register UINT16 *to;                  register int j = DCTSIZE2;                  if (!( sp->cinfo.d.quant_tbl_ptrs[i]                       = CALLJPEG(sp,0,jpeg_alloc_quant_table(&sp->cinfo.comm))                       )                     )                    {                      TIFFError(JPEGLib_name,\"No space for quantization table\");                      return 0;                    };                  to = sp->cinfo.d.quant_tbl_ptrs[i]->quantval;                  do *to++ = *from++; while (--j > 0);                }              while (++i < v32);              sp->jpegtablesmode |= JPEGTABLESMODE_QUANT;            };          break;             case TIFFTAG_JPEGDCTABLES          :          h = sp->cinfo.d.dc_huff_tbl_ptrs;          goto L;             case TIFFTAG_JPEGACTABLES          :          h = sp->cinfo.d.ac_huff_tbl_ptrs;       L: if (v32)            { uint32 *v;              int i;              if (v32 > NUM_HUFF_TBLS)                {                  TIFFError(tif->tif_name,\"Too many Huffman tables\");                  return 0;                };              v = va_arg(ap,uint32 *);                if(tag == TIFFTAG_JPEGDCTABLES) {                    sp->jpegdctables=_TIFFmalloc(272*sp->jpegdctables_length);                    if(sp->jpegdctables==NULL){return(0);}                    tiffoff = TIFFSeekFile(tif, 0, SEEK_CUR);                    bufoff=0;                    code_count=0;                                    for(i2=0;i2<sp->jpegdctables_length;i2++){                        TIFFSeekFile(tif, v[i2], SEEK_SET);                        TIFFReadFile(tif,\t\t\t\t     &(((u_char*)(sp->jpegdctables))[bufoff]),\t\t\t\t     16);                        code_count=0;                        for(k2=0;k2<16;k2++){                            code_count+=((u_char*)(sp->jpegdctables))[k2+bufoff];                        }                        TIFFReadFile(tif,\t\t\t\t     &(((u_char*)(sp->jpegdctables))[bufoff+16]),\t\t\t\t     code_count);                        bufoff+=16;                        bufoff+=code_count;                    }                    sp->jpegdctables_length=bufoff;                    TIFFSeekFile(tif, tiffoff, SEEK_SET);                }                if(tag==TIFFTAG_JPEGACTABLES){                    sp->jpegactables=_TIFFmalloc(272*sp->jpegactables_length);                    if(sp->jpegactables==NULL){return(0);}                    tiffoff = TIFFSeekFile(tif, 0, SEEK_CUR);                    bufoff=0;                    code_count=0;                                    for(i2=0;i2<sp->jpegactables_length;i2++){                        TIFFSeekFile(tif, v[i2], SEEK_SET);                        TIFFReadFile(tif, &(((unsigned char*)(sp->jpegactables))[bufoff]), 16);                        code_count=0;                        for(k2=0;k2<16;k2++){                            code_count+=((unsigned char*)(sp->jpegactables))[k2+bufoff];                        }                        TIFFReadFile(tif, &(((unsigned char*)(sp->jpegactables))[bufoff+16]), code_count);                        bufoff+=16;                        bufoff+=code_count;                    }                    sp->jpegactables_length=bufoff;                    TIFFSeekFile(tif, tiffoff, SEEK_SET);                }              i = 0;              do                 { int size = 0;                  register UINT8 *from = tif->tif_base + *v++, *to;                  register int j = sizeof (*h)->bits;                                 if (!( *h                       = CALLJPEG(sp,0,jpeg_alloc_huff_table(&sp->cinfo.comm))                       )                     )                    {                      TIFFError(JPEGLib_name,\"No space for Huffman table\");                      return 0;                    };                  to = (*h++)->bits;                  *to++ = 0;                  while (--j > 0) size += *to++ = *from++;                   if (size > sizeof (*h)->huffval/sizeof *(*h)->huffval)                    {                      TIFFError(tif->tif_name,\"Huffman table too big\");                      return 0;                    };                  if ((j = size) > 0) do *to++ = *from++; while (--j > 0);                  while (++size <= sizeof (*h)->huffval/sizeof *(*h)->huffval)                    *to++ = 0;                 }              while (++i < v32);              sp->jpegtablesmode |= JPEGTABLESMODE_HUFF;            };          break;             case TIFFTAG_WANG_PAGECONTROL      :          if (v32 == 0) v32 = -1;          sp->is_WANG = v32;          tag = TIFFTAG_JPEGPROC+FIELD_WANG_PAGECONTROL-FIELD_JPEGPROC;          break;             case TIFFTAG_JPEGCOLORMODE         :          sp->jpegcolormode = v32;                 v32 = tif->tif_flags;           tif->tif_flags &= ~TIFF_UPSAMPLED;          if (   td->td_photometric == PHOTOMETRIC_YCBCR              &&    (td->td_ycbcrsubsampling[0]<<3 | td->td_ycbcrsubsampling[1])                 != 011              && sp->jpegcolormode == JPEGCOLORMODE_RGB             ) tif->tif_flags |= TIFF_UPSAMPLED;                 if ((tif->tif_flags ^ v32) & TIFF_UPSAMPLED)            {              tif->tif_tilesize = TIFFTileSize(tif);              tif->tif_flags |= TIFF_DIRTYDIRECT;            };          return 1;      };    TIFFSetFieldBit(tif,tag-TIFFTAG_JPEGPROC+FIELD_JPEGPROC);    return 1;#   undef td  }",
        "label": 1,
        "cve": "cve-2004-0929"
    },
    {
        "code": "static intcheckcmap(int n, uint16* r, uint16* g, uint16* b){\twhile (n-- > 0)\t    if (*r++ >= 256 || *g++ >= 256 || *b++ >= 256)\t\treturn (16);\tfprintf(stderr, \"Warning, assuming 8-bit colormap.\\n\");\treturn (8);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWritePerSampleAnys(TIFF* tif,    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir){\tdouble buf[10], v;\tdouble* w = buf;\tint i, status;\tint samples = (int) tif->tif_dir.td_samplesperpixel;\tif (samples > NITEMS(buf))\t\tw = (double*) _TIFFmalloc(samples * sizeof (double));\tTIFFGetField(tif, tag, &v);\tfor (i = 0; i < samples; i++)\t\tw[i] = v;\tstatus = TIFFWriteAnyArray(tif, type, tag, dir, samples, w);\tif (w != buf)\t\t_TIFFfree(w);\treturn (status);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intreverseSamples32bits (uint16 spp, uint16 bps, uint32 width,                       uint8 *ibuff, uint8 *obuff)  {  int    ready_bits = 0 ;    uint32 bit_offset;  uint32 src_byte = 0, high_bit = 0;  uint32 col;  uint32 longbuff1 = 0, longbuff2 = 0;  uint64 mask_bits = 0, match_bits = 0;  uint64 buff1 = 0, buff2 = 0, buff3 = 0;  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;  unsigned char *src;  unsigned char *dst;  tsample_t sample;  if ((ibuff == NULL) || (obuff == NULL))    {    TIFFError(\"reverseSamples32bits\",\"Invalid image or work buffer\");    return (1);    }  ready_bits = 0;  mask_bits =  (uint64)-1 >> (64 - bps);  dst = obuff;              for (col = width; col > 0; col--)    {        bit_offset = (col - 1) * bps * spp;    for (sample = 0; sample < spp; sample++)      {      if (sample == 0)        {        src_byte = bit_offset / 8;        high_bit  = bit_offset % 8;        }      else        {        src_byte = (bit_offset + (sample * bps)) / 8;        high_bit  = (bit_offset + (sample * bps)) % 8;        }      src = ibuff + src_byte;      match_bits = mask_bits << (64 - high_bit - bps);       if (little_endian)        {\tlongbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];        longbuff2 = longbuff1;        }      else        {\tlongbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];        longbuff2 = longbuff1;\t}      buff3 = ((uint64)longbuff1 << 32) | longbuff2;      buff1 = (buff3 & match_bits) << (high_bit);      if (ready_bits < 32)        {         bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;        buff2 = (buff2 | (buff1 >> ready_bits));        }      else         {        bytebuff1 = (buff2 >> 56);        *dst++ = bytebuff1;        bytebuff2 = (buff2 >> 48);        *dst++ = bytebuff2;        bytebuff3 = (buff2 >> 40);        *dst++ = bytebuff3;        bytebuff4 = (buff2 >> 32);        *dst++ = bytebuff4;        ready_bits -= 32;                buff2 = ((buff2 << 32) | (buff1 >> ready_bits));        }      ready_bits += bps;      }    }  while (ready_bits > 0)    {    bytebuff1 = (buff2 >> 56);    *dst++ = bytebuff1;    buff2 = (buff2 << 8);    ready_bits -= 8;    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intextractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,  \t                         uint32 imagewidth, uint32 tilewidth, tsample_t sample,\t\t\t\t uint16 count, uint16 spp, uint16 bps, struct dump_opts *dump)  {  int    shift_width, bytes_per_sample, bytes_per_pixel;  uint32 src_rowsize, src_offset, row;  uint32 dst_rowsize, dst_offset;  uint8 *src, *dst;  bytes_per_sample = (bps + 7) / 8;   bytes_per_pixel  = ((bps * spp) + 7) / 8;  if ((bps % 8) == 0)    shift_width = 0;  else    {    if (bytes_per_pixel < (bytes_per_sample + 1))      shift_width = bytes_per_pixel;    else      shift_width = bytes_per_sample + 1;    }  if ((dump->outfile != NULL) && (dump->level == 4))    {    dump_info  (dump->outfile, dump->format, \"extractContigSamplesToTileBuffer\",                 \"Sample %d, %d rows\", sample + 1, rows + 1);    }  src_rowsize = ((bps * spp * imagewidth) + 7) / 8;  dst_rowsize = ((bps * tilewidth * count) + 7) / 8;  for (row = 0; row < rows; row++)    {    src_offset = row * src_rowsize;    dst_offset = row * dst_rowsize;    src = in + src_offset;    dst = out + dst_offset;        switch (shift_width)      {        case 0: if (extractContigSamplesBytes (src, dst, cols, sample,                                             spp, bps,  count, 0, cols))                  return (1); \t      break;      case 1: if (bps == 1)                {                if (extractContigSamples8bits (src, dst, cols, sample,                                               spp, bps, count, 0, cols))\t          return (1);\t        break;\t\t}\t      else                 if (extractContigSamples16bits (src, dst, cols, sample,                                                 spp, bps, count, 0, cols))\t         return (1);\t      break;      case 2: if (extractContigSamples24bits (src, dst, cols, sample,                                              spp, bps,  count, 0, cols))\t         return (1);\t      break;      case 3:      case 4:       case 5: if (extractContigSamples32bits (src, dst, cols, sample,                                              spp, bps,  count, 0, cols))\t         return (1);\t      break;      default: TIFFError (\"extractContigSamplesToTileBuffer\", \"Unsupported bit depth: %d\", bps);\t       return (1);      }    if ((dump->outfile != NULL) && (dump->level == 4))      dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst);    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int t2p_tile_is_right_edge(T2P_TILES tiles, ttile_t tile){\tif( ((tile+1) % tiles.tiles_tilecountx == 0) \t\t&& (tiles.tiles_edgetilewidth != 0) ){\t\treturn(1);\t} else {\t\treturn(0);\t}} */int t2p_tile_is_right_edge(T2P_TILES tiles, ttile_t tile){\tif( ((tile+1) % tiles.tiles_tilecountx == 0) \t\t&& (tiles.tiles_edgetilewidth != 0) ){\t\treturn(1);\t} else {\t\treturn(0);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFVGetField(TIFF* tif, ttag_t tag, va_list ap){\tconst TIFFFieldInfo* fip = _TIFFFindFieldInfo(tif, tag, TIFF_ANY);\treturn (fip && (isPseudoTag(tag) || TIFFFieldSet(tif, fip->field_bit)) ?\t    (*tif->tif_tagmethods.vgetfield)(tif, tag, ap) : 0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchExtraSamples(TIFF* tif, TIFFDirEntry* dir){\tuint16 buf[10];\tuint16* v = buf;\tint status;\tif (dir->tdir_count > NITEMS(buf))\t\tv = (uint16*) _TIFFmalloc(dir->tdir_count * sizeof (uint16));\tif (dir->tdir_type == TIFF_BYTE)\t\tstatus = TIFFFetchByteArray(tif, dir, v);\telse\t\tstatus = TIFFFetchShortArray(tif, dir, v);\tif (status)\t\tstatus = TIFFSetField(tif, dir->tdir_tag, dir->tdir_count, v);\tif (v != buf)\t\t_TIFFfree((char*) v);\treturn (status);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void main(int argc,char *argv[]){\tchar *fname=\"newtif.tif\";\tint flags;\tTIFF *tif=(TIFF*)0;  \tif (argc>1) fname=argv[1];\ttif=XTIFFOpen(fname,\"r\");\tif (!tif) goto failure;\t\tflags = TIFFPRINT_MYMULTIDOUBLES;\tTIFFPrintDirectory(tif,stdout,flags);\tXTIFFClose(tif);\texit (0);failure:\tprintf(\"failure in listtif\\n\");\tif (tif) XTIFFClose(tif);\texit (-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intextractContigSamplesShifted8bits (uint8 *in, uint8 *out, uint32 cols,                                  tsample_t sample, uint16 spp, uint16 bps, \t\t\t          tsample_t count, uint32 start, uint32 end, \t                          int shift)  {  int    ready_bits = 0, sindex = 0;  uint32 col, src_byte, src_bit, bit_offset;  uint8  maskbits = 0, matchbits = 0;  uint8  buff1 = 0, buff2 = 0;  uint8 *src = in;  uint8 *dst = out;  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"extractContigSamplesShifted8bits\",\"Invalid input or output buffer\");    return (1);    }  if ((start > end) || (start > cols))    {    TIFFError (\"extractContigSamplesShifted8bits\",                \"Invalid start column value %d ignored\", start);    start = 0;    }  if ((end == 0) || (end > cols))    {    TIFFError (\"extractContigSamplesShifted8bits\",                \"Invalid end column value %d ignored\", end);    end = cols;    }  ready_bits = shift;  maskbits =  (uint8)-1 >> ( 8 - bps);  buff1 = buff2 = 0;  for (col = start; col < end; col++)    {        bit_offset = col * bps * spp;    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)      {      if (sindex == 0)        {        src_byte = bit_offset / 8;        src_bit  = bit_offset % 8;        }      else        {        src_byte = (bit_offset + (sindex * bps)) / 8;        src_bit  = (bit_offset + (sindex * bps)) % 8;        }      src = in + src_byte;      matchbits = maskbits << (8 - src_bit - bps);       buff1 = ((*src) & matchbits) << (src_bit);      if ((col == start) && (sindex == sample))        buff2 = *src & ((uint8)-1) << (shift);            if (ready_bits >= 8)        {        *dst++ |= buff2;        buff2 = buff1;        ready_bits -= 8;        }      else\tbuff2 = buff2 | (buff1 >> ready_bits);      ready_bits += bps;      }    }  while (ready_bits > 0)    {    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));    *dst++ = buff1;    ready_bits -= 8;    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcombineSeparateSamples24bits (uint8 *in[], uint8 *out, uint32 cols,                              uint32 rows, uint16 spp, uint16 bps, \t                      FILE *dumpfile, int format, int level)  {  int    ready_bits = 0 ;  uint32 src_rowsize, dst_rowsize;   uint32 bit_offset, src_offset;  uint32 row, col, src_byte = 0, src_bit = 0;  uint32 maskbits = 0, matchbits = 0;  uint32 buff1 = 0, buff2 = 0;  uint8  bytebuff1 = 0, bytebuff2 = 0;  tsample_t s;  unsigned char *src = in[0];  unsigned char *dst = out;  char           action[8];  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"combineSeparateSamples24bits\",\"Invalid input or output buffer\");    return (1);    }     src_rowsize = ((bps * cols) + 7) / 8;  dst_rowsize = ((bps * cols * spp) + 7) / 8;  maskbits =  (uint32)-1 >> ( 32 - bps);  for (row = 0; row < rows; row++)    {    ready_bits = 0;    buff1 = buff2 = 0;    dst = out + (row * dst_rowsize);    src_offset = row * src_rowsize;    for (col = 0; col < cols; col++)      {            bit_offset = col * bps;      src_byte = bit_offset / 8;      src_bit  = bit_offset % 8;      matchbits = maskbits << (32 - src_bit - bps);       for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)        {\tsrc = in[s] + src_offset + src_byte;        if (little_endian)\t  buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];        else\t  buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\tbuff1 = (buff1 & matchbits) << (src_bit);\t\tif (ready_bits >= 16)\t  {\t    bytebuff1 = (buff2 >> 24);\t    *dst++ = bytebuff1;\t    bytebuff2 = (buff2 >> 16);\t    *dst++ = bytebuff2;\t    ready_bits -= 16;\t    \t    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\t    strcpy (action, \"Flush\");\t  }\telse\t  { \t    bytebuff1 = bytebuff2 = 0;\t    buff2 = (buff2 | (buff1 >> ready_bits));\t    strcpy (action, \"Update\");\t  }\tready_bits += bps;\tif ((dumpfile != NULL) && (level == 3))\t  {\t  dump_info (dumpfile, format, \"\",\t\t       \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\t  dump_long (dumpfile, format, \"Match bits \", matchbits);\t  dump_data (dumpfile, format, \"Src   bits \", src, 4);\t  dump_long (dumpfile, format, \"Buff1 bits \", buff1);\t  dump_long (dumpfile, format, \"Buff2 bits \", buff2);\t  dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\t  dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\t  dump_info (dumpfile, format, \"\",\"Ready bits:   %d, %s\", ready_bits, action); \t  }\t}      }        while (ready_bits > 0)      {\tbytebuff1 = (buff2 >> 24);\t*dst++ = bytebuff1;\tbuff2 = (buff2 << 8);\tbytebuff2 = bytebuff1;\tready_bits -= 8;      }    if ((dumpfile != NULL) && (level == 3))      {      dump_info (dumpfile, format, \"\",\t\t   \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\t\t   row + 1, col + 1, src_byte, src_bit, dst - out);      dump_long (dumpfile, format, \"Match bits \", matchbits);      dump_data (dumpfile, format, \"Src   bits \", src, 4);      dump_long (dumpfile, format, \"Buff1 bits \", buff1);      dump_long (dumpfile, format, \"Buff2 bits \", buff2);      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits);       }    if ((dumpfile != NULL) && (level == 2))      {      dump_info (dumpfile, format, \"combineSeparateSamples24bits\",\"Output data\");      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));      }    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcombineSeparateTileSamples32bits (uint8 *in[], uint8 *out, uint32 cols,                                  uint32 rows, uint32 imagewidth,                                   uint32 tw, uint16 spp, uint16 bps,  \t                          FILE *dumpfile, int format, int level)  {  int    ready_bits = 0 ;  uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;  uint32 src_byte = 0, src_bit = 0;  uint32 row, col;  uint32 longbuff1 = 0, longbuff2 = 0;  uint64 maskbits = 0, matchbits = 0;  uint64 buff1 = 0, buff2 = 0, buff3 = 0;  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;  tsample_t s;  unsigned char *src = in[0];  unsigned char *dst = out;  char           action[8];  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"combineSeparateTileSamples32bits\",\"Invalid input or output buffer\");    return (1);    }  src_rowsize = ((bps * tw) + 7) / 8;  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;  maskbits =  (uint64)-1 >> ( 64 - bps);     for (row = 0; row < rows; row++)    {    ready_bits = 0;    buff1 = buff2 = 0;    dst = out + (row * dst_rowsize);    src_offset = row * src_rowsize;    for (col = 0; col < cols; col++)      {            bit_offset = col * bps;      src_byte = bit_offset / 8;      src_bit  = bit_offset % 8;      matchbits = maskbits << (64 - src_bit - bps);       for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\t{\tsrc = in[s] + src_offset + src_byte;\tif (little_endian)\t  {\t  longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\t  longbuff2 = longbuff1;\t  }\telse\t  {\t  longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];          longbuff2 = longbuff1;\t  }\tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;\tbuff1 = (buff3 & matchbits) << (src_bit);\t\tif (ready_bits >= 32)\t  {\t  bytebuff1 = (buff2 >> 56);\t  *dst++ = bytebuff1;\t  bytebuff2 = (buff2 >> 48);\t  *dst++ = bytebuff2;\t  bytebuff3 = (buff2 >> 40);\t  *dst++ = bytebuff3;\t  bytebuff4 = (buff2 >> 32);\t  *dst++ = bytebuff4;\t  ready_bits -= 32;\t  \t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\t  strcpy (action, \"Flush\");\t  }\telse\t  { \t  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\t  buff2 = (buff2 | (buff1 >> ready_bits));\t  strcpy (action, \"Update\");\t  }\tready_bits += bps;\tif ((dumpfile != NULL) && (level == 3))\t  { \t  dump_info (dumpfile, format, \"\",\t\t     \"Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);\t  dump_wide (dumpfile, format, \"Match bits \", matchbits);\t  dump_data (dumpfile, format, \"Src   bits \", src, 8);\t  dump_wide (dumpfile, format, \"Buff1 bits \", buff1);\t  dump_wide (dumpfile, format, \"Buff2 bits \", buff2);\t  dump_info (dumpfile, format, \"\", \"Ready bits:   %d, %s\", ready_bits, action); \t  }\t}      }    while (ready_bits > 0)      {      bytebuff1 = (buff2 >> 56);      *dst++ = bytebuff1;      buff2 = (buff2 << 8);      ready_bits -= 8;      }    if ((dumpfile != NULL) && (level == 3))      {      dump_info (dumpfile, format, \"\",\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\t\t row + 1, col + 1, src_byte, src_bit, dst - out);      dump_long (dumpfile, format, \"Match bits \", matchbits);      dump_data (dumpfile, format, \"Src   bits \", src, 4);      dump_long (dumpfile, format, \"Buff1 bits \", buff1);      dump_long (dumpfile, format, \"Buff2 bits \", buff2);      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits);       }    if ((dumpfile != NULL) && (level == 2))      {      dump_info (dumpfile, format, \"combineSeparateTileSamples32bits\",\"Output data\");      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);      }    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFCleanup(TIFF* tif){\tif (tif->tif_mode != O_RDONLY)\t    \t    TIFFFlush(tif);\t(*tif->tif_cleanup)(tif);\tTIFFFreeDirectory(tif);\tif (tif->tif_dirlist)\t\t_TIFFfree(tif->tif_dirlist);\t\twhile( tif->tif_clientinfo )\t{\t\tTIFFClientInfoLink *link = tif->tif_clientinfo;\t\ttif->tif_clientinfo = link->next;\t\t_TIFFfree( link->name );\t\t_TIFFfree( link );\t}\tif (tif->tif_rawdata && (tif->tif_flags&TIFF_MYBUFFER))\t\t_TIFFfree(tif->tif_rawdata);\tif (isMapped(tif))\t\tTIFFUnmapFileContents(tif, tif->tif_base, tif->tif_size);\t\tif (tif->tif_nfields > 0)\t{\t\tsize_t  i;\t    for (i = 0; i < tif->tif_nfields; i++) \t    {\t\tTIFFFieldInfo *fld = tif->tif_fieldinfo[i];\t\tif (fld->field_bit == FIELD_CUSTOM && \t\t    strncmp(\"Tag \", fld->field_name, 4) == 0) \t\t{\t\t    _TIFFfree(fld->field_name);\t\t    _TIFFfree(fld);\t\t}\t    }   \t    _TIFFfree(tif->tif_fieldinfo);\t}\t_TIFFfree(tif);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFAdvanceDirectory(TIFF* tif, uint32* nextdir, toff_t* off){    static const char module[] = \"TIFFAdvanceDirectory\";    uint16 dircount;    if (isMapped(tif))    {        toff_t poff=*nextdir;        if (poff+sizeof(uint16) > tif->tif_size)        {\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory count\",                      tif->tif_name);            return (0);        }        _TIFFmemcpy(&dircount, tif->tif_base+poff, sizeof (uint16));        if (tif->tif_flags & TIFF_SWAB)            TIFFSwabShort(&dircount);        poff+=sizeof (uint16)+dircount*sizeof (TIFFDirEntry);        if (off != NULL)            *off = poff;        if (((toff_t) (poff+sizeof (uint32))) > tif->tif_size)        {\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory link\",                      tif->tif_name);            return (0);        }        _TIFFmemcpy(nextdir, tif->tif_base+poff, sizeof (uint32));        if (tif->tif_flags & TIFF_SWAB)            TIFFSwabLong(nextdir);        return (1);    }    else    {        if (!SeekOK(tif, *nextdir) ||            !ReadOK(tif, &dircount, sizeof (uint16))) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory count\",                      tif->tif_name);            return (0);        }        if (tif->tif_flags & TIFF_SWAB)            TIFFSwabShort(&dircount);        if (off != NULL)            *off = TIFFSeekFile(tif,                                dircount*sizeof (TIFFDirEntry), SEEK_CUR);        else            (void) TIFFSeekFile(tif,                                dircount*sizeof (TIFFDirEntry), SEEK_CUR);        if (!ReadOK(tif, nextdir, sizeof (uint32))) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory link\",                      tif->tif_name);            return (0);        }        if (tif->tif_flags & TIFF_SWAB)            TIFFSwabLong(nextdir);        return (1);    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intCheckShortTag(TIFF* tif1, TIFF* tif2, int tag, char* name){\tuint16 v1, v2;\tCHECK(v1 == v2, \"%s: %u %u\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcompresspalette(unsigned char* out, unsigned char* data, uint32 n, uint16* rmap, uint16* gmap, uint16* bmap){\tregister int v, red = RED, green = GREEN, blue = BLUE;\twhile (n-- > 0) {\t\tunsigned int ix = *data++;\t\tv = red*rmap[ix];\t\tv += green*gmap[ix];\t\tv += blue*bmap[ix];\t\t*out++ = v>>8;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(void){        char buf[BUFSIZ];        int i;        setbuf(stderr, buf);                fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());        for (i = 0; stuff[i] != NULL; i++)                fprintf(stderr, \"%s\\n\", stuff[i]);        exit(-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type){\tswitch (type) {\tcase TIFF_SHORT:\t\tif (count == 1) {\t\t\tuint16 shortv;\t\t\tCopyField(tag, shortv);\t\t} else if (count == 2) {\t\t\tuint16 shortv1, shortv2;\t\t\tCopyField2(tag, shortv1, shortv2);\t\t} else if (count == 4) {\t\t\tuint16 *tr, *tg, *tb, *ta;\t\t\tCopyField4(tag, tr, tg, tb, ta);\t\t} else if (count == (uint16) -1) {\t\t\tuint16 shortv1;\t\t\tuint16* shortav;\t\t\tCopyField2(tag, shortv1, shortav);\t\t}\t\tbreak;\tcase TIFF_LONG:\t\t{ uint32 longv;\t\t  CopyField(tag, longv);\t\t}\t\tbreak;\tcase TIFF_RATIONAL:\t\tif (count == 1) {\t\t\tfloat floatv;\t\t\tCopyField(tag, floatv);\t\t} else if (count == (uint16) -1) {\t\t\tfloat* floatav;\t\t\tCopyField(tag, floatav);\t\t}\t\tbreak;\tcase TIFF_ASCII:\t\t{ char* stringv;\t\t  CopyField(tag, stringv);\t\t}\t\tbreak;\tcase TIFF_DOUBLE:\t\tif (count == 1) {\t\t\tdouble doublev;\t\t\tCopyField(tag, doublev);\t\t} else if (count == (uint16) -1) {\t\t\tdouble* doubleav;\t\t\tCopyField(tag, doubleav);\t\t}\t\tbreak;          default:                TIFFError(TIFFFileName(in),                          \"Data type %d is not supported, tag %d skipped.\",                          tag, type);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void_XTIFFFreeDirectory(xtiff* xt){\tXTIFFDirectory* xd = &xt->xtif_dir;\t\tCleanupField(xd_example_multi);\tCleanupField(xd_example_ascii);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tdata_t_TIFFrealloc(tdata_t p, tsize_t s){\tPtr n = p;\tSetPtrSize(p, (size_t) s);\tif (MemError() && (n = NewPtr((size_t) s)) != NULL) {\t\tBlockMove(p, n, GetPtrSize(p));\t\tDisposePtr(p);\t}\treturn ((tdata_t) n);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFInitCCITTFax4(TIFF* tif, int scheme){\t(void) scheme;\tif (InitCCITTFax3(tif)) {\t\t\t\t_TIFFMergeFieldInfo(tif, fax4FieldInfo, N(fax4FieldInfo));\t\ttif->tif_decoderow = Fax4Decode;\t\ttif->tif_decodestrip = Fax4Decode;\t\ttif->tif_decodetile = Fax4Decode;\t\ttif->tif_encoderow = Fax4Encode;\t\ttif->tif_encodestrip = Fax4Encode;\t\ttif->tif_encodetile = Fax4Encode;\t\ttif->tif_postencode = Fax4PostEncode;\t\t\t\treturn TIFFSetField(tif, TIFFTAG_FAXMODE, FAXMODE_NORTC);\t} else\t\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int main(int argc, char *argv[]){                    int    i,    mode;   FILE    *ifile = stdin,    *ofile = stdout;  char    c,    *usage = \"usage: iptcutil -t | -b [-i file] [-o file] <input >output\";  if( argc < 2 )    {      puts(usage);      return 1;    }  mode = 0;      for (i=1; i<argc; i++)    {      c = argv[i][0];      if (c == '-' || c == '/')        {          c = argv[i][1];          switch( c )            {            case 't':              mode = 1;#ifdef WIN32                            _setmode( _fileno( ofile ), _O_BINARY );#endif              break;            case 'b':              mode = 0;#ifdef WIN32                            _setmode( _fileno( ifile ), _O_BINARY );#endif              break;            case 'i':              if (mode == 0)                ifile = fopen(argv[++i], \"rb\");              else                ifile = fopen(argv[++i], \"rt\");              if (ifile == (FILE *)NULL)                {                  printf(\"Unable to open: %s\\n\", argv[i]);                  return 1;                }              break;            case 'o':              if (mode == 0)                ofile = fopen(argv[++i], \"wt\");              else                ofile = fopen(argv[++i], \"wb\");              if (ofile == (FILE *)NULL)                {                  printf(\"Unable to open: %s\\n\", argv[i]);                  return 1;                }              break;            default:              printf(\"Unknown option: %s\\n\", argv[i]);              return 1;            }        }      else        {          puts(usage);          return 1;        }    }  if (mode == 0)     formatIPTC(ifile, ofile);  if (mode == 1)     {      char        brkused,        quoted,        *line,        *token,        *newstr;      int        state,        next;      unsigned char        recnum = 0,        dataset = 0;      int        inputlen = BUFFER_SZ;      line = (char *) malloc(inputlen);           token = (char *)NULL;      while((line = super_fgets(line,&inputlen,ifile))!=NULL)        {          state=0;          next=0;          token = (char *) malloc(inputlen);               newstr = (char *) malloc(inputlen);               while(tokenizer(0, token, inputlen, line, \"\", \"=\", \"\\\"\", 0,                          &brkused,&next,&quoted)==0)            {              if (state == 0)                {                                    int                    state,                    next;                  char                    brkused,                    quoted;                  state=0;                  next=0;                  while(tokenizer(0, newstr, inputlen, token, \"\", \"#\", \"\", 0,                                  &brkused, &next, &quoted)==0)                    {                      if (state == 0)                        dataset = (unsigned char) atoi(newstr);                      else                        if (state == 1)                          recnum = (unsigned char) atoi(newstr);                      state++;                    }                }              else                if (state == 1)                  {                    int                      next;                    unsigned long                      len;                    char                      brkused,                      quoted;                    next=0;                    len = strlen(token);                    while(tokenizer(0, newstr, inputlen, token, \"\", \"&\", \"\", 0,                                    &brkused, &next, &quoted)==0)                      {                        if (brkused && next > 0)                          {                            char                              *s = &token[next-1];                            len -= convertHTMLcodes(s, strlen(s));                          }                      }                    fputc(0x1c, ofile);                    fputc(dataset, ofile);                    fputc(recnum, ofile);                    if (len < 0x10000)                      {                        fputc((len >> 8) & 255, ofile);                        fputc(len & 255, ofile);                      }                    else                      {                        fputc(((len >> 24) & 255) | 0x80, ofile);                        fputc((len >> 16) & 255, ofile);                        fputc((len >> 8) & 255, ofile);                        fputc(len & 255, ofile);                      }                    next=0;                    while (len--)                      fputc(token[next++], ofile);                  }              state++;            }          free(token);          token = (char *)NULL;          free(newstr);          newstr = (char *)NULL;        }      free(line);      fclose( ifile );      fclose( ofile );    }  return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intLZWSetupEncode(TIFF* tif){\tstatic const char module[] = \"LZWSetupEncode\";\tLZWCodecState* sp = EncoderState(tif);\tassert(sp != NULL);\tsp->enc_hashtab = (hash_t*) _TIFFmalloc(HSIZE*sizeof (hash_t));\tif (sp->enc_hashtab == NULL) {\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t     \"No space for LZW hash table\");\t\treturn (0);\t}\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidquant(TIFF* in, TIFF* out){\tunsigned char\t*outline, *inputline;\tregister unsigned char\t*outptr, *inptr;\tregister uint32 i, j;\tregister int red, green, blue;\tinputline = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\toutline = (unsigned char *)_TIFFmalloc(imagewidth);\tfor (i = 0; i < imagelength; i++) {\t\tif (TIFFReadScanline(in, inputline, i, 0) <= 0)\t\t\tbreak;\t\tinptr = inputline;\t\toutptr = outline;\t\tfor (j = 0; j < imagewidth; j++) {\t\t\tred = *inptr++ >> COLOR_SHIFT;\t\t\tgreen = *inptr++ >> COLOR_SHIFT;\t\t\tblue = *inptr++ >> COLOR_SHIFT;\t\t\t*outptr++ = (unsigned char)histogram[red][green][blue];\t\t}\t\tif (TIFFWriteScanline(out, outline, i, 0) < 0)\t\t\tbreak;\t}\t_TIFFfree(inputline);\t_TIFFfree(outline);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int mfs_map (int fd, char **addr, size_t *len){    int ret;     if (fds[fd] == -1)      {        ret = -1;        errno = EBADF;    }    else    {        *addr = buf[fd];        *len = buf_size[fd];        ret = 0;    }    return (ret);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidhorizontalAccumulate16(uint16 *wp, int n, int stride, uint16 *op,\tuint16 *ToLinear16){    register unsigned int  cr, cg, cb, ca, mask;    if (n >= stride) {\tmask = CODE_MASK;\tif (stride == 3) {\t    op[0] = ToLinear16[cr = (wp[0] & mask)];\t    op[1] = ToLinear16[cg = (wp[1] & mask)];\t    op[2] = ToLinear16[cb = (wp[2] & mask)];\t    n -= 3;\t    while (n > 0) {\t\twp += 3;\t\top += 3;\t\tn -= 3;\t\top[0] = ToLinear16[(cr += wp[0]) & mask];\t\top[1] = ToLinear16[(cg += wp[1]) & mask];\t\top[2] = ToLinear16[(cb += wp[2]) & mask];\t    }\t} else if (stride == 4) {\t    op[0] = ToLinear16[cr = (wp[0] & mask)];\t    op[1] = ToLinear16[cg = (wp[1] & mask)];\t    op[2] = ToLinear16[cb = (wp[2] & mask)];\t    op[3] = ToLinear16[ca = (wp[3] & mask)];\t    n -= 4;\t    while (n > 0) {\t\twp += 4;\t\top += 4;\t\tn -= 4;\t\top[0] = ToLinear16[(cr += wp[0]) & mask];\t\top[1] = ToLinear16[(cg += wp[1]) & mask];\t\top[2] = ToLinear16[(cb += wp[2]) & mask];\t\top[3] = ToLinear16[(ca += wp[3]) & mask];\t    }\t} else {\t    REPEAT(stride, *op = ToLinear16[*wp&mask]; wp++; op++)\t    n -= stride;\t    while (n > 0) {\t\tREPEAT(stride,\t\t    wp[stride] += *wp; *op = ToLinear16[*wp&mask]; wp++; op++)\t\tn -= stride;\t    }\t}    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intNeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s){\tstatic const char module[] = \"NeXTDecode\";\tunsigned char *bp, *op;\ttmsize_t cc;\tuint8* row;\ttmsize_t scanline, n;\t(void) s;\t\tfor (op = (unsigned char*) buf, cc = occ; cc-- > 0;)\t\t*op++ = 0xff;\tbp = (unsigned char *)tif->tif_rawcp;\tcc = tif->tif_rawcc;\tscanline = tif->tif_scanlinesize;\tif (occ % scanline)\t{\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\t\treturn (0);\t}\tfor (row = buf; cc > 0 && occ > 0; occ -= scanline, row += scanline) {\t\tn = *bp++;\t\tcc--;\t\tswitch (n) {\t\tcase LITERALROW:\t\t\t\t\t\tif (cc < scanline)\t\t\t\tgoto bad;\t\t\t_TIFFmemcpy(row, bp, scanline);\t\t\tbp += scanline;\t\t\tcc -= scanline;\t\t\tbreak;\t\tcase LITERALSPAN: {\t\t\ttmsize_t off;\t\t\t\t\t\tif( cc < 4 )\t\t\t\tgoto bad;\t\t\toff = (bp[0] * 256) + bp[1];\t\t\tn = (bp[2] * 256) + bp[3];\t\t\tif (cc < 4+n || off+n > scanline)\t\t\t\tgoto bad;\t\t\t_TIFFmemcpy(row+off, bp+4, n);\t\t\tbp += 4+n;\t\t\tcc -= 4+n;\t\t\tbreak;\t\t}\t\tdefault: {\t\t\tuint32 npixels = 0, grey;\t\t\ttmsize_t op_offset = 0;\t\t\tuint32 imagewidth = tif->tif_dir.td_imagewidth;            if( isTiled(tif) )                imagewidth = tif->tif_dir.td_tilewidth;\t\t\t\t\t\top = row;\t\t\tfor (;;) {\t\t\t\tgrey = (uint32)((n>>6) & 0x3);\t\t\t\tn &= 0x3f;\t\t\t\t\t\t\t\twhile (n-- > 0 && npixels < imagewidth && op_offset < scanline)\t\t\t\t\tSETPIXEL(op, grey);\t\t\t\tif (npixels >= imagewidth)\t\t\t\t\tbreak;                if (op_offset >= scanline ) {                    TIFFErrorExt(tif->tif_clientdata, module, \"Invalid data for scanline %ld\",                        (long) tif->tif_row);                    return (0);                }\t\t\t\tif (cc == 0)\t\t\t\t\tgoto bad;\t\t\t\tn = *bp++;\t\t\t\tcc--;\t\t\t}\t\t\tbreak;\t\t}\t\t}\t}\ttif->tif_rawcp = (uint8*) bp;\ttif->tif_rawcc = cc;\treturn (1);bad:\tTIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\",\t    (long) tif->tif_row);\treturn (0);}",
        "label": 1,
        "cve": "cve-2016-10272"
    },
    {
        "code": "LPSTR FAR FindDIBBits(LPSTR lpDIB){   return (lpDIB + *(LPDWORD)lpDIB + PaletteSize(lpDIB));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteRational(TIFF* tif,    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, float v){\treturn (TIFFWriteRationalArray(tif, type, tag, dir, 1, &v));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff){\tstatic const char module[] = \"TIFFWriteDirectorySec\";\tuint32 ndir;\tTIFFDirEntry* dir;\tuint32 dirsize;\tvoid* dirmem;\tuint32 m;\tif (tif->tif_mode == O_RDONLY)\t\treturn (1);        _TIFFFillStriles( tif );        \t\tif (imagedone)\t{\t\tif (tif->tif_flags & TIFF_POSTENCODE)\t\t{\t\t\ttif->tif_flags &= ~TIFF_POSTENCODE;\t\t\tif (!(*tif->tif_postencode)(tif))\t\t\t{\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\t\t\t\t    \"Error post-encoding before directory write\");\t\t\t\treturn (0);\t\t\t}\t\t}\t\t(*tif->tif_close)(tif);       \t\t\t\tif (tif->tif_rawcc > 0 \t\t    && (tif->tif_flags & TIFF_BEENWRITING) != 0 )\t\t{\t\t    if( !TIFFFlushData1(tif) )                    {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"Error flushing data before directory write\");\t\t\treturn (0);                    }\t\t}\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata)\t\t{\t\t\t_TIFFfree(tif->tif_rawdata);\t\t\ttif->tif_rawdata = NULL;\t\t\ttif->tif_rawcc = 0;\t\t\ttif->tif_rawdatasize = 0;                        tif->tif_rawdataoff = 0;                        tif->tif_rawdataloaded = 0;\t\t}\t\ttif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP);\t}\tdir=NULL;\tdirmem=NULL;\tdirsize=0;\twhile (1)\t{\t\tndir=0;\t\tif (isimage)\t\t{\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGEWIDTH,tif->tif_dir.td_imagewidth))\t\t\t\t\tgoto bad;\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGELENGTH,tif->tif_dir.td_imagelength))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILEWIDTH,tif->tif_dir.td_tilewidth))\t\t\t\t\tgoto bad;\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILELENGTH,tif->tif_dir.td_tilelength))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XRESOLUTION,tif->tif_dir.td_xresolution))\t\t\t\t\tgoto bad;\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YRESOLUTION,tif->tif_dir.td_yresolution))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_POSITION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XPOSITION,tif->tif_dir.td_xposition))\t\t\t\t\tgoto bad;\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YPOSITION,tif->tif_dir.td_yposition))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SUBFILETYPE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_SUBFILETYPE,tif->tif_dir.td_subfiletype))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_BITSPERSAMPLE,tif->tif_dir.td_bitspersample))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_COMPRESSION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_COMPRESSION,tif->tif_dir.td_compression))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PHOTOMETRIC,tif->tif_dir.td_photometric))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_THRESHHOLDING,tif->tif_dir.td_threshholding))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_FILLORDER))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_FILLORDER,tif->tif_dir.td_fillorder))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_ORIENTATION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_ORIENTATION,tif->tif_dir.td_orientation))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_SAMPLESPERPIXEL,tif->tif_dir.td_samplesperpixel))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_ROWSPERSTRIP,tif->tif_dir.td_rowsperstrip))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MINSAMPLEVALUE,tif->tif_dir.td_minsamplevalue))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MAXSAMPLEVALUE,tif->tif_dir.td_maxsamplevalue))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_PLANARCONFIG))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PLANARCONFIG,tif->tif_dir.td_planarconfig))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_RESOLUTIONUNIT,tif->tif_dir.td_resolutionunit))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_PAGENUMBER))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_PAGENUMBER,2,&tif->tif_dir.td_pagenumber[0]))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPBYTECOUNTS))\t\t\t{\t\t\t\tif (!isTiled(tif))\t\t\t\t{\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\t\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\t\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPOFFSETS))\t\t\t{\t\t\t\tif (!isTiled(tif))\t\t\t\t{                                        if (tif->tif_dir.td_stripoffset != NULL &&                        !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))                        goto bad;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\t\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_COLORMAP))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_EXTRASAMPLES))\t\t\t{\t\t\t\tif (tif->tif_dir.td_extrasamples)\t\t\t\t{\t\t\t\t\tuint16 na;\t\t\t\t\tuint16* nb;\t\t\t\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb);\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb))\t\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDEPTH))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_TILEDEPTH,tif->tif_dir.td_tiledepth))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_HALFTONEHINTS,2,&tif->tif_dir.td_halftonehints[0]))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_YCBCRSUBSAMPLING,2,&tif->tif_dir.td_ycbcrsubsampling[0]))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_YCBCRPOSITIONING,tif->tif_dir.td_ycbcrpositioning))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_REFBLACKWHITE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,TIFFTAG_REFERENCEBLACKWHITE,6,tif->tif_dir.td_refblackwhite))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagTransferfunction(tif,&ndir,dir))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_INKNAMES))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir))\t\t\t\t\tgoto bad;\t\t\t}\t\t\t{\t\t\t\tuint32 n;\t\t\t\tfor (n=0; n<tif->tif_nfields; n++) {\t\t\t\t\tconst TIFFField* o;\t\t\t\t\to = tif->tif_fields[n];\t\t\t\t\tif ((o->field_bit>=FIELD_CODEC)&&(TIFFFieldSet(tif,o->field_bit)))\t\t\t\t\t{\t\t\t\t\t\tswitch (o->get_field_type)\t\t\t\t\t\t{\t\t\t\t\t\t\tcase TIFF_SETGET_ASCII:\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tuint32 pa;\t\t\t\t\t\t\t\t\tchar* pb;\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_ASCII);\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE);\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pb);\t\t\t\t\t\t\t\t\tpa=(uint32)(strlen(pb));\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\t\t\t\t\t\t\t\t\t\tgoto bad;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SETGET_UINT16:\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tuint16 p;\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_SHORT);\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p))\t\t\t\t\t\t\t\t\t\tgoto bad;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SETGET_UINT32:\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tuint32 p;\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_LONG);\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p))\t\t\t\t\t\t\t\t\t\tgoto bad;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SETGET_C32_UINT8:\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tuint32 pa;\t\t\t\t\t\t\t\t\tvoid* pb;\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_UNDEFINED);\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE2);\t\t\t\t\t\t\t\t\tassert(o->field_passcount==1);\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pa,&pb);\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\t\t\t\t\t\t\t\t\t\tgoto bad;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tdefault:\t\t\t\t\t\t\t\tassert(0);   \t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\tfor (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++)\t\t{                        uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag;                        uint32 count = tif->tif_dir.td_customValues[m].count;\t\t\tswitch (tif->tif_dir.td_customValues[m].info->field_type)\t\t\t{\t\t\t\tcase TIFF_ASCII:\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_UNDEFINED:\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_BYTE:\t\t\t\t\tif (!TIFFWriteDirectoryTagByteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SBYTE:\t\t\t\t\tif (!TIFFWriteDirectoryTagSbyteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SHORT:\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SSHORT:\t\t\t\t\tif (!TIFFWriteDirectoryTagSshortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_LONG:\t\t\t\t\tif (!TIFFWriteDirectoryTagLongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SLONG:\t\t\t\t\tif (!TIFFWriteDirectoryTagSlongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_LONG8:\t\t\t\t\tif (!TIFFWriteDirectoryTagLong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SLONG8:\t\t\t\t\tif (!TIFFWriteDirectoryTagSlong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_RATIONAL:\t\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SRATIONAL:\t\t\t\t\tif (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_FLOAT:\t\t\t\t\tif (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_DOUBLE:\t\t\t\t\tif (!TIFFWriteDirectoryTagDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_IFD:\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_IFD8:\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdIfd8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tdefault:\t\t\t\t\tassert(0);   \t\t\t\t\tbreak;\t\t\t}\t\t}\t\tif (dir!=NULL)\t\t\tbreak;\t\tdir=_TIFFmalloc(ndir*sizeof(TIFFDirEntry));\t\tif (dir==NULL)\t\t{\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\t\t\tgoto bad;\t\t}\t\tif (isimage)\t\t{\t\t\tif ((tif->tif_diroff==0)&&(!TIFFLinkDirectory(tif)))\t\t\t\tgoto bad;\t\t}\t\telse\t\t\ttif->tif_diroff=(TIFFSeekFile(tif,0,SEEK_END)+1)&(~((toff_t)1));\t\tif (pdiroff!=NULL)\t\t\t*pdiroff=tif->tif_diroff;\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t\t\tdirsize=2+ndir*12+4;\t\telse\t\t\tdirsize=8+ndir*20+8;\t\ttif->tif_dataoff=tif->tif_diroff+dirsize;\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t\t\ttif->tif_dataoff=(uint32)tif->tif_dataoff;\t\tif ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize))\t\t{\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\");\t\t\tgoto bad;\t\t}\t\tif (tif->tif_dataoff&1)\t\t\ttif->tif_dataoff++;\t\tif (isimage)\t\t\ttif->tif_curdir++;\t}\tif (isimage)\t{\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0))\t\t{\t\t\tuint32 na;\t\t\tTIFFDirEntry* nb;\t\t\tfor (na=0, nb=dir; ; na++, nb++)\t\t\t{\t\t\t\tassert(na<ndir);\t\t\t\tif (nb->tdir_tag==TIFFTAG_SUBIFD)\t\t\t\t\tbreak;\t\t\t}\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+2+na*12+8;\t\t\telse\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+8+na*20+12;\t\t}\t}\tdirmem=_TIFFmalloc(dirsize);\tif (dirmem==NULL)\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\t\tgoto bad;\t}\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t{\t\tuint8* n;\t\tuint32 nTmp;\t\tTIFFDirEntry* o;\t\tn=dirmem;\t\t*(uint16*)n=(uint16)ndir;\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabShort((uint16*)n);\t\tn+=2;\t\to=dir;\t\tfor (m=0; m<ndir; m++)\t\t{\t\t\t*(uint16*)n=o->tdir_tag;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabShort((uint16*)n);\t\t\tn+=2;\t\t\t*(uint16*)n=o->tdir_type;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabShort((uint16*)n);\t\t\tn+=2;\t\t\tnTmp = (uint32)o->tdir_count;\t\t\t_TIFFmemcpy(n,&nTmp,4);\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabLong((uint32*)n);\t\t\tn+=4;\t\t\t\t\t\t\t\t\t_TIFFmemcpy(n,&o->tdir_offset,4);\t\t\tn+=4;\t\t\to++;\t\t}\t\tnTmp = (uint32)tif->tif_nextdiroff;\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabLong(&nTmp);\t\t_TIFFmemcpy(n,&nTmp,4);\t}\telse\t{\t\tuint8* n;\t\tTIFFDirEntry* o;\t\tn=dirmem;\t\t*(uint64*)n=ndir;\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabLong8((uint64*)n);\t\tn+=8;\t\to=dir;\t\tfor (m=0; m<ndir; m++)\t\t{\t\t\t*(uint16*)n=o->tdir_tag;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabShort((uint16*)n);\t\t\tn+=2;\t\t\t*(uint16*)n=o->tdir_type;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabShort((uint16*)n);\t\t\tn+=2;\t\t\t_TIFFmemcpy(n,&o->tdir_count,8);\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabLong8((uint64*)n);\t\t\tn+=8;\t\t\t_TIFFmemcpy(n,&o->tdir_offset,8);\t\t\tn+=8;\t\t\to++;\t\t}\t\t_TIFFmemcpy(n,&tif->tif_nextdiroff,8);\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabLong8((uint64*)n);\t}\t_TIFFfree(dir);\tdir=NULL;\tif (!SeekOK(tif,tif->tif_diroff))\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\t\tgoto bad;\t}\tif (!WriteOK(tif,dirmem,(tmsize_t)dirsize))\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\t\tgoto bad;\t}\t_TIFFfree(dirmem);\tif (imagedone)\t{\t\tTIFFFreeDirectory(tif);\t\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\t\ttif->tif_flags &= ~TIFF_DIRTYSTRIP;\t\t(*tif->tif_cleanup)(tif);\t\t\t\tTIFFCreateDirectory(tif);\t}\treturn(1);bad:\tif (dir!=NULL)\t\t_TIFFfree(dir);\tif (dirmem!=NULL)\t\t_TIFFfree(dirmem);\treturn(0);}",
        "label": 1,
        "cve": "cve-2017-13726"
    },
    {
        "code": "static intreverseSamples8bits (uint16 spp, uint16 bps, uint32 width,                      uint8 *ibuff, uint8 *obuff)  {  int      ready_bits = 0;  uint32   col;  uint32   src_byte, src_bit;  uint32   bit_offset = 0;  uint8    match_bits = 0, mask_bits = 0;  uint8    buff1 = 0, buff2 = 0;  unsigned char *src;  unsigned char *dst;  tsample_t sample;  if ((ibuff == NULL) || (obuff == NULL))    {    TIFFError(\"reverseSamples8bits\",\"Invalid image or work buffer\");    return (1);    }  ready_bits = 0;  mask_bits =  (uint8)-1 >> ( 8 - bps);  dst = obuff;  for (col = width; col > 0; col--)    {        bit_offset = (col - 1) * bps * spp;    for (sample = 0; sample < spp; sample++)      {      if (sample == 0)        {        src_byte = bit_offset / 8;        src_bit  = bit_offset % 8;        }      else        {        src_byte = (bit_offset + (sample * bps)) / 8;        src_bit  = (bit_offset + (sample * bps)) % 8;        }      src = ibuff + src_byte;      match_bits = mask_bits << (8 - src_bit - bps);       buff1 = ((*src) & match_bits) << (src_bit);      if (ready_bits < 8)        buff2 = (buff2 | (buff1 >> ready_bits));      else          {        *dst++ = buff2;        buff2 = buff1;        ready_bits -= 8;        }      ready_bits += bps;      }    }  if (ready_bits > 0)    {    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));    *dst++ = buff1;    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcpTiles(TIFF* in, TIFF* out){    tsize_t bufsize = TIFFTileSize(in);    unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);    if (buf) {\tttile_t t, nt = TIFFNumberOfTiles(in);\tuint64 *bytecounts;\tTIFFGetField(in, TIFFTAG_TILEBYTECOUNTS, &bytecounts);\tfor (t = 0; t < nt; t++) {\t    if (bytecounts[t] > (uint64) bufsize) {\t\tbuf = (unsigned char *)_TIFFrealloc(buf, (tmsize_t)bytecounts[t]);\t\tif (!buf)\t\t    goto bad;\t\tbufsize = (tmsize_t)bytecounts[t];\t    }\t    if (TIFFReadRawTile(in, t, buf, (tmsize_t)bytecounts[t]) < 0 ||\t\tTIFFWriteRawTile(out, t, buf, (tmsize_t)bytecounts[t]) < 0) {\t\t_TIFFfree(buf);\t\treturn 0;\t    }\t}\t_TIFFfree(buf);\treturn 1;    }bad:    TIFFError(TIFFFileName(in),\t\t  \"Can't allocate space for tile buffer.\");\treturn (0);}",
        "label": 1,
        "cve": "cve-2016-3631-2"
    },
    {
        "code": "static voidsetWindowSize(void){        glutReshapeWindow(width, height);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(){\tTIFF\t\t*tif;\tunsigned char\tbuf[SPP] = { 0, 127, 255 };\tuint64          dir_offset = 0, dir_offset2 = 0;\tuint64          read_dir_offset = 0, read_dir_offset2 = 0;\tuint64          *dir_offset2_ptr = NULL;\tchar           *ascii_value;\tuint16          count16 = 0;\t\ttif = TIFFOpen(filename, \"w+\");\tif (!tif) {\t\tfprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename);\t\treturn 1;\t}\tif (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) {\t\tfprintf (stderr, \"Can't set ImageWidth tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) {\t\tfprintf (stderr, \"Can't set ImageLength tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps)) {\t\tfprintf (stderr, \"Can't set BitsPerSample tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, SPP)) {\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip)) {\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, planarconfig)) {\t\tfprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric)) {\t\tfprintf (stderr, \"Can't set PhotometricInterpretation tag.\\n\");\t\tgoto failure;\t}\t\tif (TIFFWriteScanline(tif, buf, 0, 0) == -1) {\t\tfprintf (stderr, \"Can't write image data.\\n\");\t\tgoto failure;\t}        if (!TIFFWriteDirectory( tif )) {\t\tfprintf (stderr, \"TIFFWriteDirectory() failed.\\n\");\t\tgoto failure;\t}\t\tif (TIFFCreateEXIFDirectory(tif) != 0) {\t\tfprintf (stderr, \"TIFFCreateEXIFDirectory() failed.\\n\" );\t\tgoto failure;\t}\tif (!TIFFSetField( tif, EXIFTAG_SPECTRALSENSITIVITY, \"EXIF Spectral Sensitivity\")) {\t\tfprintf (stderr, \"Can't write SPECTRALSENSITIVITY\\n\" );\t\tgoto failure;\t}\t\t        if (!TIFFWriteCustomDirectory( tif, &dir_offset )) {\t\tfprintf (stderr, \"TIFFWriteCustomDirectory() with EXIF failed.\\n\");\t\tgoto failure;\t}\t\tTIFFFreeDirectory( tif );\tif (TIFFCreateCustomDirectory(tif, &customFieldArray) != 0) {\t\tfprintf (stderr, \"TIFFCreateEXIFDirectory() failed.\\n\" );\t\tgoto failure;\t}\tif (!TIFFSetField( tif, TIFFTAG_IMAGEWIDTH, \"*Custom1\")) { \t\tfprintf (stderr, \"Can't write pseudo-IMAGEWIDTH.\\n\" );\t\tgoto failure;\t}\t\t\tif (!TIFFSetField( tif, TIFFTAG_DOTRANGE, \"*Custom2\")) { \t\tfprintf (stderr, \"Can't write pseudo-DOTWIDTH.\\n\" );\t\tgoto failure;\t}\t\t        if (!TIFFWriteCustomDirectory( tif, &dir_offset2 )) {\t\tfprintf (stderr, \"TIFFWriteCustomDirectory() with EXIF failed.\\n\");\t\tgoto failure;\t}\t\tTIFFSetDirectory(tif, 0);\tTIFFSetField(tif, TIFFTAG_EXIFIFD, dir_offset );\tTIFFSetField(tif, TIFFTAG_SUBIFD, 1, &dir_offset2 );\tTIFFClose(tif);\t\ttif = TIFFOpen(filename, \"r\");\tTIFFGetField(tif, TIFFTAG_EXIFIFD, &read_dir_offset );\tif( read_dir_offset != dir_offset ) {\t\tfprintf (stderr, \"Did not get expected EXIFIFD.\\n\" );\t\tgoto failure;\t}\tTIFFGetField(tif, TIFFTAG_SUBIFD, &count16, &dir_offset2_ptr );\tread_dir_offset2 = dir_offset2_ptr[0];\tif( read_dir_offset2 != dir_offset2 || count16 != 1) {\t\tfprintf (stderr, \"Did not get expected SUBIFD.\\n\" );\t\tgoto failure;\t}\tif( !TIFFReadEXIFDirectory(tif, read_dir_offset) ) {\t\tfprintf (stderr, \"TIFFReadEXIFDirectory() failed.\\n\" );\t\tgoto failure;\t}\tif (!TIFFGetField( tif, EXIFTAG_SPECTRALSENSITIVITY, &ascii_value) ) {\t\tfprintf (stderr, \"reading SPECTRALSENSITIVITY failed.\\n\" );\t\tgoto failure;\t}\tif( strcmp(ascii_value,\"EXIF Spectral Sensitivity\") != 0) {\t\tfprintf (stderr, \"got wrong SPECTRALSENSITIVITY value.\\n\" );\t\tgoto failure;\t}\t\tif( !TIFFReadCustomDirectory(tif, read_dir_offset2, &customFieldArray) ) {\t\tfprintf (stderr, \"TIFFReadCustomDirectory() failed.\\n\" );\t\tgoto failure;\t}\tif (!TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &ascii_value) ) {\t\tfprintf (stderr, \"reading pseudo-IMAGEWIDTH failed.\\n\" );\t\tgoto failure;\t}\tif( strcmp(ascii_value,\"*Custom1\") != 0) {\t\tfprintf (stderr, \"got wrong pseudo-IMAGEWIDTH value.\\n\" );\t\tgoto failure;\t}\tif (!TIFFGetField( tif, TIFFTAG_DOTRANGE, &ascii_value) ) {\t\tfprintf (stderr, \"reading pseudo-DOTRANGE failed.\\n\" );\t\tgoto failure;\t}\tif( strcmp(ascii_value,\"*Custom2\") != 0) {\t\tfprintf (stderr, \"got wrong pseudo-DOTRANGE value.\\n\" );\t\tgoto failure;\t}\tTIFFClose(tif);\t\tunlink(filename);\treturn 0;failure:\t\tTIFFClose(tif);\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*TIFFFdOpen(int fd, const char* name, const char* mode){\tTIFF* tif;\ttif = TIFFClientOpen(name, mode,\t    (void*) fd,\t    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,\t    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);\tif (tif)\t\ttif->tif_fd = fd;\treturn (tif);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFPrintDirectory(TIFF* tif, FILE* fd, long flags){\tTIFFDirectory *td = &tif->tif_dir;\tchar *sep;\tlong l, n;#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\tfprintf(fd, \"TIFF Directory at offset 0x%I64x (%I64u)\\n\",\t\t(unsigned __int64) tif->tif_diroff,\t\t(unsigned __int64) tif->tif_diroff);#else\tfprintf(fd, \"TIFF Directory at offset 0x%llx (%llu)\\n\",\t\t(unsigned long long) tif->tif_diroff,\t\t(unsigned long long) tif->tif_diroff);#endif\tif (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) {\t\tfprintf(fd, \"  Subfile Type:\");\t\tsep = \" \";\t\tif (td->td_subfiletype & FILETYPE_REDUCEDIMAGE) {\t\t\tfprintf(fd, \"%sreduced-resolution image\", sep);\t\t\tsep = \"/\";\t\t}\t\tif (td->td_subfiletype & FILETYPE_PAGE) {\t\t\tfprintf(fd, \"%smulti-page document\", sep);\t\t\tsep = \"/\";\t\t}\t\tif (td->td_subfiletype & FILETYPE_MASK)\t\t\tfprintf(fd, \"%stransparency mask\", sep);\t\tfprintf(fd, \" (%lu = 0x%lx)\\n\",\t\t    (unsigned long) td->td_subfiletype, (long) td->td_subfiletype);\t}\tif (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) {\t\tfprintf(fd, \"  Image Width: %lu Image Length: %lu\",\t\t    (unsigned long) td->td_imagewidth, (unsigned long) td->td_imagelength);\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))\t\t\tfprintf(fd, \" Image Depth: %lu\",\t\t\t    (unsigned long) td->td_imagedepth);\t\tfprintf(fd, \"\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) {\t\tfprintf(fd, \"  Tile Width: %lu Tile Length: %lu\",\t\t    (unsigned long) td->td_tilewidth, (unsigned long) td->td_tilelength);\t\tif (TIFFFieldSet(tif,FIELD_TILEDEPTH))\t\t\tfprintf(fd, \" Tile Depth: %lu\",\t\t\t    (unsigned long) td->td_tiledepth);\t\tfprintf(fd, \"\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_RESOLUTION)) {\t\tfprintf(fd, \"  Resolution: %g, %g\",\t\t    td->td_xresolution, td->td_yresolution);\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) {\t\t\tswitch (td->td_resolutionunit) {\t\t\tcase RESUNIT_NONE:\t\t\t\tfprintf(fd, \" (unitless)\");\t\t\t\tbreak;\t\t\tcase RESUNIT_INCH:\t\t\t\tfprintf(fd, \" pixels/inch\");\t\t\t\tbreak;\t\t\tcase RESUNIT_CENTIMETER:\t\t\t\tfprintf(fd, \" pixels/cm\");\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tfprintf(fd, \" (unit %u = 0x%x)\",\t\t\t\t    td->td_resolutionunit,\t\t\t\t    td->td_resolutionunit);\t\t\t\tbreak;\t\t\t}\t\t}\t\tfprintf(fd, \"\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_POSITION))\t\tfprintf(fd, \"  Position: %g, %g\\n\",\t\t    td->td_xposition, td->td_yposition);\tif (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\t\tfprintf(fd, \"  Bits/Sample: %u\\n\", td->td_bitspersample);\tif (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) {\t\tfprintf(fd, \"  Sample Format: \");\t\tswitch (td->td_sampleformat) {\t\tcase SAMPLEFORMAT_VOID:\t\t\tfprintf(fd, \"void\\n\");\t\t\tbreak;\t\tcase SAMPLEFORMAT_INT:\t\t\tfprintf(fd, \"signed integer\\n\");\t\t\tbreak;\t\tcase SAMPLEFORMAT_UINT:\t\t\tfprintf(fd, \"unsigned integer\\n\");\t\t\tbreak;\t\tcase SAMPLEFORMAT_IEEEFP:\t\t\tfprintf(fd, \"IEEE floating point\\n\");\t\t\tbreak;\t\tcase SAMPLEFORMAT_COMPLEXINT:\t\t\tfprintf(fd, \"complex signed integer\\n\");\t\t\tbreak;\t\tcase SAMPLEFORMAT_COMPLEXIEEEFP:\t\t\tfprintf(fd, \"complex IEEE floating point\\n\");\t\t\tbreak;\t\tdefault:\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_sampleformat, td->td_sampleformat);\t\t\tbreak;\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_COMPRESSION)) {\t\tconst TIFFCodec* c = TIFFFindCODEC(td->td_compression);\t\tfprintf(fd, \"  Compression Scheme: \");\t\tif (c)\t\t\tfprintf(fd, \"%s\\n\", c->name);\t\telse\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_compression, td->td_compression);\t}\tif (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) {\t\tfprintf(fd, \"  Photometric Interpretation: \");\t\tif (td->td_photometric < NPHOTONAMES)\t\t\tfprintf(fd, \"%s\\n\", photoNames[td->td_photometric]);\t\telse {\t\t\tswitch (td->td_photometric) {\t\t\tcase PHOTOMETRIC_LOGL:\t\t\t\tfprintf(fd, \"CIE Log2(L)\\n\");\t\t\t\tbreak;\t\t\tcase PHOTOMETRIC_LOGLUV:\t\t\t\tfprintf(fd, \"CIE Log2(L) (u',v')\\n\");\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t\t    td->td_photometric, td->td_photometric);\t\t\t\tbreak;\t\t\t}\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_EXTRASAMPLES) && td->td_extrasamples) {\t\tuint16 i;\t\tfprintf(fd, \"  Extra Samples: %u<\", td->td_extrasamples);\t\tsep = \"\";\t\tfor (i = 0; i < td->td_extrasamples; i++) {\t\t\tswitch (td->td_sampleinfo[i]) {\t\t\tcase EXTRASAMPLE_UNSPECIFIED:\t\t\t\tfprintf(fd, \"%sunspecified\", sep);\t\t\t\tbreak;\t\t\tcase EXTRASAMPLE_ASSOCALPHA:\t\t\t\tfprintf(fd, \"%sassoc-alpha\", sep);\t\t\t\tbreak;\t\t\tcase EXTRASAMPLE_UNASSALPHA:\t\t\t\tfprintf(fd, \"%sunassoc-alpha\", sep);\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tfprintf(fd, \"%s%u (0x%x)\", sep,\t\t\t\t    td->td_sampleinfo[i], td->td_sampleinfo[i]);\t\t\t\tbreak;\t\t\t}\t\t\tsep = \", \";\t\t}\t\tfprintf(fd, \">\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_INKNAMES)) {\t\tchar* cp;\t\tuint16 i;\t\tfprintf(fd, \"  Ink Names: \");\t\ti = td->td_samplesperpixel;\t\tsep = \"\";\t\tfor (cp = td->td_inknames; \t\t     i > 0 && cp < td->td_inknames + td->td_inknameslen; \t\t     cp = strchr(cp,'\\0')+1, i--) {\t\t\tsize_t max_chars = \t\t\t\ttd->td_inknameslen - (cp - td->td_inknames);\t\t\tfputs(sep, fd);\t\t\t_TIFFprintAsciiBounded(fd, cp, max_chars);\t\t\tsep = \", \";\t\t}                fputs(\"\\n\", fd);\t}\tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) {\t\tfprintf(fd, \"  Thresholding: \");\t\tswitch (td->td_threshholding) {\t\tcase THRESHHOLD_BILEVEL:\t\t\tfprintf(fd, \"bilevel art scan\\n\");\t\t\tbreak;\t\tcase THRESHHOLD_HALFTONE:\t\t\tfprintf(fd, \"halftone or dithered scan\\n\");\t\t\tbreak;\t\tcase THRESHHOLD_ERRORDIFFUSE:\t\t\tfprintf(fd, \"error diffused\\n\");\t\t\tbreak;\t\tdefault:\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_threshholding, td->td_threshholding);\t\t\tbreak;\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_FILLORDER)) {\t\tfprintf(fd, \"  FillOrder: \");\t\tswitch (td->td_fillorder) {\t\tcase FILLORDER_MSB2LSB:\t\t\tfprintf(fd, \"msb-to-lsb\\n\");\t\t\tbreak;\t\tcase FILLORDER_LSB2MSB:\t\t\tfprintf(fd, \"lsb-to-msb\\n\");\t\t\tbreak;\t\tdefault:\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_fillorder, td->td_fillorder);\t\t\tbreak;\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))        {\t\tfprintf(fd, \"  YCbCr Subsampling: %u, %u\\n\",\t\t\ttd->td_ycbcrsubsampling[0], td->td_ycbcrsubsampling[1] );\t}\tif (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) {\t\tfprintf(fd, \"  YCbCr Positioning: \");\t\tswitch (td->td_ycbcrpositioning) {\t\tcase YCBCRPOSITION_CENTERED:\t\t\tfprintf(fd, \"centered\\n\");\t\t\tbreak;\t\tcase YCBCRPOSITION_COSITED:\t\t\tfprintf(fd, \"cosited\\n\");\t\t\tbreak;\t\tdefault:\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_ycbcrpositioning, td->td_ycbcrpositioning);\t\t\tbreak;\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))\t\tfprintf(fd, \"  Halftone Hints: light %u dark %u\\n\",\t\t    td->td_halftonehints[0], td->td_halftonehints[1]);\tif (TIFFFieldSet(tif,FIELD_ORIENTATION)) {\t\tfprintf(fd, \"  Orientation: \");\t\tif (td->td_orientation < NORIENTNAMES)\t\t\tfprintf(fd, \"%s\\n\", orientNames[td->td_orientation]);\t\telse\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_orientation, td->td_orientation);\t}\tif (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\t\tfprintf(fd, \"  Samples/Pixel: %u\\n\", td->td_samplesperpixel);\tif (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) {\t\tfprintf(fd, \"  Rows/Strip: \");\t\tif (td->td_rowsperstrip == (uint32) -1)\t\t\tfprintf(fd, \"(infinite)\\n\");\t\telse\t\t\tfprintf(fd, \"%lu\\n\", (unsigned long) td->td_rowsperstrip);\t}\tif (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))\t\tfprintf(fd, \"  Min Sample Value: %u\\n\", td->td_minsamplevalue);\tif (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))\t\tfprintf(fd, \"  Max Sample Value: %u\\n\", td->td_maxsamplevalue);\tif (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) {\t\tint i;\t\tint count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;\t\tfprintf(fd, \"  SMin Sample Value:\");\t\tfor (i = 0; i < count; ++i)\t\t\tfprintf(fd, \" %g\", td->td_sminsamplevalue[i]);\t\tfprintf(fd, \"\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) {\t\tint i;\t\tint count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;\t\tfprintf(fd, \"  SMax Sample Value:\");\t\tfor (i = 0; i < count; ++i)\t\t\tfprintf(fd, \" %g\", td->td_smaxsamplevalue[i]);\t\tfprintf(fd, \"\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) {\t\tfprintf(fd, \"  Planar Configuration: \");\t\tswitch (td->td_planarconfig) {\t\tcase PLANARCONFIG_CONTIG:\t\t\tfprintf(fd, \"single image plane\\n\");\t\t\tbreak;\t\tcase PLANARCONFIG_SEPARATE:\t\t\tfprintf(fd, \"separate image planes\\n\");\t\t\tbreak;\t\tdefault:\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_planarconfig, td->td_planarconfig);\t\t\tbreak;\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_PAGENUMBER))\t\tfprintf(fd, \"  Page Number: %u-%u\\n\",\t\t    td->td_pagenumber[0], td->td_pagenumber[1]);\tif (TIFFFieldSet(tif,FIELD_COLORMAP)) {\t\tfprintf(fd, \"  Color Map: \");\t\tif (flags & TIFFPRINT_COLORMAP) {\t\t\tfprintf(fd, \"\\n\");\t\t\tn = 1L<<td->td_bitspersample;\t\t\tfor (l = 0; l < n; l++)\t\t\t\tfprintf(fd, \"   %5ld: %5u %5u %5u\\n\",\t\t\t\t    l,\t\t\t\t    td->td_colormap[0][l],\t\t\t\t    td->td_colormap[1][l],\t\t\t\t    td->td_colormap[2][l]);\t\t} else\t\t\tfprintf(fd, \"(present)\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) {\t\tint i;\t\tfprintf(fd, \"  Reference Black/White:\\n\");\t\tfor (i = 0; i < 3; i++)\t\tfprintf(fd, \"    %2d: %5g %5g\\n\", i,\t\t\ttd->td_refblackwhite[2*i+0],\t\t\ttd->td_refblackwhite[2*i+1]);\t}\tif (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) {\t\tfprintf(fd, \"  Transfer Function: \");\t\tif (flags & TIFFPRINT_CURVES) {\t\t\tfprintf(fd, \"\\n\");\t\t\tn = 1L<<td->td_bitspersample;\t\t\tfor (l = 0; l < n; l++) {\t\t\t\tuint16 i;\t\t\t\tfprintf(fd, \"    %2ld: %5u\",\t\t\t\t    l, td->td_transferfunction[0][l]);\t\t\t\tfor (i = 1; i < td->td_samplesperpixel; i++)\t\t\t\t\tfprintf(fd, \" %5u\",\t\t\t\t\t    td->td_transferfunction[i][l]);\t\t\t\tfputc('\\n', fd);\t\t\t}\t\t} else\t\t\tfprintf(fd, \"(present)\\n\");\t}\tif (TIFFFieldSet(tif, FIELD_SUBIFD) && (td->td_subifd)) {\t\tuint16 i;\t\tfprintf(fd, \"  SubIFD Offsets:\");\t\tfor (i = 0; i < td->td_nsubifd; i++)#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\t\tfprintf(fd, \" %5I64u\",\t\t\t\t(unsigned __int64) td->td_subifd[i]);#else\t\t\tfprintf(fd, \" %5llu\",\t\t\t\t(unsigned long long) td->td_subifd[i]);#endif\t\tfputc('\\n', fd);\t}\t \t{\t\tint  i;\t\tshort count;\t\tcount = (short) TIFFGetTagListCount(tif);\t\tfor(i = 0; i < count; i++) {\t\t\tuint32 tag = TIFFGetTagListEntry(tif, i);\t\t\tconst TIFFField *fip;\t\t\tuint32 value_count;\t\t\tint mem_alloc = 0;\t\t\tvoid *raw_data;\t\t\tfip = TIFFFieldWithTag(tif, tag);\t\t\tif(fip == NULL)\t\t\t\tcontinue;\t\t\tif(fip->field_passcount) {\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2 ) {\t\t\t\t\tif(TIFFGetField(tif, tag, &value_count, &raw_data) != 1)\t\t\t\t\t\tcontinue;\t\t\t\t} else if (fip->field_readcount == TIFF_VARIABLE ) {\t\t\t\t\tuint16 small_value_count;\t\t\t\t\tif(TIFFGetField(tif, tag, &small_value_count, &raw_data) != 1)\t\t\t\t\t\tcontinue;\t\t\t\t\tvalue_count = small_value_count;\t\t\t\t} else {\t\t\t\t\tassert (fip->field_readcount == TIFF_VARIABLE\t\t\t\t\t\t|| fip->field_readcount == TIFF_VARIABLE2);\t\t\t\t\tcontinue;\t\t\t\t} \t\t\t} else {\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2)\t\t\t\t\tvalue_count = 1;\t\t\t\telse if (fip->field_readcount == TIFF_SPP)\t\t\t\t\tvalue_count = td->td_samplesperpixel;\t\t\t\telse\t\t\t\t\tvalue_count = fip->field_readcount;\t\t\t\tif (fip->field_tag == TIFFTAG_DOTRANGE\t\t\t\t    && strcmp(fip->field_name,\"DotRange\") == 0) {\t\t\t\t\t \t\t\t\t\tstatic uint16 dotrange[2];\t\t\t\t\traw_data = dotrange;\t\t\t\t\tTIFFGetField(tif, tag, dotrange+0, dotrange+1);\t\t\t\t} else if (fip->field_type == TIFF_ASCII\t\t\t\t\t   || fip->field_readcount == TIFF_VARIABLE\t\t\t\t\t   || fip->field_readcount == TIFF_VARIABLE2\t\t\t\t\t   || fip->field_readcount == TIFF_SPP\t\t\t\t\t   || value_count > 1) {\t\t\t\t\tif(TIFFGetField(tif, tag, &raw_data) != 1)\t\t\t\t\t\tcontinue;\t\t\t\t} else {\t\t\t\t\traw_data = _TIFFmalloc(\t\t\t\t\t    _TIFFDataSize(fip->field_type)\t\t\t\t\t    * value_count);\t\t\t\t\tmem_alloc = 1;\t\t\t\t\tif(TIFFGetField(tif, tag, raw_data) != 1) {\t\t\t\t\t\t_TIFFfree(raw_data);\t\t\t\t\t\tcontinue;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\t \t\t\tif (!_TIFFPrettyPrintField(tif, fip, fd, tag, value_count, raw_data))\t\t\t\t_TIFFPrintField(fd, fip, value_count, raw_data);\t\t\tif(mem_alloc)\t\t\t\t_TIFFfree(raw_data);\t\t}\t}        \tif (tif->tif_tagmethods.printdir)\t\t(*tif->tif_tagmethods.printdir)(tif, fd, flags);        _TIFFFillStriles( tif );        \tif ((flags & TIFFPRINT_STRIPS) &&\t    TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) {\t\tuint32 s;\t\tfprintf(fd, \"  %lu %s:\\n\",\t\t    (unsigned long) td->td_nstrips,\t\t    isTiled(tif) ? \"Tiles\" : \"Strips\");\t\tfor (s = 0; s < td->td_nstrips; s++)#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\t\tfprintf(fd, \"    %3lu: [%8I64u, %8I64u]\\n\",\t\t\t    (unsigned long) s,\t\t\t    (unsigned __int64) td->td_stripoffset[s],\t\t\t    (unsigned __int64) td->td_stripbytecount[s]);#else\t\t\tfprintf(fd, \"    %3lu: [%8llu, %8llu]\\n\",\t\t\t    (unsigned long) s,\t\t\t    (unsigned long long) td->td_stripoffset[s],\t\t\t    (unsigned long long) td->td_stripbytecount[s]);#endif\t}}",
        "label": 1,
        "cve": "CVE-2017-18013"
    },
    {
        "code": "static tsize_t _tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size){\treturn (read((int) fd, buf, size));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidWin32WarningHandler(const char* module, const char* fmt, va_list ap){\tLPTSTR szTitle;\tLPTSTR szTmp;\tLPCTSTR szTitleText = \"%s Warning\";\tLPCTSTR szDefaultModule = \"LIBTIFF\";\tLPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;\tif ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) +\t\tstrlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL)\t\treturn;\tsprintf(szTitle, szTitleText, szTmpModule);\tszTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);\tvsprintf(szTmp, fmt, ap);\tMessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONINFORMATION);\tLocalFree(szTitle);\treturn;\tif (module != NULL)\t\tfprintf(stderr, \"%s: \", module);\tfprintf(stderr, \"Warning, \");\tvfprintf(stderr, fmt, ap);\tfprintf(stderr, \".\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int JBIGSetupEncode(TIFF* tif){\tif (TIFFNumberOfStrips(tif) != 1)\t{\t\tTIFFErrorExt(tif->tif_clientdata, \"JBIG\", \"Multistrip images not supported in encoder\");\t\treturn 0;\t}\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intNeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s){\tstatic const char module[] = \"NeXTDecode\";\tunsigned char *bp, *op;\ttmsize_t cc;\tuint8* row;\ttmsize_t scanline, n;\t(void) s;\t \tfor (op = (unsigned char*) buf, cc = occ; cc-- > 0;)\t\t*op++ = 0xff;\tbp = (unsigned char *)tif->tif_rawcp;\tcc = tif->tif_rawcc;\tscanline = tif->tif_scanlinesize;\tif (occ % scanline)\t{\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\t\treturn (0);\t}\tfor (row = buf; cc > 0 && occ > 0; occ -= scanline, row += scanline) {\t\tn = *bp++;\t\tcc--;\t\tswitch (n) {\t\tcase LITERALROW:\t\t\t \t\t\tif (cc < scanline)\t\t\t\tgoto bad;\t\t\t_TIFFmemcpy(row, bp, scanline);\t\t\tbp += scanline;\t\t\tcc -= scanline;\t\t\tbreak;\t\tcase LITERALSPAN: {\t\t\ttmsize_t off;\t\t\t \t\t\tif( cc < 4 )\t\t\t\tgoto bad;\t\t\toff = (bp[0] * 256) + bp[1];\t\t\tn = (bp[2] * 256) + bp[3];\t\t\tif (cc < 4+n || off+n > scanline)\t\t\t\tgoto bad;\t\t\t_TIFFmemcpy(row+off, bp+4, n);\t\t\tbp += 4+n;\t\t\tcc -= 4+n;\t\t\tbreak;\t\t}\t\tdefault: {\t\t\tuint32 npixels = 0, grey;\t\t\ttmsize_t op_offset = 0;\t\t\tuint32 imagewidth = tif->tif_dir.td_imagewidth;            if( isTiled(tif) )                imagewidth = tif->tif_dir.td_tilewidth;\t\t\t \t\t\top = row;\t\t\tfor (;;) {\t\t\t\tgrey = (uint32)((n>>6) & 0x3);\t\t\t\tn &= 0x3f;\t\t\t\t \t\t\t\twhile (n-- > 0 && npixels < imagewidth && op_offset < scanline)\t\t\t\t\tSETPIXEL(op, grey);\t\t\t\tif (npixels >= imagewidth)\t\t\t\t\tbreak;                if (op_offset >= scanline ) {                    TIFFErrorExt(tif->tif_clientdata, module, \"Invalid data for scanline %ld\",                        (long) tif->tif_row);                    return (0);                }\t\t\t\tif (cc == 0)\t\t\t\t\tgoto bad;\t\t\t\tn = *bp++;\t\t\t\tcc--;\t\t\t}\t\t\tbreak;\t\t}\t\t}\t}\ttif->tif_rawcp = (uint8*) bp;\ttif->tif_rawcc = cc;\treturn (1);bad:\tTIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\",\t    (long) tif->tif_row);\treturn (0);}",
        "label": 1,
        "cve": "CVE-2015-8784"
    },
    {
        "code": "intmain(int argc, char* argv[]){\tuint16 photometric = 0;\tuint32 rowsperstrip = (uint32) -1;\tdouble resolution = -1;\tunsigned char *buf = NULL;\ttmsize_t linebytes = 0;\tuint16 spp = 1;\tuint16 bpp = 8;\tTIFF *out;\tFILE *in;\tunsigned int w, h, prec, row;\tchar *infile;\tint c;#if !HAVE_DECL_OPTARG\textern int optind;\textern char* optarg;#endif\ttmsize_t scanline_size;\tif (argc < 2) {\t    fprintf(stderr, \"%s: Too few arguments\\n\", argv[0]);\t    usage();\t}\twhile ((c = getopt(argc, argv, \"c:r:R:\")) != -1)\t\tswitch (c) {\t\tcase 'c':\t\t\t\t\tif (!processCompressOptions(optarg))\t\t\t\tusage();\t\t\tbreak;\t\tcase 'r':\t\t\t\t\trowsperstrip = atoi(optarg);\t\t\tbreak;\t\tcase 'R':\t\t\t\t\tresolution = atof(optarg);\t\t\tbreak;\t\tcase '?':\t\t\tusage();\t\t\t\t\t}\tif (optind + 2 < argc) {\t    fprintf(stderr, \"%s: Too many arguments\\n\", argv[0]);\t    usage();\t}\t\tif (argc - optind > 1) {\t\tinfile = argv[optind++];\t\tin = fopen(infile, \"rb\");\t\tif (in == NULL) {\t\t\tfprintf(stderr, \"%s: Can not open.\\n\", infile);\t\t\treturn (-1);\t\t}\t} else {\t\tinfile = \"<stdin>\";\t\tin = stdin;#if defined(HAVE_SETMODE) && defined(O_BINARY)\t\tsetmode(fileno(stdin), O_BINARY);#endif\t}\tif (fgetc(in) != 'P')\t\tBadPPM(infile);\tswitch (fgetc(in)) {\t\tcase '4':\t\t\t\t\t\tbpp = 1;\t\t\tspp = 1;\t\t\tphotometric = PHOTOMETRIC_MINISWHITE;\t\t\tbreak;\t\tcase '5':\t\t\t\t\t\tbpp = 8;\t\t\tspp = 1;\t\t\tphotometric = PHOTOMETRIC_MINISBLACK;\t\t\tbreak;\t\tcase '6':\t\t\t\t\t\tbpp = 8;\t\t\tspp = 3;\t\t\tphotometric = PHOTOMETRIC_RGB;\t\t\tif (compression == COMPRESSION_JPEG &&\t\t\t    jpegcolormode == JPEGCOLORMODE_RGB)\t\t\t\tphotometric = PHOTOMETRIC_YCBCR;\t\t\tbreak;\t\tdefault:\t\t\tBadPPM(infile);\t}\t\twhile(1) {\t\tif (feof(in))\t\t\tBadPPM(infile);\t\tc = fgetc(in);\t\t\t\tif (strchr(\" \\t\\r\\n\", c))\t\t\tcontinue;\t\t\t\tif (c == '#') {\t\t\tdo {\t\t\t    c = fgetc(in);\t\t\t} while(!(strchr(\"\\r\\n\", c) || feof(in)));\t\t\tcontinue;\t\t}\t\tungetc(c, in);\t\tbreak;\t}\tswitch (bpp) {\tcase 1:\t\tif (fscanf(in, \" %u %u\", &w, &h) != 2)\t\t\tBadPPM(infile);\t\tif (fgetc(in) != '\\n')\t\t\tBadPPM(infile);\t\tbreak;\tcase 8:\t\tif (fscanf(in, \" %u %u %u\", &w, &h, &prec) != 3)\t\t\tBadPPM(infile);\t\tif (fgetc(in) != '\\n' || prec != 255)\t\t\tBadPPM(infile);\t\tbreak;\t}\tout = TIFFOpen(argv[optind], \"w\");\tif (out == NULL)\t\treturn (-4);\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, (uint32) w);\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, (uint32) h);\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp);\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bpp);\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\tswitch (compression) {\tcase COMPRESSION_JPEG:\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\t\tbreak;\tcase COMPRESSION_LZW:\tcase COMPRESSION_DEFLATE:\t\tif (predictor != 0)\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\t\tbreak;        case COMPRESSION_CCITTFAX3:\t\tTIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);\t\tbreak;\t}\tswitch (bpp) {\t\tcase 1:\t\t\t\t\t\tlinebytes = (multiply_ms(spp, w) + (8 - 1)) / 8;\t\t\tif (rowsperstrip == (uint32) -1) {\t\t\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, h);\t\t\t} else {\t\t\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\t\t\t\t    TIFFDefaultStripSize(out, rowsperstrip));\t\t\t}\t\t\tbreak;\t\tcase 8:\t\t\tlinebytes = multiply_ms(spp, w);\t\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\t\t\t    TIFFDefaultStripSize(out, rowsperstrip));\t\t\tbreak;\t}\tif (linebytes == 0) {\t\tfprintf(stderr, \"%s: scanline size overflow\\n\", infile);\t\t(void) TIFFClose(out);\t\texit(-2);\t\t\t\t\t\t}\tscanline_size = TIFFScanlineSize(out);\tif (scanline_size == 0) {\t\t\t\t(void) TIFFClose(out);\t\texit(-2);\t\t\t\t\t\t}\tif (scanline_size < linebytes)\t\tbuf = (unsigned char *)_TIFFmalloc(linebytes);\telse\t\tbuf = (unsigned char *)_TIFFmalloc(scanline_size);\tif (buf == NULL) {\t\tfprintf(stderr, \"%s: Not enough memory\\n\", infile);\t\t(void) TIFFClose(out);\t\texit(-2);\t}\tif (resolution > 0) {\t\tTIFFSetField(out, TIFFTAG_XRESOLUTION, resolution);\t\tTIFFSetField(out, TIFFTAG_YRESOLUTION, resolution);\t\tTIFFSetField(out, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\t}\tfor (row = 0; row < h; row++) {\t\tif (fread(buf, linebytes, 1, in) != 1) {\t\t\tfprintf(stderr, \"%s: scanline %lu: Read error.\\n\",\t\t\t    infile, (unsigned long) row);\t\t\tbreak;\t\t}\t\tif (TIFFWriteScanline(out, buf, row, 0) < 0)\t\t\tbreak;\t}\t(void) TIFFClose(out);\tif (buf)\t\t_TIFFfree(buf);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidBadPPM(char* file){\tfprintf(stderr, \"%s: Not a PPM file.\\n\", file);\texit(-2);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s){\tTIFFPredictorState *sp = PredictorState(tif);\tassert(sp != NULL);\tassert(sp->decodetile != NULL);\tif ((*sp->decodetile)(tif, op0, occ0, s)) {\t\ttmsize_t rowsize = sp->rowsize;\t\tassert(rowsize > 0);\t\tif((occ0%rowsize) !=0)        {            TIFFErrorExt(tif->tif_clientdata, \"PredictorDecodeTile\",                         \"%s\", \"occ0%rowsize != 0\");            return 0;        }\t\tassert(sp->decodepfunc != NULL);\t\twhile (occ0 > 0) {\t\t\tif( !(*sp->decodepfunc)(tif, op0, rowsize) )                return 0;\t\t\tocc0 -= rowsize;\t\t\top0 += rowsize;\t\t}\t\treturn 1;\t} else\t\treturn 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static uint32checkInkNamesString(TIFF* tif, uint32 slen, const char* s){\tTIFFDirectory* td = &tif->tif_dir;\tuint16 i = td->td_samplesperpixel;\tif (slen > 0) {\t\tconst char* ep = s+slen;\t\tconst char* cp = s;\t\tfor (; i > 0; i--) {\t\t\tfor (; *cp != '\\0'; cp++)\t\t\t\tif (cp >= ep)\t\t\t\t\tgoto bad;\t\t\tcp++;\t\t\t\t\t\t}\t\treturn (cp-s);\t}bad:\tTIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\",\t    \"%s: Invalid InkNames value; expecting %d names, found %d\",\t    tif->tif_name,\t    td->td_samplesperpixel,\t    td->td_samplesperpixel-i);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(void){\tchar buf[BUFSIZ];\tint i;\tsetbuf(stderr, buf);        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\tfor (i = 0; stuff[i] != NULL; i++)\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\texit(-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedSrational(TIFF* tif, TIFFDirEntry* direntry, double* value){\tUInt64Aligned_t m;\tassert(sizeof(double)==8);\tassert(sizeof(uint64)==8);\tassert(sizeof(int32)==4);\tassert(sizeof(uint32)==4);\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t{\t\tenum TIFFReadDirEntryErr err;\t\tuint32 offset = direntry->tdir_offset.toff_long;\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabLong(&offset);\t\terr=TIFFReadDirEntryData(tif,offset,8,m.i);\t\tif (err!=TIFFReadDirEntryErrOk)\t\t\treturn(err);\t}\telse\t\tm.l=direntry->tdir_offset.toff_long8;\tif (tif->tif_flags&TIFF_SWAB)\t\tTIFFSwabArrayOfLong(m.i,2);\tif ((int32)m.i[0]==0)\t\t*value=0.0;\telse\t\t*value=(double)((int32)m.i[0])/(double)m.i[1];\treturn(TIFFReadDirEntryErrOk);}",
        "label": 1,
        "cve": "cve-2017-7597-2"
    },
    {
        "code": "static voidinitPageSetup (struct pagedef *page, struct pageseg *pagelist,                struct buffinfo seg_buffs[])   {   int i;    strcpy (page->name, \"\");   page->mode = PAGE_MODE_NONE;   page->res_unit = RESUNIT_NONE;   page->hres = 0.0;   page->vres = 0.0;   page->width = 0.0;   page->length = 0.0;   page->hmargin = 0.0;   page->vmargin = 0.0;   page->rows = 0;   page->cols = 0;   page->orient = ORIENTATION_NONE;   for (i = 0; i < MAX_SECTIONS; i++)     {     pagelist[i].x1 = (uint32)0;     pagelist[i].x2 = (uint32)0;     pagelist[i].y1 = (uint32)0;     pagelist[i].y2 = (uint32)0;     pagelist[i].buffsize = (uint32)0;     pagelist[i].position = 0;     pagelist[i].total = 0;     }   for (i = 0; i < MAX_OUTBUFFS; i++)     {     seg_buffs[i].size = 0;     seg_buffs[i].buffer = NULL;     }   }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char* argv[]){\tint dirnum = -1, multiplefiles, c;\tuint16 order = 0;\tTIFF* tif;\textern int optind;\textern char* optarg;\tlong flags = 0;\tuint32 diroff = 0;\tint chopstrips = 0;\t\t\twhile ((c = getopt(argc, argv, \"f:o:cdDSjilmrsvwz0123456789\")) != -1)\t\tswitch (c) {\t\tcase '0': case '1': case '2': case '3':\t\tcase '4': case '5': case '6': case '7':\t\tcase '8': case '9':\t\t\tdirnum = atoi(&argv[optind-1][1]);\t\t\tbreak;\t\tcase 'd':\t\t\tshowdata++;\t\t\t\t\tcase 'D':\t\t\treaddata++;\t\t\tbreak;\t\tcase 'c':\t\t\tflags |= TIFFPRINT_COLORMAP | TIFFPRINT_CURVES;\t\t\tbreak;\t\tcase 'f':\t\t\t\t\tif (streq(optarg, \"lsb2msb\"))\t\t\t\torder = FILLORDER_LSB2MSB;\t\t\telse if (streq(optarg, \"msb2lsb\"))\t\t\t\torder = FILLORDER_MSB2LSB;\t\t\telse\t\t\t\tusage();\t\t\tbreak;\t\tcase 'i':\t\t\tstoponerr = 0;\t\t\tbreak;\t\tcase 'o':\t\t\tdiroff = strtoul(optarg, NULL, 0);\t\t\tbreak;\t\tcase 'j':\t\t\tflags |= TIFFPRINT_JPEGQTABLES |\t\t\t\t TIFFPRINT_JPEGACTABLES |\t\t\t\t TIFFPRINT_JPEGDCTABLES;\t\t\tbreak;\t\tcase 'r':\t\t\trawdata = 1;\t\t\tbreak;\t\tcase 's':\t\t\tflags |= TIFFPRINT_STRIPS;\t\t\tbreak;\t\tcase 'w':\t\t\tshowwords = 1;\t\t\tbreak;\t\tcase 'z':\t\t\tchopstrips = 1;\t\t\tbreak;\t\tcase '?':\t\t\tusage();\t\t\t\t\t}\tif (optind >= argc)    {\t\tusage();    }\tmultiplefiles = (argc - optind > 1);\tfor (; optind < argc; optind++)    {\t\tif (multiplefiles)        {\t\t\tprintf(\"%s:\\n\", argv[optind]);        }\t\ttif = TIFFOpen(argv[optind], chopstrips ? \"rC\" : \"rc\");\t\tif (tif != NULL)        {\t\t\tif (dirnum != -1)            {\t\t\t\tif (TIFFSetDirectory(tif, (tdir_t) dirnum))\t\t\t\t\ttiffinfo(tif, order, flags);\t\t\t} else if (diroff != 0) {\t\t\t\tif (TIFFSetSubDirectory(tif, diroff))\t\t\t\t\ttiffinfo(tif, order, flags);\t\t\t} else {\t\t\t\tdo {\t\t\t\t\ttoff_t offset;\t\t\t\t\ttiffinfo(tif, order, flags);\t\t\t\t\tif (TIFFGetField(tif, TIFFTAG_EXIFIFD,\t\t\t\t\t\t\t &offset)) {\t\t\t\t\t\tif (TIFFReadEXIFDirectory(tif, offset))\t\t\t\t\t\t\ttiffinfo(tif, order, flags);\t\t\t\t\t}\t\t\t\t} while (TIFFReadDirectory(tif));\t\t\t}\t\t\tTIFFClose(tif);\t\t}\t}    printf(\"\\n<press any key to exit>\\n\");    getc(stdin);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intswabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc){    uint32* wp = (uint32*) cp0;    tmsize_t wc = cc / 4;    if( !horDiff32(tif, cp0, cc) )        return 0;    TIFFSwabArrayOfLong(wp, wc);    return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFSetDirectory(TIFF* tif, uint16 dirn){\tuint64 nextdir;\tuint16 n;\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t\tnextdir = tif->tif_header.classic.tiff_diroff;\telse\t\tnextdir = tif->tif_header.big.tiff_diroff;\tfor (n = dirn; n > 0 && nextdir != 0; n--)\t\tif (!TIFFAdvanceDirectory(tif, &nextdir, NULL))\t\t\treturn (0);\ttif->tif_nextdiroff = nextdir;\t \ttif->tif_curdir = (dirn - n) - 1;\t \ttif->tif_dirnumber = 0;\treturn (TIFFReadDirectory(tif));}",
        "label": 1,
        "cve": "CVE-2018-5784"
    },
    {
        "code": "int main(int argc, char **argv){    char *          input_file = NULL;    double          image_gamma = TIFF_GAMMA;    int             i, j;    TIFF *          tif;    unsigned char * scan_line;    uint16          red[CMSIZE], green[CMSIZE], blue[CMSIZE];    float\t    refblackwhite[2*3];    programName = argv[0];    switch (argc) {    case 2:        image_gamma = TIFF_GAMMA;        input_file = argv[1];        break;    case 4:        if (!strcmp(argv[1], \"-gamma\")) {            image_gamma = atof(argv[2]);            input_file = argv[3];        } else            Usage();        break;    default:        Usage();    }    for (i = 0; i < CMSIZE; i++) {        if (i == 0)            red[i] = green[i] = blue[i] = 0;        else {            red[i] = ROUND((pow(i / 255.0, 1.0 / image_gamma) * 65535.0));            green[i] = ROUND((pow(i / 255.0, 1.0 / image_gamma) * 65535.0));            blue[i] = ROUND((pow(i / 255.0, 1.0 / image_gamma) * 65535.0));        }    }    refblackwhite[0] = 0.0; refblackwhite[1] = 255.0;    refblackwhite[2] = 0.0; refblackwhite[3] = 255.0;    refblackwhite[4] = 0.0; refblackwhite[5] = 255.0;    if ((tif = TIFFOpen(input_file, \"w\")) == NULL) {        fprintf(stderr, \"can't open %s as a TIFF file\\n\", input_file);        exit(0);    }    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, WIDTH);    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, HEIGHT);    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);    TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_NONE);#ifdef notdef    TIFFSetField(tif, TIFFTAG_WHITEPOINT, whitex, whitey);    TIFFSetField(tif, TIFFTAG_PRIMARYCHROMATICITIES, primaries);#endif    TIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE, refblackwhite);    TIFFSetField(tif, TIFFTAG_TRANSFERFUNCTION, red, green, blue);    scan_line = (unsigned char *) malloc(WIDTH * 3);    for (i = 0; i < 255; i++) {        for (j = 0; j < 75; j++) {             scan_line[j * 3] = 255;             scan_line[(j * 3) + 1] = 255 - i;             scan_line[(j * 3) + 2] = 255 - i;        }        for (j = 75; j < 150; j++) {             scan_line[j * 3] = 255 - i;             scan_line[(j * 3) + 1] = 255;             scan_line[(j * 3) + 2] = 255 - i;        }        for (j = 150; j < 225; j++) {             scan_line[j * 3] = 255 - i;             scan_line[(j * 3) + 1] = 255 - i;             scan_line[(j * 3) + 2] = 255;        }        for (j = 225; j < 300; j++) {             scan_line[j * 3] = (i - 1) / 2;             scan_line[(j * 3) + 1] = (i - 1) / 2;             scan_line[(j * 3) + 2] = (i - 1) / 2;        }        for (j = 300; j < 375; j++) {             scan_line[j * 3] = 255 - i;             scan_line[(j * 3) + 1] = 255;             scan_line[(j * 3) + 2] = 255;        }        for (j = 375; j < 450; j++) {             scan_line[j * 3] = 255;             scan_line[(j * 3) + 1] = 255 - i;             scan_line[(j * 3) + 2] = 255;        }        for (j = 450; j < 525; j++) {             scan_line[j * 3] = 255;             scan_line[(j * 3) + 1] = 255;             scan_line[(j * 3) + 2] = 255 - i;        }        TIFFWriteScanline(tif, scan_line, i, 0);    }    for (i = 255; i < 512; i++) {        for (j = 0; j < 75; j++) {             scan_line[j * 3] = i;             scan_line[(j * 3) + 1] = 0;             scan_line[(j * 3) + 2] = 0;        }        for (j = 75; j < 150; j++) {             scan_line[j * 3] = 0;             scan_line[(j * 3) + 1] = i;             scan_line[(j * 3) + 2] = 0;        }        for (j = 150; j < 225; j++) {             scan_line[j * 3] = 0;             scan_line[(j * 3) + 1] = 0;             scan_line[(j * 3) + 2] = i;        }        for (j = 225; j < 300; j++) {             scan_line[j * 3] = (i - 1) / 2;             scan_line[(j * 3) + 1] = (i - 1) / 2;             scan_line[(j * 3) + 2] = (i - 1) / 2;        }        for (j = 300; j < 375; j++) {             scan_line[j * 3] = 0;             scan_line[(j * 3) + 1] = i;             scan_line[(j * 3) + 2] = i;        }        for (j = 375; j < 450; j++) {             scan_line[j * 3] = i;             scan_line[(j * 3) + 1] = 0;             scan_line[(j * 3) + 2] = i;        }        for (j = 450; j < 525; j++) {             scan_line[j * 3] = i;             scan_line[(j * 3) + 1] = i;             scan_line[(j * 3) + 2] = 0;        }        TIFFWriteScanline(tif, scan_line, i, 0);    }    free(scan_line);    TIFFClose(tif);    exit(0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidWin32ErrorHandler(const char* module, const char* fmt, va_list ap){#ifndef TIF_PLATFORM_CONSOLE\tLPTSTR szTitle;\tLPTSTR szTmp;\tLPCTSTR szTitleText = \"%s Error\";\tLPCTSTR szDefaultModule = \"LIBTIFF\";\tLPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;\tif ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szTmpModule) +\t\tstrlen(szTitleText) + strlen(fmt) + 128)*sizeof(char))) == NULL)\t\treturn;\tsprintf(szTitle, szTitleText, szTmpModule);\tszTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);\tvsprintf(szTmp, fmt, ap);\tMessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONEXCLAMATION);\tLocalFree(szTitle);\treturn;\tif (module != NULL)\t\tfprintf(stderr, \"%s: \", module);\tvfprintf(stderr, fmt, ap);\tfprintf(stderr, \".\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcpStrips(TIFF* in, TIFF* out){    tsize_t bufsize  = TIFFStripSize(in);    unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);    if (buf) {\ttstrip_t s, ns = TIFFNumberOfStrips(in);\tuint64 *bytecounts;\tTIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);\tfor (s = 0; s < ns; s++) {\t  if (bytecounts[s] > (uint64) bufsize) {\t\tbuf = (unsigned char *)_TIFFrealloc(buf, (tmsize_t)bytecounts[s]);\t\tif (!buf)\t\t    goto bad;\t\tbufsize = (tmsize_t)bytecounts[s];\t    }\t    if (TIFFReadRawStrip(in, s, buf, (tmsize_t)bytecounts[s]) < 0 ||\t\tTIFFWriteRawStrip(out, s, buf, (tmsize_t)bytecounts[s]) < 0) {\t\t_TIFFfree(buf);\t\treturn 0;\t    }\t}\t_TIFFfree(buf);\treturn 1;    }bad:\tTIFFError(TIFFFileName(in),\t\t  \"Can't allocate space for strip buffer.\");\treturn 0;}",
        "label": 1,
        "cve": "cve-2016-3631-1"
    },
    {
        "code": "static intPredictorEncodeRow(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s){\tTIFFPredictorState *sp = PredictorState(tif);\tassert(sp != NULL);\tassert(sp->encodepfunc != NULL);\tassert(sp->encoderow != NULL);\t\tif( !(*sp->encodepfunc)(tif, bp, cc) )        return 0;\treturn (*sp->encoderow)(tif, bp, cc, s);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s){\tstatic const char module[] = \"PredictorEncodeTile\";\tTIFFPredictorState *sp = PredictorState(tif);        uint8 *working_copy;\ttmsize_t cc = cc0, rowsize;\tunsigned char* bp;        int result_code;\tassert(sp != NULL);\tassert(sp->encodepfunc != NULL);\tassert(sp->encodetile != NULL);                working_copy = (uint8*) _TIFFmalloc(cc0);        if( working_copy == NULL )        {            TIFFErrorExt(tif->tif_clientdata, module,                          \"Out of memory allocating \" TIFF_SSIZE_FORMAT \" byte temp buffer.\",                         cc0 );            return 0;        }        memcpy( working_copy, bp0, cc0 );        bp = working_copy;\trowsize = sp->rowsize;\tassert(rowsize > 0);\tif((cc0%rowsize)!=0)    {        TIFFErrorExt(tif->tif_clientdata, \"PredictorEncodeTile\",                     \"%s\", \"(cc0%rowsize)!=0\");        _TIFFfree( working_copy );        return 0;    }\twhile (cc > 0) {\t\t(*sp->encodepfunc)(tif, bp, rowsize);\t\tcc -= rowsize;\t\tbp += rowsize;\t}\tresult_code = (*sp->encodetile)(tif, working_copy, cc0, s);        _TIFFfree( working_copy );        return result_code;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intFax3PostEncode(TIFF* tif){\tFax3CodecState* sp = EncoderState(tif);\tif (sp->bit != 8)\t\tFax3FlushBits(tif, sp);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char* argv[]){\tint one = 1, fd;\tint multiplefiles = (argc > 1);\tint c;\tuint64 diroff = 0;\tbigendian = (*(char *)&one == 0);\tappname = argv[0];\twhile ((c = getopt(argc, argv, \"m:o:h\")) != -1) {\t\tswitch (c) {\t\tcase 'h':\t\t\t\t\t\tshortfmt = \"%s%#x\";\t\t\tsshortfmt = \"%s%#x\";\t\t\tlongfmt = \"%s%#lx\";\t\t\tslongfmt = \"%s%#lx\";\t\t\tbreak;\t\tcase 'o':\t\t\tdiroff = (uint64) strtoul(optarg, NULL, 0);\t\t\tbreak;\t\tcase 'm':\t\t\tmaxitems = strtoul(optarg, NULL, 0);\t\t\tbreak;\t\tdefault:\t\t\tusage();\t\t}\t}\tif (optind >= argc)\t\tusage();\tfor (; optind < argc; optind++) {\t\tfd = open(argv[optind], O_RDONLY|O_BINARY, 0);\t\tif (fd < 0) {\t\t\tperror(argv[0]);\t\t\treturn (-1);\t\t}\t\tif (multiplefiles)\t\t\tprintf(\"%s:\\n\", argv[optind]);\t\tcurfile = argv[optind];\t\tswabflag = 0;\t\tbigtiff = 0;\t\tdump(fd, diroff);\t\tclose(fd);\t}\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "unsigned long longstrtoull(const char *nptr, char **endptr, int base){\tconst char *s;\tunsigned long long acc;\tchar c;\tunsigned long long cutoff;\tint neg, any, cutlim;\t\ts = nptr;\tdo {\t\tc = *s++;\t} while (isspace((unsigned char)c));\tif (c == '-') {\t\tneg = 1;\t\tc = *s++;\t} else {\t\tneg = 0;\t\tif (c == '+')\t\t\tc = *s++;\t}\tif ((base == 0 || base == 16) &&\t    c == '0' && (*s == 'x' || *s == 'X') &&\t    ((s[1] >= '0' && s[1] <= '9') ||\t    (s[1] >= 'A' && s[1] <= 'F') ||\t    (s[1] >= 'a' && s[1] <= 'f'))) {\t\tc = s[1];\t\ts += 2;\t\tbase = 16;\t}\tif (base == 0)\t\tbase = c == '0' ? 8 : 10;\tacc = any = 0;\tif (base < 2 || base > 36)\t\tgoto noconv;\tcutoff = ULLONG_MAX / base;\tcutlim = ULLONG_MAX % base;\tfor ( ; ; c = *s++) {\t\tif (c >= '0' && c <= '9')\t\t\tc -= '0';\t\telse if (c >= 'A' && c <= 'Z')\t\t\tc -= 'A' - 10;\t\telse if (c >= 'a' && c <= 'z')\t\t\tc -= 'a' - 10;\t\telse\t\t\tbreak;\t\tif (c >= base)\t\t\tbreak;\t\tif (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))\t\t\tany = -1;\t\telse {\t\t\tany = 1;\t\t\tacc *= base;\t\t\tacc += c;\t\t}\t}\tif (any < 0) {\t\tacc = ULLONG_MAX;\t\terrno = ERANGE;\t} else if (!any) {noconv:\t\terrno = EINVAL;\t} else if (neg)\t\tacc = -acc;\tif (endptr != NULL)\t\t*endptr = (char *)(any ? s - 1 : nptr);\treturn (acc);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intOJPEGReadHeaderInfoSecTablesDcTable(TIFF* tif){\tstatic const char module[]=\"OJPEGReadHeaderInfoSecTablesDcTable\";\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\tuint8 m;\tuint8 n;\tuint8 o[16];\tuint32 p;\tuint32 q;\tuint32 ra;\tuint8* rb;\tif (sp->dctable_offset[0]==0)\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Missing JPEG tables\");\t\treturn(0);\t}\tsp->in_buffer_file_pos_log=0;\tfor (m=0; m<sp->samples_per_pixel; m++)\t{\t\tif ((sp->dctable_offset[m]!=0) && ((m==0) || (sp->dctable_offset[m]!=sp->dctable_offset[m-1])))\t\t{\t\t\tfor (n=0; n<m-1; n++)\t\t\t{\t\t\t\tif (sp->dctable_offset[m]==sp->dctable_offset[n])\t\t\t\t{\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JpegDcTables tag value\");\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tTIFFSeekFile(tif,sp->dctable_offset[m],SEEK_SET);\t\t\tp=(uint32)TIFFReadFile(tif,o,16);\t\t\tif (p!=16)\t\t\t\treturn(0);\t\t\tq=0;\t\t\tfor (n=0; n<16; n++)\t\t\t\tq+=o[n];\t\t\tra=sizeof(uint32)+21+q;\t\t\trb=_TIFFmalloc(ra);\t\t\tif (rb==0)\t\t\t{\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\t\t\t\treturn(0);\t\t\t}\t\t\t*(uint32*)rb=ra;\t\t\trb[sizeof(uint32)]=255;\t\t\trb[sizeof(uint32)+1]=JPEG_MARKER_DHT;\t\t\trb[sizeof(uint32)+2]=(uint8)((19+q)>>8);\t\t\trb[sizeof(uint32)+3]=((19+q)&255);\t\t\trb[sizeof(uint32)+4]=m;\t\t\tfor (n=0; n<16; n++)\t\t\t\trb[sizeof(uint32)+5+n]=o[n];\t\t\tp=(uint32)TIFFReadFile(tif,&(rb[sizeof(uint32)+21]),q);\t\t\tif (p!=q)\t\t\t\treturn(0);\t\t\tsp->dctable[m]=rb;\t\t\tsp->sos_tda[m]=(m<<4);\t\t}\t\telse\t\t\tsp->sos_tda[m]=sp->sos_tda[m-1];\t}\treturn(1);}",
        "label": 1,
        "cve": "cve-2017-7594"
    },
    {
        "code": "static intLZWPreDecode(TIFF* tif, uint16 s){\tstatic const char module[] = \"LZWPreDecode\";\tLZWCodecState *sp = DecoderState(tif);\t(void) s;\tassert(sp != NULL);\tif( sp->dec_codetab == NULL )        {            tif->tif_setupdecode( tif );\t    if( sp->dec_codetab == NULL )\t\treturn (0);        }\t\tif (tif->tif_rawdata[0] == 0 && (tif->tif_rawdata[1] & 0x1)) {#ifdef LZW_COMPAT\t\tif (!sp->dec_decode) {\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\t\t\t    \"Old-style LZW codes, convert file\");\t\t\t\t\t\ttif->tif_decoderow = LZWDecodeCompat;\t\t\ttif->tif_decodestrip = LZWDecodeCompat;\t\t\ttif->tif_decodetile = LZWDecodeCompat;\t\t\t\t\t\t(*tif->tif_setupdecode)(tif);\t\t\tsp->dec_decode = LZWDecodeCompat;\t\t}\t\tsp->lzw_maxcode = MAXCODE(BITS_MIN);#else \t\tif (!sp->dec_decode) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"Old-style LZW codes not supported\");\t\t\tsp->dec_decode = LZWDecode;\t\t}\t\treturn (0);#endif\t} else {\t\tsp->lzw_maxcode = MAXCODE(BITS_MIN)-1;\t\tsp->dec_decode = LZWDecode;\t}\tsp->lzw_nbits = BITS_MIN;\tsp->lzw_nextbits = 0;\tsp->lzw_nextdata = 0;\tsp->dec_restart = 0;\tsp->dec_nbitsmask = MAXCODE(BITS_MIN);#ifdef LZW_CHECKEOS\tsp->dec_bitsleft = 0;#endif\tsp->dec_free_entp = sp->dec_codetab + CODE_FIRST;\t\t_TIFFmemset(sp->dec_free_entp, 0, (CSIZE-CODE_FIRST)*sizeof (code_t));\tsp->dec_oldcodep = &sp->dec_codetab[-1];\tsp->dec_maxcodep = &sp->dec_codetab[sp->dec_nbitsmask-1];\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFReadDirectory(TIFF* tif){\tstatic const char module[] = \"TIFFReadDirectory\";\tint n;\tTIFFDirectory* td;\tTIFFDirEntry *dp, *dir = NULL;\tuint16 iv;\tuint32 v;\tconst TIFFFieldInfo* fip;\tsize_t fix;\tuint16 dircount;\tint diroutoforderwarning = 0, compressionknown = 0;\ttif->tif_diroff = tif->tif_nextdiroff;\t\tif (!TIFFCheckDirOffset(tif, tif->tif_nextdiroff))\t\treturn 0;\t\t(*tif->tif_cleanup)(tif);\ttif->tif_curdir++;\tdircount = TIFFFetchDirectory(tif, tif->tif_nextdiroff,\t\t\t\t      &dir, &tif->tif_nextdiroff);\tif (!dircount) {\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t     \"%s: Failed to read directory at offset %u\",\t\t\t     tif->tif_name, tif->tif_nextdiroff);\t\treturn 0;\t}\ttif->tif_flags &= ~TIFF_BEENWRITING;\t\t\ttd = &tif->tif_dir;\t\tTIFFFreeDirectory(tif);\tTIFFDefaultDirectory(tif);\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\t\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\t\tif (tif->tif_flags & TIFF_SWAB) {\t\t\tTIFFSwabArrayOfShort(&dp->tdir_tag, 2);\t\t\tTIFFSwabArrayOfLong(&dp->tdir_count, 2);\t\t}\t\tif (dp->tdir_tag == TIFFTAG_SAMPLESPERPIXEL) {\t\t\tif (!TIFFFetchNormalTag(tif, dp))\t\t\t\tgoto bad;\t\t\tdp->tdir_tag = IGNORE;\t\t}\t}\t\tfix = 0;\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\t\tif (fix >= tif->tif_nfields || dp->tdir_tag == IGNORE)\t\t\tcontinue;\t\t\t\tif (dp->tdir_tag < tif->tif_fieldinfo[fix]->field_tag) {\t\t\tif (!diroutoforderwarning) {\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\t\"%s: invalid TIFF directory; tags are not sorted in ascending order\",\t\t\t\t\t    tif->tif_name);\t\t\t\tdiroutoforderwarning = 1;\t\t\t}\t\t\tfix = 0;\t\t\t\t\t}\t\twhile (fix < tif->tif_nfields &&\t\t    tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\t\t\tfix++;\t\tif (fix >= tif->tif_nfields ||\t\t    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\t\t\t\t\t\t       module,                        \"%s: unknown field with tag %d (0x%x) encountered\",\t\t\t\t\t\t       tif->tif_name,\t\t\t\t\t\t       dp->tdir_tag,\t\t\t\t\t\t       dp->tdir_tag);\t\t\t\t\tif (!_TIFFMergeFieldInfo(tif,\t\t\t\t\t\t_TIFFCreateAnonFieldInfo(tif,\t\t\t\t\t\tdp->tdir_tag,\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\t\t\t\t\t\t1))\t\t\t\t\t{\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\t\t\t\t\t\t       module,\t\t\t\"Registering anonymous field with tag %d (0x%x) failed\",\t\t\t\t\t\t       dp->tdir_tag,\t\t\t\t\t\t       dp->tdir_tag);\t\t\t\t\tgoto ignore;\t\t\t\t\t}\t\t\tfix = 0;\t\t\twhile (fix < tif->tif_nfields &&\t\t\t       tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\t\t\t\tfix++;\t\t}\t\t\t\tif (tif->tif_fieldinfo[fix]->field_bit == FIELD_IGNORE) {\tignore:\t\t\tdp->tdir_tag = IGNORE;\t\t\tcontinue;\t\t}\t\t\t\tfip = tif->tif_fieldinfo[fix];\t\twhile (dp->tdir_type != (unsigned short) fip->field_type\t\t    && fix < tif->tif_nfields) {\t\t\tif (fip->field_type == TIFF_ANY)\t\t\t\t\tbreak;\t\t\tfip = tif->tif_fieldinfo[++fix];\t\t\tif (fix >= tif->tif_nfields ||\t\t\t    fip->field_tag != dp->tdir_tag) {\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\t\t\t\"%s: wrong data type %d for \\\"%s\\\"; tag ignored\",\t\t\t\t\t    tif->tif_name, dp->tdir_type,\t\t\t\t\t    tif->tif_fieldinfo[fix-1]->field_name);\t\t\t\tgoto ignore;\t\t\t}\t\t}\t\t\t\tif (fip->field_readcount != TIFF_VARIABLE\t\t    && fip->field_readcount != TIFF_VARIABLE2) {\t\t\tuint32 expected = (fip->field_readcount == TIFF_SPP) ?\t\t\t    (uint32) td->td_samplesperpixel :\t\t\t    (uint32) fip->field_readcount;\t\t\tif (!CheckDirCount(tif, dp, expected))\t\t\t\tgoto ignore;\t\t}\t\tswitch (dp->tdir_tag) {\t\tcase TIFFTAG_COMPRESSION:\t\t\t\t\t\tif (dp->tdir_count == 1) {\t\t\t\tv = TIFFExtractData(tif,\t\t\t\t    dp->tdir_type, dp->tdir_offset);\t\t\t\tif (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))\t\t\t\t\tgoto bad;\t\t\t\telse\t\t\t\t\tcompressionknown = 1;\t\t\t\tbreak;\t\t\t\t\t\t} else if (dp->tdir_type == TIFF_LONG) {\t\t\t\tif (!TIFFFetchPerSampleLongs(tif, dp, &v) ||\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))\t\t\t\t\tgoto bad;\t\t\t} else {\t\t\t\tif (!TIFFFetchPerSampleShorts(tif, dp, &iv)\t\t\t\t    || !TIFFSetField(tif, dp->tdir_tag, iv))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tdp->tdir_tag = IGNORE;\t\t\tbreak;\t\tcase TIFFTAG_STRIPOFFSETS:\t\tcase TIFFTAG_STRIPBYTECOUNTS:\t\tcase TIFFTAG_TILEOFFSETS:\t\tcase TIFFTAG_TILEBYTECOUNTS:\t\t\tTIFFSetFieldBit(tif, fip->field_bit);\t\t\tbreak;\t\tcase TIFFTAG_IMAGEWIDTH:\t\tcase TIFFTAG_IMAGELENGTH:\t\tcase TIFFTAG_IMAGEDEPTH:\t\tcase TIFFTAG_TILELENGTH:\t\tcase TIFFTAG_TILEWIDTH:\t\tcase TIFFTAG_TILEDEPTH:\t\tcase TIFFTAG_PLANARCONFIG:\t\tcase TIFFTAG_ROWSPERSTRIP:\t\tcase TIFFTAG_EXTRASAMPLES:\t\t\tif (!TIFFFetchNormalTag(tif, dp))\t\t\t\tgoto bad;\t\t\tdp->tdir_tag = IGNORE;\t\t\tbreak;\t\t}\t}\t\tif ((td->td_compression==COMPRESSION_OJPEG) &&\t    (td->td_planarconfig==PLANARCONFIG_SEPARATE)) {\t\tdp = TIFFReadDirectoryFind(dir,dircount,TIFFTAG_STRIPOFFSETS);\t\tif ((dp!=0) && (dp->tdir_count==1)) {\t\t\tdp = TIFFReadDirectoryFind(dir, dircount,\t\t\t\t\t\t   TIFFTAG_STRIPBYTECOUNTS);\t\t\tif ((dp!=0) && (dp->tdir_count==1)) {\t\t\t\ttd->td_planarconfig=PLANARCONFIG_CONTIG;\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\t\t\t\t\t       \"TIFFReadDirectory\",\t\t\t\t\"Planarconfig tag value assumed incorrect, \"\t\t\t\t\"assuming data is contig instead of chunky\");\t\t\t}\t\t}\t}\t\tif (!TIFFFieldSet(tif, FIELD_IMAGEDIMENSIONS)) {\t\tMissingRequired(tif, \"ImageLength\");\t\tgoto bad;\t}\t\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\t\ttd->td_nstrips = TIFFNumberOfStrips(tif);\t\ttd->td_tilewidth = td->td_imagewidth;\t\ttd->td_tilelength = td->td_rowsperstrip;\t\ttd->td_tiledepth = td->td_imagedepth;\t\ttif->tif_flags &= ~TIFF_ISTILED;\t} else {\t\ttd->td_nstrips = TIFFNumberOfTiles(tif);\t\ttif->tif_flags |= TIFF_ISTILED;\t}\tif (!td->td_nstrips) {\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t     \"%s: cannot handle zero number of %s\",\t\t\t     tif->tif_name, isTiled(tif) ? \"tiles\" : \"strips\");\t\tgoto bad;\t}\ttd->td_stripsperimage = td->td_nstrips;\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\t\ttd->td_stripsperimage /= td->td_samplesperpixel;\tif (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {\t\tif ((td->td_compression==COMPRESSION_OJPEG) &&\t\t    (isTiled(tif)==0) &&\t\t    (td->td_nstrips==1)) {\t\t\t\t\t\tTIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\t\t} else {\t\t\tMissingRequired(tif,\t\t\t\tisTiled(tif) ? \"TileOffsets\" : \"StripOffsets\");\t\t\tgoto bad;\t\t}\t}\t\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\t\tif (dp->tdir_tag == IGNORE)\t\t\tcontinue;\t\tswitch (dp->tdir_tag) {\t\tcase TIFFTAG_MINSAMPLEVALUE:\t\tcase TIFFTAG_MAXSAMPLEVALUE:\t\tcase TIFFTAG_BITSPERSAMPLE:\t\tcase TIFFTAG_DATATYPE:\t\tcase TIFFTAG_SAMPLEFORMAT:\t\t\t\t\t\tif (dp->tdir_count == 1) {\t\t\t\tv = TIFFExtractData(tif,\t\t\t\t    dp->tdir_type, dp->tdir_offset);\t\t\t\tif (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))\t\t\t\t\tgoto bad;\t\t\t\t\t\t} else if (dp->tdir_tag == TIFFTAG_BITSPERSAMPLE\t\t\t\t   && dp->tdir_type == TIFF_LONG) {\t\t\t\tif (!TIFFFetchPerSampleLongs(tif, dp, &v) ||\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))\t\t\t\t\tgoto bad;\t\t\t} else {\t\t\t\tif (!TIFFFetchPerSampleShorts(tif, dp, &iv) ||\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, iv))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_SMINSAMPLEVALUE:\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\t\t\t{\t\t\t\tdouble dv = 0.0;\t\t\t\tif (!TIFFFetchPerSampleAnys(tif, dp, &dv) ||\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, dv))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_STRIPOFFSETS:\t\tcase TIFFTAG_TILEOFFSETS:\t\t\tif (!TIFFFetchStripThing(tif, dp,\t\t\t    td->td_nstrips, &td->td_stripoffset))\t\t\t\tgoto bad;\t\t\tbreak;\t\tcase TIFFTAG_STRIPBYTECOUNTS:\t\tcase TIFFTAG_TILEBYTECOUNTS:\t\t\tif (!TIFFFetchStripThing(tif, dp,\t\t\t    td->td_nstrips, &td->td_stripbytecount))\t\t\t\tgoto bad;\t\t\tbreak;\t\tcase TIFFTAG_COLORMAP:\t\tcase TIFFTAG_TRANSFERFUNCTION:\t\t\t{\t\t\t\tchar* cp;\t\t\t\t\t\t\t\tv = 1L<<td->td_bitspersample;\t\t\t\tif (dp->tdir_tag == TIFFTAG_COLORMAP ||\t\t\t\t    dp->tdir_count != v) {\t\t\t\t\tif (!CheckDirCount(tif, dp, 3 * v))\t\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\tv *= sizeof(uint16);\t\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\t\t\t\t\t\t\t      dp->tdir_count,\t\t\t\t\t\t\t      sizeof (uint16),\t\t\t\t\t\"to read \\\"TransferFunction\\\" tag\");\t\t\t\tif (cp != NULL) {\t\t\t\t\tif (TIFFFetchData(tif, dp, cp)) {\t\t\t\t\t\t\t\t\t\t\t\tuint32 c = 1L << td->td_bitspersample;\t\t\t\t\t\tif (dp->tdir_count == c)\t\t\t\t\t\t\tv = 0L;\t\t\t\t\t\tTIFFSetField(tif, dp->tdir_tag,\t\t\t\t\t\t    cp, cp+v, cp+2*v);\t\t\t\t\t}\t\t\t\t\t_TIFFfree(cp);\t\t\t\t}\t\t\t\tbreak;\t\t\t}\t\tcase TIFFTAG_PAGENUMBER:\t\tcase TIFFTAG_HALFTONEHINTS:\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\t\tcase TIFFTAG_DOTRANGE:\t\t\t(void) TIFFFetchShortPair(tif, dp);\t\t\tbreak;\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\t\t\t(void) TIFFFetchRefBlackWhite(tif, dp);\t\t\tbreak;\t\tcase TIFFTAG_OSUBFILETYPE:\t\t\tv = 0L;\t\t\tswitch (TIFFExtractData(tif, dp->tdir_type,\t\t\t    dp->tdir_offset)) {\t\t\tcase OFILETYPE_REDUCEDIMAGE:\t\t\t\tv = FILETYPE_REDUCEDIMAGE;\t\t\t\tbreak;\t\t\tcase OFILETYPE_PAGE:\t\t\t\tv = FILETYPE_PAGE;\t\t\t\tbreak;\t\t\t}\t\t\tif (v)\t\t\t\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, v);\t\t\tbreak;\t\tdefault:\t\t\t(void) TIFFFetchNormalTag(tif, dp);\t\t\tbreak;\t\t}\t}\t\tif (td->td_compression==COMPRESSION_OJPEG)\t{\t\tif (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\t\t{\t\t\tTIFFWarningExt(tif->tif_clientdata, \"TIFFReadDirectory\",\t\t\t\"Photometric tag is missing, assuming data is YCbCr\");\t\t\tif (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))\t\t\t\tgoto bad;\t\t}\t\telse if (td->td_photometric==PHOTOMETRIC_RGB)\t\t{\t\t\ttd->td_photometric=PHOTOMETRIC_YCBCR;\t\t\tTIFFWarningExt(tif->tif_clientdata, \"TIFFReadDirectory\",\t\t\t\"Photometric tag value assumed incorrect, \"\t\t\t\"assuming data is YCbCr instead of RGB\");\t\t}\t\tif (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\t\t{\t\t\tTIFFWarningExt(tif->tif_clientdata,\"TIFFReadDirectory\",\t\t\"BitsPerSample tag is missing, assuming 8 bits per sample\");\t\t\tif (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))\t\t\t\tgoto bad;\t\t}\t\tif (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\t\t{\t\t\tif ((td->td_photometric==PHOTOMETRIC_RGB)\t\t\t    || (td->td_photometric==PHOTOMETRIC_YCBCR))\t\t\t{\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\t\t\t\t\t       \"TIFFReadDirectory\",\t\t\t\t\"SamplesPerPixel tag is missing, \"\t\t\t\t\"assuming correct SamplesPerPixel value is 3\");\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\t\t\t\t\tgoto bad;\t\t\t}\t\t\telse if ((td->td_photometric==PHOTOMETRIC_MINISWHITE)\t\t\t\t || (td->td_photometric==PHOTOMETRIC_MINISBLACK))\t\t\t{\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\t\t\t\t\t       \"TIFFReadDirectory\",\t\t\t\t\"SamplesPerPixel tag is missing, \"\t\t\t\t\"assuming correct SamplesPerPixel value is 1\");\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))\t\t\t\t\tgoto bad;\t\t\t}\t\t}\t}\t\tif (td->td_photometric == PHOTOMETRIC_PALETTE &&\t    !TIFFFieldSet(tif, FIELD_COLORMAP)) {\t\tMissingRequired(tif, \"Colormap\");\t\tgoto bad;\t}\t\tif (td->td_compression!=COMPRESSION_OJPEG)\t{\t\t\t\tif (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {\t\t\t\t\t\tif ((td->td_planarconfig == PLANARCONFIG_CONTIG &&\t\t\t    td->td_nstrips > 1) ||\t\t\t    (td->td_planarconfig == PLANARCONFIG_SEPARATE &&\t\t\t     td->td_nstrips != td->td_samplesperpixel)) {\t\t\t    MissingRequired(tif, \"StripByteCounts\");\t\t\t    goto bad;\t\t\t}\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\t\t\t\t\"%s: TIFF directory is missing required \"\t\t\t\t\"\\\"%s\\\" field, calculating from imagelength\",\t\t\t\ttif->tif_name,\t\t\t\t_TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\t\t\t    goto bad;\t\t\t\t#define\tBYTECOUNTLOOKSBAD \\\t\t    ( (td->td_stripbytecount[0] == 0 && td->td_stripoffset[0] != 0) || \\\t\t      (td->td_compression == COMPRESSION_NONE && \\\t\t       td->td_stripbytecount[0] > TIFFGetFileSize(tif) - td->td_stripoffset[0]) || \\\t\t      (tif->tif_mode == O_RDONLY && \\\t\t       td->td_compression == COMPRESSION_NONE && \\\t\t       td->td_stripbytecount[0] < TIFFScanlineSize(tif) * td->td_imagelength) )\t\t} else if (td->td_nstrips == 1\t\t\t   && td->td_stripoffset[0] != 0\t\t\t   && BYTECOUNTLOOKSBAD) {\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\t\"%s: Bogus \\\"%s\\\" field, ignoring and calculating from imagelength\",\t\t\t\t    tif->tif_name,\t\t\t\t    _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\t\t\tif(EstimateStripByteCounts(tif, dir, dircount) < 0)\t\t\t    goto bad;\t\t} else if (td->td_planarconfig == PLANARCONFIG_CONTIG\t\t\t   && td->td_nstrips > 2\t\t\t   && td->td_compression == COMPRESSION_NONE\t\t\t   && td->td_stripbytecount[0] != td->td_stripbytecount[1]                           && td->td_stripbytecount[0] != 0                            && td->td_stripbytecount[1] != 0 ) {\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\t\"%s: Wrong \\\"%s\\\" field, ignoring and calculating from imagelength\",\t\t\t\t    tif->tif_name,\t\t\t\t    _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\t\t\t    goto bad;\t\t}\t}\tif (dir) {\t\t_TIFFfree((char *)dir);\t\tdir = NULL;\t}\tif (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))\t\ttd->td_maxsamplevalue = (uint16)((1L<<td->td_bitspersample)-1);\t\t\tif (td->td_nstrips > 1) {\t\ttstrip_t strip;\t\ttd->td_stripbytecountsorted = 1;\t\tfor (strip = 1; strip < td->td_nstrips; strip++) {\t\t\tif (td->td_stripoffset[strip - 1] >\t\t\t    td->td_stripoffset[strip]) {\t\t\t\ttd->td_stripbytecountsorted = 0;\t\t\t\tbreak;\t\t\t}\t\t}\t}\tif (!TIFFFieldSet(tif, FIELD_COMPRESSION))\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\t\tif (td->td_nstrips == 1 && td->td_compression == COMPRESSION_NONE &&\t    (tif->tif_flags & (TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP)\t\tChopUpSingleUncompressedStrip(tif);\t\ttif->tif_row = (uint32) -1;\ttif->tif_curstrip = (tstrip_t) -1;\ttif->tif_col = (uint32) -1;\ttif->tif_curtile = (ttile_t) -1;\ttif->tif_tilesize = (tsize_t) -1;\ttif->tif_scanlinesize = TIFFScanlineSize(tif);\tif (!tif->tif_scanlinesize) {\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t     \"%s: cannot handle zero scanline size\",\t\t\t     tif->tif_name);\t\treturn (0);\t}\tif (isTiled(tif)) {\t\ttif->tif_tilesize = TIFFTileSize(tif);\t\tif (!tif->tif_tilesize) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t     \"%s: cannot handle zero tile size\",\t\t\t\t     tif->tif_name);\t\t\treturn (0);\t\t}\t} else {\t\tif (!TIFFStripSize(tif)) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t     \"%s: cannot handle zero strip size\",\t\t\t\t     tif->tif_name);\t\t\treturn (0);\t\t}\t}\treturn (1);bad:\tif (dir)\t\t_TIFFfree(dir);\treturn (0);}",
        "label": 1,
        "cve": "cve-2012-2088"
    },
    {
        "code": "void t2p_read_tiff_data(T2P* t2p, TIFF* input){\tint i=0;\tuint16* r;\tuint16* g;\tuint16* b;\tuint16* a;\tuint16 xuint16;\tuint16* xuint16p;\tfloat* xfloatp;\tt2p->pdf_transcode = T2P_TRANSCODE_ENCODE;\tt2p->pdf_sample = T2P_SAMPLE_NOTHING;        t2p->pdf_switchdecode = t2p->pdf_colorspace_invert;\tTIFFSetDirectory(input, t2p->tiff_pages[t2p->pdf_page].page_directory);\tTIFFGetField(input, TIFFTAG_IMAGEWIDTH, &(t2p->tiff_width));\tif(t2p->tiff_width == 0){\t\tTIFFError(\t\t\tTIFF2PDF_MODULE, \t\t\t\"No support for %s with zero width\", \t\t\tTIFFFileName(input)\t);\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn;\t}\tTIFFGetField(input, TIFFTAG_IMAGELENGTH, &(t2p->tiff_length));\tif(t2p->tiff_length == 0){\t\tTIFFError(\t\t\tTIFF2PDF_MODULE, \t\t\t\"No support for %s with zero length\", \t\t\tTIFFFileName(input)\t);\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn;\t}        if(TIFFGetField(input, TIFFTAG_COMPRESSION, &(t2p->tiff_compression)) == 0){                TIFFError(                        TIFF2PDF_MODULE,                         \"No support for %s with no compression tag\",                         TIFFFileName(input)     );                t2p->t2p_error = T2P_ERR_ERROR;                return;        }        if( TIFFIsCODECConfigured(t2p->tiff_compression) == 0){\t\tTIFFError(\t\t\tTIFF2PDF_MODULE, \t\t\t\"No support for %s with compression type %u:  not configured\", \t\t\tTIFFFileName(input), \t\t\tt2p->tiff_compression\t\t\t\t);\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn;\t}\tTIFFGetFieldDefaulted(input, TIFFTAG_BITSPERSAMPLE, &(t2p->tiff_bitspersample));\tswitch(t2p->tiff_bitspersample){\t\tcase 1:\t\tcase 2:\t\tcase 4:\t\tcase 8:\t\t\tbreak;\t\tcase 0:\t\t\tTIFFWarning(\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\"Image %s has 0 bits per sample, assuming 1\",\t\t\t\tTIFFFileName(input));\t\t\tt2p->tiff_bitspersample=1;\t\t\tbreak;\t\tdefault:\t\t\tTIFFError(\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\"No support for %s with %u bits per sample\",\t\t\t\tTIFFFileName(input),\t\t\t\tt2p->tiff_bitspersample);\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\treturn;\t}\tTIFFGetFieldDefaulted(input, TIFFTAG_SAMPLESPERPIXEL, &(t2p->tiff_samplesperpixel));\tif(t2p->tiff_samplesperpixel>4){\t\tTIFFError(\t\t\tTIFF2PDF_MODULE, \t\t\t\"No support for %s with %u samples per pixel\",\t\t\tTIFFFileName(input),\t\t\tt2p->tiff_samplesperpixel);\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn;\t}\tif(t2p->tiff_samplesperpixel==0){\t\tTIFFWarning(\t\t\tTIFF2PDF_MODULE, \t\t\t\"Image %s has 0 samples per pixel, assuming 1\",\t\t\tTIFFFileName(input));\t\tt2p->tiff_samplesperpixel=1;\t}\tif(TIFFGetField(input, TIFFTAG_SAMPLEFORMAT, &xuint16) != 0 ){\t\tswitch(xuint16){\t\t\tcase 0:\t\t\tcase 1:\t\t\tcase 4:\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tTIFFError(\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\"No support for %s with sample format %u\",\t\t\t\t\tTIFFFileName(input),\t\t\t\t\txuint16);\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn;\t\t\t\tbreak;\t\t}\t}\tTIFFGetFieldDefaulted(input, TIFFTAG_FILLORDER, &(t2p->tiff_fillorder));        if(TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &(t2p->tiff_photometric)) == 0){                TIFFError(                        TIFF2PDF_MODULE,                         \"No support for %s with no photometric interpretation tag\",                         TIFFFileName(input)     );                t2p->t2p_error = T2P_ERR_ERROR;                return;        }\tswitch(t2p->tiff_photometric){\t\tcase PHOTOMETRIC_MINISWHITE:\t\tcase PHOTOMETRIC_MINISBLACK: \t\t\tif (t2p->tiff_bitspersample==1){\t\t\t\tt2p->pdf_colorspace=T2P_CS_BILEVEL;\t\t\t\tif(t2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){\t\t\t\t\tt2p->pdf_switchdecode ^= 1;\t\t\t\t}\t\t\t} else {\t\t\t\tt2p->pdf_colorspace=T2P_CS_GRAY;\t\t\t\tif(t2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){\t\t\t\t\tt2p->pdf_switchdecode ^= 1;\t\t\t\t} \t\t\t}\t\t\tbreak;\t\tcase PHOTOMETRIC_RGB: \t\t\tt2p->pdf_colorspace=T2P_CS_RGB;\t\t\tif(t2p->tiff_samplesperpixel == 3){\t\t\t\tbreak;\t\t\t}\t\t\tif(TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)){\t\t\t\tif(xuint16==1)\t\t\t\t\tgoto photometric_palette;\t\t\t}\t\t\tif(t2p->tiff_samplesperpixel > 3) {\t\t\t\tif(t2p->tiff_samplesperpixel == 4) {\t\t\t\t\tt2p->pdf_colorspace = T2P_CS_RGB;\t\t\t\t\tif(TIFFGetField(input,\t\t\t\t\t\t\tTIFFTAG_EXTRASAMPLES,\t\t\t\t\t\t\t&xuint16, &xuint16p)\t\t\t\t\t   && xuint16 == 1) {\t\t\t\t\t\tif(xuint16p[0] == EXTRASAMPLE_ASSOCALPHA){\t\t\t\t\t\t\tif( t2p->tiff_bitspersample != 8 )\t\t\t\t\t\t\t{\t\t\t\t\t\t\t    TIFFError(\t\t\t\t\t\t\t\t    TIFF2PDF_MODULE, \t\t\t\t\t\t\t\t    \"No support for BitsPerSample=%d for RGBA\",\t\t\t\t\t\t\t\t    t2p->tiff_bitspersample);\t\t\t\t\t\t\t    t2p->t2p_error = T2P_ERR_ERROR;\t\t\t\t\t\t\t    return;\t\t\t\t\t\t\t}\t\t\t\t\t\t\tt2p->pdf_sample=T2P_SAMPLE_RGBAA_TO_RGB;\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t}\t\t\t\t\t\tif(xuint16p[0] == EXTRASAMPLE_UNASSALPHA){\t\t\t\t\t\t\tif( t2p->tiff_bitspersample != 8 )\t\t\t\t\t\t\t{\t\t\t\t\t\t\t    TIFFError(\t\t\t\t\t\t\t\t    TIFF2PDF_MODULE, \t\t\t\t\t\t\t\t    \"No support for BitsPerSample=%d for RGBA\",\t\t\t\t\t\t\t\t    t2p->tiff_bitspersample);\t\t\t\t\t\t\t    t2p->t2p_error = T2P_ERR_ERROR;\t\t\t\t\t\t\t    return;\t\t\t\t\t\t\t}\t\t\t\t\t\t\tt2p->pdf_sample=T2P_SAMPLE_RGBA_TO_RGB;\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t}\t\t\t\t\t\tTIFFWarning(\t\t\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\t\t\"RGB image %s has 4 samples per pixel, assuming RGBA\",\t\t\t\t\t\t\tTIFFFileName(input));\t\t\t\t\t\t\tbreak;\t\t\t\t\t}\t\t\t\t\tt2p->pdf_colorspace=T2P_CS_CMYK;\t\t\t\t\tt2p->pdf_switchdecode ^= 1;\t\t\t\t\tTIFFWarning(\t\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\t\"RGB image %s has 4 samples per pixel, assuming inverse CMYK\",\t\t\t\t\tTIFFFileName(input));\t\t\t\t\tbreak;\t\t\t\t} else {\t\t\t\t\tTIFFError(\t\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\t\"No support for RGB image %s with %u samples per pixel\", \t\t\t\t\t\tTIFFFileName(input), \t\t\t\t\t\tt2p->tiff_samplesperpixel);\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t} else {\t\t\t\tTIFFError(\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\"No support for RGB image %s with %u samples per pixel\", \t\t\t\t\tTIFFFileName(input), \t\t\t\t\tt2p->tiff_samplesperpixel);\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\tbreak;\t\t\t}\t\tcase PHOTOMETRIC_PALETTE: \t\t\tphotometric_palette:\t\t\tif(t2p->tiff_samplesperpixel!=1){\t\t\t\tTIFFError(\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\"No support for palettized image %s with not one sample per pixel\", \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn;\t\t\t}\t\t\tt2p->pdf_colorspace=T2P_CS_RGB | T2P_CS_PALETTE;\t\t\tt2p->pdf_palettesize=0x0001<<t2p->tiff_bitspersample;\t\t\tif(!TIFFGetField(input, TIFFTAG_COLORMAP, &r, &g, &b)){\t\t\t\tTIFFError(\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\"Palettized image %s has no color map\", \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn;\t\t\t} \t\t\tif(t2p->pdf_palette != NULL){\t\t\t\t_TIFFfree(t2p->pdf_palette);\t\t\t\tt2p->pdf_palette=NULL;\t\t\t}\t\t\tt2p->pdf_palette = (unsigned char*)\t\t\t\t_TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_palettesize,3));\t\t\tif(t2p->pdf_palette==NULL){\t\t\t\tTIFFError(\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate %u bytes of memory for t2p_read_tiff_image, %s\", \t\t\t\t\tt2p->pdf_palettesize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn;\t\t\t}\t\t\tfor(i=0;i<t2p->pdf_palettesize;i++){\t\t\t\tt2p->pdf_palette[(i*3)]  = (unsigned char) (r[i]>>8);\t\t\t\tt2p->pdf_palette[(i*3)+1]= (unsigned char) (g[i]>>8);\t\t\t\tt2p->pdf_palette[(i*3)+2]= (unsigned char) (b[i]>>8);\t\t\t}\t\t\tt2p->pdf_palettesize *= 3;\t\t\tbreak;\t\tcase PHOTOMETRIC_SEPARATED:\t\t\tif(TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)){\t\t\t\tif(xuint16==1){\t\t\t\t\t\tgoto photometric_palette_cmyk;\t\t\t\t}\t\t\t}\t\t\tif( TIFFGetField(input, TIFFTAG_INKSET, &xuint16) ){\t\t\t\tif(xuint16 != INKSET_CMYK){\t\t\t\t\tTIFFError(\t\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\t\"No support for %s because its inkset is not CMYK\",\t\t\t\t\t\tTIFFFileName(input) );\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\t\treturn;\t\t\t\t}\t\t\t}\t\t\tif(t2p->tiff_samplesperpixel==4){\t\t\t\tt2p->pdf_colorspace=T2P_CS_CMYK;\t\t\t} else {\t\t\t\tTIFFError(\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\"No support for %s because it has %u samples per pixel\",\t\t\t\t\tTIFFFileName(input), \t\t\t\t\tt2p->tiff_samplesperpixel);\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn;\t\t\t}\t\t\tbreak;\t\t\tphotometric_palette_cmyk:\t\t\tif(t2p->tiff_samplesperpixel!=1){\t\t\t\tTIFFError(\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\"No support for palettized CMYK image %s with not one sample per pixel\", \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn;\t\t\t}\t\t\tt2p->pdf_colorspace=T2P_CS_CMYK | T2P_CS_PALETTE;\t\t\tt2p->pdf_palettesize=0x0001<<t2p->tiff_bitspersample;\t\t\tif(!TIFFGetField(input, TIFFTAG_COLORMAP, &r, &g, &b, &a)){\t\t\t\tTIFFError(\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\"Palettized image %s has no color map\", \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn;\t\t\t} \t\t\tif(t2p->pdf_palette != NULL){\t\t\t\t_TIFFfree(t2p->pdf_palette);\t\t\t\tt2p->pdf_palette=NULL;\t\t\t}\t\t\tt2p->pdf_palette = (unsigned char*) \t\t\t\t_TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_palettesize,4));\t\t\tif(t2p->pdf_palette==NULL){\t\t\t\tTIFFError(\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate %u bytes of memory for t2p_read_tiff_image, %s\", \t\t\t\t\tt2p->pdf_palettesize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn;\t\t\t}\t\t\tfor(i=0;i<t2p->pdf_palettesize;i++){\t\t\t\tt2p->pdf_palette[(i*4)]  = (unsigned char) (r[i]>>8);\t\t\t\tt2p->pdf_palette[(i*4)+1]= (unsigned char) (g[i]>>8);\t\t\t\tt2p->pdf_palette[(i*4)+2]= (unsigned char) (b[i]>>8);\t\t\t\tt2p->pdf_palette[(i*4)+3]= (unsigned char) (a[i]>>8);\t\t\t}\t\t\tt2p->pdf_palettesize *= 4;\t\t\tbreak;\t\tcase PHOTOMETRIC_YCBCR:\t\t\tt2p->pdf_colorspace=T2P_CS_RGB;\t\t\tif(t2p->tiff_samplesperpixel==1){\t\t\t\tt2p->pdf_colorspace=T2P_CS_GRAY;\t\t\t\tt2p->tiff_photometric=PHOTOMETRIC_MINISBLACK;\t\t\t\tbreak;\t\t\t}\t\t\tt2p->pdf_sample=T2P_SAMPLE_YCBCR_TO_RGB;#ifdef JPEG_SUPPORT\t\t\tif(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){\t\t\t\tt2p->pdf_sample=T2P_SAMPLE_NOTHING;\t\t\t}#endif\t\t\tbreak;\t\tcase PHOTOMETRIC_CIELAB:            if( t2p->tiff_samplesperpixel != 3){                TIFFError(                    TIFF2PDF_MODULE,                     \"Unsupported samplesperpixel = %d for CIELAB\",                     t2p->tiff_samplesperpixel);                t2p->t2p_error = T2P_ERR_ERROR;                return;            }            if( t2p->tiff_bitspersample != 8){                TIFFError(                    TIFF2PDF_MODULE,                     \"Invalid bitspersample = %d for CIELAB\",                     t2p->tiff_bitspersample);                t2p->t2p_error = T2P_ERR_ERROR;                return;            }\t\t\tt2p->pdf_labrange[0]= -127;\t\t\tt2p->pdf_labrange[1]= 127;\t\t\tt2p->pdf_labrange[2]= -127;\t\t\tt2p->pdf_labrange[3]= 127;\t\t\tt2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;\t\t\tt2p->pdf_colorspace=T2P_CS_LAB;\t\t\tbreak;\t\tcase PHOTOMETRIC_ICCLAB:\t\t\tt2p->pdf_labrange[0]= 0;\t\t\tt2p->pdf_labrange[1]= 255;\t\t\tt2p->pdf_labrange[2]= 0;\t\t\tt2p->pdf_labrange[3]= 255;\t\t\tt2p->pdf_colorspace=T2P_CS_LAB;\t\t\tbreak;\t\tcase PHOTOMETRIC_ITULAB:            if( t2p->tiff_samplesperpixel != 3){                TIFFError(                    TIFF2PDF_MODULE,                     \"Unsupported samplesperpixel = %d for ITULAB\",                     t2p->tiff_samplesperpixel);                t2p->t2p_error = T2P_ERR_ERROR;                return;            }            if( t2p->tiff_bitspersample != 8){                TIFFError(                    TIFF2PDF_MODULE,                     \"Invalid bitspersample = %d for ITULAB\",                     t2p->tiff_bitspersample);                t2p->t2p_error = T2P_ERR_ERROR;                return;            }\t\t\tt2p->pdf_labrange[0]=-85;\t\t\tt2p->pdf_labrange[1]=85;\t\t\tt2p->pdf_labrange[2]=-75;\t\t\tt2p->pdf_labrange[3]=124;\t\t\tt2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;\t\t\tt2p->pdf_colorspace=T2P_CS_LAB;\t\t\tbreak;\t\tcase PHOTOMETRIC_LOGL:\t\tcase PHOTOMETRIC_LOGLUV:\t\t\tTIFFError(\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\"No support for %s with photometric interpretation LogL/LogLuv\", \t\t\t\tTIFFFileName(input));\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\treturn;\t\tdefault:\t\t\tTIFFError(\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\"No support for %s with photometric interpretation %u\", \t\t\t\tTIFFFileName(input),\t\t\t\tt2p->tiff_photometric);\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\treturn;\t}\tif(TIFFGetField(input, TIFFTAG_PLANARCONFIG, &(t2p->tiff_planar))){\t\tswitch(t2p->tiff_planar){\t\t\tcase 0:\t\t\t\tTIFFWarning(\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\"Image %s has planar configuration 0, assuming 1\", \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->tiff_planar=PLANARCONFIG_CONTIG;\t\t\tcase PLANARCONFIG_CONTIG:\t\t\t\tbreak;\t\t\tcase PLANARCONFIG_SEPARATE:\t\t\t\tt2p->pdf_sample=T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG;\t\t\t\tif(t2p->tiff_bitspersample!=8){\t\t\t\t\tTIFFError(\t\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\t\"No support for %s with separated planar configuration and %u bits per sample\", \t\t\t\t\t\tTIFFFileName(input),\t\t\t\t\t\tt2p->tiff_bitspersample);\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\t\treturn;\t\t\t\t}\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tTIFFError(\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\"No support for %s with planar configuration %u\", \t\t\t\t\tTIFFFileName(input),\t\t\t\t\tt2p->tiff_planar);\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn;\t\t}\t}        TIFFGetFieldDefaulted(input, TIFFTAG_ORIENTATION,                              &(t2p->tiff_orientation));        if(t2p->tiff_orientation>8){                TIFFWarning(TIFF2PDF_MODULE,                            \"Image %s has orientation %u, assuming 0\",                            TIFFFileName(input), t2p->tiff_orientation);                t2p->tiff_orientation=0;        }        if(TIFFGetField(input, TIFFTAG_XRESOLUTION, &(t2p->tiff_xres) ) == 0){                t2p->tiff_xres=0.0;        }        if(TIFFGetField(input, TIFFTAG_YRESOLUTION, &(t2p->tiff_yres) ) == 0){                t2p->tiff_yres=0.0;        }\tTIFFGetFieldDefaulted(input, TIFFTAG_RESOLUTIONUNIT,\t\t\t      &(t2p->tiff_resunit));\tif(t2p->tiff_resunit == RESUNIT_CENTIMETER) {\t\tt2p->tiff_xres *= 2.54F;\t\tt2p->tiff_yres *= 2.54F;\t} else if (t2p->tiff_resunit != RESUNIT_INCH\t\t   && t2p->pdf_centimeters != 0) {\t\tt2p->tiff_xres *= 2.54F;\t\tt2p->tiff_yres *= 2.54F;\t}\tt2p_compose_pdf_page(t2p);        if( t2p->t2p_error == T2P_ERR_ERROR )\t    return;\tt2p->pdf_transcode = T2P_TRANSCODE_ENCODE;\tif(t2p->pdf_nopassthrough==0){#ifdef CCITT_SUPPORT\t\tif(t2p->tiff_compression==COMPRESSION_CCITTFAX4  \t\t\t){\t\t\tif(TIFFIsTiled(input) || (TIFFNumberOfStrips(input)==1) ){\t\t\t\tt2p->pdf_transcode = T2P_TRANSCODE_RAW;\t\t\t\tt2p->pdf_compression=T2P_COMPRESS_G4;\t\t\t}\t\t}#endif#ifdef ZIP_SUPPORT\t\tif(t2p->tiff_compression== COMPRESSION_ADOBE_DEFLATE \t\t\t|| t2p->tiff_compression==COMPRESSION_DEFLATE){\t\t\tif(TIFFIsTiled(input) || (TIFFNumberOfStrips(input)==1) ){\t\t\t\tt2p->pdf_transcode = T2P_TRANSCODE_RAW;\t\t\t\tt2p->pdf_compression=T2P_COMPRESS_ZIP;\t\t\t}\t\t}#endif#ifdef OJPEG_SUPPORT\t\tif(t2p->tiff_compression==COMPRESSION_OJPEG){\t\t\tt2p->pdf_transcode = T2P_TRANSCODE_RAW;\t\t\tt2p->pdf_compression=T2P_COMPRESS_JPEG;\t\t\tt2p_process_ojpeg_tables(t2p, input);\t\t}#endif#ifdef JPEG_SUPPORT\t\tif(t2p->tiff_compression==COMPRESSION_JPEG){\t\t\tt2p->pdf_transcode = T2P_TRANSCODE_RAW;\t\t\tt2p->pdf_compression=T2P_COMPRESS_JPEG;\t\t}#endif\t\t(void)0;\t}\tif(t2p->pdf_transcode!=T2P_TRANSCODE_RAW){\t\tt2p->pdf_compression = t2p->pdf_defaultcompression;\t}#ifdef JPEG_SUPPORT\tif(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){\t\tif(t2p->pdf_colorspace & T2P_CS_PALETTE){\t\t\tt2p->pdf_sample|=T2P_SAMPLE_REALIZE_PALETTE;\t\t\tt2p->pdf_colorspace ^= T2P_CS_PALETTE;\t\t\tt2p->tiff_pages[t2p->pdf_page].page_extra--;\t\t}\t}\tif(t2p->tiff_compression==COMPRESSION_JPEG){\t\tif(t2p->tiff_planar==PLANARCONFIG_SEPARATE){\t\t\tTIFFError(\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\"No support for %s with JPEG compression and separated planar configuration\", \t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\t\t\treturn;\t\t}\t}#endif#ifdef OJPEG_SUPPORT\tif(t2p->tiff_compression==COMPRESSION_OJPEG){\t\tif(t2p->tiff_planar==PLANARCONFIG_SEPARATE){\t\t\tTIFFError(\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\"No support for %s with OJPEG compression and separated planar configuration\", \t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\t\t\treturn;\t\t}\t}#endif\tif(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\t\t\tt2p->tiff_samplesperpixel=4;\t\t\tt2p->tiff_photometric=PHOTOMETRIC_SEPARATED;\t\t} else {\t\t\tt2p->tiff_samplesperpixel=3;\t\t\tt2p->tiff_photometric=PHOTOMETRIC_RGB;\t\t}\t}\tif (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,\t\t\t &(t2p->tiff_transferfunction[0]),\t\t\t &(t2p->tiff_transferfunction[1]),\t\t\t &(t2p->tiff_transferfunction[2]))) {\t\tif((t2p->tiff_transferfunction[1] != (float*) NULL) &&                   (t2p->tiff_transferfunction[2] != (float*) NULL) &&                   (t2p->tiff_transferfunction[1] !=                    t2p->tiff_transferfunction[0])) {\t\t\tt2p->tiff_transferfunctioncount=3;\t\t} else {\t\t\tt2p->tiff_transferfunctioncount=1;\t\t}\t} else {\t\tt2p->tiff_transferfunctioncount=0;\t}\tif(TIFFGetField(input, TIFFTAG_WHITEPOINT, &xfloatp)!=0){\t\tt2p->tiff_whitechromaticities[0]=xfloatp[0];\t\tt2p->tiff_whitechromaticities[1]=xfloatp[1];\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\t\t\tt2p->pdf_colorspace |= T2P_CS_CALGRAY;\t\t}\t\tif(t2p->pdf_colorspace & T2P_CS_RGB){\t\t\tt2p->pdf_colorspace |= T2P_CS_CALRGB;\t\t}\t}\tif(TIFFGetField(input, TIFFTAG_PRIMARYCHROMATICITIES, &xfloatp)!=0){\t\tt2p->tiff_primarychromaticities[0]=xfloatp[0];\t\tt2p->tiff_primarychromaticities[1]=xfloatp[1];\t\tt2p->tiff_primarychromaticities[2]=xfloatp[2];\t\tt2p->tiff_primarychromaticities[3]=xfloatp[3];\t\tt2p->tiff_primarychromaticities[4]=xfloatp[4];\t\tt2p->tiff_primarychromaticities[5]=xfloatp[5];\t\tif(t2p->pdf_colorspace & T2P_CS_RGB){\t\t\tt2p->pdf_colorspace |= T2P_CS_CALRGB;\t\t}\t}\tif(t2p->pdf_colorspace & T2P_CS_LAB){\t\tif(TIFFGetField(input, TIFFTAG_WHITEPOINT, &xfloatp) != 0){\t\t\tt2p->tiff_whitechromaticities[0]=xfloatp[0];\t\t\tt2p->tiff_whitechromaticities[1]=xfloatp[1];\t\t} else {\t\t\tt2p->tiff_whitechromaticities[0]=0.3457F; \t\t\tt2p->tiff_whitechromaticities[1]=0.3585F; \t\t}\t}\tif(TIFFGetField(input, \t\tTIFFTAG_ICCPROFILE, \t\t&(t2p->tiff_iccprofilelength), \t\t&(t2p->tiff_iccprofile))!=0){\t\tt2p->pdf_colorspace |= T2P_CS_ICCBASED;\t} else {\t\tt2p->tiff_iccprofilelength=0;\t\tt2p->tiff_iccprofile=NULL;\t}#ifdef CCITT_SUPPORT\tif( t2p->tiff_bitspersample==1 &&\t\tt2p->tiff_samplesperpixel==1){\t\tt2p->pdf_compression = T2P_COMPRESS_G4;\t}#endif\treturn;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tmsize_tTIFFReadRawStrip1(TIFF* tif, uint32 strip, void* buf, tmsize_t size,    const char* module){\tTIFFDirectory *td = &tif->tif_dir;    if (!_TIFFFillStriles( tif ))        return ((tmsize_t)(-1));        \tassert((tif->tif_flags&TIFF_NOREADRAW)==0);\tif (!isMapped(tif)) {\t\ttmsize_t cc;\t\tif (!SeekOK(tif, td->td_stripoffset[strip])) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"Seek error at scanline %lu, strip %lu\",\t\t\t    (unsigned long) tif->tif_row, (unsigned long) strip);\t\t\treturn ((tmsize_t)(-1));\t\t}\t\tcc = TIFFReadFile(tif, buf, size);\t\tif (cc != size) {#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\"Read error at scanline %lu; got %I64u bytes, expected %I64u\",\t\t\t\t     (unsigned long) tif->tif_row,\t\t\t\t     (unsigned __int64) cc,\t\t\t\t     (unsigned __int64) size);#else\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\"Read error at scanline %lu; got %llu bytes, expected %llu\",\t\t\t\t     (unsigned long) tif->tif_row,\t\t\t\t     (unsigned long long) cc,\t\t\t\t     (unsigned long long) size);#endif\t\t\treturn ((tmsize_t)(-1));\t\t}\t} else {\t\ttmsize_t ma,mb;\t\ttmsize_t n;\t\tma=(tmsize_t)td->td_stripoffset[strip];\t\tmb=ma+size;\t\tif (((uint64)ma!=td->td_stripoffset[strip])||(ma>tif->tif_size))\t\t\tn=0;\t\telse if ((mb<ma)||(mb<size)||(mb>tif->tif_size))\t\t\tn=tif->tif_size-ma;\t\telse\t\t\tn=size;\t\tif (n!=size) {#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\"Read error at scanline %lu, strip %lu; got %I64u bytes, expected %I64u\",\t\t\t\t     (unsigned long) tif->tif_row,\t\t\t\t     (unsigned long) strip,\t\t\t\t     (unsigned __int64) n,\t\t\t\t     (unsigned __int64) size);#else\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\"Read error at scanline %lu, strip %lu; got %llu bytes, expected %llu\",\t\t\t\t     (unsigned long) tif->tif_row,\t\t\t\t     (unsigned long) strip,\t\t\t\t     (unsigned long long) n,\t\t\t\t     (unsigned long long) size);#endif\t\t\treturn ((tmsize_t)(-1));\t\t}\t\t_TIFFmemcpy(buf, tif->tif_base + ma,\t\t\t    size);\t}\treturn (size);}",
        "label": 1,
        "cve": "cve-2016-6223"
    },
    {
        "code": "static int_tiffCloseProc(thandle_t fd){\treturn (close((int) fd));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intreadgifimage(char* mode){    unsigned char buf[9];    int local, interleaved;    unsigned char localmap[256][3];    int localbits;    int status;    size_t raster_size;    if (fread(buf, 1, 9, infile) != 9) {        fprintf(stderr, \"short read from file %s (%s)\\n\",                filename, strerror(errno));\treturn (0);    }    width = (buf[4] + (buf[5] << 8)) & 0xffff;     height = (buf[6] + (buf[7] << 8)) & 0xffff;      local = buf[8] & 0x80;    interleaved = buf[8] & 0x40;    if (width == 0UL || height == 0UL || (width > 2000000000UL / height)) {        fprintf(stderr, \"Invalid value of width or height\\n\");        return(0);    }    if (local == 0 && global == 0) {        fprintf(stderr, \"no colormap present for image\\n\");        return (0);    }    raster_size=width*height;    if ((raster_size/width) == height) {        raster_size += EXTRAFUDGE;      } else {        raster_size=0;    }    if ((raster = (unsigned char*) _TIFFmalloc(raster_size)) == NULL) {        fprintf(stderr, \"not enough memory for image\\n\");        return (0);    }    if (local) {        localbits = (buf[8] & 0x7) + 1;        fprintf(stderr, \"   local colors: %d\\n\", 1<<localbits);        if (fread(localmap, 3, ((size_t)1)<<localbits, infile) !=            ((size_t)1)<<localbits) {            fprintf(stderr, \"short read from file %s (%s)\\n\",                    filename, strerror(errno));            return (0);        }        initcolors(localmap, 1<<localbits);    } else if (global) {        initcolors(globalmap, 1<<globalbits);    }    if ((status = readraster()))\trasterize(interleaved, mode);    _TIFFfree(raster);    return status;}",
        "label": 1,
        "cve": "cve-2016-5102"
    },
    {
        "code": "static void_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size){}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intgetopt(int argc, char * const argv[], const char *optstring){\tstatic char *place = EMSG;\t\t\tchar *oli;\t\t\t\t\tif (optreset || *place == 0) {\t\t\t\toptreset = 0;\t\tplace = argv[optind];\t\tif (optind >= argc || *place++ != '-') {\t\t\t\t\t\tplace = EMSG;\t\t\treturn (-1);\t\t}\t\toptopt = *place++;\t\tif (optopt == '-' && *place == 0) {\t\t\t\t\t\t++optind;\t\t\tplace = EMSG;\t\t\treturn (-1);\t\t}\t\tif (optopt == 0) {\t\t\t\t\t\tplace = EMSG;\t\t\tif (strchr(optstring, '-') == NULL)\t\t\t\treturn -1;\t\t\toptopt = '-';\t\t}\t} else\t\toptopt = *place++;\t\tif (optopt == ':' || (oli = strchr(optstring, optopt)) == NULL) {\t\tif (*place == 0)\t\t\t++optind;\t\tif (opterr && *optstring != ':')\t\t\t(void)fprintf(stderr,                                      \"unknown option -- %c\\n\", optopt);\t\treturn (BADCH);\t}\t\tif (oli[1] != ':') {\t\t\t\toptarg = NULL;\t\tif (*place == 0)\t\t\t++optind;\t} else {\t\t\t\tif (*place)\t\t\toptarg = place;\t\telse if (argc > ++optind)\t\t\toptarg = argv[optind];\t\telse {\t\t\t\t\t\tplace = EMSG;\t\t\tif (*optstring == ':')\t\t\t\treturn (BADARG);\t\t\tif (opterr)\t\t\t\t(void)fprintf(stderr,                                        \"option requires an argument -- %c\\n\",                                        optopt);\t\t\treturn (BADCH);\t\t}\t\tplace = EMSG;\t\t++optind;\t}\treturn (optopt);\t\t\t}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static inthorAcc8(TIFF* tif, uint8* cp0, tmsize_t cc){\ttmsize_t stride = PredictorState(tif)->stride;\tunsigned char* cp = (unsigned char*) cp0;    if((cc%stride)!=0)    {        TIFFErrorExt(tif->tif_clientdata, \"horAcc8\",                     \"%s\", \"(cc%stride)!=0\");        return 0;    }\tif (cc > stride) {\t\t\t\tif (stride == 3)  {\t\t\tunsigned int cr = cp[0];\t\t\tunsigned int cg = cp[1];\t\t\tunsigned int cb = cp[2];\t\t\tcc -= 3;\t\t\tcp += 3;\t\t\twhile (cc>0) {\t\t\t\tcp[0] = (unsigned char) ((cr += cp[0]) & 0xff);\t\t\t\tcp[1] = (unsigned char) ((cg += cp[1]) & 0xff);\t\t\t\tcp[2] = (unsigned char) ((cb += cp[2]) & 0xff);\t\t\t\tcc -= 3;\t\t\t\tcp += 3;\t\t\t}\t\t} else if (stride == 4)  {\t\t\tunsigned int cr = cp[0];\t\t\tunsigned int cg = cp[1];\t\t\tunsigned int cb = cp[2];\t\t\tunsigned int ca = cp[3];\t\t\tcc -= 4;\t\t\tcp += 4;\t\t\twhile (cc>0) {\t\t\t\tcp[0] = (unsigned char) ((cr += cp[0]) & 0xff);\t\t\t\tcp[1] = (unsigned char) ((cg += cp[1]) & 0xff);\t\t\t\tcp[2] = (unsigned char) ((cb += cp[2]) & 0xff);\t\t\t\tcp[3] = (unsigned char) ((ca += cp[3]) & 0xff);\t\t\t\tcc -= 4;\t\t\t\tcp += 4;\t\t\t}\t\t} else  {\t\t\tcc -= stride;\t\t\tdo {\t\t\t\tREPEAT4(stride, cp[stride] =\t\t\t\t\t(unsigned char) ((cp[stride] + *cp) & 0xff); cp++)\t\t\t\tcc -= stride;\t\t\t} while (cc>0);\t\t}\t}\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(void){\tchar buf[BUFSIZ];\tint i;\tsetbuf(stderr, buf);\tfprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\tfor (i = 0; stuff[i] != NULL; i++)\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\texit(-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, long nstrips, uint32** lpp){\tregister uint32* lp;\tint status;\tif (!CheckDirCount(tif, dir, (uint32) nstrips))\t\treturn (0);\t\tif (*lpp == NULL &&\t    (*lpp = (uint32 *)CheckMalloc(tif,\t      nstrips * sizeof (uint32), \"for strip array\")) == NULL)\t\treturn (0);\tlp = *lpp;\tif (dir->tdir_type == (int)TIFF_SHORT) {\t\t\t\tuint16* dp = (uint16*) CheckMalloc(tif,\t\t    dir->tdir_count* sizeof (uint16), \"to fetch strip tag\");\t\tif (dp == NULL)\t\t\treturn (0);\t\tif (status = TIFFFetchShortArray(tif, dir, dp)) {\t\t\tregister uint16* wp = dp;\t\t\twhile (nstrips-- > 0)\t\t\t\t*lp++ = *wp++;\t\t}\t\t_TIFFfree((char*) dp);\t} else\t\tstatus = TIFFFetchLongArray(tif, dir, lp);\treturn (status);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "unsigned longstrtoul(const char *nptr, char **endptr, int base){\tconst char *s;\tunsigned long acc, cutoff;\tint c;\tint neg, any, cutlim;\t\ts = nptr;\tdo {\t\tc = (unsigned char) *s++;\t} while (isspace(c));\tif (c == '-') {\t\tneg = 1;\t\tc = *s++;\t} else {\t\tneg = 0;\t\tif (c == '+')\t\t\tc = *s++;\t}\tif ((base == 0 || base == 16) &&\t    c == '0' && (*s == 'x' || *s == 'X')) {\t\tc = s[1];\t\ts += 2;\t\tbase = 16;\t}\tif (base == 0)\t\tbase = c == '0' ? 8 : 10;\tcutoff = ULONG_MAX / (unsigned long)base;\tcutlim = (int)(ULONG_MAX % (unsigned long)base);\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\t\tif (isdigit(c))\t\t\tc -= '0';\t\telse if (isalpha(c))\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\t\telse\t\t\tbreak;\t\tif (c >= base)\t\t\tbreak;\t\tif (any < 0)\t\t\tcontinue;\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\t\t\tany = -1;\t\t\tacc = ULONG_MAX;\t\t\terrno = ERANGE;\t\t} else {\t\t\tany = 1;\t\t\tacc *= (unsigned long)base;\t\t\tacc += c;\t\t}\t}\tif (neg && any > 0)\t\tacc = -acc;\tif (endptr != 0)\t\t\t\t*endptr = (char *)(any ? s - 1 : nptr);\treturn (acc);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intfindPage(TIFF* tif, uint16 pageNumber){    uint16 pn = (uint16) -1;    uint16 ptotal = (uint16) -1;    if (GetPageNumber(tif)) {\twhile (pn != (pageNumber-1) && TIFFReadDirectory(tif) && GetPageNumber(tif))\t    ;\treturn (pn == (pageNumber-1));    } else\treturn (TIFFSetDirectory(tif, (tdir_t)(pageNumber-1)));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static toff_t_tiffSeekProc(thandle_t fd, off_t off, int whence){\tchar buf[256];\tlong current_off, expected_off, new_off;\tif (whence == SEEK_END || off <= 0)\t\treturn Fseek(off, (int) fd, whence);\tcurrent_off = Fseek(0, (int) fd, SEEK_CUR); \tif (whence == SEEK_SET)\t\texpected_off = off;\telse\t\texpected_off = off + current_off;\tnew_off = Fseek(off, (int) fd, whence);\tif (new_off == expected_off)\t\treturn new_off;\t\tif (new_off < 0)            \t\tnew_off = Fseek(0, (int) fd, SEEK_END); \t_TIFFmemset(buf, 0, sizeof(buf));\twhile (expected_off > new_off) {\t\toff = expected_off - new_off;\t\tif (off > sizeof(buf))\t\t\toff = sizeof(buf);\t\tif ((current_off = Fwrite((int) fd, off, buf)) != off)\t\t\treturn (current_off > 0) ?\t\t\t    new_off + current_off : new_off;\t\tnew_off += off;\t}\treturn new_off;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFPrintDirectory(TIFF* tif, FILE* fd, long flags){\tTIFFDirectory *td = &tif->tif_dir;\tchar *sep;\tlong l, n;#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\tfprintf(fd, \"TIFF Directory at offset 0x%I64x (%I64u)\\n\",\t\t(unsigned __int64) tif->tif_diroff,\t\t(unsigned __int64) tif->tif_diroff);#else\tfprintf(fd, \"TIFF Directory at offset 0x%llx (%llu)\\n\",\t\t(unsigned long long) tif->tif_diroff,\t\t(unsigned long long) tif->tif_diroff);#endif\tif (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) {\t\tfprintf(fd, \"  Subfile Type:\");\t\tsep = \" \";\t\tif (td->td_subfiletype & FILETYPE_REDUCEDIMAGE) {\t\t\tfprintf(fd, \"%sreduced-resolution image\", sep);\t\t\tsep = \"/\";\t\t}\t\tif (td->td_subfiletype & FILETYPE_PAGE) {\t\t\tfprintf(fd, \"%smulti-page document\", sep);\t\t\tsep = \"/\";\t\t}\t\tif (td->td_subfiletype & FILETYPE_MASK)\t\t\tfprintf(fd, \"%stransparency mask\", sep);\t\tfprintf(fd, \" (%lu = 0x%lx)\\n\",\t\t    (unsigned long) td->td_subfiletype, (long) td->td_subfiletype);\t}\tif (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) {\t\tfprintf(fd, \"  Image Width: %lu Image Length: %lu\",\t\t    (unsigned long) td->td_imagewidth, (unsigned long) td->td_imagelength);\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))\t\t\tfprintf(fd, \" Image Depth: %lu\",\t\t\t    (unsigned long) td->td_imagedepth);\t\tfprintf(fd, \"\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) {\t\tfprintf(fd, \"  Tile Width: %lu Tile Length: %lu\",\t\t    (unsigned long) td->td_tilewidth, (unsigned long) td->td_tilelength);\t\tif (TIFFFieldSet(tif,FIELD_TILEDEPTH))\t\t\tfprintf(fd, \" Tile Depth: %lu\",\t\t\t    (unsigned long) td->td_tiledepth);\t\tfprintf(fd, \"\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_RESOLUTION)) {\t\tfprintf(fd, \"  Resolution: %g, %g\",\t\t    td->td_xresolution, td->td_yresolution);\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) {\t\t\tswitch (td->td_resolutionunit) {\t\t\tcase RESUNIT_NONE:\t\t\t\tfprintf(fd, \" (unitless)\");\t\t\t\tbreak;\t\t\tcase RESUNIT_INCH:\t\t\t\tfprintf(fd, \" pixels/inch\");\t\t\t\tbreak;\t\t\tcase RESUNIT_CENTIMETER:\t\t\t\tfprintf(fd, \" pixels/cm\");\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tfprintf(fd, \" (unit %u = 0x%x)\",\t\t\t\t    td->td_resolutionunit,\t\t\t\t    td->td_resolutionunit);\t\t\t\tbreak;\t\t\t}\t\t}\t\tfprintf(fd, \"\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_POSITION))\t\tfprintf(fd, \"  Position: %g, %g\\n\",\t\t    td->td_xposition, td->td_yposition);\tif (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\t\tfprintf(fd, \"  Bits/Sample: %u\\n\", td->td_bitspersample);\tif (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) {\t\tfprintf(fd, \"  Sample Format: \");\t\tswitch (td->td_sampleformat) {\t\tcase SAMPLEFORMAT_VOID:\t\t\tfprintf(fd, \"void\\n\");\t\t\tbreak;\t\tcase SAMPLEFORMAT_INT:\t\t\tfprintf(fd, \"signed integer\\n\");\t\t\tbreak;\t\tcase SAMPLEFORMAT_UINT:\t\t\tfprintf(fd, \"unsigned integer\\n\");\t\t\tbreak;\t\tcase SAMPLEFORMAT_IEEEFP:\t\t\tfprintf(fd, \"IEEE floating point\\n\");\t\t\tbreak;\t\tcase SAMPLEFORMAT_COMPLEXINT:\t\t\tfprintf(fd, \"complex signed integer\\n\");\t\t\tbreak;\t\tcase SAMPLEFORMAT_COMPLEXIEEEFP:\t\t\tfprintf(fd, \"complex IEEE floating point\\n\");\t\t\tbreak;\t\tdefault:\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_sampleformat, td->td_sampleformat);\t\t\tbreak;\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_COMPRESSION)) {\t\tconst TIFFCodec* c = TIFFFindCODEC(td->td_compression);\t\tfprintf(fd, \"  Compression Scheme: \");\t\tif (c)\t\t\tfprintf(fd, \"%s\\n\", c->name);\t\telse\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_compression, td->td_compression);\t}\tif (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) {\t\tfprintf(fd, \"  Photometric Interpretation: \");\t\tif (td->td_photometric < NPHOTONAMES)\t\t\tfprintf(fd, \"%s\\n\", photoNames[td->td_photometric]);\t\telse {\t\t\tswitch (td->td_photometric) {\t\t\tcase PHOTOMETRIC_LOGL:\t\t\t\tfprintf(fd, \"CIE Log2(L)\\n\");\t\t\t\tbreak;\t\t\tcase PHOTOMETRIC_LOGLUV:\t\t\t\tfprintf(fd, \"CIE Log2(L) (u',v')\\n\");\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t\t    td->td_photometric, td->td_photometric);\t\t\t\tbreak;\t\t\t}\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_EXTRASAMPLES) && td->td_extrasamples) {\t\tuint16 i;\t\tfprintf(fd, \"  Extra Samples: %u<\", td->td_extrasamples);\t\tsep = \"\";\t\tfor (i = 0; i < td->td_extrasamples; i++) {\t\t\tswitch (td->td_sampleinfo[i]) {\t\t\tcase EXTRASAMPLE_UNSPECIFIED:\t\t\t\tfprintf(fd, \"%sunspecified\", sep);\t\t\t\tbreak;\t\t\tcase EXTRASAMPLE_ASSOCALPHA:\t\t\t\tfprintf(fd, \"%sassoc-alpha\", sep);\t\t\t\tbreak;\t\t\tcase EXTRASAMPLE_UNASSALPHA:\t\t\t\tfprintf(fd, \"%sunassoc-alpha\", sep);\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tfprintf(fd, \"%s%u (0x%x)\", sep,\t\t\t\t    td->td_sampleinfo[i], td->td_sampleinfo[i]);\t\t\t\tbreak;\t\t\t}\t\t\tsep = \", \";\t\t}\t\tfprintf(fd, \">\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_INKNAMES)) {\t\tchar* cp;\t\tuint16 i;\t\tfprintf(fd, \"  Ink Names: \");\t\ti = td->td_samplesperpixel;\t\tsep = \"\";\t\tfor (cp = td->td_inknames; \t\t     i > 0 && cp < td->td_inknames + td->td_inknameslen; \t\t     cp = strchr(cp,'\\0')+1, i--) {\t\t\tsize_t max_chars = \t\t\t\ttd->td_inknameslen - (cp - td->td_inknames);\t\t\tfputs(sep, fd);\t\t\t_TIFFprintAsciiBounded(fd, cp, max_chars);\t\t\tsep = \", \";\t\t}                fputs(\"\\n\", fd);\t}\tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) {\t\tfprintf(fd, \"  Thresholding: \");\t\tswitch (td->td_threshholding) {\t\tcase THRESHHOLD_BILEVEL:\t\t\tfprintf(fd, \"bilevel art scan\\n\");\t\t\tbreak;\t\tcase THRESHHOLD_HALFTONE:\t\t\tfprintf(fd, \"halftone or dithered scan\\n\");\t\t\tbreak;\t\tcase THRESHHOLD_ERRORDIFFUSE:\t\t\tfprintf(fd, \"error diffused\\n\");\t\t\tbreak;\t\tdefault:\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_threshholding, td->td_threshholding);\t\t\tbreak;\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_FILLORDER)) {\t\tfprintf(fd, \"  FillOrder: \");\t\tswitch (td->td_fillorder) {\t\tcase FILLORDER_MSB2LSB:\t\t\tfprintf(fd, \"msb-to-lsb\\n\");\t\t\tbreak;\t\tcase FILLORDER_LSB2MSB:\t\t\tfprintf(fd, \"lsb-to-msb\\n\");\t\t\tbreak;\t\tdefault:\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_fillorder, td->td_fillorder);\t\t\tbreak;\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))        {\t\tfprintf(fd, \"  YCbCr Subsampling: %u, %u\\n\",\t\t\ttd->td_ycbcrsubsampling[0], td->td_ycbcrsubsampling[1] );\t}\tif (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) {\t\tfprintf(fd, \"  YCbCr Positioning: \");\t\tswitch (td->td_ycbcrpositioning) {\t\tcase YCBCRPOSITION_CENTERED:\t\t\tfprintf(fd, \"centered\\n\");\t\t\tbreak;\t\tcase YCBCRPOSITION_COSITED:\t\t\tfprintf(fd, \"cosited\\n\");\t\t\tbreak;\t\tdefault:\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_ycbcrpositioning, td->td_ycbcrpositioning);\t\t\tbreak;\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))\t\tfprintf(fd, \"  Halftone Hints: light %u dark %u\\n\",\t\t    td->td_halftonehints[0], td->td_halftonehints[1]);\tif (TIFFFieldSet(tif,FIELD_ORIENTATION)) {\t\tfprintf(fd, \"  Orientation: \");\t\tif (td->td_orientation < NORIENTNAMES)\t\t\tfprintf(fd, \"%s\\n\", orientNames[td->td_orientation]);\t\telse\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_orientation, td->td_orientation);\t}\tif (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\t\tfprintf(fd, \"  Samples/Pixel: %u\\n\", td->td_samplesperpixel);\tif (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) {\t\tfprintf(fd, \"  Rows/Strip: \");\t\tif (td->td_rowsperstrip == (uint32) -1)\t\t\tfprintf(fd, \"(infinite)\\n\");\t\telse\t\t\tfprintf(fd, \"%lu\\n\", (unsigned long) td->td_rowsperstrip);\t}\tif (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))\t\tfprintf(fd, \"  Min Sample Value: %u\\n\", td->td_minsamplevalue);\tif (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))\t\tfprintf(fd, \"  Max Sample Value: %u\\n\", td->td_maxsamplevalue);\tif (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) {\t\tint i;\t\tint count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;\t\tfprintf(fd, \"  SMin Sample Value:\");\t\tfor (i = 0; i < count; ++i)\t\t\tfprintf(fd, \" %g\", td->td_sminsamplevalue[i]);\t\tfprintf(fd, \"\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) {\t\tint i;\t\tint count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;\t\tfprintf(fd, \"  SMax Sample Value:\");\t\tfor (i = 0; i < count; ++i)\t\t\tfprintf(fd, \" %g\", td->td_smaxsamplevalue[i]);\t\tfprintf(fd, \"\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) {\t\tfprintf(fd, \"  Planar Configuration: \");\t\tswitch (td->td_planarconfig) {\t\tcase PLANARCONFIG_CONTIG:\t\t\tfprintf(fd, \"single image plane\\n\");\t\t\tbreak;\t\tcase PLANARCONFIG_SEPARATE:\t\t\tfprintf(fd, \"separate image planes\\n\");\t\t\tbreak;\t\tdefault:\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_planarconfig, td->td_planarconfig);\t\t\tbreak;\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_PAGENUMBER))\t\tfprintf(fd, \"  Page Number: %u-%u\\n\",\t\t    td->td_pagenumber[0], td->td_pagenumber[1]);\tif (TIFFFieldSet(tif,FIELD_COLORMAP)) {\t\tfprintf(fd, \"  Color Map: \");\t\tif (flags & TIFFPRINT_COLORMAP) {\t\t\tfprintf(fd, \"\\n\");\t\t\tn = 1L<<td->td_bitspersample;\t\t\tfor (l = 0; l < n; l++)\t\t\t\tfprintf(fd, \"   %5ld: %5u %5u %5u\\n\",\t\t\t\t    l,\t\t\t\t    td->td_colormap[0][l],\t\t\t\t    td->td_colormap[1][l],\t\t\t\t    td->td_colormap[2][l]);\t\t} else\t\t\tfprintf(fd, \"(present)\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) {\t\tint i;\t\tfprintf(fd, \"  Reference Black/White:\\n\");\t\tfor (i = 0; i < 3; i++)\t\tfprintf(fd, \"    %2d: %5g %5g\\n\", i,\t\t\ttd->td_refblackwhite[2*i+0],\t\t\ttd->td_refblackwhite[2*i+1]);\t}\tif (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) {\t\tfprintf(fd, \"  Transfer Function: \");\t\tif (flags & TIFFPRINT_CURVES) {\t\t\tfprintf(fd, \"\\n\");\t\t\tn = 1L<<td->td_bitspersample;\t\t\tfor (l = 0; l < n; l++) {\t\t\t\tuint16 i;\t\t\t\tfprintf(fd, \"    %2ld: %5u\",\t\t\t\t    l, td->td_transferfunction[0][l]);\t\t\t\tfor (i = 1; i < td->td_samplesperpixel; i++)\t\t\t\t\tfprintf(fd, \" %5u\",\t\t\t\t\t    td->td_transferfunction[i][l]);\t\t\t\tfputc('\\n', fd);\t\t\t}\t\t} else\t\t\tfprintf(fd, \"(present)\\n\");\t}\tif (TIFFFieldSet(tif, FIELD_SUBIFD) && (td->td_subifd)) {\t\tuint16 i;\t\tfprintf(fd, \"  SubIFD Offsets:\");\t\tfor (i = 0; i < td->td_nsubifd; i++)#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\t\tfprintf(fd, \" %5I64u\",\t\t\t\t(unsigned __int64) td->td_subifd[i]);#else\t\t\tfprintf(fd, \" %5llu\",\t\t\t\t(unsigned long long) td->td_subifd[i]);#endif\t\tfputc('\\n', fd);\t}\t\t{\t\tint  i;\t\tshort count;\t\tcount = (short) TIFFGetTagListCount(tif);\t\tfor(i = 0; i < count; i++) {\t\t\tuint32 tag = TIFFGetTagListEntry(tif, i);\t\t\tconst TIFFField *fip;\t\t\tuint32 value_count;\t\t\tint mem_alloc = 0;\t\t\tvoid *raw_data;\t\t\tfip = TIFFFieldWithTag(tif, tag);\t\t\tif(fip == NULL)\t\t\t\tcontinue;\t\t\tif(fip->field_passcount) {\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2 ) {\t\t\t\t\tif(TIFFGetField(tif, tag, &value_count, &raw_data) != 1)\t\t\t\t\t\tcontinue;\t\t\t\t} else if (fip->field_readcount == TIFF_VARIABLE ) {\t\t\t\t\tuint16 small_value_count;\t\t\t\t\tif(TIFFGetField(tif, tag, &small_value_count, &raw_data) != 1)\t\t\t\t\t\tcontinue;\t\t\t\t\tvalue_count = small_value_count;\t\t\t\t} else {\t\t\t\t\tassert (fip->field_readcount == TIFF_VARIABLE\t\t\t\t\t\t|| fip->field_readcount == TIFF_VARIABLE2);\t\t\t\t\tcontinue;\t\t\t\t} \t\t\t} else {\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2)\t\t\t\t\tvalue_count = 1;\t\t\t\telse if (fip->field_readcount == TIFF_SPP)\t\t\t\t\tvalue_count = td->td_samplesperpixel;\t\t\t\telse\t\t\t\t\tvalue_count = fip->field_readcount;\t\t\t\tif (fip->field_tag == TIFFTAG_DOTRANGE\t\t\t\t    && strcmp(fip->field_name,\"DotRange\") == 0) {\t\t\t\t\t\t\t\t\t\tstatic uint16 dotrange[2];\t\t\t\t\traw_data = dotrange;\t\t\t\t\tTIFFGetField(tif, tag, dotrange+0, dotrange+1);\t\t\t\t} else if (fip->field_type == TIFF_ASCII\t\t\t\t\t   || fip->field_readcount == TIFF_VARIABLE\t\t\t\t\t   || fip->field_readcount == TIFF_VARIABLE2\t\t\t\t\t   || fip->field_readcount == TIFF_SPP\t\t\t\t\t   || value_count > 1) {\t\t\t\t\tif(TIFFGetField(tif, tag, &raw_data) != 1)\t\t\t\t\t\tcontinue;\t\t\t\t} else {\t\t\t\t\traw_data = _TIFFmalloc(\t\t\t\t\t    _TIFFDataSize(fip->field_type)\t\t\t\t\t    * value_count);\t\t\t\t\tmem_alloc = 1;\t\t\t\t\tif(TIFFGetField(tif, tag, raw_data) != 1) {\t\t\t\t\t\t_TIFFfree(raw_data);\t\t\t\t\t\tcontinue;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\t\t\t\tif (!_TIFFPrettyPrintField(tif, fip, fd, tag, value_count, raw_data))\t\t\t\t_TIFFPrintField(fd, fip, value_count, raw_data);\t\t\tif(mem_alloc)\t\t\t\t_TIFFfree(raw_data);\t\t}\t}\tif (tif->tif_tagmethods.printdir)\t\t(*tif->tif_tagmethods.printdir)(tif, fd, flags);        _TIFFFillStriles( tif );\tif ((flags & TIFFPRINT_STRIPS) &&\t    TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) {\t\tuint32 s;\t\tfprintf(fd, \"  %lu %s:\\n\",\t\t    (unsigned long) td->td_nstrips,\t\t    isTiled(tif) ? \"Tiles\" : \"Strips\");\t\tfor (s = 0; s < td->td_nstrips; s++)#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\t\tfprintf(fd, \"    %3lu: [%8I64u, %8I64u]\\n\",\t\t\t    (unsigned long) s,\t\t\t    (unsigned __int64) td->td_stripoffset[s],\t\t\t    (unsigned __int64) td->td_stripbytecount[s]);#else\t\t\tfprintf(fd, \"    %3lu: [%8llu, %8llu]\\n\",\t\t\t    (unsigned long) s,\t\t\t    (unsigned long long) td->td_stripoffset[s],\t\t\t    (unsigned long long) td->td_stripbytecount[s]);#endif\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidprocessG3Options(char* cp){\tif( (cp = strchr(cp, ':')) ) {\t\tif (defg3opts == (uint32) -1)\t\t\tdefg3opts = 0;\t\tdo {\t\t\tcp++;\t\t\tif (strneq(cp, \"1d\", 2))\t\t\t\tdefg3opts &= ~GROUP3OPT_2DENCODING;\t\t\telse if (strneq(cp, \"2d\", 2))\t\t\t\tdefg3opts |= GROUP3OPT_2DENCODING;\t\t\telse if (strneq(cp, \"fill\", 4))\t\t\t\tdefg3opts |= GROUP3OPT_FILLBITS;\t\t\telse\t\t\t\tusage();\t\t} while( (cp = strchr(cp, ':')) );\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tdata_t_TIFFrealloc(tdata_t p, tsize_t s){\treturn (realloc(p, (size_t) s));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "    { setByteArray(vpp, vp, n, 1); }void _TIFFsetString(char** cpp, char* cp)    { setByteArray((void**) cpp, (void*) cp, strlen(cp)+1, 1); }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intThunderDecode(TIFF* tif, tidata_t op, tsize_t maxpixels){\tregister u_char *bp;\tregister tsize_t cc;\tu_int lastpixel;\ttsize_t npixels;\tbp = (u_char *)tif->tif_rawcp;\tcc = tif->tif_rawcc;\tlastpixel = 0;\tnpixels = 0;\twhile (cc > 0 && npixels < maxpixels) {\t\tint n, delta;\t\tn = *bp++, cc--;\t\tswitch (n & THUNDER_CODE) {\t\tcase THUNDER_RUN:\t\t\t\t\t\t\t\tif (npixels & 1) {\t\t\t\top[0] |= lastpixel;\t\t\t\tlastpixel = *op++; npixels++; n--;\t\t\t} else\t\t\t\tlastpixel |= lastpixel << 4;\t\t\tnpixels += n;\t\t\tfor (; n > 0; n -= 2)\t\t\t\t*op++ = (tidataval_t) lastpixel;\t\t\tif (n == -1)\t\t\t\t*--op &= 0xf0;\t\t\tlastpixel &= 0xf;\t\t\tbreak;\t\tcase THUNDER_2BITDELTAS:\t\t\t\tif ((delta = ((n >> 4) & 3)) != DELTA2_SKIP)\t\t\t\tSETPIXEL(op, lastpixel + twobitdeltas[delta]);\t\t\tif ((delta = ((n >> 2) & 3)) != DELTA2_SKIP)\t\t\t\tSETPIXEL(op, lastpixel + twobitdeltas[delta]);\t\t\tif ((delta = (n & 3)) != DELTA2_SKIP)\t\t\t\tSETPIXEL(op, lastpixel + twobitdeltas[delta]);\t\t\tbreak;\t\tcase THUNDER_3BITDELTAS:\t\t\t\tif ((delta = ((n >> 3) & 7)) != DELTA3_SKIP)\t\t\t\tSETPIXEL(op, lastpixel + threebitdeltas[delta]);\t\t\tif ((delta = (n & 7)) != DELTA3_SKIP)\t\t\t\tSETPIXEL(op, lastpixel + threebitdeltas[delta]);\t\t\tbreak;\t\tcase THUNDER_RAW:\t\t\t\t\tSETPIXEL(op, n);\t\t\tbreak;\t\t}\t}\ttif->tif_rawcp = (tidata_t) bp;\ttif->tif_rawcc = cc;\tif (npixels != maxpixels) {\t\tTIFFError(tif->tif_name,\t\t    \"ThunderDecode: %s data at scanline %ld (%lu != %lu)\",\t\t    npixels < maxpixels ? \"Not enough\" : \"Too much\",\t\t    (long) tif->tif_row, (long) npixels, (long) maxpixels);\t\treturn (0);\t}\treturn (1);}",
        "label": 1,
        "cve": "cve-2004-0803_2"
    },
    {
        "code": "static intFax3Decode2D(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s){\tDECLARE_STATE_2D(tif, sp, \"Fax3Decode2D\");        int line = 0;\tint is1D;\t\t\t\t(void) s;\tCACHE_STATE(tif, sp);\twhile ((long)occ > 0) {\t\ta0 = 0;\t\tRunLength = 0;\t\tpa = thisrun = sp->curruns;#ifdef FAX3_DEBUG\t\tprintf(\"\\nBitAcc=%08X, BitsAvail = %d EOLcnt = %d\",\t\t    BitAcc, BitsAvail, EOLcnt);#endif\t\tSYNC_EOL(EOF2D);\t\tNeedBits8(1, EOF2D);\t\tis1D = GetBits(1);\t\t\tClrBits(1);#ifdef FAX3_DEBUG\t\tprintf(\" %s\\n-------------------- %d\\n\",\t\t    is1D ? \"1D\" : \"2D\", tif->tif_row);\t\tfflush(stdout);#endif\t\tpb = sp->refruns;\t\tb1 = *pb++;\t\tif (is1D)\t\t\tEXPAND1D(EOF2Da);\t\telse\t\t\tEXPAND2D(EOF2Da);\t\t(*sp->fill)(buf, thisrun, pa, lastx);\t\tSETVALUE(0);\t\t\t\tSWAP(uint32*, sp->curruns, sp->refruns);\t\tbuf += sp->b.rowbytes;\t\tocc -= sp->b.rowbytes;                line++;\t\tcontinue;\tEOF2D:\t\t\t\t\t\tCLEANUP_RUNS();\tEOF2Da:\t\t\t\t\t\t(*sp->fill)(buf, thisrun, pa, lastx);\t\tUNCACHE_STATE(tif, sp);\t\treturn (-1);\t}\tUNCACHE_STATE(tif, sp);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidt2p_enable(TIFF *tif){\tT2P *t2p = (T2P*) TIFFClientdata(tif);\tt2p->outputdisable = 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int tiff2pdf_match_paper_size(float* width, float* length, char* papersize){\tsize_t i, len;\tconst char* sizes[]={\t\t\"LETTER\", \"A4\", \"LEGAL\",\t\t\"EXECUTIVE\", \"LETTER\", \"LEGAL\", \"LEDGER\", \"TABLOID\", \t\t\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"J\", \"K\", \t\t\"A10\", \"A9\", \"A8\", \"A7\", \"A6\", \"A5\", \"A4\", \"A3\", \"A2\", \"A1\", \"A0\", \t\t\"2A0\", \"4A0\", \"2A\", \"4A\", \t\t\"B10\", \"B9\", \"B8\", \"B7\", \"B6\", \"B5\", \"B4\", \"B3\", \"B2\", \"B1\", \"B0\", \t\t\"JISB10\", \"JISB9\", \"JISB8\", \"JISB7\", \"JISB6\", \"JISB5\", \"JISB4\", \t\t\"JISB3\", \"JISB2\", \"JISB1\", \"JISB0\", \t\t\"C10\", \"C9\", \"C8\", \"C7\", \"C6\", \"C5\", \"C4\", \"C3\", \"C2\", \"C1\", \"C0\", \t\t\"RA2\", \"RA1\", \"RA0\", \"SRA4\", \"SRA3\", \"SRA2\", \"SRA1\", \"SRA0\", \t\t\"A3EXTRA\", \"A4EXTRA\", \t\t\"STATEMENT\", \"FOLIO\", \"QUARTO\", \t\tNULL\t} ;\tconst int widths[]={\t\t612, 595, 612,\t\t522, 612,612,792,792,\t\t612,792,1224,1584,2448,2016,792,2016,2448,2880,\t\t74,105,147,210,298,420,595,842,1191,1684,2384,3370,4768,3370,4768,\t\t88,125,176,249,354,499,709,1001,1417,2004,2835,\t\t91,128,181,258,363,516,729,1032,1460,2064,2920,\t\t79,113,162,230,323,459,649,918,1298,1298,2599,\t\t1219,1729,2438,638,907,1276,1814,2551,\t\t914,667,\t\t396, 612, 609, \t\t0\t};\tconst int lengths[]={\t\t792,842,1008,\t\t756,792,1008,1224,1224,\t\t792,1224,1584,2448,3168,2880,6480,10296,12672,10296,\t\t105,147,210,298,420,595,842,1191,1684,2384,3370,4768,6741,4768,6741,\t\t125,176,249,354,499,709,1001,1417,2004,2835,4008,\t\t128,181,258,363,516,729,1032,1460,2064,2920,4127,\t\t113,162,230,323,459,649,918,1298,1837,1837,3677,\t\t1729,2438,3458,907,1276,1814,2551,3628,\t\t1262,914,\t\t612, 936, 780, \t\t0\t};\tlen=strlen(papersize);\tfor(i=0;i<len;i++){\t\tpapersize[i]=toupper((int) papersize[i]);\t}\tfor(i=0;sizes[i]!=NULL; i++){\t\tif (strcmp( (const char*)papersize, sizes[i])==0){\t\t\t*width=(float)widths[i];\t\t\t*length=(float)lengths[i];\t\t\treturn(1);\t\t}\t}\treturn(0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char* argv[]){\tuint32\twidth = 0, length = 0, linebytes, bufsize;\tuint32\tnbands = 1;\t\t    \toff_t\thdr_size = 0;\t\t    \tTIFFDataType dtype = TIFF_BYTE;\tint16\tdepth = 1;\t\t    \tint\tswab = 0;\t\t    \tInterleavingType interleaving = 0;  \tuint32  rowsperstrip = (uint32) -1;\tuint16\tphotometric = PHOTOMETRIC_MINISBLACK;\tuint16\tconfig = PLANARCONFIG_CONTIG;\tuint16\tfillorder = FILLORDER_LSB2MSB;\tint\tfd;\tchar\t*outfilename = NULL;\tTIFF\t*out;\tuint32 row, col, band;\tint\tc;\tunsigned char *buf = NULL, *buf1 = NULL;\textern int optind;\textern char* optarg;\twhile ((c = getopt(argc, argv, \"c:r:H:w:l:b:d:LMp:si:o:h\")) != -1) {\t\tswitch (c) {\t\tcase 'c':\t\t\t\t\tif (!processCompressOptions(optarg))\t\t\t\tusage();\t\t\tbreak;\t\tcase 'r':\t\t\t\t\trowsperstrip = atoi(optarg);\t\t\tbreak;\t\tcase 'H':\t\t\t\t\thdr_size = atoi(optarg);\t\t\tbreak;\t\tcase 'w':\t\t\t\t\twidth = atoi(optarg);\t\t\tbreak;\t\tcase 'l':\t\t\t\t\tlength = atoi(optarg);\t\t\tbreak;\t\tcase 'b':\t\t\t\t\tnbands = atoi(optarg);\t\t\tbreak;\t\tcase 'd':\t\t\t\t\tif (strncmp(optarg, \"byte\", 4) == 0)\t\t\t\tdtype = TIFF_BYTE;\t\t\telse if (strncmp(optarg, \"short\", 5) == 0)\t\t\t\tdtype = TIFF_SHORT;\t\t\telse if  (strncmp(optarg, \"long\", 4) == 0)\t\t\t\tdtype = TIFF_LONG;\t\t\telse if  (strncmp(optarg, \"sbyte\", 5) == 0)\t\t\t\tdtype = TIFF_SBYTE;\t\t\telse if  (strncmp(optarg, \"sshort\", 6) == 0)\t\t\t\tdtype = TIFF_SSHORT;\t\t\telse if  (strncmp(optarg, \"slong\", 5) == 0)\t\t\t\tdtype = TIFF_SLONG;\t\t\telse if  (strncmp(optarg, \"float\", 5) == 0)\t\t\t\tdtype = TIFF_FLOAT;\t\t\telse if  (strncmp(optarg, \"double\", 6) == 0)\t\t\t\tdtype = TIFF_DOUBLE;\t\t\telse\t\t\t\tdtype = TIFF_BYTE;\t\t\tdepth = TIFFDataWidth(dtype);\t\t\tbreak;\t\tcase 'L':\t\t\t\t\tfillorder = FILLORDER_LSB2MSB;\t\t\tbreak;\t\tcase 'M':\t\t\t\t\tfillorder = FILLORDER_MSB2LSB;\t\t\tbreak;\t\tcase 'p':\t\t\t\t\tif (strncmp(optarg, \"miniswhite\", 10) == 0)\t\t\t\tphotometric = PHOTOMETRIC_MINISWHITE;\t\t\telse if (strncmp(optarg, \"minisblack\", 10) == 0)\t\t\t\tphotometric = PHOTOMETRIC_MINISBLACK;\t\t\telse if (strncmp(optarg, \"rgb\", 3) == 0)\t\t\t\tphotometric = PHOTOMETRIC_RGB;\t\t\telse if (strncmp(optarg, \"cmyk\", 4) == 0)\t\t\t\tphotometric = PHOTOMETRIC_SEPARATED;\t\t\telse if (strncmp(optarg, \"ycbcr\", 5) == 0)\t\t\t\tphotometric = PHOTOMETRIC_YCBCR;\t\t\telse if (strncmp(optarg, \"cielab\", 6) == 0)\t\t\t\tphotometric = PHOTOMETRIC_CIELAB;\t\t\telse if (strncmp(optarg, \"icclab\", 6) == 0)\t\t\t\tphotometric = PHOTOMETRIC_ICCLAB;\t\t\telse if (strncmp(optarg, \"itulab\", 6) == 0)\t\t\t\tphotometric = PHOTOMETRIC_ITULAB;\t\t\telse\t\t\t\tphotometric = PHOTOMETRIC_MINISBLACK;\t\t\tbreak;\t\tcase 's':\t\t\t\t\tswab = 1;\t\t\tbreak;\t\tcase 'i':\t\t\t\t\tif (strncmp(optarg, \"pixel\", 4) == 0)\t\t\t\tinterleaving = PIXEL;\t\t\telse if  (strncmp(optarg, \"band\", 6) == 0)\t\t\t\tinterleaving = BAND;\t\t\telse\t\t\t\tinterleaving = 0;\t\t\tbreak;\t\tcase 'o':\t\t\toutfilename = optarg;\t\t\tbreak;\t\tcase 'h':\t\t\tusage();\t\tdefault:\t\t\tbreak;\t\t}        }        if (argc - optind < 2)\t\tusage();        fd = open(argv[optind], O_RDONLY|O_BINARY, 0);\tif (fd < 0) {\t\tfprintf(stderr, \"%s: %s: Cannot open input file.\\n\",\t\t\targv[0], argv[optind]);\t\treturn (-1);\t}\tif (guessSize(fd, dtype, hdr_size, nbands, swab, &width, &length) < 0)\t\treturn 1;\tif (outfilename == NULL)\t\toutfilename = argv[optind+1];\tout = TIFFOpen(outfilename, \"w\");\tif (out == NULL) {\t\tfprintf(stderr, \"%s: %s: Cannot open file for output.\\n\",\t\t\targv[0], outfilename);\t\treturn (-1);\t}\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, length);\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, nbands);\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, depth * 8);\tTIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\tswitch (dtype) {\tcase TIFF_BYTE:\tcase TIFF_SHORT:\tcase TIFF_LONG:\t\tTIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\t\tbreak;\tcase TIFF_SBYTE:\tcase TIFF_SSHORT:\tcase TIFF_SLONG:\t\tTIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\t\tbreak;\tcase TIFF_FLOAT:\tcase TIFF_DOUBLE:\t\tTIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\t\tbreak;\tdefault:\t\tTIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_VOID);\t\tbreak;\t}\tif (compression == (uint16) -1)\t\tcompression = COMPRESSION_PACKBITS;\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\tswitch (compression) {\tcase COMPRESSION_JPEG:\t\tif (photometric == PHOTOMETRIC_RGB\t\t    && jpegcolormode == JPEGCOLORMODE_RGB)\t\t\tphotometric = PHOTOMETRIC_YCBCR;\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\t\tbreak;\tcase COMPRESSION_LZW:\tcase COMPRESSION_DEFLATE:\t\tif (predictor != 0)\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\t\tbreak;\t}\tswitch(interleaving) {\tcase BAND:\t\t\t\t\t\tlinebytes = width * depth;\t\tbuf = (unsigned char *)_TIFFmalloc(linebytes);\t\tbreak;\tcase PIXEL:\t\t\t\t\tdefault:\t\tlinebytes = width * nbands * depth;\t\tbreak;\t}\tbufsize = width * nbands * depth;\tbuf1 = (unsigned char *)_TIFFmalloc(bufsize);\trowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\tif (rowsperstrip > length) {\t\trowsperstrip = length;\t}\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip );\tlseek(fd, hdr_size, SEEK_SET);\t\t\tfor (row = 0; row < length; row++) {\t\tswitch(interleaving) {\t\tcase BAND:\t\t\t\t\t\tfor (band = 0; band < nbands; band++) {\t\t\t\tlseek(fd,\t\t\t\t      hdr_size + (length*band+row)*linebytes,\t\t\t\t      SEEK_SET);\t\t\t\tif (read(fd, buf, linebytes) < 0) {\t\t\t\t\tfprintf(stderr,\t\t\t\t\t\"%s: %s: scanline %lu: Read error.\\n\",\t\t\t\t\targv[0], argv[optind],\t\t\t\t\t(unsigned long) row);\t\t\t\tbreak;\t\t\t\t}\t\t\t\tif (swab)\t\t\t\t\t\tswapBytesInScanline(buf, width, dtype);\t\t\t\tfor (col = 0; col < width; col++)\t\t\t\t\tmemcpy(buf1 + (col*nbands+band)*depth,\t\t\t\t\t       buf + col * depth, depth);\t\t\t}\t\t\tbreak;\t\tcase PIXEL:\t\t\t\t\tdefault:\t\t\tif (read(fd, buf1, bufsize) < 0) {\t\t\t\tfprintf(stderr,\t\t\t\t\t\"%s: %s: scanline %lu: Read error.\\n\",\t\t\t\t\targv[0], argv[optind],\t\t\t\t\t(unsigned long) row);\t\t\t\tbreak;\t\t\t}\t\t\tif (swab)\t\t\t\t\t\tswapBytesInScanline(buf1, width, dtype);\t\t\tbreak;\t\t}\t\tif (TIFFWriteScanline(out, buf1, row, 0) < 0) {\t\t\tfprintf(stderr,\t\"%s: %s: scanline %lu: Write error.\\n\",\t\t\t\targv[0], outfilename, (unsigned long) row);\t\t\tbreak;\t\t}\t}\tif (buf)\t\t_TIFFfree(buf);\tif (buf1)\t\t_TIFFfree(buf1);\tTIFFClose(out);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intCheckFloatTag(TIFF* tif1, TIFF* tif2, int tag, char* name){\tfloat v1, v2;\tCHECK(v1 == v2, \"%s: %g %g\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*TIFFOpen(const char* name, const char* mode){\tstatic const char module[] = \"TIFFOpen\";\tint m, fd;\tOFSTRUCT of;\tint mm = 0;\tm = _TIFFgetMode(mode, module);\tif (m == -1)\t\treturn ((TIFF*)0);\tif (m & O_CREAT) {\t\tif ((m & O_TRUNC) || OpenFile(name, &of, OF_EXIST) != HFILE_ERROR)\t\t\tmm |= OF_CREATE;\t}\tif (m & O_WRONLY)\t\tmm |= OF_WRITE;\tif (m & O_RDWR)\t\tmm |= OF_READWRITE;\tfd = OpenFile(name, &of, mm);\tif (fd < 0) {\t\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\t\treturn ((TIFF*)0);\t}\treturn (TIFFFdOpen(fd, name, mode));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intwrite_strips(TIFF *tif, const tdata_t array, const tsize_t size){\ttstrip_t\tstrip, nstrips;\ttsize_t\t\tstripsize, offset;\tstripsize = TIFFStripSize(tif);\tif (!stripsize) {\t\tfprintf (stderr, \"Wrong size of strip.\\n\");\t\treturn -1;\t}\tnstrips = TIFFNumberOfStrips(tif);\tfor (offset = 0, strip = 0;\t     offset < size && strip < nstrips;\t     offset+=stripsize, strip++) {\t\t\t\ttsize_t\tbufsize = size - offset;\t\tif (bufsize > stripsize)\t\t\tbufsize = stripsize;\t\tif (TIFFWriteEncodedStrip(tif, strip, (char *)array + offset,\t\t\t\t\t  bufsize) != bufsize) {\t\t\tfprintf (stderr, \"Can't write strip %lu.\\n\",\t\t\t\t (unsigned long)strip);\t\t\treturn -1;\t\t}        }\treturn 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPixarLogFixupTags(TIFF* tif){\t(void) tif;\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intprocessCompressOptions(char* opt){\tif (streq(opt, \"none\"))\t\tcompression = COMPRESSION_NONE;\telse if (streq(opt, \"packbits\"))\t\tcompression = COMPRESSION_PACKBITS;\telse if (strneq(opt, \"lzw\", 3)) {\t\tchar* cp = strchr(opt, ':');\t\tif (cp)\t\t\tpredictor = atoi(cp+1);\t\tcompression = COMPRESSION_LZW;\t} else if (strneq(opt, \"zip\", 3)) {\t\tchar* cp = strchr(opt, ':');\t\tif (cp)\t\t\tpredictor = atoi(cp+1);\t\tcompression = COMPRESSION_DEFLATE;\t} else\t\treturn (0);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFSwabArrayOfShort(register uint16* wp, tmsize_t n){\tregister unsigned char* cp;\tregister unsigned char t;\tassert(sizeof(uint16)==2);\t\twhile (n-- > 0) {\t\tcp = (unsigned char*) wp;\t\tt = cp[1]; cp[1] = cp[0]; cp[0] = t;\t\twp++;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidappleWarningHandler(const char* module, const char* fmt, va_list ap){\tif (module != NULL)\t\tfprintf(stderr, \"%s: \", module);\tfprintf(stderr, \"Warning, \");\tvfprintf(stderr, fmt, ap);\tfprintf(stderr, \".\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchAnyArray(TIFF* tif, TIFFDirEntry* dir, double* v){\tint i;\tswitch (dir->tdir_type) {\tcase TIFF_BYTE:\tcase TIFF_SBYTE:\t\tif (!TIFFFetchByteArray(tif, dir, (uint16*) v))\t\t\treturn (0);\t\tif (dir->tdir_type == TIFF_BYTE) {\t\t\tuint16* vp = (uint16*) v;\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\t\t\t\tv[i] = vp[i];\t\t} else {\t\t\tint16* vp = (int16*) v;\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\t\t\t\tv[i] = vp[i];\t\t}\t\tbreak;\tcase TIFF_SHORT:\tcase TIFF_SSHORT:\t\tif (!TIFFFetchShortArray(tif, dir, (uint16*) v))\t\t\treturn (0);\t\tif (dir->tdir_type == TIFF_SHORT) {\t\t\tuint16* vp = (uint16*) v;\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\t\t\t\tv[i] = vp[i];\t\t} else {\t\t\tint16* vp = (int16*) v;\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\t\t\t\tv[i] = vp[i];\t\t}\t\tbreak;\tcase TIFF_LONG:\tcase TIFF_SLONG:\t\tif (!TIFFFetchLongArray(tif, dir, (uint32*) v))\t\t\treturn (0);\t\tif (dir->tdir_type == TIFF_LONG) {\t\t\tuint32* vp = (uint32*) v;\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\t\t\t\tv[i] = vp[i];\t\t} else {\t\t\tint32* vp = (int32*) v;\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\t\t\t\tv[i] = vp[i];\t\t}\t\tbreak;\tcase TIFF_RATIONAL:\tcase TIFF_SRATIONAL:\t\tif (!TIFFFetchRationalArray(tif, dir, (float*) v))\t\t\treturn (0);\t\t{ float* vp = (float*) v;\t\t  for (i = dir->tdir_count-1; i >= 0; i--)\t\t\tv[i] = vp[i];\t\t}\t\tbreak;\tcase TIFF_FLOAT:\t\tif (!TIFFFetchFloatArray(tif, dir, (float*) v))\t\t\treturn (0);\t\t{ float* vp = (float*) v;\t\t  for (i = dir->tdir_count-1; i >= 0; i--)\t\t\tv[i] = vp[i];\t\t}\t\tbreak;\tcase TIFF_DOUBLE:\t\treturn (TIFFFetchDoubleArray(tif, dir, (double*) v));\tdefault:\t\t\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t    \"Cannot read TIFF_ANY type %d for field \\\"%s\\\"\",\t\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\t\treturn (0);\t}\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "inline static int32find0span(unsigned char* bp, int32 bs, int32 be){\tint32 bits = be - bs;\tint32 n, span;\tbp += bs>>3;\t\tif (bits > 0 && (n = (bs & 7))) {\t\tspan = zeroruns[(*bp << n) & 0xff];\t\tif (span > 8-n)\t\t\t\t\tspan = 8-n;\t\tif (span > bits)\t\t\t\tspan = bits;\t\tif (n+span < 8)\t\t\t\t\treturn (span);\t\tbits -= span;\t\tbp++;\t} else\t\tspan = 0;\tif (bits >= (int32)(2 * 8 * sizeof(long))) {\t\tlong* lp;\t\t\t\twhile (!isAligned(bp, long)) {\t\t\tif (*bp != 0x00)\t\t\t\treturn (span + zeroruns[*bp]);\t\t\tspan += 8, bits -= 8;\t\t\tbp++;\t\t}\t\tlp = (long*) bp;\t\twhile ((bits >= (int32)(8 * sizeof(long))) && (0 == *lp)) {\t\t\tspan += 8*sizeof (long), bits -= 8*sizeof (long);\t\t\tlp++;\t\t}\t\tbp = (unsigned char*) lp;\t}\t\twhile (bits >= 8) {\t\tif (*bp != 0x00)\t\t\t\treturn (span + zeroruns[*bp]);\t\tspan += 8, bits -= 8;\t\tbp++;\t}\t\tif (bits > 0) {\t\tn = zeroruns[*bp];\t\tspan += (n > bits ? bits : n);\t}\treturn (span);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void t2p_free(T2P* t2p){\tint i = 0;\tif (t2p != NULL) {\t\tif(t2p->pdf_xrefoffsets != NULL){\t\t\t_TIFFfree( (tdata_t) t2p->pdf_xrefoffsets);\t\t}\t\tif(t2p->tiff_pages != NULL){\t\t\t_TIFFfree( (tdata_t) t2p->tiff_pages);\t\t}\t\tfor(i=0;i<t2p->tiff_pagecount;i++){\t\t\tif(t2p->tiff_tiles[i].tiles_tiles != NULL){\t\t\t\t_TIFFfree( (tdata_t) t2p->tiff_tiles[i].tiles_tiles);\t\t\t}\t\t}\t\tif(t2p->tiff_tiles != NULL){\t\t\t_TIFFfree( (tdata_t) t2p->tiff_tiles);\t\t}\t\tif(t2p->pdf_palette != NULL){\t\t\t_TIFFfree( (tdata_t) t2p->pdf_palette);\t\t}#ifdef OJPEG_SUPPORT\t\tif(t2p->pdf_ojpegdata != NULL){\t\t\t_TIFFfree( (tdata_t) t2p->pdf_ojpegdata);\t\t}#endif\t\t_TIFFfree( (tdata_t) t2p );\t}\treturn;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcpTags(TIFF* in, TIFF* out){    struct cpTag *p;    for (p = tags; p < &tags[NTAGS]; p++)\tcpTag(in, out, p->tag, p->count, p->type);}",
        "label": 1,
        "cve": "CVE-2018-17101"
    },
    {
        "code": "intTIFFRGBAImageGet(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h){    if (img->get == NULL) {\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"No \\\"get\\\" routine setup\");\t\treturn (0);\t}\tif (img->put.any == NULL) {\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif),\t\t\"No \\\"put\\\" routine setupl; probably can not handle image format\");\t\treturn (0);    }    return (*img->get)(img, raster, w, h);}",
        "label": 1,
        "cve": "cve-2010-2483"
    },
    {
        "code": "static intgtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h){\tTIFF* tif = img->tif;\ttileSeparateRoutine put = img->put.separate;\tunsigned char *buf;\tunsigned char *p0, *p1, *p2, *pa;\tuint32 row, y, nrow, rowstoread;\tuint32 pos;\ttsize_t scanline;\tuint32 rowsperstrip, offset_row;\tuint32 imagewidth = img->width;\ttsize_t stripsize;\tint32 fromskew, toskew;\tint alpha = img->alpha;\tint ret = 1, flip;\tstripsize = TIFFStripSize(tif);\tp0 = buf = (unsigned char *)_TIFFmalloc((alpha?4:3)*stripsize);\tif (buf == 0) {\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for tile buffer\");\t\treturn (0);\t}\t_TIFFmemset(buf, 0, (alpha?4:3)*stripsize);\tp1 = p0 + stripsize;\tp2 = p1 + stripsize;\tpa = (alpha?(p2+stripsize):NULL);\tflip = setorientation(img);\tif (flip & FLIP_VERTICALLY) {\t\ty = h - 1;\t\ttoskew = -(int32)(w + w);\t}\telse {\t\ty = 0;\t\ttoskew = -(int32)(w - w);\t}\tTIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\tscanline = TIFFScanlineSize(tif);\tfromskew = (w < imagewidth ? imagewidth - w : 0);\tfor (row = 0; row < h; row += nrow)\t{\t\trowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\t\toffset_row = row + img->row_offset;\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 0),\t\t    p0, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) < 0\t\t    && img->stoponerr)\t\t{\t\t\tret = 0;\t\t\tbreak;\t\t}\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 1),\t\t    p1, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) < 0\t\t    && img->stoponerr)\t\t{\t\t\tret = 0;\t\t\tbreak;\t\t}\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 2),\t\t    p2, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) < 0\t\t    && img->stoponerr)\t\t{\t\t\tret = 0;\t\t\tbreak;\t\t}\t\tif (alpha)\t\t{\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 3),\t\t\t    pa, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) < 0\t\t\t    && img->stoponerr)\t\t\t{\t\t\t\tret = 0;\t\t\t\tbreak;\t\t\t}\t\t}\t\tpos = ((row + img->row_offset) % rowsperstrip) * scanline;\t\t(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, p0 + pos, p1 + pos,\t\t    p2 + pos, (alpha?(pa+pos):NULL));\t\ty += (flip & FLIP_VERTICALLY ? -(int32) nrow : (int32) nrow);\t}\tif (flip & FLIP_HORIZONTALLY) {\t\tuint32 line;\t\tfor (line = 0; line < h; line++) {\t\t\tuint32 *left = raster + (line * w);\t\t\tuint32 *right = left + w - 1;\t\t\twhile ( left < right ) {\t\t\t\tuint32 temp = *left;\t\t\t\t*left = *right;\t\t\t\t*right = temp;\t\t\t\tleft++, right--;\t\t\t}\t\t}\t}\t_TIFFfree(buf);\treturn (ret);}",
        "label": 1,
        "cve": "cve-2012-1173_2"
    },
    {
        "code": "static voidget_histogram(TIFF* in, Colorbox* box){\tregister unsigned char *inptr;\tregister int red, green, blue;\tregister uint32 j, i;\tunsigned char *inputline;\tinputline = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\tif (inputline == NULL) {\t\tfprintf(stderr, \"No space for scanline buffer\\n\");\t\texit(-1);\t}\tbox->rmin = box->gmin = box->bmin = 999;\tbox->rmax = box->gmax = box->bmax = -1;\tbox->total = imagewidth * imagelength;\t{ register uint32 *ptr = &histogram[0][0][0];\t  for (i = B_LEN*B_LEN*B_LEN; i-- > 0;)\t\t*ptr++ = 0;\t}\tfor (i = 0; i < imagelength; i++) {\t\tif (TIFFReadScanline(in, inputline, i, 0) <= 0)\t\t\tbreak;\t\tinptr = inputline;\t\tfor (j = imagewidth; j-- > 0;) {\t\t\tred = (*inptr++) & 0xff >> COLOR_SHIFT;\t\t\tgreen = (*inptr++) & 0xff >> COLOR_SHIFT;\t\t\tblue = (*inptr++) & 0xff >> COLOR_SHIFT;                        if ((red | green | blue) >= B_LEN) {                                fprintf(stderr,                                        \"Logic error. \"                                        \"Histogram array overflow!\\n\");                                exit(-6);                        }\t\t\tif (red < box->rmin)\t\t\t\tbox->rmin = red;\t\t        if (red > box->rmax)\t\t\t\tbox->rmax = red;\t\t        if (green < box->gmin)\t\t\t\tbox->gmin = green;\t\t        if (green > box->gmax)\t\t\t\tbox->gmax = green;\t\t        if (blue < box->bmin)\t\t\t\tbox->bmin = blue;\t\t        if (blue > box->bmax)\t\t\t\tbox->bmax = blue;\t\t        histogram[red][green][blue]++;\t\t}\t}\t_TIFFfree(inputline);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int t2p_cmp_t2p_page(const void* e1, const void* e2){\tint d;\td = (int32)(((T2P_PAGE*)e1)->page_number) - (int32)(((T2P_PAGE*)e2)->page_number);\tif(d == 0){\t\td = (int32)(((T2P_PAGE*)e1)->page_directory) - (int32)(((T2P_PAGE*)e2)->page_directory);\t}\treturn d;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFmemset(tdata_t p, int v, tsize_t c){\tmemset(p, v, (size_t) c);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int combineSeparateTileSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,                                 uint32 cols, uint32 rows, uint32 imagewidth,                                 uint32 tw, uint16 spp, uint16 bps,                                 FILE *dumpfile, int format, int level)  {  int i, bytes_per_sample;  uint32 row, col, col_offset, src_rowsize, dst_rowsize, src_offset;  unsigned char *src;  unsigned char *dst;  tsample_t s;  src = srcbuffs[0];  dst = out;  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"combineSeparateTileSamplesBytes\",\"Invalid buffer address\");    return (1);    }  bytes_per_sample = (bps + 7) / 8;   src_rowsize = ((bps * tw) + 7) / 8;  dst_rowsize = imagewidth * bytes_per_sample * spp;  for (row = 0; row < rows; row++)    {    if ((dumpfile != NULL) && (level == 2))      {      for (s = 0; s < spp; s++)        {        dump_info (dumpfile, format, \"combineSeparateTileSamplesBytes\",\"Input data, Sample %d\", s);        dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));        }      }    dst = out + (row * dst_rowsize);    src_offset = row * src_rowsize;#ifdef DEVELMODE    TIFFError(\"\",\"Tile row %4d, Src offset %6d   Dst offset %6d\",               row, src_offset, dst - out);#endif    for (col = 0; col < cols; col++)      {      col_offset = src_offset + (col * (bps / 8));       for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)        {        src = srcbuffs[s] + col_offset;         for (i = 0; i < bytes_per_sample; i++)          *(dst + i) = *(src + i);        dst += bytes_per_sample;        }         }    if ((dumpfile != NULL) && (level == 2))      {      dump_info (dumpfile, format, \"combineSeparateTileSamplesBytes\",\"Output data, combined samples\");      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));      }    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFFImageIterEnd(TIFFImageIter* img){    }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPixarLogPostEncode(TIFF* tif){\tstatic const char module[] = \"PixarLogPostEncode\";\tPixarLogState *sp = EncoderState(tif);\tint state;\tsp->stream.avail_in = 0;\tdo {\t\tstate = deflate(&sp->stream, Z_FINISH);\t\tswitch (state) {\t\tcase Z_STREAM_END:\t\tcase Z_OK:\t\t    if ((tmsize_t)sp->stream.avail_out != tif->tif_rawdatasize) {\t\t\t    tif->tif_rawcc =\t\t\t\ttif->tif_rawdatasize - sp->stream.avail_out;\t\t\t    TIFFFlushData1(tif);\t\t\t    sp->stream.next_out = tif->tif_rawdata;\t\t\t    sp->stream.avail_out = (uInt) tif->tif_rawdatasize;  \t\t    }\t\t    break;\t\tdefault:\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"ZLib error: %s\",\t\t\tsp->stream.msg ? sp->stream.msg : \"(null)\");\t\t    return (0);\t\t}\t} while (state != Z_STREAM_END);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidvmsWarningHandler(const char* module, const char* fmt, va_list ap){\tif (module != NULL)\t\tfprintf(stderr, \"%s: \", module);\tfprintf(stderr, \"Warning, \");\tvfprintf(stderr, fmt, ap);\tfprintf(stderr, \".\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void _XTIFFLocalDefaultDirectory(TIFF *tif){\txtiff *xt = XTIFFDIR(tif);\tXTIFFDirectory* xd = &xt->xtif_dir;\t\t_TIFFMergeFieldInfo(tif, xtiffFieldInfo, N(xtiffFieldInfo));\t\t_XTIFFFreeDirectory(xt);\t\t_TIFFmemset(xt,0,sizeof(xtiff));\t\tPARENT(xt,vsetfield) =  TIFFMEMBER(tif,vsetfield);\tTIFFMEMBER(tif,vsetfield) = _XTIFFVSetField;\tPARENT(xt,vgetfield) =  TIFFMEMBER(tif,vgetfield);\tTIFFMEMBER(tif,vgetfield) = _XTIFFVGetField;\t\txd->xd_example_single = 234;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*XTIFFOpen(const char* name, const char* mode){\t\t_XTIFFInitialize();\t\t\treturn TIFFOpen(name, mode);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char** argv){    int R, G, B;    if (argc > 1) {\trefBlackWhite[0] = 16;\trefBlackWhite[1] = 235;\trefBlackWhite[2] = 128;\trefBlackWhite[3] = 240;\trefBlackWhite[4] = 128;\trefBlackWhite[5] = 240;    }    D3 = 2 - 2*LumaRed;    D4 = 2 - 2*LumaBlue;    D1 = 1. / D3;    D2 = 1. / D4;    D5 = D3*LumaRed / LumaGreen;    D6 = D4*LumaBlue / LumaGreen;    setupLumaTables();    for (R = 0; R < 256; R++) {\tfor (G = 0; G < 256; G++)\t    for (B = 0; B < 256; B++)\t\tcheck(R, G, B);\tprintf(\"[%3u] c %u/%u b %u/%u (R %u/%d/%u G %u/%d/%u B %u/%d/%u)\\n\"\t    , R\t    , eCodes - preveCodes, eCodes\t    , eBits - preveBits, eBits\t    , abs(AbseRtotal - preveRtotal), eRtotal , AbseRtotal\t    , abs(AbseGtotal - preveGtotal), eGtotal , AbseGtotal\t    , abs(AbseBtotal - preveBtotal), eBtotal , AbseBtotal\t);\tpreveRtotal = AbseRtotal;\tpreveGtotal = AbseGtotal;\tpreveBtotal = AbseBtotal;\tpreveCodes = eCodes;\tpreveBits = eBits;    }    printf(\"%u total codes\\n\", 256*256*256);    printf(\"total error: %u codes %u bits (R %d/%u G %d/%u B %d/%u)\\n\"\t, eCodes\t, eBits\t, eRtotal , AbseRtotal\t, eGtotal , AbseGtotal\t, eBtotal , AbseBtotal    );    return (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tdata_t_TIFFmalloc(tsize_t s){        if (s == 0)                return ((void *) NULL);\treturn (malloc((size_t) s));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidShowTile(uint32 row, uint32 col, tsample_t sample,    unsigned char* pp, uint32 nrow, tsize_t rowsize){\tuint32 cc;\tprintf(\"Tile (%lu,%lu\", (unsigned long) row, (unsigned long) col);\tif (sample != (tsample_t) -1)\t\tprintf(\",%u\", sample);\tprintf(\"):\\n\");\twhile (nrow-- > 0) {\t  for (cc = 0; cc < (uint32) rowsize; cc++) {\t\t\tprintf(\" %02x\", *pp++);\t\t\tif (((cc+1) % 24) == 0)\t\t\t\tputchar('\\n');\t\t}\t\tputchar('\\n');\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int_TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c){\treturn (memcmp(p1, p2, (size_t) c));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void                Usage();int main(int argc, char **argv){    int             bits_per_pixel = 8, cmsize, i, j, k,                    gray_index, chunk_size = 32, nchunks = 16;    unsigned char * scan_line;    uint16 *        gray;    float           refblackwhite[2*1];    TIFF *          tif;    programName = argv[0];    if (argc != 4)        Usage();    if (!strcmp(argv[1], \"-depth\"))         bits_per_pixel = atoi(argv[2]);    else         Usage();    switch (bits_per_pixel) {        case 8:            nchunks = 16;            chunk_size = 32;            break;        case 4:            nchunks = 4;            chunk_size = 128;            break;        case 2:            nchunks = 2;            chunk_size = 256;            break;        default:            Usage();    }    cmsize = nchunks * nchunks;    gray = (uint16 *) malloc(cmsize * sizeof(uint16));    gray[0] = 3000;    for (i = 1; i < cmsize; i++)        gray[i] = (uint16) (-log10((double) i / (cmsize - 1)) * 1000);    refblackwhite[0] = 0.0;    refblackwhite[1] = (float)((1L<<bits_per_pixel) - 1);    if ((tif = TIFFOpen(argv[3], \"w\")) == NULL) {        fprintf(stderr, \"can't open %s as a TIFF file\\n\", argv[3]);\t\tfree(gray);        return 0;    }    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, WIDTH);    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, HEIGHT);    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bits_per_pixel);    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);    TIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE, refblackwhite);    TIFFSetField(tif, TIFFTAG_TRANSFERFUNCTION, gray);    TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_NONE);    scan_line = (unsigned char *) malloc(WIDTH / (8 / bits_per_pixel));    for (i = 0; i < HEIGHT; i++) {        for (j = 0, k = 0; j < WIDTH;) {            gray_index = (j / chunk_size) + ((i / chunk_size) * nchunks);            switch (bits_per_pixel) {            case 8:                scan_line[k++] = gray_index;                j++;                break;            case 4:                scan_line[k++] = (gray_index << 4) + gray_index;                j += 2;                break;            case 2:                scan_line[k++] = (gray_index << 6) + (gray_index << 4)                    + (gray_index << 2) + gray_index;                j += 4;                break;            }        }        TIFFWriteScanline(tif, scan_line, i, 0);    }    free(scan_line);    TIFFClose(tif);    return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteFloatArray(TIFF* tif,    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, float* v){\tdir->tdir_tag = tag;\tdir->tdir_type = (short) type;\tdir->tdir_count = n;\tTIFFCvtNativeToIEEEFloat(tif, n, v);\tif (n == 1) {\t\tdir->tdir_offset = *(uint32*) &v[0];\t\treturn (1);\t} else\t\treturn (TIFFWriteData(tif, dir, (char*) v));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tsize_t_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size){\treturn (read((int) fd, buf, size));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int  writeSingleSection(TIFF *in, TIFF *out, struct image_data *image,                   struct dump_opts *dump, uint32 width, uint32 length,                   double hres, double vres,                   unsigned char *sect_buff)  {  uint16 bps, spp;  uint16 input_compression, input_photometric;  uint16 input_planar;  struct cpTag* p;    input_compression = image->compression;  input_photometric = image->photometric;  spp = image->spp;  bps = image->bps;  TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);  TIFFSetField(out, TIFFTAG_IMAGELENGTH, length);  TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bps);  TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp);#ifdef DEBUG2  TIFFError(\"writeSingleSection\", \"Input compression: %s\",\t    (input_compression == COMPRESSION_OJPEG) ? \"Old Jpeg\" :\t    ((input_compression == COMPRESSION_JPEG) ?  \"New Jpeg\" : \"Non Jpeg\"));#endif    if (compression != (uint16)-1)    TIFFSetField(out, TIFFTAG_COMPRESSION, compression);  else    {     if (input_compression == COMPRESSION_OJPEG)      {      compression = COMPRESSION_JPEG;      jpegcolormode = JPEGCOLORMODE_RAW;      TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);      }    else       CopyField(TIFFTAG_COMPRESSION, compression);    }  if (compression == COMPRESSION_JPEG)    {    if ((input_photometric == PHOTOMETRIC_PALETTE) ||          (input_photometric == PHOTOMETRIC_MASK))             {      TIFFError (\"writeSingleSection\",                 \"JPEG compression cannot be used with %s image data\",\t\t (input_photometric == PHOTOMETRIC_PALETTE) ?                 \"palette\" : \"mask\");      return (-1);      }    if ((input_photometric == PHOTOMETRIC_RGB) &&\t(jpegcolormode == JPEGCOLORMODE_RGB))      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);    else\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);    }  else    {    if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24)      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?\t\t\tPHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);    else      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, image->photometric);    }#ifdef DEBUG2  TIFFError(\"writeSingleSection\", \"Input photometric: %s\",\t    (input_photometric == PHOTOMETRIC_RGB) ? \"RGB\" :\t    ((input_photometric == PHOTOMETRIC_YCBCR) ?  \"YCbCr\" : \"Not RGB or YCbCr\"));#endif  if (((input_photometric == PHOTOMETRIC_LOGL) ||       (input_photometric ==  PHOTOMETRIC_LOGLUV)) &&      ((compression != COMPRESSION_SGILOG) &&        (compression != COMPRESSION_SGILOG24)))    {    TIFFError(\"writeSingleSection\",              \"LogL and LogLuv source data require SGI_LOG or SGI_LOG24 compression\");    return (-1);    }  if (fillorder != 0)    TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);  else    CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);    TIFFSetField(out, TIFFTAG_ORIENTATION, image->orientation);    if (outtiled == -1)    outtiled = TIFFIsTiled(in);  if (outtiled) {        if (tilewidth == (uint32) 0)      TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);    if (tilelength == (uint32) 0)      TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);    if (tilewidth == 0 || tilelength == 0)      TIFFDefaultTileSize(out, &tilewidth, &tilelength);    TIFFDefaultTileSize(out, &tilewidth, &tilelength);    TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);    TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);    } else {       \tif (rowsperstrip == (uint32) 0)          {\t  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))\t    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);          if (compression != COMPRESSION_JPEG)            {  \t    if (rowsperstrip > length)\t      rowsperstrip = length;\t    }\t  }\telse           if (rowsperstrip == (uint32) -1)\t    rowsperstrip = length;\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\t}  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);  if (config != (uint16) -1)    TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);  else    CopyField(TIFFTAG_PLANARCONFIG, config);  if (spp <= 4)    CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);  CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);  switch (compression) {        case COMPRESSION_JPEG:         if (((bps % 8) == 0) || ((bps % 12) == 0))\t   {           TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\t   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);           }         else           {\t   TIFFError(\"writeSingleSection\",                     \"JPEG compression requires 8 or 12 bits per sample\");           return (-1);           }\t break;   case COMPRESSION_LZW:   case COMPRESSION_ADOBE_DEFLATE:   case COMPRESSION_DEFLATE:\tif (predictor != (uint16)-1)          TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\telse\t  CopyField(TIFFTAG_PREDICTOR, predictor);\tbreak;   case COMPRESSION_CCITTFAX3:   case COMPRESSION_CCITTFAX4:\tif (compression == COMPRESSION_CCITTFAX3) {          if (g3opts != (uint32) -1)\t    TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);\t  else\t    CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\t} else {\t    CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);        }        CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);        CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);        CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);        CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);        CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);        CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\tbreak;   }   { uint32 len32;     void** data;     if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))       TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);   }   { uint16 ninks;     const char* inknames;     if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {       TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);       if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {\t int inknameslen = strlen(inknames) + 1;\t const char* cp = inknames;\t while (ninks > 1) {\t   cp = strchr(cp, '\\0');\t   if (cp) {\t     cp++;\t     inknameslen += (strlen(cp) + 1);\t   }\t   ninks--;         }\t TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);       }     }   }   {   unsigned short pg0, pg1;   if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {     if (pageNum < 0) \tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);     else \tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);     }   }  for (p = tags; p < &tags[NTAGS]; p++)\t\tCopyTag(p->tag, p->count, p->type);    TIFFSetField(out, TIFFTAG_XRESOLUTION, (float)hres);  TIFFSetField(out, TIFFTAG_YRESOLUTION, (float)vres);    if (outtiled)    {    if (config == PLANARCONFIG_CONTIG)      writeBufferToContigTiles (out, sect_buff, length, width, spp, dump);    else      writeBufferToSeparateTiles (out, sect_buff, length, width, spp, dump);    }  else    {    if (config == PLANARCONFIG_CONTIG)      writeBufferToContigStrips (out, sect_buff, length);    else      writeBufferToSeparateStrips(out, sect_buff, length, width, spp, dump);    }  if (!TIFFWriteDirectory(out))    {    TIFFClose(out);    return (-1);    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteTransferFunction(TIFF* tif, TIFFDirEntry* dir){\tTIFFDirectory* td = &tif->tif_dir;\ttsize_t n = (1L<<td->td_bitspersample) * sizeof (uint16);\tuint16** tf = td->td_transferfunction;\tint ncols;\t\tswitch (td->td_samplesperpixel - td->td_extrasamples) {\tdefault:\tif (_TIFFmemcmp(tf[0], tf[2], n)) { ncols = 3; break; }\tcase 2:\t\tif (_TIFFmemcmp(tf[0], tf[1], n)) { ncols = 3; break; }\tcase 1: case 0:\tncols = 1;\t}\treturn (TIFFWriteShortTable(tif,\t    TIFFTAG_TRANSFERFUNCTION, dir, ncols, tf));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "DECLAREcpFunc(cpSeparateTiles2SeparateStrips){\treturn cpImage(in, out,\t    readSeparateTilesIntoBuffer,\t    writeBufferToSeparateStrips,\t    imagelength, imagewidth, spp);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFSwabFloat(float* fp){\tregister unsigned char* cp = (unsigned char*) fp;\tunsigned char t;\tassert(sizeof(float)==4);\tt = cp[3]; cp[3] = cp[0]; cp[0] = t;\tt = cp[2]; cp[2] = cp[1]; cp[1] = t;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteByteArray(TIFF* tif, TIFFDirEntry* dir, char* cp){\tif (dir->tdir_count > 4) {\t\tif (!TIFFWriteData(tif, dir, cp))\t\t\treturn (0);\t} else\t\t_TIFFmemcpy(&dir->tdir_offset, cp, dir->tdir_count);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intCheckShortPairedField(TIFF *tif, const ttag_t field, const uint16 *values){\tuint16 tmp[2] = { 123, 456 };\tif (!TIFFGetField(tif, field, tmp, tmp + 1)) {\t\tfprintf (stderr, \"Problem fetching tag %lu.\\n\",\t\t\t (unsigned long) field);\t\treturn -1;\t}\tif (tmp[0] != values[0] || tmp[1] != values[1]) {\t\tfprintf (stderr, \"Wrong SHORT PAIR fetched for tag %lu.\\n\",\t\t\t (unsigned long) field);\t\treturn -1;\t}\treturn 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFmemset(void* p, int v, tsize_t c){\tFillMemory(p, c, (BYTE)v);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteShortArray(TIFF* tif,    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, uint16* v){\tdir->tdir_tag = tag;\tdir->tdir_type = (short) type;\tdir->tdir_count = n;\tif (n <= 2) {\t\tif (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {\t\t\tdir->tdir_offset = (uint32) ((long) v[0] << 16);\t\t\tif (n == 2)\t\t\t\tdir->tdir_offset |= v[1] & 0xffff;\t\t} else {\t\t\tdir->tdir_offset = v[0] & 0xffff;\t\t\tif (n == 2)\t\t\t\tdir->tdir_offset |= (long) v[1] << 16;\t\t}\t\treturn (1);\t} else\t\treturn (TIFFWriteData(tif, dir, (char*) v));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidMissingRequired(TIFF* tif, const char* tagname){\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t    \"TIFF directory is missing required \\\"%s\\\" field\", tagname);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFfree(tdata_t p){\tfree(p);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidvmsErrorHandler(const char* module, const char* fmt, va_list ap){\tif (module != NULL)\t\tfprintf(stderr, \"%s: \", module);\tvfprintf(stderr, fmt, ap);\tfprintf(stderr, \".\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static toff_t_tiffSizeProc(thandle_t fd){\tlong size;\tif (GetEOF((short) fd, &size) != noErr) {\t\tTIFFErrorExt(fd, \"_tiffSizeProc\", \"%s: Cannot get file size\");\t\treturn (-1L);\t}\treturn ((toff_t) size);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidGetTIFFHeader(){    register int i;    if (!TIFFSetDirectory(tfFile, tfDirectory)) {        fprintf(stderr, \"xtiff: can't seek to directory %d in %s\\n\",            tfDirectory, fileName);        exit(0);    }    TIFFGetField(tfFile, TIFFTAG_IMAGEWIDTH, &tfImageWidth);    TIFFGetField(tfFile, TIFFTAG_IMAGELENGTH, &tfImageHeight);        TIFFGetFieldDefaulted(tfFile, TIFFTAG_BITSPERSAMPLE, &tfBitsPerSample);    TIFFGetFieldDefaulted(tfFile, TIFFTAG_SAMPLESPERPIXEL, &tfSamplesPerPixel);    TIFFGetFieldDefaulted(tfFile, TIFFTAG_PLANARCONFIG, &tfPlanarConfiguration);    TIFFGetFieldDefaulted(tfFile, TIFFTAG_GRAYRESPONSEUNIT, &tfGrayResponseUnit);    tfUnitMap = tfGrayResponseUnitMap[tfGrayResponseUnit];    colormapSize = 1 << tfBitsPerSample;    tfImageDepth = tfBitsPerSample * tfSamplesPerPixel;    dRed = (double *) malloc(colormapSize * sizeof(double));    dGreen = (double *) malloc(colormapSize * sizeof(double));    dBlue = (double *) malloc(colormapSize * sizeof(double));    MCHECK(dRed); MCHECK(dGreen); MCHECK(dBlue);        if (!TIFFGetField(tfFile, TIFFTAG_PHOTOMETRIC,            &tfPhotometricInterpretation)) {        if (tfSamplesPerPixel != 1)            tfPhotometricInterpretation = PHOTOMETRIC_RGB;        else if (tfBitsPerSample == 1)            tfPhotometricInterpretation = PHOTOMETRIC_MINISBLACK;        else if (TIFFGetField(tfFile, TIFFTAG_COLORMAP,                &redMap, &greenMap, &blueMap)) {            tfPhotometricInterpretation = PHOTOMETRIC_PALETTE;            redMap = greenMap = blueMap = NULL;        } else            tfPhotometricInterpretation = PHOTOMETRIC_MINISBLACK;    }        switch (tfPhotometricInterpretation) {    case PHOTOMETRIC_RGB:\tredMap = (uint16 *) malloc(colormapSize * sizeof(uint16));\tgreenMap = (uint16 *) malloc(colormapSize * sizeof(uint16));\tblueMap = (uint16 *) malloc(colormapSize * sizeof(uint16));\tMCHECK(redMap); MCHECK(greenMap); MCHECK(blueMap);\tfor (i = 0; i < colormapSize; i++)\t    dRed[i] = dGreen[i] = dBlue[i]\t\t= (double) SCALE(i, colormapSize - 1);        break;    case PHOTOMETRIC_PALETTE:        if (!TIFFGetField(tfFile, TIFFTAG_COLORMAP,                &redMap, &greenMap, &blueMap)) {            redMap = (uint16 *) malloc(colormapSize * sizeof(uint16));            greenMap = (uint16 *) malloc(colormapSize * sizeof(uint16));            blueMap = (uint16 *) malloc(colormapSize * sizeof(uint16));            MCHECK(redMap); MCHECK(greenMap); MCHECK(blueMap);            for (i = 0; i < colormapSize; i++)                dRed[i] = dGreen[i] = dBlue[i]                    = (double) SCALE(i, colormapSize - 1);        } else {            CheckAndCorrectColormap();            for (i = 0; i < colormapSize; i++) {                dRed[i] = (double) redMap[i];                dGreen[i] = (double) greenMap[i];                dBlue[i] = (double) blueMap[i];            }        }        break;    case PHOTOMETRIC_MINISWHITE:        redMap = (uint16 *) malloc(colormapSize * sizeof(uint16));        greenMap = (uint16 *) malloc(colormapSize * sizeof(uint16));        blueMap = (uint16 *) malloc(colormapSize * sizeof(uint16));        MCHECK(redMap); MCHECK(greenMap); MCHECK(blueMap);\tfor (i = 0; i < colormapSize; i++)\t    dRed[i] = dGreen[i] = dBlue[i] = (double)\t\t SCALE(colormapSize-1-i, colormapSize-1);        break;    case PHOTOMETRIC_MINISBLACK:        redMap = (uint16 *) malloc(colormapSize * sizeof(uint16));        greenMap = (uint16 *) malloc(colormapSize * sizeof(uint16));        blueMap = (uint16 *) malloc(colormapSize * sizeof(uint16));        MCHECK(redMap); MCHECK(greenMap); MCHECK(blueMap);\tfor (i = 0; i < colormapSize; i++)\t    dRed[i] = dGreen[i] = dBlue[i] = (double) SCALE(i, colormapSize-1);        break;    default:        fprintf(stderr,            \"xtiff: can't display photometric interpretation type %d\\n\",            tfPhotometricInterpretation);        exit(0);    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPredictorSetupEncode(TIFF* tif){\tTIFFPredictorState* sp = PredictorState(tif);\tTIFFDirectory* td = &tif->tif_dir;\tif (!(*sp->setupencode)(tif) || !PredictorSetup(tif))\t\treturn 0;\tif (sp->predictor == 2) {\t\tswitch (td->td_bitspersample) {\t\t\tcase 8:  sp->encodepfunc = horDiff8; break;\t\t\tcase 16: sp->encodepfunc = horDiff16; break;\t\t\tcase 32: sp->encodepfunc = horDiff32; break;\t\t}\t\t                if( tif->tif_encoderow != PredictorEncodeRow )                {                    sp->encoderow = tif->tif_encoderow;                    tif->tif_encoderow = PredictorEncodeRow;                    sp->encodestrip = tif->tif_encodestrip;                    tif->tif_encodestrip = PredictorEncodeTile;                    sp->encodetile = tif->tif_encodetile;                    tif->tif_encodetile = PredictorEncodeTile;                }                                if (tif->tif_flags & TIFF_SWAB) {                    if (sp->encodepfunc == horDiff16) {                            sp->encodepfunc = swabHorDiff16;                            tif->tif_postdecode = _TIFFNoPostDecode;                    } else if (sp->encodepfunc == horDiff32) {                            sp->encodepfunc = swabHorDiff32;                            tif->tif_postdecode = _TIFFNoPostDecode;                    }                }        }\telse if (sp->predictor == 3) {\t\tsp->encodepfunc = fpDiff;\t\t                if( tif->tif_encoderow != PredictorEncodeRow )                {                    sp->encoderow = tif->tif_encoderow;                    tif->tif_encoderow = PredictorEncodeRow;                    sp->encodestrip = tif->tif_encodestrip;                    tif->tif_encodestrip = PredictorEncodeTile;                    sp->encodetile = tif->tif_encodetile;                    tif->tif_encodetile = PredictorEncodeTile;                }\t}\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFErrorExt(thandle_t fd, const char* module, const char* fmt, ...){\tva_list ap;\tva_start(ap, fmt);\tif (_TIFFerrorHandler)\t\t(*_TIFFerrorHandler)(module, fmt, ap);\tif (_TIFFerrorHandlerExt)\t\t(*_TIFFerrorHandlerExt)(fd, module, fmt, ap);\tva_end(ap);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "WORD DIBNumColors(LPSTR lpDIB){   WORD wBitCount;        if (IS_WIN30_DIB(lpDIB))   {      DWORD dwClrUsed;      dwClrUsed = ((LPBITMAPINFOHEADER)lpDIB)->biClrUsed;      if (dwClrUsed)     return (WORD)dwClrUsed;   }      if (IS_WIN30_DIB(lpDIB))      wBitCount = ((LPBITMAPINFOHEADER)lpDIB)->biBitCount;   else      wBitCount = ((LPBITMAPCOREHEADER)lpDIB)->bcBitCount;      switch (wBitCount)      {   case 1:      return 2;   case 4:      return 16;   case 8:      return 256;   default:      return 0;      }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFReadSeparateTileData(TIFF* tif){\tunsigned char *buf;\ttsize_t rowsize = TIFFTileRowSize(tif);\tbuf = (unsigned char *)_TIFFmalloc(TIFFTileSize(tif));\tif (buf) {\t\tuint32 tw, th, w, h;\t\tuint32 row, col;\t\ttsample_t s, samplesperpixel;\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\t\tfor (row = 0; row < h; row += th) {\t\t\tfor (col = 0; col < w; col += tw) {\t\t\t\tfor (s = 0; s < samplesperpixel; s++) {\t\t\t\t\tif (TIFFReadTile(tif, buf, col, row, 0, s) < 0) {\t\t\t\t\t\tif (stoponerr)\t\t\t\t\t\t\tbreak;\t\t\t\t\t} else if (showdata)\t\t\t\t\t\tShowTile(row, col, s, buf, th, rowsize);\t\t\t\t}\t\t\t}\t\t}\t\t_TIFFfree(buf);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void t2p_read_tiff_init(T2P* t2p, TIFF* input){\ttdir_t directorycount=0;\ttdir_t i=0;\tuint16 pagen=0;\tuint16 paged=0;\tuint16 xuint16=0;\tdirectorycount=TIFFNumberOfDirectories(input);\tt2p->tiff_pages = (T2P_PAGE*) _TIFFmalloc(directorycount * sizeof(T2P_PAGE));\tif(t2p->tiff_pages==NULL){\t\tTIFFError(\t\t\tTIFF2PDF_MODULE, \t\t\t\"Can't allocate %u bytes of memory for tiff_pages array, %s\", \t\t\tdirectorycount * sizeof(T2P_PAGE), \t\t\tTIFFFileName(input));\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn;\t}\t_TIFFmemset( t2p->tiff_pages, 0x00, directorycount * sizeof(T2P_PAGE));\tt2p->tiff_tiles = (T2P_TILES*) _TIFFmalloc(directorycount * sizeof(T2P_TILES));\tif(t2p->tiff_tiles==NULL){\t\tTIFFError(\t\t\tTIFF2PDF_MODULE, \t\t\t\"Can't allocate %u bytes of memory for tiff_tiles array, %s\", \t\t\tdirectorycount * sizeof(T2P_TILES), \t\t\tTIFFFileName(input));\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn;\t}\t_TIFFmemset( t2p->tiff_tiles, 0x00, directorycount * sizeof(T2P_TILES));\tfor(i=0;i<directorycount;i++){\t\tuint32 subfiletype = 0;\t\t\t\tif(!TIFFSetDirectory(input, i)){\t\t\tTIFFError(\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\"Can't set directory %u of input file %s\", \t\t\t\ti,\t\t\t\tTIFFFileName(input));\t\t\treturn;\t\t}\t\tif(TIFFGetField(input, TIFFTAG_PAGENUMBER, &pagen, &paged)){\t\t\tif((pagen>paged) && (paged != 0)){\t\t\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_number = \t\t\t\t\tpaged;\t\t\t} else {\t\t\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_number = \t\t\t\t\tpagen;\t\t\t}\t\t\tgoto ispage2;\t\t}\t\tif(TIFFGetField(input, TIFFTAG_SUBFILETYPE, &subfiletype)){\t\t\tif ( ((subfiletype & FILETYPE_PAGE) != 0)                             || (subfiletype == 0)){\t\t\t\tgoto ispage;\t\t\t} else {\t\t\t\tgoto isnotpage;\t\t\t}\t\t}\t\tif(TIFFGetField(input, TIFFTAG_OSUBFILETYPE, &subfiletype)){\t\t\tif ((subfiletype == OFILETYPE_IMAGE) \t\t\t\t|| (subfiletype == OFILETYPE_PAGE)\t\t\t\t|| (subfiletype == 0) ){\t\t\t\tgoto ispage;\t\t\t} else {\t\t\t\tgoto isnotpage;\t\t\t}\t\t}\t\tispage:\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_number=t2p->tiff_pagecount;\t\tispage2:\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_directory=i;\t\tif(TIFFIsTiled(input)){\t\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_tilecount = \t\t\t\tTIFFNumberOfTiles(input);\t\t}\t\tt2p->tiff_pagecount++;\t\tisnotpage:\t\t(void)0;\t}\t\tqsort((void*) t2p->tiff_pages, t2p->tiff_pagecount,              sizeof(T2P_PAGE), t2p_cmp_t2p_page);\tfor(i=0;i<t2p->tiff_pagecount;i++){\t\tt2p->pdf_xrefcount += 5;\t\tTIFFSetDirectory(input, t2p->tiff_pages[i].page_directory );\t\tif((TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &xuint16)                    && (xuint16==PHOTOMETRIC_PALETTE))\t\t   || TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)) {\t\t\tt2p->tiff_pages[i].page_extra++;\t\t\tt2p->pdf_xrefcount++;\t\t}#ifdef ZIP_SUPPORT\t\tif (TIFFGetField(input, TIFFTAG_COMPRESSION, &xuint16)) {                        if( (xuint16== COMPRESSION_DEFLATE ||                             xuint16== COMPRESSION_ADOBE_DEFLATE) &&                             ((t2p->tiff_pages[i].page_tilecount != 0)                              || TIFFNumberOfStrips(input)==1) &&                            (t2p->pdf_nopassthrough==0)\t){                                if(t2p->pdf_minorversion<2){t2p->pdf_minorversion=2;}                        }                }#endif\t\tif (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,                                 &(t2p->tiff_transferfunction[0]),                                 &(t2p->tiff_transferfunction[1]),                                 &(t2p->tiff_transferfunction[2]))) {\t\t\tif(t2p->tiff_transferfunction[1] !=\t\t\t   t2p->tiff_transferfunction[0]) {\t\t\t\tt2p->tiff_transferfunctioncount = 3;\t\t\t\tt2p->tiff_pages[i].page_extra += 4;\t\t\t\tt2p->pdf_xrefcount += 4;\t\t\t} else {\t\t\t\tt2p->tiff_transferfunctioncount = 1;\t\t\t\tt2p->tiff_pages[i].page_extra += 2;\t\t\t\tt2p->pdf_xrefcount += 2;\t\t\t}\t\t\tif(t2p->pdf_minorversion < 2)\t\t\t\tt2p->pdf_minorversion = 2;                } else {\t\t\tt2p->tiff_transferfunctioncount=0;\t\t}\t\tif( TIFFGetField(\t\t\tinput, \t\t\tTIFFTAG_ICCPROFILE, \t\t\t&(t2p->tiff_iccprofilelength), \t\t\t&(t2p->tiff_iccprofile)) != 0){\t\t\tt2p->tiff_pages[i].page_extra++;\t\t\tt2p->pdf_xrefcount++;\t\t\tif(t2p->pdf_minorversion<3){t2p->pdf_minorversion=3;}\t\t}\t\tt2p->tiff_tiles[i].tiles_tilecount=\t\t\tt2p->tiff_pages[i].page_tilecount;\t\tif( (TIFFGetField(input, TIFFTAG_PLANARCONFIG, &xuint16) != 0)\t\t\t&& (xuint16 == PLANARCONFIG_SEPARATE ) ){\t\t\t\tTIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &xuint16);\t\t\t\tt2p->tiff_tiles[i].tiles_tilecount/= xuint16;\t\t}\t\tif( t2p->tiff_tiles[i].tiles_tilecount > 0){\t\t\tt2p->pdf_xrefcount += \t\t\t\t(t2p->tiff_tiles[i].tiles_tilecount -1)*2;\t\t\tTIFFGetField(input, \t\t\t\tTIFFTAG_TILEWIDTH, \t\t\t\t&( t2p->tiff_tiles[i].tiles_tilewidth) );\t\t\tTIFFGetField(input, \t\t\t\tTIFFTAG_TILELENGTH, \t\t\t\t&( t2p->tiff_tiles[i].tiles_tilelength) );\t\t\tt2p->tiff_tiles[i].tiles_tiles = \t\t\t(T2P_TILE*) _TIFFmalloc(\t\t\t\tt2p->tiff_tiles[i].tiles_tilecount \t\t\t\t* sizeof(T2P_TILE) );\t\t\tif( t2p->tiff_tiles[i].tiles_tiles == NULL){\t\t\t\tTIFFError(\t\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate %u bytes of memory for t2p_read_tiff_init, %s\", \t\t\t\t\tt2p->tiff_tiles[i].tiles_tilecount * sizeof(T2P_TILE), \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn;\t\t\t}\t\t}\t}\treturn;}",
        "label": 1,
        "cve": "cve-2012-3401"
    },
    {
        "code": "voidTIFFSwabArrayOfLong(register uint32* lp, tmsize_t n){\tregister unsigned char *cp;\tregister unsigned char t;\tassert(sizeof(uint32)==4);\t\twhile (n-- > 0) {\t\tcp = (unsigned char *)lp;\t\tt = cp[3]; cp[3] = cp[0]; cp[0] = t;\t\tt = cp[2]; cp[2] = cp[1]; cp[1] = t;\t\tlp++;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void_XTIFFPrintDirectory(TIFF* tif, FILE* fd, long flags){\txtiff *xt = XTIFFDIR(tif);\tXTIFFDirectory *xd = &xt->xtif_dir;\tint i,num;\t\tif (PARENT(xt,printdir))\t\t(PARENT(xt,printdir))(tif,fd,flags);\t\tfprintf(fd,\"--My Example Tags--\\n\");\t\tif (TIFFFieldSet(tif,FIELD_EXAMPLE_MULTI))\t{\t\tfprintf(fd, \"  My Multi-Valued Doubles:\");\t\tif (flags & TIFFPRINT_MYMULTIDOUBLES) \t\t{\t\t\tdouble *value = xd->xd_example_multi;\t\t\tnum = xd->xd_num_multi;\t\t\tfprintf(fd,\"(\");\t\t\tfor (i=0;i<num;i++) fprintf(fd, \" %lg\", *value++);\t\t\tfprintf(fd,\")\\n\");\t\t} else\t\t\tfprintf(fd, \"(present)\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_EXAMPLE_SINGLE))\t{\t\tfprintf(fd, \"  My Single Long Tag:  %lu\\n\", xd->xd_example_single);\t}\tif (TIFFFieldSet(tif,FIELD_EXAMPLE_ASCII))\t{\t\t_TIFFprintAsciiTag(fd,\"My ASCII Tag\",\t\t\t xd->xd_example_ascii);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidReadError(char* what){\tFatal(\"Error while reading %s\", what);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intpcompar(const void* va, const void* vb){    const int* pa = (const int*) va;    const int* pb = (const int*) vb;    return (*pa - *pb);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPixarLogMakeTables(PixarLogState *sp){    int  nlin, lt2size;    int  i, j;    double  b, c, linstep, v;    float *ToLinearF;    uint16 *ToLinear16;    unsigned char *ToLinear8;    uint16  *FromLT2;    uint16  *From14;     uint16  *From8;    c = log(RATIO);\t    nlin = (int)(1./c);\t    c = 1./nlin;    b = exp(-c*ONE);\t    linstep = b*c*exp(1.);    LogK1 = (float)(1./c);\t    LogK2 = (float)(1./b);    lt2size = (int)(2./linstep) + 1;    FromLT2 = (uint16 *)_TIFFmalloc(lt2size*sizeof(uint16));    From14 = (uint16 *)_TIFFmalloc(16384*sizeof(uint16));    From8 = (uint16 *)_TIFFmalloc(256*sizeof(uint16));    ToLinearF = (float *)_TIFFmalloc(TSIZEP1 * sizeof(float));    ToLinear16 = (uint16 *)_TIFFmalloc(TSIZEP1 * sizeof(uint16));    ToLinear8 = (unsigned char *)_TIFFmalloc(TSIZEP1 * sizeof(unsigned char));    if (FromLT2 == NULL || From14  == NULL || From8   == NULL ||\t ToLinearF == NULL || ToLinear16 == NULL || ToLinear8 == NULL) {\tif (FromLT2) _TIFFfree(FromLT2);\tif (From14) _TIFFfree(From14);\tif (From8) _TIFFfree(From8);\tif (ToLinearF) _TIFFfree(ToLinearF);\tif (ToLinear16) _TIFFfree(ToLinear16);\tif (ToLinear8) _TIFFfree(ToLinear8);\tsp->FromLT2 = NULL;\tsp->From14 = NULL;\tsp->From8 = NULL;\tsp->ToLinearF = NULL;\tsp->ToLinear16 = NULL;\tsp->ToLinear8 = NULL;\treturn 0;    }    j = 0;    for (i = 0; i < nlin; i++)  {\tv = i * linstep;\tToLinearF[j++] = (float)v;    }    for (i = nlin; i < TSIZE; i++)\tToLinearF[j++] = (float)(b*exp(c*i));    ToLinearF[2048] = ToLinearF[2047];    for (i = 0; i < TSIZEP1; i++)  {\tv = ToLinearF[i]*65535.0 + 0.5;\tToLinear16[i] = (v > 65535.0) ? 65535 : (uint16)v;\tv = ToLinearF[i]*255.0  + 0.5;\tToLinear8[i]  = (v > 255.0) ? 255 : (unsigned char)v;    }    j = 0;    for (i = 0; i < lt2size; i++)  {\tif ((i*linstep)*(i*linstep) > ToLinearF[j]*ToLinearF[j+1])\t    j++;\tFromLT2[i] = (uint16)j;    }        j = 0;    for (i = 0; i < 16384; i++)  {\twhile ((i/16383.)*(i/16383.) > ToLinearF[j]*ToLinearF[j+1])\t    j++;\tFrom14[i] = (uint16)j;    }    j = 0;    for (i = 0; i < 256; i++)  {\twhile ((i/255.)*(i/255.) > ToLinearF[j]*ToLinearF[j+1])\t    j++;\tFrom8[i] = (uint16)j;    }    Fltsize = (float)(lt2size/2);    sp->ToLinearF = ToLinearF;    sp->ToLinear16 = ToLinear16;    sp->ToLinear8 = ToLinear8;    sp->FromLT2 = FromLT2;    sp->From14 = From14;    sp->From8 = From8;    return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidGetTIFFImage(){    int pixel_map[3], red_shift, green_shift, blue_shift;    char *scan_line, *output_p, *input_p;    uint32 i, j;    uint16 s;    scan_line = (char *) malloc(tfBytesPerRow = TIFFScanlineSize(tfFile));    MCHECK(scan_line);    if ((tfImageDepth == 32) || (tfImageDepth == 24)) {        output_p = imageMemory = (char *)            malloc(tfImageWidth * tfImageHeight * 4);        MCHECK(imageMemory);                if (ImageByteOrder(xDisplay) == LSBFirst) {             red_shift = pixel_map[0] = xRedMask == 0xFF000000 ? 3                : (xRedMask == 0xFF0000 ? 2 : (xRedMask == 0xFF00 ? 1 : 0));            green_shift = pixel_map[1] = xGreenMask == 0xFF000000 ? 3                : (xGreenMask == 0xFF0000 ? 2 : (xGreenMask == 0xFF00 ? 1 : 0));            blue_shift = pixel_map[2] = xBlueMask == 0xFF000000 ? 3                : (xBlueMask == 0xFF0000 ? 2 : (xBlueMask == 0xFF00 ? 1 : 0));        } else {             red_shift = pixel_map[0] = xRedMask == 0xFF000000 ? 0                : (xRedMask == 0xFF0000 ? 1 : (xRedMask == 0xFF00 ? 2 : 3));            green_shift = pixel_map[0] = xGreenMask == 0xFF000000 ? 0                : (xGreenMask == 0xFF0000 ? 1 : (xGreenMask == 0xFF00 ? 2 : 3));            blue_shift = pixel_map[0] = xBlueMask == 0xFF000000 ? 0                : (xBlueMask == 0xFF0000 ? 1 : (xBlueMask == 0xFF00 ? 2 : 3));        }        if (tfPlanarConfiguration == PLANARCONFIG_CONTIG) {            for (i = 0; i < tfImageHeight; i++) {                if (TIFFReadScanline(tfFile, scan_line, i, 0) < 0)                    break;                for (input_p = scan_line, j = 0; j < tfImageWidth; j++) {                    *(output_p + red_shift) = *input_p++;                    *(output_p + green_shift) = *input_p++;                    *(output_p + blue_shift) = *input_p++;                    output_p += 4;                    if (tfSamplesPerPixel == 4)                         input_p++;                }            }        } else {            for (s = 0; s < tfSamplesPerPixel; s++) {                if (s == 3)                                 continue;                for (i = 0; i < tfImageHeight; i++) {                    if (TIFFReadScanline(tfFile, scan_line, i, s) < 0)                        break;                    input_p = scan_line;                    output_p = imageMemory + (i*tfImageWidth*4) + pixel_map[s];                    for (j = 0; j < tfImageWidth; j++, output_p += 4)                        *output_p = *input_p++;                }            }        }    } else {        if (xImageDepth == tfImageDepth) {            output_p = imageMemory = (char *)                malloc(tfBytesPerRow * tfImageHeight);            MCHECK(imageMemory);            for (i = 0; i < tfImageHeight; i++, output_p += tfBytesPerRow)                if (TIFFReadScanline(tfFile, output_p, i, 0) < 0)                    break;        } else if ((xImageDepth == 8) && (tfImageDepth == 4)) {            output_p = imageMemory = (char *)                malloc(tfBytesPerRow * 2 * tfImageHeight + 2);            MCHECK(imageMemory);                        for (i = 0; i < tfImageHeight; i++) {                if (TIFFReadScanline(tfFile, scan_line, i, 0) < 0)                    break;                output_p = &imageMemory[i * tfImageWidth];                input_p = scan_line;                for (j = 0; j < tfImageWidth; j += 2, input_p++) {                    *output_p++ = (*input_p >> 4) + basePixel;                    *output_p++ = (*input_p & 0xf) + basePixel;                }            }        } else if ((xImageDepth == 8) && (tfImageDepth == 2)) {            output_p = imageMemory = (char *)                malloc(tfBytesPerRow * 4 * tfImageHeight + 4);            MCHECK(imageMemory);            for (i = 0; i < tfImageHeight; i++) {                if (TIFFReadScanline(tfFile, scan_line, i, 0) < 0)                    break;                output_p = &imageMemory[i * tfImageWidth];                input_p = scan_line;                for (j = 0; j < tfImageWidth; j += 4, input_p++) {                    *output_p++ = (*input_p >> 6) + basePixel;                    *output_p++ = ((*input_p >> 4) & 3) + basePixel;                    *output_p++ = ((*input_p >> 2) & 3) + basePixel;                    *output_p++ = (*input_p & 3) + basePixel;                }            }        } else if ((xImageDepth == 4) && (tfImageDepth == 2)) {            output_p = imageMemory = (char *)                malloc(tfBytesPerRow * 2 * tfImageHeight + 2);            MCHECK(imageMemory);            for (i = 0; i < tfImageHeight; i++) {                if (TIFFReadScanline(tfFile, scan_line, i, 0) < 0)                    break;                output_p = &imageMemory[i * tfBytesPerRow * 2];                input_p = scan_line;                for (j = 0; j < tfImageWidth; j += 4, input_p++) {                    *output_p++ = (((*input_p>>6) << 4)                        | ((*input_p >> 4) & 3)) + basePixel;                    *output_p++ = ((((*input_p>>2) & 3) << 4)                        | (*input_p & 3)) + basePixel;                }            }        } else {            fprintf(stderr,                \"xtiff: can't handle %d-bit TIFF file on an %d-bit display\\n\",                tfImageDepth, xImageDepth);            exit(0);        }    }    free(scan_line);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidprocessG3Options(char* cp){\tif ((cp = strchr(cp, ':'))) {\t\tdo {\t\t\tcp++;\t\t\tif (strneq(cp, \"1d\", 2))\t\t\t\tgroup3options &= ~GROUP3OPT_2DENCODING;\t\t\telse if (strneq(cp, \"2d\", 2))\t\t\t\tgroup3options |= GROUP3OPT_2DENCODING;\t\t\telse if (strneq(cp, \"fill\", 4))\t\t\t\tgroup3options |= GROUP3OPT_FILLBITS;\t\t\telse\t\t\t\tusage();\t\t} while ((cp = strchr(cp, ':')));\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size){}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int_TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c){\treturn (memcmp(p1, p2, (size_t) c));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char* argv[]){\tFILE *in;\tTIFF *out = NULL;\tTIFFErrorHandler whandler = NULL;\tint compression_in = COMPRESSION_CCITTFAX3;\tint compression_out = COMPRESSION_CCITTFAX3;\tint fillorder_in = FILLORDER_LSB2MSB;\tint fillorder_out = FILLORDER_LSB2MSB;\tuint32 group3options_in = 0;\t\tuint32 group3options_out = 0;\t\tuint32 group4options_in = 0;\t\tuint32 group4options_out = 0;\t\tuint32 defrowsperstrip = (uint32) 0;\tuint32 rowsperstrip;\tint photometric_in = PHOTOMETRIC_MINISWHITE;\tint photometric_out = PHOTOMETRIC_MINISWHITE;\tint mode = FAXMODE_CLASSF;\tint rows;\tint c;\tint pn, npages;\tfloat resY = 196.0;\textern int optind;\textern char* optarg;\twhile ((c = getopt(argc, argv, \"R:X:o:1234ABLMPUW5678abcflmprsuvwz?\")) != -1)\t\tswitch (c) {\t\t\t\t\tcase '3':\t\t\t\t\tcompression_in = COMPRESSION_CCITTFAX3;\t\t\tbreak;\t\tcase '4':\t\t\t\t\tcompression_in = COMPRESSION_CCITTFAX4;\t\t\tbreak;\t\tcase 'U':\t\t\t\t\tgroup3options_in |= GROUP3OPT_UNCOMPRESSED;\t\t\tgroup4options_in |= GROUP4OPT_UNCOMPRESSED;\t\t\tbreak;\t\tcase '1':\t\t\t\t\tgroup3options_in &= ~GROUP3OPT_2DENCODING;\t\t\tbreak;\t\tcase '2':\t\t\t\t\tgroup3options_in |= GROUP3OPT_2DENCODING;\t\t\tbreak;\t\tcase 'P':\t\t\t\tgroup3options_in &= ~GROUP3OPT_FILLBITS;\t\t\tbreak;\t\tcase 'A':\t\t\t\t\tgroup3options_in |= GROUP3OPT_FILLBITS;\t\t\tbreak;\t\tcase 'W':\t\t\t\t\tphotometric_in = PHOTOMETRIC_MINISWHITE;\t\t\tbreak;\t\tcase 'B':\t\t\t\t\tphotometric_in = PHOTOMETRIC_MINISBLACK;\t\t\tbreak;\t\tcase 'L':\t\t\t\t\tfillorder_in = FILLORDER_LSB2MSB;\t\t\tbreak;\t\tcase 'M':\t\t\t\t\tfillorder_in = FILLORDER_MSB2LSB;\t\t\tbreak;\t\tcase 'R':\t\t\t\t\tresY = (float) atof(optarg);\t\t\tbreak;\t\tcase 'X':\t\t\t\t\txsize = (uint32) atoi(optarg);\t\t\tbreak;\t\t\t\t\tcase '7':\t\t\t\t\tcompression_out = COMPRESSION_CCITTFAX3;\t\t\tbreak;\t\tcase '8':\t\t\t\t\tcompression_out = COMPRESSION_CCITTFAX4;\t\t\tbreak;\t\tcase 'u':\t\t\t\tgroup3options_out |= GROUP3OPT_UNCOMPRESSED;\t\t\tgroup4options_out |= GROUP4OPT_UNCOMPRESSED;\t\t\tbreak;\t\tcase '5':\t\t\t\tgroup3options_out &= ~GROUP3OPT_2DENCODING;\t\t\tbreak;\t\tcase '6':\t\t\t\tgroup3options_out |= GROUP3OPT_2DENCODING;\t\t\tbreak;\t\tcase 'c':\t\t\t\t\tmode = FAXMODE_CLASSIC;\t\t\tbreak;\t\tcase 'f':\t\t\t\t\tmode = FAXMODE_CLASSF;\t\t\tbreak;\t\tcase 'm':\t\t\t\t\tfillorder_out = FILLORDER_MSB2LSB;\t\t\tbreak;\t\tcase 'l':\t\t\t\t\tfillorder_out = FILLORDER_LSB2MSB;\t\t\tbreak;\t\tcase 'o':\t\t\tout = TIFFOpen(optarg, \"w\");\t\t\tif (out == NULL) {\t\t\t\tfprintf(stderr,\t\t\t\t    \"%s: Can not create or open %s\\n\",\t\t\t\t    argv[0], optarg);\t\t\t\treturn EXIT_FAILURE;\t\t\t}\t\t\tbreak;\t\tcase 'a':\t\t\t\tgroup3options_out |= GROUP3OPT_FILLBITS;\t\t\tbreak;\t\tcase 'p':\t\t\t\tgroup3options_out &= ~GROUP3OPT_FILLBITS;\t\t\tbreak;\t\tcase 'r':\t\t\t\t\tdefrowsperstrip = atol(optarg);\t\t\tbreak;\t\tcase 's':\t\t\t\t\tstretch = 1;\t\t\tbreak;\t\tcase 'w':\t\t\t\t\tphotometric_out = PHOTOMETRIC_MINISWHITE;\t\t\tbreak;\t\tcase 'b':\t\t\t\t\tphotometric_out = PHOTOMETRIC_MINISBLACK;\t\t\tbreak;\t\tcase 'z':\t\t\t\t\tcompression_out = COMPRESSION_LZW;\t\t\tbreak;\t\tcase 'v':\t\t\t\t\tverbose++;\t\t\tbreak;\t\tcase '?':\t\t\tusage();\t\t\t\t\t}\tnpages = argc - optind;\tif (npages < 1)\t\tusage();\trowbuf = _TIFFmalloc(TIFFhowmany8(xsize));\trefbuf = _TIFFmalloc(TIFFhowmany8(xsize));\tif (rowbuf == NULL || refbuf == NULL) {\t\tfprintf(stderr, \"%s: Not enough memory\\n\", argv[0]);\t\treturn (EXIT_FAILURE);\t}\tif (out == NULL) {\t\tout = TIFFOpen(\"fax.tif\", \"w\");\t\tif (out == NULL) {\t\t\tfprintf(stderr, \"%s: Can not create fax.tif\\n\",\t\t\t    argv[0]);\t\t\treturn (EXIT_FAILURE);\t\t}\t}\tfaxTIFF = TIFFClientOpen(\"(FakeInput)\", \"w\",\t\t\t\t\t TIFFClientdata(out),\t\t\t\t TIFFGetReadProc(out), TIFFGetWriteProc(out),\t\t\t\t TIFFGetSeekProc(out), TIFFGetCloseProc(out),\t\t\t\t TIFFGetSizeProc(out), TIFFGetMapFileProc(out),\t\t\t\t TIFFGetUnmapFileProc(out));\tif (faxTIFF == NULL) {\t\tfprintf(stderr, \"%s: Can not create fake input file\\n\",\t\t    argv[0]);\t\treturn (EXIT_FAILURE);\t}\tTIFFSetMode(faxTIFF, O_RDONLY);\tTIFFSetField(faxTIFF, TIFFTAG_IMAGEWIDTH,\txsize);\tTIFFSetField(faxTIFF, TIFFTAG_SAMPLESPERPIXEL,\t1);\tTIFFSetField(faxTIFF, TIFFTAG_BITSPERSAMPLE,\t1);\tTIFFSetField(faxTIFF, TIFFTAG_FILLORDER,\tfillorder_in);\tTIFFSetField(faxTIFF, TIFFTAG_PLANARCONFIG,\tPLANARCONFIG_CONTIG);\tTIFFSetField(faxTIFF, TIFFTAG_PHOTOMETRIC,\tphotometric_in);\tTIFFSetField(faxTIFF, TIFFTAG_YRESOLUTION,\tresY);\tTIFFSetField(faxTIFF, TIFFTAG_RESOLUTIONUNIT,\tRESUNIT_INCH);\t\tTIFFSetField(faxTIFF, TIFFTAG_COMPRESSION, compression_in);\tif (compression_in == COMPRESSION_CCITTFAX3)\t\tTIFFSetField(faxTIFF, TIFFTAG_GROUP3OPTIONS, group3options_in);\telse if (compression_in == COMPRESSION_CCITTFAX4)\t\tTIFFSetField(faxTIFF, TIFFTAG_GROUP4OPTIONS, group4options_in);\tfor (pn = 0; optind < argc; pn++, optind++) {\t\tin = fopen(argv[optind], \"rb\");\t\tif (in == NULL) {\t\t\tfprintf(stderr,\t\t\t    \"%s: %s: Can not open\\n\", argv[0], argv[optind]);\t\t\tcontinue;\t\t}#if defined(_WIN32) && defined(USE_WIN32_FILEIO)                TIFFSetClientdata(faxTIFF, (thandle_t)_get_osfhandle(fileno(in)));#else                TIFFSetClientdata(faxTIFF, (thandle_t)fileno(in));#endif\t\tTIFFSetFileName(faxTIFF, (const char*)argv[optind]);\t\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, xsize);\t\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 1);\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression_out);\t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric_out);\t\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\t\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 1);\t\tswitch (compression_out) {\t\t\t\t\t\tcase COMPRESSION_CCITTFAX3:\t\t\tTIFFSetField(out, TIFFTAG_GROUP3OPTIONS,\t\t\t\t     group3options_out);\t\t\tTIFFSetField(out, TIFFTAG_FAXMODE, mode);\t\t\trowsperstrip =\t\t\t\t(defrowsperstrip)?defrowsperstrip:(uint32)-1L;\t\t\tbreak;\t\t\t\t\t\tcase COMPRESSION_CCITTFAX4:\t\t\tTIFFSetField(out, TIFFTAG_GROUP4OPTIONS,\t\t\t\t     group4options_out);\t\t\tTIFFSetField(out, TIFFTAG_FAXMODE, mode);\t\t\trowsperstrip =\t\t\t\t(defrowsperstrip)?defrowsperstrip:(uint32)-1L;\t\t\tbreak;\t\t\tdefault:\t\t\trowsperstrip = (defrowsperstrip) ?\t\t\t\tdefrowsperstrip : TIFFDefaultStripSize(out, 0);\t\t}\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\t\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\t\tTIFFSetField(out, TIFFTAG_FILLORDER, fillorder_out);\t\tTIFFSetField(out, TIFFTAG_SOFTWARE, \"fax2tiff\");\t\tTIFFSetField(out, TIFFTAG_XRESOLUTION, 204.0);\t\tif (!stretch) {\t\t\tTIFFGetField(faxTIFF, TIFFTAG_YRESOLUTION, &resY);\t\t\tTIFFSetField(out, TIFFTAG_YRESOLUTION, resY);\t\t} else\t\t\tTIFFSetField(out, TIFFTAG_YRESOLUTION, 196.);\t\tTIFFSetField(out, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pn, npages);\t\tif (!verbose)\t\t    whandler = TIFFSetWarningHandler(NULL);\t\trows = copyFaxFile(faxTIFF, out);\t\tfclose(in);\t\tif (!verbose)\t\t    (void) TIFFSetWarningHandler(whandler);\t\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, rows);\t\tif (verbose) {\t\t\tfprintf(stderr, \"%s:\\n\", argv[optind]);\t\t\tfprintf(stderr, \"%d rows in input\\n\", rows);\t\t\tfprintf(stderr, \"%ld total bad rows\\n\",\t\t\t    (long) badfaxlines);\t\t\tfprintf(stderr, \"%d max consecutive bad rows\\n\", badfaxrun);\t\t}\t\tif (compression_out == COMPRESSION_CCITTFAX3 &&\t\t    mode == FAXMODE_CLASSF) {\t\t\tTIFFSetField(out, TIFFTAG_BADFAXLINES, badfaxlines);\t\t\tTIFFSetField(out, TIFFTAG_CLEANFAXDATA, badfaxlines ?\t\t\t    CLEANFAXDATA_REGENERATED : CLEANFAXDATA_CLEAN);\t\t\tTIFFSetField(out, TIFFTAG_CONSECUTIVEBADFAXLINES, badfaxrun);\t\t}\t\tTIFFWriteDirectory(out);\t}\tTIFFClose(out);\t_TIFFfree(rowbuf);\t_TIFFfree(refbuf);\treturn (EXIT_SUCCESS);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFmemcpy(tdata_t d, const tdata_t s, size_t c){\tmemcpy(d, s, (size_t) c);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFReadPrivateDataSubDirectory(TIFF* tif, toff_t pdir_offset,\t\t\t\tTIFFFieldInfo *field_info,\t\t\t\tint (*setFieldFn)(TIFF *tif, ttag_t tag, ...)){\tregister TIFFDirEntry* dp;\tregister int n;\tregister TIFFDirectory* td;\tTIFFDirEntry* dir;\tint iv;\tlong v;\tdouble dv;\tconst TIFFFieldInfo* fip;\tint fix;\tuint16 dircount;\tuint32 nextdiroff;\tchar* cp;\tint diroutoforderwarning = 0;\t\tif (!isMapped(tif)) {\t\tif (!SeekOK(tif, pdir_offset)) {\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\t    \"Seek error accessing TIFF private subdirectory\");\t\t\treturn (0);\t\t}\t\tif (!ReadOK(tif, &dircount, sizeof (uint16))) {\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\t    \"Can not read TIFF private subdirectory count\");\t\t\treturn (0);\t\t}\t\tif (tif->tif_flags & TIFF_SWAB)\t\t\tTIFFSwabShort(&dircount);\t\tdir = (TIFFDirEntry *)CheckMalloc(tif,\t\t    dircount * sizeof (TIFFDirEntry), \"to read TIFF private subdirectory\");\t\tif (dir == NULL)\t\t\treturn (0);\t\tif (!ReadOK(tif, dir, dircount*sizeof (TIFFDirEntry))) {\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Can not read TIFF private subdirectory\");\t\t\tgoto bad;\t\t}\t\t\t\t(void) ReadOK(tif, &nextdiroff, sizeof (uint32));\t} else {\t\ttoff_t off = pdir_offset;\t\tif (off + sizeof (short) > tif->tif_size) {\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\t    \"Can not read TIFF private subdirectory count\");\t\t\treturn (0);\t\t} else\t\t\t_TIFFmemcpy(&dircount, tif->tif_base + off, sizeof (uint16));\t\toff += sizeof (uint16);\t\tif (tif->tif_flags & TIFF_SWAB)\t\t\tTIFFSwabShort(&dircount);\t\tdir = (TIFFDirEntry *)CheckMalloc(tif,\t\t    dircount * sizeof (TIFFDirEntry), \"to read TIFF private subdirectory\");\t\tif (dir == NULL)\t\t\treturn (0);\t\tif (off + dircount*sizeof (TIFFDirEntry) > tif->tif_size) {\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Can not read TIFF private subdirectory\");\t\t\tgoto bad;\t\t} else\t\t\t_TIFFmemcpy(dir, tif->tif_base + off,\t\t\t    dircount*sizeof (TIFFDirEntry));\t\toff += dircount* sizeof (TIFFDirEntry);\t\tif (off + sizeof (uint32) < tif->tif_size)\t\t\t_TIFFmemcpy(&nextdiroff, tif->tif_base+off, sizeof (uint32));\t}\tif (tif->tif_flags & TIFF_SWAB)\t\tTIFFSwabLong(&nextdiroff);\t\ttd = &tif->tif_dir;\tfor (fip = field_info, dp = dir, n = dircount;\t     n > 0; n--, dp++) {\t\tif (tif->tif_flags & TIFF_SWAB) {\t\t\tTIFFSwabArrayOfShort(&dp->tdir_tag, 2);\t\t\tTIFFSwabArrayOfLong(&dp->tdir_count, 2);\t\t}\t\t\t\t\t\tif (dp->tdir_tag < fip->field_tag) {\t\t\tif (!diroutoforderwarning) {\t\t\t\tTIFFWarning(tif->tif_name,\t\"invalid TIFF private subdirectory; tags are not sorted in ascending order\");\t\t\t\tdiroutoforderwarning = 1;\t\t\t}\t\t\tfip = field_info;    \t\t}\t\twhile (fip->field_tag && fip->field_tag < dp->tdir_tag)\t\t\tfip++;\t\tif (!fip->field_tag || fip->field_tag != dp->tdir_tag) {\t\t\tTIFFWarning(tif->tif_name,\t\t\t    \"unknown field with tag %d (0x%x) in private subdirectory ignored\",\t\t\t    dp->tdir_tag,  dp->tdir_tag);\t\t\tdp->tdir_tag = IGNORE;\t\t\tfip = field_info;\t\t\tcontinue;\t\t}\t\t\t\t\t\tif (0 ) {\tignore:\t\t\tdp->tdir_tag = IGNORE;\t\t\tcontinue;\t\t}\t\t\t\twhile (dp->tdir_type != (u_short)fip->field_type) {\t\t\tif (fip->field_type == TIFF_ANY)\t\t\t\t\tbreak;\t\t\tfip++;\t\t\tif (!fip->field_tag || fip->field_tag != dp->tdir_tag) {\t\t\t\tTIFFWarning(tif->tif_name,\t\t\t\t   \"wrong data type %d for \\\"%s\\\"; tag ignored\",\t\t\t\t    dp->tdir_type, fip[-1].field_name);\t\t\t\tgoto ignore;\t\t\t}\t\t}\t\t\t\tif (fip->field_readcount != TIFF_VARIABLE) {\t\t\tuint32 expected = (fip->field_readcount == TIFF_SPP) ?\t\t\t    (uint32) td->td_samplesperpixel :\t\t\t    (uint32) fip->field_readcount;\t\t\tif (!CheckDirCount(tif, dp, expected))\t\t\t\tgoto ignore;\t\t}\t\t\t\tif (!TIFFFetchNormalSubTag(tif, dp, fip, setFieldFn))\t\t    goto bad;\t}\tif (dir)\t\t_TIFFfree(dir);\treturn (1);bad:\tif (dir)\t\t_TIFFfree(dir);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tmsize_tmultiply_ms(tmsize_t m1, tmsize_t m2){\ttmsize_t bytes = m1 * m2;\tif (m1 && bytes / m1 != m2)\t\tbytes = 0;\treturn bytes;}",
        "label": 1,
        "cve": "CVE-2018-17100"
    },
    {
        "code": "static voidusage(void){\tchar buf[BUFSIZ];\tint i;\tsetbuf(stderr, buf);        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\tfor (i = 0; stuff[i] != NULL; i++)\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\texit(-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intreadraster(void){    unsigned char *fill = raster;    unsigned char buf[255];    register int bits=0;    register unsigned long datum=0;    register unsigned char *ch;    register int count, code;    int status = 1;    datasize = getc(infile);    clear = 1 << datasize;    eoi = clear + 1;    avail = clear + 2;    oldcode = -1;    codesize = datasize + 1;    codemask = (1 << codesize) - 1;    for (code = 0; code < clear; code++) {\tprefix[code] = 0;\tsuffix[code] = code;    }    stackp = stack;    for (count = getc(infile); count > 0; count = getc(infile)) {\tfread(buf,1,count,infile);\tfor (ch=buf; count-- > 0; ch++) {\t    datum += (unsigned long) *ch << bits;\t    bits += 8;\t    while (bits >= codesize) {\t\tcode = datum & codemask;\t\tdatum >>= codesize;\t\tbits -= codesize;\t\tif (code == eoi) {               \t\t    goto exitloop;               \t\t}                                \t\tif (!process(code, &fill)) {\t\t    status = 0;\t\t    goto exitloop;\t\t}\t    }\t}\tif (fill >= raster + width*height) {\t    fprintf(stderr, \"raster full before eoi code\\n\");\t    break;\t}    }exitloop:    if (fill != raster + width*height)  {\tfprintf(stderr, \"warning: wrong rastersize: %ld bytes\\n\",\t\t\t\t\t\t      (long) (fill-raster));\tfprintf(stderr, \"         instead of %ld bytes\\n\",\t\t\t\t\t\t      (long) width*height);    }    return status;}",
        "label": 1,
        "cve": "cve-2013-4231"
    },
    {
        "code": "static void_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size){\tchar *inadr[2];\tint i, j;\t\tfor (i = 0;i < no_mapped; i++) {\t\tif (map_table[i].base == (char *) base) {\t\t\t\t\t\tinadr[0] = (char *) base;\t\t\tinadr[1] = map_table[i].top;\t\t\tsys$deltva(inadr, 0, 0);\t\t\tsys$dassgn(map_table[i].channel);\t\t\t\t\t\tfor (j = i+1; j < no_mapped; j++)\t\t\t\tmap_table[j-1] = map_table[j];\t\t\tno_mapped--;\t\t\treturn;\t\t}\t}}static void_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size){}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static inttiffcp(TIFF* in, TIFF* out){\tuint16 bitspersample = 1, samplesperpixel = 1;\tuint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;\tcopyFunc cf;\tuint32 width, length;\tstruct cpTag* p;\tCopyField(TIFFTAG_IMAGEWIDTH, width);\tCopyField(TIFFTAG_IMAGELENGTH, length);\tCopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);\tCopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\tif (compression != (uint16)-1)\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\telse\t\tCopyField(TIFFTAG_COMPRESSION, compression);\tTIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);\tTIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric);\tif (input_compression == COMPRESSION_JPEG) {\t\t\t\tTIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\t} else if (input_photometric == PHOTOMETRIC_YCBCR) {\t\t\t\tuint16 subsamplinghor,subsamplingver;\t\tTIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\t\t\t\t      &subsamplinghor, &subsamplingver);\t\tif (subsamplinghor!=1 || subsamplingver!=1) {\t\t\tfprintf(stderr, \"tiffcp: %s: Can't copy/convert subsampled image.\\n\",\t\t\t\tTIFFFileName(in));\t\t\treturn FALSE;\t\t}\t}\tif (compression == COMPRESSION_JPEG) {\t\tif (input_photometric == PHOTOMETRIC_RGB &&\t\t    jpegcolormode == JPEGCOLORMODE_RGB)\t\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\t\telse\t\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\t}\telse if (compression == COMPRESSION_SGILOG\t    || compression == COMPRESSION_SGILOG24)\t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC,\t\t    samplesperpixel == 1 ?\t\t    PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);\telse if (input_compression == COMPRESSION_JPEG &&\t\t\t samplesperpixel == 3 ) {\t\t\t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\t}\telse\t\tCopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);\tif (fillorder != 0)\t\tTIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\telse\t\tCopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);\t\tTIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\tswitch (orientation) {\t\tcase ORIENTATION_BOTRIGHT:\t\tcase ORIENTATION_RIGHTBOT:\t\t\t\tTIFFWarning(TIFFFileName(in), \"using bottom-left orientation\");\t\t\torientation = ORIENTATION_BOTLEFT;\t\t\t\tcase ORIENTATION_LEFTBOT:\t\t\tcase ORIENTATION_BOTLEFT:\t\t\tbreak;\t\tcase ORIENTATION_TOPRIGHT:\t\tcase ORIENTATION_RIGHTTOP:\t\t\tdefault:\t\t\tTIFFWarning(TIFFFileName(in), \"using top-left orientation\");\t\t\torientation = ORIENTATION_TOPLEFT;\t\t\t\tcase ORIENTATION_LEFTTOP:\t\t\tcase ORIENTATION_TOPLEFT:\t\t\tbreak;\t}\tTIFFSetField(out, TIFFTAG_ORIENTATION, orientation);\t\tif (outtiled == -1)\t\touttiled = TIFFIsTiled(in);\tif (outtiled) {\t\t\t\tif (tilewidth == (uint32) -1)\t\t\tTIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\t\tif (tilelength == (uint32) -1)\t\t\tTIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\t\tTIFFDefaultTileSize(out, &tilewidth, &tilelength);\t\tTIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\t\tTIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\t} else {\t\t\t\tif (rowsperstrip == (uint32) 0) {\t\t\tif (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP,\t\t\t    &rowsperstrip)) {\t\t\t\trowsperstrip =\t\t\t\t    TIFFDefaultStripSize(out, rowsperstrip);\t\t\t}\t\t\tif (rowsperstrip > length && rowsperstrip != (uint32)-1)\t\t\t\trowsperstrip = length;\t\t}\t\telse if (rowsperstrip == (uint32) -1)\t\t\trowsperstrip = length;\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\t}\tif (config != (uint16) -1)\t\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\telse\t\tCopyField(TIFFTAG_PLANARCONFIG, config);\tif (samplesperpixel <= 4)\t\tCopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);\tCopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);\tswitch (compression) {\t\tcase COMPRESSION_JPEG:\t\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\t\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\t\t\tbreak;\t\tcase COMPRESSION_JBIG:\t\t\tCopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\t\t\tCopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\t\t\tCopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\t\t\tCopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII);\t\t\tbreak;\t\tcase COMPRESSION_LZW:\t\tcase COMPRESSION_ADOBE_DEFLATE:\t\tcase COMPRESSION_DEFLATE:                case COMPRESSION_LZMA:\t\t\tif (predictor != (uint16)-1)\t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\t\t\telse\t\t\t\tCopyField(TIFFTAG_PREDICTOR, predictor);\t\t\tif (preset != -1) {                                if (compression == COMPRESSION_ADOBE_DEFLATE                                         || compression == COMPRESSION_DEFLATE)                                        TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset);\t\t\t\telse if (compression == COMPRESSION_LZMA)\t\t\t\t\tTIFFSetField(out, TIFFTAG_LZMAPRESET, preset);                        }\t\t\tbreak;\t\tcase COMPRESSION_CCITTFAX3:\t\tcase COMPRESSION_CCITTFAX4:\t\t\tif (compression == COMPRESSION_CCITTFAX3) {\t\t\t\tif (g3opts != (uint32) -1)\t\t\t\t\tTIFFSetField(out, TIFFTAG_GROUP3OPTIONS,\t\t\t\t\t    g3opts);\t\t\t\telse\t\t\t\t\tCopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\t\t\t} else\t\t\t\tCopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);\t\t\tCopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);\t\t\tCopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);\t\t\tCopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);\t\t\tCopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\t\t\tCopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\t\t\tCopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\t\t\tbreak;\t}\t{\t\tuint32 len32;\t\tvoid** data;\t\tif (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))\t\t\tTIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);\t}\t{\t\tuint16 ninks;\t\tconst char* inknames;\t\tif (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {\t\t\tTIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\t\t\tif (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {\t\t\t\tint inknameslen = strlen(inknames) + 1;\t\t\t\tconst char* cp = inknames;\t\t\t\twhile (ninks > 1) {\t\t\t\t\tcp = strchr(cp, '\\0');                                        cp++;                                        inknameslen += (strlen(cp) + 1);\t\t\t\t\tninks--;\t\t\t\t}\t\t\t\tTIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);\t\t\t}\t\t}\t}\t{\t\tunsigned short pg0, pg1;\t\tif (pageInSeq == 1) {\t\t\tif (pageNum < 0)  {\t\t\t\tif (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))\t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\t\t\t} else\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\t\t} else {\t\t\tif (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {\t\t\t\tif (pageNum < 0) \t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\t\t\t\telse\t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\t\t\t}\t\t}\t}\tfor (p = tags; p < &tags[NTAGS]; p++)\t\tCopyTag(p->tag, p->count, p->type);\tcf = pickCopyFunc(in, out, bitspersample, samplesperpixel);\treturn (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void TIFFDestroyOvrCache( TIFFOvrCache * psCache ){    while( psCache->nBlockOffset < psCache->nBlocksPerColumn )        TIFFWriteOvrRow( psCache );    _TIFFfree( psCache->pabyRow1Blocks );    _TIFFfree( psCache->pabyRow2Blocks );    _TIFFfree( psCache );}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcmptags(TIFF* tif1, TIFF* tif2){\tCmpLongField(TIFFTAG_SUBFILETYPE,\t\"SubFileType\");\tCmpLongField(TIFFTAG_IMAGEWIDTH,\t\"ImageWidth\");\tCmpLongField(TIFFTAG_IMAGELENGTH,\t\"ImageLength\");\tCmpShortField(TIFFTAG_BITSPERSAMPLE,\t\"BitsPerSample\");\tCmpShortField(TIFFTAG_COMPRESSION,\t\"Compression\");\tCmpShortField(TIFFTAG_PREDICTOR,\t\"Predictor\");\tCmpShortField(TIFFTAG_PHOTOMETRIC,\t\"PhotometricInterpretation\");\tCmpShortField(TIFFTAG_THRESHHOLDING,\t\"Thresholding\");\tCmpShortField(TIFFTAG_FILLORDER,\t\"FillOrder\");\tCmpShortField(TIFFTAG_ORIENTATION,\t\"Orientation\");\tCmpShortField(TIFFTAG_SAMPLESPERPIXEL,\t\"SamplesPerPixel\");\tCmpShortField(TIFFTAG_MINSAMPLEVALUE,\t\"MinSampleValue\");\tCmpShortField(TIFFTAG_MAXSAMPLEVALUE,\t\"MaxSampleValue\");\tCmpShortField(TIFFTAG_SAMPLEFORMAT,\t\"SampleFormat\");\tCmpFloatField(TIFFTAG_XRESOLUTION,\t\"XResolution\");\tCmpFloatField(TIFFTAG_YRESOLUTION,\t\"YResolution\");\tCmpLongField(TIFFTAG_GROUP3OPTIONS,\t\"Group3Options\");\tCmpLongField(TIFFTAG_GROUP4OPTIONS,\t\"Group4Options\");\tCmpShortField(TIFFTAG_RESOLUTIONUNIT,\t\"ResolutionUnit\");\tCmpShortField(TIFFTAG_PLANARCONFIG,\t\"PlanarConfiguration\");\tCmpLongField(TIFFTAG_ROWSPERSTRIP,\t\"RowsPerStrip\");\tCmpFloatField(TIFFTAG_XPOSITION,\t\"XPosition\");\tCmpFloatField(TIFFTAG_YPOSITION,\t\"YPosition\");\tCmpShortField(TIFFTAG_GRAYRESPONSEUNIT, \"GrayResponseUnit\");\tCmpShortField(TIFFTAG_COLORRESPONSEUNIT, \"ColorResponseUnit\");#ifdef notdef\t{ uint16 *graycurve;\t  CmpField(TIFFTAG_GRAYRESPONSECURVE, graycurve);\t}\t{ uint16 *red, *green, *blue;\t  CmpField3(TIFFTAG_COLORRESPONSECURVE, red, green, blue);\t}\t{ uint16 *red, *green, *blue;\t  CmpField3(TIFFTAG_COLORMAP, red, green, blue);\t}#endif\tCmpShortField2(TIFFTAG_PAGENUMBER,\t\"PageNumber\");\tCmpStringField(TIFFTAG_ARTIST,\t\t\"Artist\");\tCmpStringField(TIFFTAG_IMAGEDESCRIPTION,\"ImageDescription\");\tCmpStringField(TIFFTAG_MAKE,\t\t\"Make\");\tCmpStringField(TIFFTAG_MODEL,\t\t\"Model\");\tCmpStringField(TIFFTAG_SOFTWARE,\t\"Software\");\tCmpStringField(TIFFTAG_DATETIME,\t\"DateTime\");\tCmpStringField(TIFFTAG_HOSTCOMPUTER,\t\"HostComputer\");\tCmpStringField(TIFFTAG_PAGENAME,\t\"PageName\");\tCmpStringField(TIFFTAG_DOCUMENTNAME,\t\"DocumentName\");\tCmpShortField(TIFFTAG_MATTEING,\t\t\"Matteing\");\tCmpShortArrayField(TIFFTAG_EXTRASAMPLES,\"ExtraSamples\");\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize){\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intinvertImage(uint16 photometric, uint16 spp, uint16 bps, uint32 width, uint32 length, unsigned char *work_buff)  {  uint32   row, col;  unsigned char  bytebuff1, bytebuff2, bytebuff3, bytebuff4;  unsigned char *src;  uint16        *src_uint16;  uint32        *src_uint32;  if (spp != 1)    {    TIFFError(\"invertImage\", \"Image inversion not supported for more than one sample per pixel\");    return (-1);    }  if (photometric !=  PHOTOMETRIC_MINISWHITE && photometric !=  PHOTOMETRIC_MINISBLACK)    {    TIFFError(\"invertImage\", \"Only black and white and grayscale images can be inverted\");    return (-1);    }  src = work_buff;  if (src == NULL)    {    TIFFError (\"invertImage\", \"Invalid crop buffer passed to invertImage\");    return (-1);    }  switch (bps)    {    case 32: src_uint32 = (uint32 *)src;             for (row = 0; row < length; row++)               for (col = 0; col < width; col++)                 {\t\t *src_uint32 = (uint32)0xFFFFFFFF - *src_uint32;                  src_uint32++;                 }            break;    case 16: src_uint16 = (uint16 *)src;             for (row = 0; row < length; row++)               for (col = 0; col < width; col++)                 {\t\t *src_uint16 = (uint16)0xFFFF - *src_uint16;                  src_uint16++;                 }            break;    case 8: for (row = 0; row < length; row++)              for (col = 0; col < width; col++)                {\t\t*src = (uint8)255 - *src;                 src++;                }            break;    case 4: for (row = 0; row < length; row++)              for (col = 0; col < width; col++)                {\t\tbytebuff1 = 16 - (uint8)(*src & 240 >> 4);\t\tbytebuff2 = 16 - (*src & 15);\t\t*src = bytebuff1 << 4 & bytebuff2;                src++;                }            break;    case 2: for (row = 0; row < length; row++)              for (col = 0; col < width; col++)                {\t\tbytebuff1 = 4 - (uint8)(*src & 192 >> 6);\t\tbytebuff2 = 4 - (uint8)(*src & 48  >> 4);\t\tbytebuff3 = 4 - (uint8)(*src & 12  >> 2);\t\tbytebuff4 = 4 - (uint8)(*src & 3);\t\t*src = (bytebuff1 << 6) || (bytebuff2 << 4) || (bytebuff3 << 2) || bytebuff4;                src++;                }            break;    case 1: for (row = 0; row < length; row++)              for (col = 0; col < width; col += 8 /(spp * bps))                {                *src = ~(*src);                src++;                }            break;    default: TIFFError(\"invertImage\", \"Unsupported bit depth %d\", bps);      return (-1);    }  return (0);  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intDumpModeEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s){\t(void) s;\twhile (cc > 0) {\t\ttmsize_t n;\t\tn = cc;\t\tif (tif->tif_rawcc + n > tif->tif_rawdatasize)\t\t\tn = tif->tif_rawdatasize - tif->tif_rawcc;\t\tassert( n > 0 );\t\t\t\tif (tif->tif_rawcp != pp)\t\t\t_TIFFmemcpy(tif->tif_rawcp, pp, n);\t\ttif->tif_rawcp += n;\t\ttif->tif_rawcc += n;\t\tpp += n;\t\tcc -= n;\t\tif (tif->tif_rawcc >= tif->tif_rawdatasize &&\t\t    !TIFFFlushData1(tif))\t\t\treturn (-1);\t}\treturn (1);}",
        "label": 1,
        "cve": "cve-2016-3619"
    },
    {
        "code": " * do with a single TIFFGetOvrBlock and no longer need TIFFGetOvrBlock_Subsampled */unsigned char *TIFFGetOvrBlock( TIFFOvrCache *psCache, int iTileX, int iTileY,                                int iSample ){    int\t\tnRowOffset;    if( iTileY > psCache->nBlockOffset + 1 )        TIFFWriteOvrRow( psCache );    assert( iTileX >= 0 && iTileX < psCache->nBlocksPerRow );    assert( iTileY >= 0 && iTileY < psCache->nBlocksPerColumn );    assert( iTileY >= psCache->nBlockOffset            && iTileY < psCache->nBlockOffset+2 );    assert( iSample >= 0 && iSample < psCache->nSamples );    if (psCache->nPlanarConfig == PLANARCONFIG_SEPARATE)        nRowOffset = ((iTileX * psCache->nSamples) + iSample)            * psCache->nBytesPerBlock;    else        nRowOffset = iTileX * psCache->nBytesPerBlock +            (psCache->nBitsPerPixel + 7) / 8 * iSample;    if( iTileY == psCache->nBlockOffset )        return psCache->pabyRow1Blocks + nRowOffset;    else        return psCache->pabyRow2Blocks + nRowOffset;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intFax3Encode2DRow(TIFF* tif, unsigned char* bp, unsigned char* rp, uint32 bits){#define\tPIXEL(buf,ix)\t((((buf)[(ix)>>3]) >> (7-((ix)&7))) & 1)        uint32 a0 = 0;\tuint32 a1 = (PIXEL(bp, 0) != 0 ? 0 : finddiff(bp, 0, bits, 0));\tuint32 b1 = (PIXEL(rp, 0) != 0 ? 0 : finddiff(rp, 0, bits, 0));\tuint32 a2, b2;\tfor (;;) {\t\tb2 = finddiff2(rp, b1, bits, PIXEL(rp,b1));\t\tif (b2 >= a1) {\t\t\tint32 d = b1 - a1;\t\t\tif (!(-3 <= d && d <= 3)) {\t\t\t\t\ta2 = finddiff2(bp, a1, bits, PIXEL(bp,a1));\t\t\t\tputcode(tif, &horizcode);\t\t\t\tif (a0+a1 == 0 || PIXEL(bp, a0) == 0) {\t\t\t\t\tputspan(tif, a1-a0, TIFFFaxWhiteCodes);\t\t\t\t\tputspan(tif, a2-a1, TIFFFaxBlackCodes);\t\t\t\t} else {\t\t\t\t\tputspan(tif, a1-a0, TIFFFaxBlackCodes);\t\t\t\t\tputspan(tif, a2-a1, TIFFFaxWhiteCodes);\t\t\t\t}\t\t\t\ta0 = a2;\t\t\t} else {\t\t\t\t\t\t\tputcode(tif, &vcodes[d+3]);\t\t\t\ta0 = a1;\t\t\t}\t\t} else {\t\t\t\t\t\t\tputcode(tif, &passcode);\t\t\ta0 = b2;\t\t}\t\tif (a0 >= bits)\t\t\tbreak;\t\ta1 = finddiff(bp, a0, bits, PIXEL(bp,a0));\t\tb1 = finddiff(rp, a0, bits, !PIXEL(bp,a0));\t\tb1 = finddiff(rp, b1, bits, PIXEL(bp,a0));\t}\treturn (1);#undef PIXEL}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "inline static int32find1span(unsigned char* bp, int32 bs, int32 be){\tint32 bits = be - bs;\tint32 n, span;\tbp += bs>>3;\t\tif (bits > 0 && (n = (bs & 7))) {\t\tspan = oneruns[(*bp << n) & 0xff];\t\tif (span > 8-n)\t\t\t\t\tspan = 8-n;\t\tif (span > bits)\t\t\t\tspan = bits;\t\tif (n+span < 8)\t\t\t\t\treturn (span);\t\tbits -= span;\t\tbp++;\t} else\t\tspan = 0;\tif (bits >= (int32)(2 * 8 * sizeof(long))) {\t\tlong* lp;\t\t\t\twhile (!isAligned(bp, long)) {\t\t\tif (*bp != 0xff)\t\t\t\treturn (span + oneruns[*bp]);\t\t\tspan += 8, bits -= 8;\t\t\tbp++;\t\t}\t\tlp = (long*) bp;\t\twhile ((bits >= (int32)(8 * sizeof(long))) && (~0 == *lp)) {\t\t\tspan += 8*sizeof (long), bits -= 8*sizeof (long);\t\t\tlp++;\t\t}\t\tbp = (unsigned char*) lp;\t}\t\twhile (bits >= 8) {\t\tif (*bp != 0xff)\t\t\t\treturn (span + oneruns[*bp]);\t\tspan += 8, bits -= 8;\t\tbp++;\t}\t\tif (bits > 0) {\t\tn = oneruns[*bp];\t\tspan += (n > bits ? bits : n);\t}\treturn (span);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int writeSelections(TIFF *in, TIFF **out, struct crop_mask *crop,                 struct image_data *image, struct dump_opts *dump,                struct buffinfo seg_buffs[], char *mp, char *filename,                 unsigned int *page, unsigned int total_pages)  {  int i, page_count;  int autoindex = 0;  unsigned char *crop_buff = NULL;      switch (crop->exp_mode)    {    case ONE_FILE_COMPOSITE:          autoindex = 0;         crop_buff = seg_buffs[0].buffer;         if (update_output_file (out, mp, autoindex, filename, page))           return (1);         page_count = total_pages;         if (writeCroppedImage(in, *out, image, dump,                               crop->combined_width,                                crop->combined_length,                               crop_buff, *page, total_pages))            {             TIFFError(\"writeRegions\", \"Unable to write new image\");             return (-1);             }\t break;    case ONE_FILE_SEPARATED:          autoindex = 0;         if (update_output_file (out, mp, autoindex, filename, page))           return (1);         page_count = crop->selections * total_pages;         for (i = 0; i < crop->selections; i++)           {           crop_buff = seg_buffs[i].buffer;           if (writeCroppedImage(in, *out, image, dump,                                 crop->regionlist[i].width,                                  crop->regionlist[i].length,                                  crop_buff, *page, page_count))             {             TIFFError(\"writeRegions\", \"Unable to write new image\");             return (-1);             }\t   }         break;    case FILE_PER_IMAGE_COMPOSITE:          autoindex = 1;         if (update_output_file (out, mp, autoindex, filename, page))           return (1);         crop_buff = seg_buffs[0].buffer;         if (writeCroppedImage(in, *out, image, dump,                               crop->combined_width,                                crop->combined_length,                                crop_buff, *page, total_pages))           {           TIFFError(\"writeRegions\", \"Unable to write new image\");           return (-1);           }         break;    case FILE_PER_IMAGE_SEPARATED:          autoindex = 1;         page_count = crop->selections;         if (update_output_file (out, mp, autoindex, filename, page))           return (1);         for (i = 0; i < crop->selections; i++)           {           crop_buff = seg_buffs[i].buffer;                      if (writeCroppedImage(in, *out, image, dump,                                 crop->regionlist[i].width,                                  crop->regionlist[i].length,                                  crop_buff, *page, page_count))             {             TIFFError(\"writeRegions\", \"Unable to write new image\");             return (-1);             }           }         break;    case FILE_PER_SELECTION:         autoindex = 1;\t page_count = 1;         for (i = 0; i < crop->selections; i++)           {           if (update_output_file (out, mp, autoindex, filename, page))             return (1);           crop_buff = seg_buffs[i].buffer;                      if (writeCroppedImage(in, *out, image, dump,                                 crop->regionlist[i].width,                                  crop->regionlist[i].length,                                  crop_buff, *page, page_count))             {             TIFFError(\"writeRegions\", \"Unable to write new image\");             return (-1);             }           }\t break;    default: return (1);    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void mem_init (){    int i;    for (i = 0; i < MAX_BUFFS; i++)    {        fds[i] = -1;        buf[i] = (char *)NULL;        buf_size[i] = 0;        buf_off[i] = 0;    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intfpDiff(TIFF* tif, uint8* cp0, tmsize_t cc){\ttmsize_t stride = PredictorState(tif)->stride;\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\ttmsize_t wc = cc / bps;\ttmsize_t count;\tuint8 *cp = (uint8 *) cp0;\tuint8 *tmp;    if((cc%(bps*stride))!=0)    {        TIFFErrorExt(tif->tif_clientdata, \"fpDiff\",                     \"%s\", \"(cc%(bps*stride))!=0\");        return 0;    }    tmp = (uint8 *)_TIFFmalloc(cc);\tif (!tmp)\t\treturn 0;\t_TIFFmemcpy(tmp, cp0, cc);\tfor (count = 0; count < wc; count++) {\t\tuint32 byte;\t\tfor (byte = 0; byte < bps; byte++) {\t\t\t#if WORDS_BIGENDIAN\t\t\tcp[byte * wc + count] = tmp[bps * count + byte];\t\t\t#else\t\t\tcp[(bps - byte - 1) * wc + count] =\t\t\t\ttmp[bps * count + byte];\t\t\t#endif\t\t}\t}\t_TIFFfree(tmp);\tcp = (uint8 *) cp0;\tcp += cc - stride - 1;\tfor (count = cc; count > stride; count -= stride)\t\tREPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)    return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidShowRawBytes(unsigned char* pp, uint32 n){\tuint32 i;\tfor (i = 0; i < n; i++) {\t\tprintf(\" %02x\", *pp++);\t\tif (((i+1) % 24) == 0)\t\t\tprintf(\"\\n \");\t}\tputchar('\\n');}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int t2p_process_ojpeg_tables(T2P* t2p, TIFF* input){\tuint16 proc=0;\tvoid* q;\tuint32 q_length=0;\tvoid* dc;\tuint32 dc_length=0;\tvoid* ac;\tuint32 ac_length=0;\tuint16* lp;\tuint16* pt;\tuint16 h_samp=1;\tuint16 v_samp=1;\tunsigned char* ojpegdata;\tuint16 table_count;\tuint32 offset_table;\tuint32 offset_ms_l;\tuint32 code_count;\tuint32 i=0;\tuint32 dest=0;\tuint16 ri=0;\tuint32 rows=0;\tif(!TIFFGetField(input, TIFFTAG_JPEGPROC, &proc)){\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\"Missing JPEGProc field in OJPEG image %s\", \t\t\tTIFFFileName(input));\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn(0);\t}\tif(proc!=JPEGPROC_BASELINE && proc!=JPEGPROC_LOSSLESS){\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\"Bad JPEGProc field in OJPEG image %s\", \t\t\tTIFFFileName(input));\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn(0);\t}\tif(!TIFFGetField(input, TIFFTAG_JPEGQTABLES, &q_length, &q)){\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\"Missing JPEGQTables field in OJPEG image %s\", \t\t\tTIFFFileName(input));\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn(0);\t}\tif(q_length < (64U * t2p->tiff_samplesperpixel)){\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\"Bad JPEGQTables field in OJPEG image %s\", \t\t\tTIFFFileName(input));\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn(0);\t} \tif(!TIFFGetField(input, TIFFTAG_JPEGDCTABLES, &dc_length, &dc)){\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\"Missing JPEGDCTables field in OJPEG image %s\", \t\t\tTIFFFileName(input));\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn(0);\t}\tif(proc==JPEGPROC_BASELINE){\t\tif(!TIFFGetField(input, TIFFTAG_JPEGACTABLES, &ac_length, &ac)){\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\"Missing JPEGACTables field in OJPEG image %s\", \t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\treturn(0);\t\t}\t} else {\t\tif(!TIFFGetField(input, TIFFTAG_JPEGLOSSLESSPREDICTORS, &lp)){\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\"Missing JPEGLosslessPredictors field in OJPEG image %s\", \t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t}\t\tif(!TIFFGetField(input, TIFFTAG_JPEGPOINTTRANSFORM, &pt)){\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\"Missing JPEGPointTransform field in OJPEG image %s\", \t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\treturn(0);\t\t}\t}\tif(!TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &h_samp, &v_samp)){\t\th_samp=1;\t\tv_samp=1;\t}\tif(t2p->pdf_ojpegdata != NULL){\t\t_TIFFfree(t2p->pdf_ojpegdata);\t\tt2p->pdf_ojpegdata=NULL;\t} \tt2p->pdf_ojpegdata = _TIFFmalloc(2048);\tif(t2p->pdf_ojpegdata == NULL){\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\"Can't allocate %u bytes of memory for t2p_process_ojpeg_tables, %s\", \t\t\t2048, \t\t\tTIFFFileName(input));\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn(0);\t}\t_TIFFmemset(t2p->pdf_ojpegdata, 0x00, 2048);\tt2p->pdf_ojpegdatalength = 0;\ttable_count=t2p->tiff_samplesperpixel;\tif(proc==JPEGPROC_BASELINE){\t\tif(table_count>2) table_count=2;\t}\tojpegdata=(unsigned char*)t2p->pdf_ojpegdata;\tojpegdata[t2p->pdf_ojpegdatalength++]=0xff;\tojpegdata[t2p->pdf_ojpegdatalength++]=0xd8;\tojpegdata[t2p->pdf_ojpegdatalength++]=0xff;\tif(proc==JPEGPROC_BASELINE){\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xc0;\t} else {\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xc3;\t}\tojpegdata[t2p->pdf_ojpegdatalength++]=0x00;\tojpegdata[t2p->pdf_ojpegdatalength++]=(8 + 3*t2p->tiff_samplesperpixel);\tojpegdata[t2p->pdf_ojpegdatalength++]=(t2p->tiff_bitspersample & 0xff);\tif(TIFFIsTiled(input)){\t\tojpegdata[t2p->pdf_ojpegdatalength++]=\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength >> 8) & 0xff;\t\tojpegdata[t2p->pdf_ojpegdatalength++]=\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength ) & 0xff;\t\tojpegdata[t2p->pdf_ojpegdatalength++]=\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth >> 8) & 0xff;\t\tojpegdata[t2p->pdf_ojpegdatalength++]=\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth ) & 0xff;\t} else {\t\tojpegdata[t2p->pdf_ojpegdatalength++]=\t\t\t(t2p->tiff_length >> 8) & 0xff;\t\tojpegdata[t2p->pdf_ojpegdatalength++]=\t\t\t(t2p->tiff_length ) & 0xff;\t\tojpegdata[t2p->pdf_ojpegdatalength++]=\t\t\t(t2p->tiff_width >> 8) & 0xff;\t\tojpegdata[t2p->pdf_ojpegdatalength++]=\t\t\t(t2p->tiff_width ) & 0xff;\t}\tojpegdata[t2p->pdf_ojpegdatalength++]=(t2p->tiff_samplesperpixel & 0xff);\tfor(i=0;i<t2p->tiff_samplesperpixel;i++){\t\tojpegdata[t2p->pdf_ojpegdatalength++]=i;\t\tif(i==0){\t\t\tojpegdata[t2p->pdf_ojpegdatalength] |= h_samp<<4 & 0xf0;;\t\t\tojpegdata[t2p->pdf_ojpegdatalength++] |= v_samp & 0x0f;\t\t} else {\t\t\t\tojpegdata[t2p->pdf_ojpegdatalength++]= 0x11;\t\t}\t\tojpegdata[t2p->pdf_ojpegdatalength++]=i;\t}\tfor(dest=0;dest<t2p->tiff_samplesperpixel;dest++){\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xff;\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xdb;\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0x00;\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0x43;\t\tojpegdata[t2p->pdf_ojpegdatalength++]=dest;\t\t_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength++]), \t\t\t&(((unsigned char*)q)[64*dest]), 64);\t\tt2p->pdf_ojpegdatalength+=64;\t}\toffset_table=0;\tfor(dest=0;dest<table_count;dest++){\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xff;\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xc4;\t\toffset_ms_l=t2p->pdf_ojpegdatalength;\t\tt2p->pdf_ojpegdatalength+=2;\t\tojpegdata[t2p->pdf_ojpegdatalength++]=dest & 0x0f;\t\t_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), \t\t\t&(((unsigned char*)dc)[offset_table]), 16);\t\tcode_count=0;\t\toffset_table+=16;\t\tfor(i=0;i<16;i++){\t\t\tcode_count+=ojpegdata[t2p->pdf_ojpegdatalength++];\t\t}\t\tojpegdata[offset_ms_l]=((19+code_count)>>8) & 0xff;\t\tojpegdata[offset_ms_l+1]=(19+code_count) & 0xff;\t\t_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), \t\t\t&(((unsigned char*)dc)[offset_table]), code_count);\t\toffset_table+=code_count;\t\tt2p->pdf_ojpegdatalength+=code_count;\t}\tif(proc==JPEGPROC_BASELINE){\toffset_table=0;\t\tfor(dest=0;dest<table_count;dest++){\t\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xff;\t\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xc4;\t\t\toffset_ms_l=t2p->pdf_ojpegdatalength;\t\t\tt2p->pdf_ojpegdatalength+=2;\t\t\tojpegdata[t2p->pdf_ojpegdatalength] |= 0x10;\t\t\tojpegdata[t2p->pdf_ojpegdatalength++] |=dest & 0x0f;\t\t\t_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), \t\t\t\t&(((unsigned char*)ac)[offset_table]), 16);\t\t\tcode_count=0;\t\t\toffset_table+=16;\t\t\tfor(i=0;i<16;i++){\t\t\t\tcode_count+=ojpegdata[t2p->pdf_ojpegdatalength++];\t\t\t}\t\t\t\tojpegdata[offset_ms_l]=((19+code_count)>>8) & 0xff;\t\t\tojpegdata[offset_ms_l+1]=(19+code_count) & 0xff;\t\t\t_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), \t\t\t\t&(((unsigned char*)ac)[offset_table]), code_count);\t\t\toffset_table+=code_count;\t\t\tt2p->pdf_ojpegdatalength+=code_count;\t\t}\t}\tif(TIFFNumberOfStrips(input)>1){\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xff;\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xdd;\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0x00;\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0x04;\t\th_samp*=8;\t\tv_samp*=8;\t\tri=(t2p->tiff_width+h_samp-1) / h_samp;\t\tTIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rows);\t\tri*=(rows+v_samp-1)/v_samp;\t\tojpegdata[t2p->pdf_ojpegdatalength++]= (ri>>8) & 0xff;\t\tojpegdata[t2p->pdf_ojpegdatalength++]= ri & 0xff;\t}\tojpegdata[t2p->pdf_ojpegdatalength++]=0xff;\tojpegdata[t2p->pdf_ojpegdatalength++]=0xda;\tojpegdata[t2p->pdf_ojpegdatalength++]=0x00;\tojpegdata[t2p->pdf_ojpegdatalength++]=(6 + 2*t2p->tiff_samplesperpixel);\tojpegdata[t2p->pdf_ojpegdatalength++]=t2p->tiff_samplesperpixel & 0xff;\tfor(i=0;i<t2p->tiff_samplesperpixel;i++){\t\tojpegdata[t2p->pdf_ojpegdatalength++]= i & 0xff;\t\tif(proc==JPEGPROC_BASELINE){\t\t\tojpegdata[t2p->pdf_ojpegdatalength] |= \t\t\t\t( ( (i>(table_count-1U)) ? (table_count-1U) : i) << 4U) & 0xf0;\t\t\tojpegdata[t2p->pdf_ojpegdatalength++] |= \t\t\t\t( (i>(table_count-1U)) ? (table_count-1U) : i) & 0x0f;\t\t} else {\t\t\tojpegdata[t2p->pdf_ojpegdatalength++] =  (i << 4) & 0xf0;\t\t}\t}\tif(proc==JPEGPROC_BASELINE){\t\tt2p->pdf_ojpegdatalength++;\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0x3f;\t\tt2p->pdf_ojpegdatalength++;\t} else {\t\tojpegdata[t2p->pdf_ojpegdatalength++]= (lp[0] & 0xff);\t\tt2p->pdf_ojpegdatalength++;\t\tojpegdata[t2p->pdf_ojpegdatalength++]= (pt[0] & 0x0f);\t}\treturn(1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFPredictorInit(TIFF* tif){\tTIFFPredictorState* sp = PredictorState(tif);\tassert(sp != 0);\t\tif (!_TIFFMergeFields(tif, predictFields,\t\t\t      TIFFArrayCount(predictFields))) {\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFPredictorInit\",\t\t    \"Merging Predictor codec-specific tags failed\");\t\treturn 0;\t}\t\tsp->vgetparent = tif->tif_tagmethods.vgetfield;\ttif->tif_tagmethods.vgetfield =            PredictorVGetField;\tsp->vsetparent = tif->tif_tagmethods.vsetfield;\ttif->tif_tagmethods.vsetfield =\t    PredictorVSetField;\tsp->printdir = tif->tif_tagmethods.printdir;\ttif->tif_tagmethods.printdir =            PredictorPrintDir;\t\tsp->setupdecode = tif->tif_setupdecode;\ttif->tif_setupdecode = PredictorSetupDecode;\tsp->setupencode = tif->tif_setupencode;\ttif->tif_setupencode = PredictorSetupEncode;\tsp->predictor = 1;\t\t\t\tsp->encodepfunc = NULL;\t\t\t\tsp->decodepfunc = NULL;\t\t\t\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmsdosWarningHandler(const char* module, const char* fmt, va_list ap){\tif (module != NULL)\t\tfprintf(stderr, \"%s: \", module);\tfprintf(stderr, \"Warning, \");\tvfprintf(stderr, fmt, ap);\tfprintf(stderr, \".\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intreverseSamplesBytes (uint16 spp, uint16 bps, uint32 width,                      uint8 *src, uint8 *dst)  {  int i;  uint32  col, bytes_per_pixel, col_offset;  uint8   bytebuff1;  unsigned char swapbuff[32];  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"reverseSamplesBytes\",\"Invalid input or output buffer\");    return (1);    }  bytes_per_pixel  = ((bps * spp) + 7) / 8;  if( bytes_per_pixel > sizeof(swapbuff) )  {    TIFFError(\"reverseSamplesBytes\",\"bytes_per_pixel too large\");    return (1);  }  switch (bps / 8)     {     case 8:       case 4:     case 3:     case 2: for (col = 0; col < (width / 2); col++)               {\t       col_offset = col * bytes_per_pixel;                     \t       _TIFFmemcpy (swapbuff, src + col_offset, bytes_per_pixel);\t       _TIFFmemcpy (src + col_offset, dst - col_offset - bytes_per_pixel, bytes_per_pixel);\t       _TIFFmemcpy (dst - col_offset - bytes_per_pixel, swapbuff, bytes_per_pixel);               }\t     break;     case 1:              for (col = 0; col < (width / 2); col++)               { \t       for (i = 0; i < spp; i++)                  {\t\t  bytebuff1 = *src;\t\t  *src++ = *(dst - spp + i);                  *(dst - spp + i) = bytebuff1;\t\t  }\t\tdst -= spp;                }\t     break;     default: TIFFError(\"reverseSamplesBytes\",\"Unsupported bit depth %d\", bps);       return (1);     }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char* argv[]){\tuint32 rowsperstrip = (uint32) -1;\tTIFF *in, *out;\tuint32 w, h;\tuint16 samplesperpixel;\tuint16 bitspersample;\tuint16 config;\tuint16 photometric;\tuint16* red;\tuint16* green;\tuint16* blue;\ttsize_t rowsize;\tregister uint32 row;\tregister tsample_t s;\tunsigned char *inbuf, *outbuf;\tchar thing[1024];\tint c;\textern int optind;\textern char *optarg;\twhile ((c = getopt(argc, argv, \"c:r:R:G:B:\")) != -1)\t\tswitch (c) {\t\tcase 'c':\t\t\t\t\tif (!processCompressOptions(optarg))\t\t\t\tusage();\t\t\tbreak;\t\tcase 'r':\t\t\t\t\trowsperstrip = atoi(optarg);\t\t\tbreak;\t\tcase 'R':\t\t\tRED = PCT(atoi(optarg));\t\t\tbreak;\t\tcase 'G':\t\t\tGREEN = PCT(atoi(optarg));\t\t\tbreak;\t\tcase 'B':\t\t\tBLUE = PCT(atoi(optarg));\t\t\tbreak;\t\tcase '?':\t\t\tusage();\t\t\t\t\t}\tif (argc - optind < 2)\t\tusage();\tin = TIFFOpen(argv[optind], \"r\");\tif (in == NULL)\t\treturn (-1);\tphotometric = 0;\tTIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric);\tif (photometric != PHOTOMETRIC_RGB && photometric != PHOTOMETRIC_PALETTE ) {\t\tfprintf(stderr,\t    \"%s: Bad photometric; can only handle RGB and Palette images.\\n\",\t\t    argv[optind]);\t\treturn (-1);\t}\tTIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\tif (samplesperpixel != 1 && samplesperpixel != 3) {\t\tfprintf(stderr, \"%s: Bad samples/pixel %u.\\n\",\t\t    argv[optind], samplesperpixel);\t\treturn (-1);\t}\tTIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\tif (bitspersample != 8) {\t\tfprintf(stderr,\t\t    \" %s: Sorry, only handle 8-bit samples.\\n\", argv[optind]);\t\treturn (-1);\t}\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w);\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &h);\tTIFFGetField(in, TIFFTAG_PLANARCONFIG, &config);\tout = TIFFOpen(argv[optind+1], \"w\");\tif (out == NULL)\t\treturn (-1);\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, w);\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, h);\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 1);\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\tcpTags(in, out);\tif (compression != (uint16) -1) {\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\t\tswitch (compression) {\t\tcase COMPRESSION_JPEG:\t\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\t\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\t\t\tbreak;\t\tcase COMPRESSION_LZW:\t\tcase COMPRESSION_DEFLATE:\t\t\tif (predictor != 0)\t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\t\t\tbreak;\t\t}\t}\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\tsprintf(thing, \"B&W version of %s\", argv[optind]);\tTIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, thing);\tTIFFSetField(out, TIFFTAG_SOFTWARE, \"tiff2bw\");\toutbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(out));\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\t    TIFFDefaultStripSize(out, rowsperstrip));#define\tpack(a,b)\t((a)<<8 | (b))\tswitch (pack(photometric, config)) {\tcase pack(PHOTOMETRIC_PALETTE, PLANARCONFIG_CONTIG):\tcase pack(PHOTOMETRIC_PALETTE, PLANARCONFIG_SEPARATE):\t\tTIFFGetField(in, TIFFTAG_COLORMAP, &red, &green, &blue);\t\t\t\tif (checkcmap(in, 1<<bitspersample, red, green, blue) == 16) {\t\t\tint i;#define\tCVT(x)\t\t(((x) * 255L) / ((1L<<16)-1))\t\t\tfor (i = (1<<bitspersample)-1; i >= 0; i--) {\t\t\t\tred[i] = CVT(red[i]);\t\t\t\tgreen[i] = CVT(green[i]);\t\t\t\tblue[i] = CVT(blue[i]);\t\t\t}#undef CVT\t\t}\t\tinbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\t\tfor (row = 0; row < h; row++) {\t\t\tif (TIFFReadScanline(in, inbuf, row, 0) < 0)\t\t\t\tbreak;\t\t\tcompresspalette(outbuf, inbuf, w, red, green, blue);\t\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0)\t\t\t\tbreak;\t\t}\t\tbreak;\tcase pack(PHOTOMETRIC_RGB, PLANARCONFIG_CONTIG):\t\tinbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\t\tfor (row = 0; row < h; row++) {\t\t\tif (TIFFReadScanline(in, inbuf, row, 0) < 0)\t\t\t\tbreak;\t\t\tcompresscontig(outbuf, inbuf, w);\t\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0)\t\t\t\tbreak;\t\t}\t\tbreak;\tcase pack(PHOTOMETRIC_RGB, PLANARCONFIG_SEPARATE):\t\trowsize = TIFFScanlineSize(in);\t\tinbuf = (unsigned char *)_TIFFmalloc(3*rowsize);\t\tfor (row = 0; row < h; row++) {\t\t\tfor (s = 0; s < 3; s++)\t\t\t\tif (TIFFReadScanline(in,\t\t\t\t    inbuf+s*rowsize, row, s) < 0)\t\t\t\t\t return (-1);\t\t\tcompresssep(outbuf,\t\t\t    inbuf, inbuf+rowsize, inbuf+2*rowsize, w);\t\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0)\t\t\t\tbreak;\t\t}\t\tbreak;\t}#undef pack\tTIFFClose(out);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int_TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c){\treturn (memcmp(p1, p2, (size_t) c));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static uint64 t2p_seekproc(thandle_t handle, uint64 offset, int whence) { \tT2P *t2p = (T2P*) handle;\tif (t2p->outputdisable <= 0 && t2p->outputfile)\t\treturn _TIFF_fseek_f(t2p->outputfile, (_TIFF_off_t) offset, whence);\treturn offset;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intprocessCompressOptions(char* opt)  {  char* cp = NULL;  if (strneq(opt, \"none\",4))    {    defcompression = COMPRESSION_NONE;    }  else if (streq(opt, \"packbits\"))    {    defcompression = COMPRESSION_PACKBITS;    }  else if (strneq(opt, \"jpeg\", 4))    {    cp = strchr(opt, ':');    defcompression = COMPRESSION_JPEG;    while (cp)      {      if (isdigit((int)cp[1]))\tquality = atoi(cp + 1);      else if (strneq(cp + 1, \"raw\", 3 ))\tjpegcolormode = JPEGCOLORMODE_RAW;      else if (strneq(cp + 1, \"rgb\", 3 ))\tjpegcolormode = JPEGCOLORMODE_RGB;      else\tusage();      cp = strchr(cp + 1, ':');      }    }  else if (strneq(opt, \"g3\", 2))    {    processG3Options(opt);    defcompression = COMPRESSION_CCITTFAX3;    }  else if (streq(opt, \"g4\"))    {    defcompression = COMPRESSION_CCITTFAX4;    }  else if (strneq(opt, \"lzw\", 3))    {    cp = strchr(opt, ':');    if (cp)      defpredictor = atoi(cp+1);    defcompression = COMPRESSION_LZW;    }  else if (strneq(opt, \"zip\", 3))    {    cp = strchr(opt, ':');    if (cp)      defpredictor = atoi(cp+1);    defcompression = COMPRESSION_ADOBE_DEFLATE;   }  else    return (0);  return (1);  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(int code){\tchar buf[BUFSIZ];\tint i;\tsetbuf(stderr, buf);        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\tfor (i = 0; stuff[i] != NULL; i++)\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\texit(code);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void_TIFFPrintField(FILE* fd, const TIFFField *fip,\t\tuint32 value_count, void *raw_data){\tuint32 j;\tfprintf(fd, \"  %s: \", fip->field_name);\tfor(j = 0; j < value_count; j++) {\t\tif(fip->field_type == TIFF_BYTE)\t\t\tfprintf(fd, \"%u\", ((uint8 *) raw_data)[j]);\t\telse if(fip->field_type == TIFF_UNDEFINED)\t\t\tfprintf(fd, \"0x%x\",\t\t\t    (unsigned int) ((unsigned char *) raw_data)[j]);\t\telse if(fip->field_type == TIFF_SBYTE)\t\t\tfprintf(fd, \"%d\", ((int8 *) raw_data)[j]);\t\telse if(fip->field_type == TIFF_SHORT)\t\t\tfprintf(fd, \"%u\", ((uint16 *) raw_data)[j]);\t\telse if(fip->field_type == TIFF_SSHORT)\t\t\tfprintf(fd, \"%d\", ((int16 *) raw_data)[j]);\t\telse if(fip->field_type == TIFF_LONG)\t\t\tfprintf(fd, \"%lu\",\t\t\t    (unsigned long)((uint32 *) raw_data)[j]);\t\telse if(fip->field_type == TIFF_SLONG)\t\t\tfprintf(fd, \"%ld\", (long)((int32 *) raw_data)[j]);\t\telse if(fip->field_type == TIFF_IFD)\t\t\tfprintf(fd, \"0x%lx\",\t\t\t\t(unsigned long)((uint32 *) raw_data)[j]);\t\telse if(fip->field_type == TIFF_RATIONAL\t\t\t|| fip->field_type == TIFF_SRATIONAL\t\t\t|| fip->field_type == TIFF_FLOAT)\t\t\tfprintf(fd, \"%f\", ((float *) raw_data)[j]);\t\telse if(fip->field_type == TIFF_LONG8)#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\t\tfprintf(fd, \"%I64u\",\t\t\t    (unsigned __int64)((uint64 *) raw_data)[j]);#else\t\t\tfprintf(fd, \"%llu\",\t\t\t    (unsigned long long)((uint64 *) raw_data)[j]);#endif\t\telse if(fip->field_type == TIFF_SLONG8)#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\t\tfprintf(fd, \"%I64d\", (__int64)((int64 *) raw_data)[j]);#else\t\t\tfprintf(fd, \"%lld\", (long long)((int64 *) raw_data)[j]);#endif\t\telse if(fip->field_type == TIFF_IFD8)#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\t\tfprintf(fd, \"0x%I64x\",\t\t\t\t(unsigned __int64)((uint64 *) raw_data)[j]);#else\t\t\tfprintf(fd, \"0x%llx\",\t\t\t\t(unsigned long long)((uint64 *) raw_data)[j]);#endif\t\telse if(fip->field_type == TIFF_FLOAT)\t\t\tfprintf(fd, \"%f\", ((float *)raw_data)[j]);\t\telse if(fip->field_type == TIFF_DOUBLE)\t\t\tfprintf(fd, \"%f\", ((double *) raw_data)[j]);\t\telse if(fip->field_type == TIFF_ASCII) {\t\t\tfprintf(fd, \"%s\", (char *) raw_data);\t\t\tbreak;\t\t}\t\telse {\t\t\tfprintf(fd, \"<unsupported data type in TIFFPrint>\");\t\t\tbreak;\t\t}\t\tif(j < value_count - 1)\t\t\tfprintf(fd, \",\");\t}\tfprintf(fd, \"\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidswapBytesInScanline(void *buf, uint32 width, TIFFDataType dtype){\tswitch (dtype) {\t\tcase TIFF_SHORT:\t\tcase TIFF_SSHORT:\t\t\tTIFFSwabArrayOfShort((uint16*)buf,                                             (unsigned long)width);\t\t\tbreak;\t\tcase TIFF_LONG:\t\tcase TIFF_SLONG:\t\t\tTIFFSwabArrayOfLong((uint32*)buf,                                            (unsigned long)width);\t\t\tbreak;\t\t\t\t\tcase TIFF_DOUBLE:\t\t\tTIFFSwabArrayOfDouble((double*)buf,                                              (unsigned long)width);\t\t\tbreak;\t\tdefault:\t\t\tbreak;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type){\tswitch (type) {\tcase TIFF_SHORT:\t\tif (count == 1) {\t\t\tuint16 shortv;\t\t\tCopyField(tag, shortv);\t\t} else if (count == 2) {\t\t\tuint16 shortv1, shortv2;\t\t\tCopyField2(tag, shortv1, shortv2);\t\t} else if (count == 4) {\t\t\tuint16 *tr, *tg, *tb, *ta;\t\t\tCopyField4(tag, tr, tg, tb, ta);\t\t} else if (count == (uint16) -1) {\t\t\tuint16 shortv1;\t\t\tuint16* shortav;\t\t\tCopyField2(tag, shortv1, shortav);\t\t}\t\tbreak;\tcase TIFF_LONG:\t\t{ uint32 longv;\t\t  CopyField(tag, longv);\t\t}\t\tbreak;\tcase TIFF_RATIONAL:\t\tif (count == 1) {\t\t\tfloat floatv;\t\t\tCopyField(tag, floatv);\t\t} else if (count == (uint16) -1) {\t\t\tfloat* floatav;\t\t\tCopyField(tag, floatav);\t\t}\t\tbreak;\tcase TIFF_ASCII:\t\t{ char* stringv;\t\t  CopyField(tag, stringv);\t\t}\t\tbreak;\tcase TIFF_DOUBLE:\t\tif (count == 1) {\t\t\tdouble doublev;\t\t\tCopyField(tag, doublev);\t\t} else if (count == (uint16) -1) {\t\t\tdouble* doubleav;\t\t\tCopyField(tag, doubleav);\t\t}\t\tbreak;          default:                TIFFError(TIFFFileName(in),                          \"Data type %d is not supported, tag %d skipped\",                          tag, type);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int_TIFFNoTileEncode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s){\t(void) pp; (void) cc; (void) s;\treturn (TIFFNoEncode(tif, \"tile\"));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidNextProc(){    PageProc(ButtonNextPage);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void* _TIFFcalloc(tmsize_t nmemb, tmsize_t siz){    if( nmemb == 0 || siz == 0 )        return ((void *) NULL);    return calloc((size_t) nmemb, (size_t)siz);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcvtClump(unsigned char* op, uint32* raster, uint32 ch, uint32 cw, uint32 w){\tfloat Y, Cb = 0, Cr = 0;\tuint32 j, k;\t\tfor (k = 0; k < ch; k++) {\t\tfor (j = 0; j < cw; j++) {\t\t\tuint32 RGB = (raster - k*w)[j];\t\t\tY = lumaRed[TIFFGetR(RGB)] +\t\t\t    lumaGreen[TIFFGetG(RGB)] +\t\t\t    lumaBlue[TIFFGetB(RGB)];\t\t\t\t\t\tCb += (TIFFGetB(RGB) - Y) * D1;\t\t\tCr += (TIFFGetR(RGB) - Y) * D2;\t\t\t\t\t\t*op++ = V2Code(Y,\t\t\t    refBlackWhite[0], refBlackWhite[1], 255);\t\t}\t\tfor (; j < horizSubSampling; j++)\t\t\t*op++ = Yzero;\t}\tfor (; k < vertSubSampling; k++) {\t\tfor (j = 0; j < horizSubSampling; j++)\t\t\t*op++ = Yzero;\t}\t\t*op++ = V2Code(Cb / (ch*cw), refBlackWhite[2], refBlackWhite[3], 127);\t*op++ = V2Code(Cr / (ch*cw), refBlackWhite[4], refBlackWhite[5], 127);}",
        "label": 1,
        "cve": "cve-2016-3624"
    },
    {
        "code": "static intCheckLongTag(TIFF* tif1, TIFF* tif2, int tag, char* name){\tuint32 v1, v2;\tCHECK(v1 == v2, \"%s: %u %u\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int _TIFF_vsnprintf_f(char* str, size_t size, const char* format, va_list ap){  int count = -1;  if (size != 0)    count = _vsnprintf_s(str, size, _TRUNCATE, format, ap);  if (count == -1)    count = _vscprintf(format, ap);  return count;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void TIFFSetClientInfo( TIFF *tif, void *data, const char *name ){    TIFFClientInfoLink *psLink = tif->tif_clientinfo;        while( psLink != NULL && strcmp(psLink->name,name) != 0 )        psLink = psLink->next;    if( psLink != NULL )    {        psLink->data = data;        return;    }        psLink = (TIFFClientInfoLink *) _TIFFmalloc(sizeof(TIFFClientInfoLink));    assert (psLink != NULL);    psLink->next = tif->tif_clientinfo;    psLink->name = (char *) _TIFFmalloc((tmsize_t)(strlen(name)+1));    assert (psLink->name != NULL);    strcpy(psLink->name, name);    psLink->data = data;    tif->tif_clientinfo = psLink;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "extern off_t lseek(int fd, off_t offset, int whence){\tint absolute = 0;\tswitch (whence)\t{\t\tcase SEEK_SET:\t\t{\t\t\tabsolute = (int) offset;\t\t\tbreak;\t\t}\t\tcase SEEK_CUR:\t\t{\t\t\tabsolute = osargs_read_ptr((os_f) fd) + (int) offset;\t\t\tbreak;\t\t}\t\tcase SEEK_END:\t\t{\t\t\tabsolute = osargs_read_ext((os_f) fd) + (int) offset;\t\t\tbreak;\t\t}\t}\tosargs_set_ptr((os_f) fd, absolute);\treturn ((off_t) osargs_read_ptr((os_f) fd));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char* argv[]){\tunsigned char* buf;\tlong row;\ttsize_t linebytes, scanline;\tTIFF *out;\tFILE *in;\tstruct rasterfile h;\tuint16 photometric;\tuint16 config = PLANARCONFIG_CONTIG;\tuint32 rowsperstrip = (uint32) -1;\tint c;#if !HAVE_DECL_OPTARG\textern int optind;\textern char* optarg;#endif\twhile ((c = getopt(argc, argv, \"c:r:h\")) != -1)\t\tswitch (c) {\t\tcase 'c':\t\t\t\t\tif (!processCompressOptions(optarg))\t\t\t\tusage();\t\t\tbreak;\t\tcase 'r':\t\t\t\t\trowsperstrip = atoi(optarg);\t\t\tbreak;\t\tcase 'h':\t\t\tusage();\t\t\t\t\t}\tif (argc - optind != 2)\t\tusage();\tin = fopen(argv[optind], \"rb\");\tif (in == NULL) {\t\tfprintf(stderr, \"%s: Can not open.\\n\", argv[optind]);\t\treturn (-1);\t}\tif (fread(&h, sizeof (h), 1, in) != 1) {\t\tfprintf(stderr, \"%s: Can not read header.\\n\", argv[optind]);\t\tfclose(in);\t\treturn (-2);\t}\tif (strcmp(h.ras_magic, RAS_MAGIC) == 0) {#ifndef WORDS_BIGENDIAN\t\t\tTIFFSwabLong((uint32 *)&h.ras_width);\t\t\tTIFFSwabLong((uint32 *)&h.ras_height);\t\t\tTIFFSwabLong((uint32 *)&h.ras_depth);\t\t\tTIFFSwabLong((uint32 *)&h.ras_length);\t\t\tTIFFSwabLong((uint32 *)&h.ras_type);\t\t\tTIFFSwabLong((uint32 *)&h.ras_maptype);\t\t\tTIFFSwabLong((uint32 *)&h.ras_maplength);#endif\t} else if (strcmp(h.ras_magic, RAS_MAGIC_INV) == 0) {#ifdef WORDS_BIGENDIAN\t\t\tTIFFSwabLong((uint32 *)&h.ras_width);\t\t\tTIFFSwabLong((uint32 *)&h.ras_height);\t\t\tTIFFSwabLong((uint32 *)&h.ras_depth);\t\t\tTIFFSwabLong((uint32 *)&h.ras_length);\t\t\tTIFFSwabLong((uint32 *)&h.ras_type);\t\t\tTIFFSwabLong((uint32 *)&h.ras_maptype);\t\t\tTIFFSwabLong((uint32 *)&h.ras_maplength);#endif\t} else {\t\tfprintf(stderr, \"%s: Not a rasterfile.\\n\", argv[optind]);\t\tfclose(in);\t\treturn (-3);\t}        if ((h.ras_width <= 0) || (h.ras_width >= INT_MAX) ||            (h.ras_height <= 0) || (h.ras_height >= INT_MAX) ||            (h.ras_depth <= 0) || (h.ras_depth >= INT_MAX) ||            (h.ras_length <= 0) || (h.ras_length >= INT_MAX) ||            (h.ras_type <= 0) ||            (h.ras_maptype <= 0) ||            (h.ras_maplength <= 0) || (h.ras_maplength >= INT_MAX)) {                fprintf(stderr, \"%s: Improper image header.\\n\", argv[optind]);                fclose(in);\t\treturn (-2);        }        if ((h.ras_depth != 1) &&            (h.ras_depth != 8) &&            (h.ras_depth != 24)) {                fprintf(stderr, \"%s: Improper image depth (%d).\\n\",                        argv[optind], h.ras_depth);                fclose(in);\t\treturn (-2);        }\tout = TIFFOpen(argv[optind+1], \"w\");\tif (out == NULL)\t{\t\tfclose(in);\t\treturn (-4);\t}\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, (uint32) h.ras_width);\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, (uint32) h.ras_height);\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, h.ras_depth > 8 ? 3 : 1);\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, h.ras_depth > 1 ? 8 : 1);\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\tif (h.ras_maptype != RMT_NONE) {\t\tuint16* red;\t\tregister uint16* map;\t\tregister int i, j;\t\tint mapsize;\t\tbuf = (unsigned char *)_TIFFmalloc(h.ras_maplength);\t\tif (buf == NULL) {\t\t\tfprintf(stderr, \"No space to read in colormap.\\n\");\t\t\treturn (-5);\t\t}\t\tif (fread(buf, h.ras_maplength, 1, in) != 1) {\t\t\tfprintf(stderr, \"%s: Read error on colormap.\\n\",\t\t\t    argv[optind]);\t\t\treturn (-6);\t\t}\t\tmapsize = 1<<h.ras_depth; \t\tif (h.ras_maplength > mapsize*3) {\t\t\tfprintf(stderr,\t\t\t    \"%s: Huh, %d colormap entries, should be %d?\\n\",\t\t\t    argv[optind], h.ras_maplength, mapsize*3);\t\t\treturn (-7);\t\t}\t\tred = (uint16*)_TIFFmalloc(mapsize * 3 * sizeof (uint16));\t\tif (red == NULL) {\t\t\tfprintf(stderr, \"No space for colormap.\\n\");\t\t\treturn (-8);\t\t}\t\tmap = red;\t\tfor (j = 0; j < 3; j++) {#define\tSCALE(x)\t(((x)*((1L<<16)-1))/255)\t\t\tfor (i = h.ras_maplength/3; i-- > 0;)\t\t\t\t*map++ = SCALE(*buf++);\t\t\tif ((i = h.ras_maplength/3) < mapsize) {\t\t\t\ti = mapsize - i;\t\t\t\t_TIFFmemset(map, 0, i*sizeof (uint16));\t\t\t\tmap += i;\t\t\t}\t\t}\t\tTIFFSetField(out, TIFFTAG_COLORMAP,\t\t     red, red + mapsize, red + 2*mapsize);\t\tphotometric = PHOTOMETRIC_PALETTE;\t\tif (compression == (uint16) -1)\t\t\tcompression = COMPRESSION_PACKBITS;\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\t} else {\t\t\t\tphotometric = h.ras_depth == 24 ?\t\t    PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\t\tif (compression == (uint16) -1)\t\t\tcompression = COMPRESSION_LZW;\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\t}\tswitch (compression) {\tcase COMPRESSION_JPEG:\t\tif (photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB)\t\t\tphotometric = PHOTOMETRIC_YCBCR;\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\t\tbreak;\tcase COMPRESSION_LZW:\tcase COMPRESSION_DEFLATE:\t\tif (predictor != 0)\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\t\tbreak;\t}\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\tlinebytes = ((h.ras_depth*h.ras_width+15) >> 3) &~ 1;\tscanline = TIFFScanlineSize(out);\tif (scanline > linebytes) {\t\tbuf = (unsigned char *)_TIFFmalloc(scanline);\t\t_TIFFmemset(buf+linebytes, 0, scanline-linebytes);\t} else\t\tbuf = (unsigned char *)_TIFFmalloc(linebytes);\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\t    TIFFDefaultStripSize(out, rowsperstrip));\tfor (row = 0; row < h.ras_height; row++) {\t\tif (fread(buf, linebytes, 1, in) != 1) {\t\t\tfprintf(stderr, \"%s: scanline %ld: Read error.\\n\",\t\t\t    argv[optind], row);\t\t\tbreak;\t\t}\t\tif (h.ras_type == RT_STANDARD && h.ras_depth == 24) {\t\t\ttsize_t cc = h.ras_width;\t\t\tunsigned char* cp = buf;#define\tSWAP(a,b)\t{ unsigned char t = (a); (a) = (b); (b) = t; }\t\t\tdo {\t\t\t\tSWAP(cp[0], cp[2]);\t\t\t\tcp += 3;\t\t\t} while (--cc);\t\t}\t\tif (TIFFWriteScanline(out, buf, row, 0) < 0)\t\t\tbreak;\t}\t(void) TIFFClose(out);\tfclose(in);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcheckTag(TIFF* tif1, TIFF* tif2, int tag, char* name, void* p1, void* p2){\tif (TIFFGetField(tif1, tag, p1)) {\t\tif (!TIFFGetField(tif2, tag, p2)) {\t\t\tprintf(\"%s tag appears only in %s\\n\",\t\t\t    name, TIFFFileName(tif1));\t\t\treturn (0);\t\t}\t\treturn (1);\t} else if (TIFFGetField(tif2, tag, p2)) {\t\tprintf(\"%s tag appears only in %s\\n\", name, TIFFFileName(tif2));\t\treturn (0);\t}\treturn (-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void chstore(char *string,int max,char ch){  char c;  if(_p_tokpos>=0&&_p_tokpos<max-1)    {      if(_p_state==IN_QUOTE)        c=ch;      else        switch(_p_flag&3)          {          case 1: \t                c=toupper((int) ch);            break;          case 2: \t                c=tolower((int) ch);            break;          default:\t                c=ch;            break;          }      string[_p_tokpos++]=c;    }  return;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFCvtIEEEDoubleToNative(TIFF* tif, u_int n, double* f){\tdouble_t* fp = (double_t*) f;\twhile (n-- > 0) {\t\tIEEEDOUBLE2NATIVE(fp);\t\tfp++;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap){\tTIFFDirectory* td = &tif->tif_dir;\tint ret_val = 1;\tuint32 standard_tag = tag;\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\tif( fip == NULL ) \t    return 0;\t\t\tif (fip->field_bit == FIELD_CUSTOM) {\t\tstandard_tag = 0;\t}\tswitch (standard_tag) {\t\tcase TIFFTAG_SUBFILETYPE:\t\t\t*va_arg(ap, uint32*) = td->td_subfiletype;\t\t\tbreak;\t\tcase TIFFTAG_IMAGEWIDTH:\t\t\t*va_arg(ap, uint32*) = td->td_imagewidth;\t\t\tbreak;\t\tcase TIFFTAG_IMAGELENGTH:\t\t\t*va_arg(ap, uint32*) = td->td_imagelength;\t\t\tbreak;\t\tcase TIFFTAG_BITSPERSAMPLE:\t\t\t*va_arg(ap, uint16*) = td->td_bitspersample;\t\t\tbreak;\t\tcase TIFFTAG_COMPRESSION:\t\t\t*va_arg(ap, uint16*) = td->td_compression;\t\t\tbreak;\t\tcase TIFFTAG_PHOTOMETRIC:\t\t\t*va_arg(ap, uint16*) = td->td_photometric;\t\t\tbreak;\t\tcase TIFFTAG_THRESHHOLDING:\t\t\t*va_arg(ap, uint16*) = td->td_threshholding;\t\t\tbreak;\t\tcase TIFFTAG_FILLORDER:\t\t\t*va_arg(ap, uint16*) = td->td_fillorder;\t\t\tbreak;\t\tcase TIFFTAG_ORIENTATION:\t\t\t*va_arg(ap, uint16*) = td->td_orientation;\t\t\tbreak;\t\tcase TIFFTAG_SAMPLESPERPIXEL:\t\t\t*va_arg(ap, uint16*) = td->td_samplesperpixel;\t\t\tbreak;\t\tcase TIFFTAG_ROWSPERSTRIP:\t\t\t*va_arg(ap, uint32*) = td->td_rowsperstrip;\t\t\tbreak;\t\tcase TIFFTAG_MINSAMPLEVALUE:\t\t\t*va_arg(ap, uint16*) = td->td_minsamplevalue;\t\t\tbreak;\t\tcase TIFFTAG_MAXSAMPLEVALUE:\t\t\t*va_arg(ap, uint16*) = td->td_maxsamplevalue;\t\t\tbreak;\t\tcase TIFFTAG_SMINSAMPLEVALUE:\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\t\t\t\t*va_arg(ap, double**) = td->td_sminsamplevalue;\t\t\telse\t\t\t{\t\t\t\t\t\t\t\tuint16 i;\t\t\t\tdouble v = td->td_sminsamplevalue[0];\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\t\t\t\t\tif( td->td_sminsamplevalue[i] < v )\t\t\t\t\t\tv = td->td_sminsamplevalue[i];\t\t\t\t*va_arg(ap, double*) = v;\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\t\t\t\t*va_arg(ap, double**) = td->td_smaxsamplevalue;\t\t\telse\t\t\t{\t\t\t\t\t\t\t\tuint16 i;\t\t\t\tdouble v = td->td_smaxsamplevalue[0];\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\t\t\t\t\tif( td->td_smaxsamplevalue[i] > v )\t\t\t\t\t\tv = td->td_smaxsamplevalue[i];\t\t\t\t*va_arg(ap, double*) = v;\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_XRESOLUTION:\t\t\t*va_arg(ap, float*) = td->td_xresolution;\t\t\tbreak;\t\tcase TIFFTAG_YRESOLUTION:\t\t\t*va_arg(ap, float*) = td->td_yresolution;\t\t\tbreak;\t\tcase TIFFTAG_PLANARCONFIG:\t\t\t*va_arg(ap, uint16*) = td->td_planarconfig;\t\t\tbreak;\t\tcase TIFFTAG_XPOSITION:\t\t\t*va_arg(ap, float*) = td->td_xposition;\t\t\tbreak;\t\tcase TIFFTAG_YPOSITION:\t\t\t*va_arg(ap, float*) = td->td_yposition;\t\t\tbreak;\t\tcase TIFFTAG_RESOLUTIONUNIT:\t\t\t*va_arg(ap, uint16*) = td->td_resolutionunit;\t\t\tbreak;\t\tcase TIFFTAG_PAGENUMBER:\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[0];\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[1];\t\t\tbreak;\t\tcase TIFFTAG_HALFTONEHINTS:\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[0];\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[1];\t\t\tbreak;\t\tcase TIFFTAG_COLORMAP:\t\t\t*va_arg(ap, uint16**) = td->td_colormap[0];\t\t\t*va_arg(ap, uint16**) = td->td_colormap[1];\t\t\t*va_arg(ap, uint16**) = td->td_colormap[2];\t\t\tbreak;\t\tcase TIFFTAG_STRIPOFFSETS:\t\tcase TIFFTAG_TILEOFFSETS:\t\t\t_TIFFFillStriles( tif );\t\t\t*va_arg(ap, uint64**) = td->td_stripoffset;\t\t\tbreak;\t\tcase TIFFTAG_STRIPBYTECOUNTS:\t\tcase TIFFTAG_TILEBYTECOUNTS:\t\t\t_TIFFFillStriles( tif );\t\t\t*va_arg(ap, uint64**) = td->td_stripbytecount;\t\t\tbreak;\t\tcase TIFFTAG_MATTEING:\t\t\t*va_arg(ap, uint16*) =\t\t\t    (td->td_extrasamples == 1 &&\t\t\t    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\t\t\tbreak;\t\tcase TIFFTAG_EXTRASAMPLES:\t\t\t*va_arg(ap, uint16*) = td->td_extrasamples;\t\t\t*va_arg(ap, uint16**) = td->td_sampleinfo;\t\t\tbreak;\t\tcase TIFFTAG_TILEWIDTH:\t\t\t*va_arg(ap, uint32*) = td->td_tilewidth;\t\t\tbreak;\t\tcase TIFFTAG_TILELENGTH:\t\t\t*va_arg(ap, uint32*) = td->td_tilelength;\t\t\tbreak;\t\tcase TIFFTAG_TILEDEPTH:\t\t\t*va_arg(ap, uint32*) = td->td_tiledepth;\t\t\tbreak;\t\tcase TIFFTAG_DATATYPE:\t\t\tswitch (td->td_sampleformat) {\t\t\t\tcase SAMPLEFORMAT_UINT:\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_UINT;\t\t\t\t\tbreak;\t\t\t\tcase SAMPLEFORMAT_INT:\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_INT;\t\t\t\t\tbreak;\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_IEEEFP;\t\t\t\t\tbreak;\t\t\t\tcase SAMPLEFORMAT_VOID:\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_VOID;\t\t\t\t\tbreak;\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_SAMPLEFORMAT:\t\t\t*va_arg(ap, uint16*) = td->td_sampleformat;\t\t\tbreak;\t\tcase TIFFTAG_IMAGEDEPTH:\t\t\t*va_arg(ap, uint32*) = td->td_imagedepth;\t\t\tbreak;\t\tcase TIFFTAG_SUBIFD:\t\t\t*va_arg(ap, uint16*) = td->td_nsubifd;\t\t\t*va_arg(ap, uint64**) = td->td_subifd;\t\t\tbreak;\t\tcase TIFFTAG_YCBCRPOSITIONING:\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrpositioning;\t\t\tbreak;\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];\t\t\tbreak;\t\tcase TIFFTAG_TRANSFERFUNCTION:\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[0];\t\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[1];\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[2];\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\t\t\t*va_arg(ap, float**) = td->td_refblackwhite;\t\t\tbreak;\t\tcase TIFFTAG_INKNAMES:\t\t\t*va_arg(ap, char**) = td->td_inknames;\t\t\tbreak;\t\tdefault:\t\t\t{\t\t\t\tint i;\t\t\t\t\t\t\t\tif( fip->field_bit != FIELD_CUSTOM )\t\t\t\t{\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFVGetField\",\t\t\t\t\t    \"%s: Invalid %stag \\\"%s\\\" \"\t\t\t\t\t    \"(not supported by codec)\",\t\t\t\t\t    tif->tif_name,\t\t\t\t\t    isPseudoTag(tag) ? \"pseudo-\" : \"\",\t\t\t\t\t    fip->field_name);\t\t\t\t\tret_val = 0;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\t\t\t\t\tret_val = 0;\t\t\t\tfor (i = 0; i < td->td_customValueCount; i++) {\t\t\t\t\tTIFFTagValue *tv = td->td_customValues + i;\t\t\t\t\tif (tv->info->field_tag != tag)\t\t\t\t\t\tcontinue;\t\t\t\t\tif (fip->field_passcount) {\t\t\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2)\t\t\t\t\t\t\t*va_arg(ap, uint32*) = (uint32)tv->count;\t\t\t\t\t\telse  \t\t\t\t\t\t\t*va_arg(ap, uint16*) = (uint16)tv->count;\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\t\t\t\t\t\tret_val = 1;\t\t\t\t\t} else if (fip->field_tag == TIFFTAG_DOTRANGE\t\t\t\t\t\t   && strcmp(fip->field_name,\"DotRange\") == 0) {\t\t\t\t\t\t\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];\t\t\t\t\t\tret_val = 1;\t\t\t\t\t} else {\t\t\t\t\t\tif (fip->field_type == TIFF_ASCII\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2\t\t\t\t\t\t    || fip->field_readcount == TIFF_SPP\t\t\t\t\t\t    || tv->count > 1) {\t\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t} else {\t\t\t\t\t\t\tchar *val = (char *)tv->value;\t\t\t\t\t\t\tassert( tv->count == 1 );\t\t\t\t\t\t\tswitch (fip->field_type) {\t\t\t\t\t\t\tcase TIFF_BYTE:\t\t\t\t\t\t\tcase TIFF_UNDEFINED:\t\t\t\t\t\t\t\t*va_arg(ap, uint8*) =\t\t\t\t\t\t\t\t\t*(uint8 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SBYTE:\t\t\t\t\t\t\t\t*va_arg(ap, int8*) =\t\t\t\t\t\t\t\t\t*(int8 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SHORT:\t\t\t\t\t\t\t\t*va_arg(ap, uint16*) =\t\t\t\t\t\t\t\t\t*(uint16 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SSHORT:\t\t\t\t\t\t\t\t*va_arg(ap, int16*) =\t\t\t\t\t\t\t\t\t*(int16 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_LONG:\t\t\t\t\t\t\tcase TIFF_IFD:\t\t\t\t\t\t\t\t*va_arg(ap, uint32*) =\t\t\t\t\t\t\t\t\t*(uint32 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SLONG:\t\t\t\t\t\t\t\t*va_arg(ap, int32*) =\t\t\t\t\t\t\t\t\t*(int32 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_LONG8:\t\t\t\t\t\t\tcase TIFF_IFD8:\t\t\t\t\t\t\t\t*va_arg(ap, uint64*) =\t\t\t\t\t\t\t\t\t*(uint64 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SLONG8:\t\t\t\t\t\t\t\t*va_arg(ap, int64*) =\t\t\t\t\t\t\t\t\t*(int64 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_RATIONAL:\t\t\t\t\t\t\tcase TIFF_SRATIONAL:\t\t\t\t\t\t\tcase TIFF_FLOAT:\t\t\t\t\t\t\t\t*va_arg(ap, float*) =\t\t\t\t\t\t\t\t\t*(float *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_DOUBLE:\t\t\t\t\t\t\t\t*va_arg(ap, double*) =\t\t\t\t\t\t\t\t\t*(double *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tdefault:\t\t\t\t\t\t\t\tret_val = 0;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t}\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t}\treturn(ret_val);}",
        "label": 1,
        "cve": "cve-2016-3632"
    },
    {
        "code": "static intFax4Decode(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s){\tDECLARE_STATE_2D(tif, sp, \"Fax4Decode\");        int line = 0;\t(void) s;\tCACHE_STATE(tif, sp);\twhile ((long)occ > 0) {\t\ta0 = 0;\t\tRunLength = 0;\t\tpa = thisrun = sp->curruns;\t\tpb = sp->refruns;\t\tb1 = *pb++;#ifdef FAX3_DEBUG\t\tprintf(\"\\nBitAcc=%08X, BitsAvail = %d\\n\", BitAcc, BitsAvail);\t\tprintf(\"-------------------- %d\\n\", tif->tif_row);\t\tfflush(stdout);#endif\t\tEXPAND2D(EOFG4);                if (EOLcnt)                    goto EOFG4;\t\t(*sp->fill)(buf, thisrun, pa, lastx);\t\tSETVALUE(0);\t\t\t\tSWAP(uint32*, sp->curruns, sp->refruns);\t\tbuf += sp->b.rowbytes;\t\tocc -= sp->b.rowbytes;                line++;\t\tcontinue;\tEOFG4:                NeedBits16( 13, BADG4 );        BADG4:#ifdef FAX3_DEBUG                if( GetBits(13) != 0x1001 )                    fputs( \"Bad RTC\\n\", stderr );#endif                                ClrBits( 13 );\t\t(*sp->fill)(buf, thisrun, pa, lastx);\t\tUNCACHE_STATE(tif, sp);\t\treturn (-1);\t}\tUNCACHE_STATE(tif, sp);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize){\tchar name[256];\tstruct FAB fab;\tunsigned short channel;\tchar *inadr[2], *retadr[2];\tunsigned long status;\tlong size;\tif (no_mapped >= MAX_MAPPED)\t\treturn(0);\t\tif (getname((int)fd, name, 1) == NULL)\t\treturn(0);\t\tfab = cc$rms_fab;\tfab.fab$l_fop |= FAB$V_UFO;\tfab.fab$b_fac = FAB$M_GET;\tfab.fab$b_shr = FAB$M_SHRGET;\tfab.fab$l_fna = name;\tfab.fab$b_fns = strlen(name);\tstatus = sys$open(&fab);\t\tif ((status&1) == 0)\t\treturn(0);\tchannel = (unsigned short)fab.fab$l_stv;\tinadr[0] = inadr[1] = (char *)0; \t\tsize = _tiffSizeProc(fd);\tstatus = sys$crmpsc(inadr, retadr, 0, SEC$M_EXPREG, 0,0,0, channel,\t\tTIFFhowmany(size,512), 0,0,0);  ddd\tif ((status&1) == 0){\t\tsys$dassgn(channel);\t\treturn(0);\t}\t*pbase = (tdata_t) retadr[0];\t\t\t*psize = (toff_t) size;\t\tmap_table[no_mapped].base = retadr[0];\tmap_table[no_mapped].top = retadr[1];\tmap_table[no_mapped].channel = channel;\tno_mapped++;        return(1);}static int_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize){\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidwin3ErrorHandler(const char* module, const char* fmt, va_list ap){\tchar e[512] = { '\\0' };\tif (module != NULL)\t\tstrcat(strcpy(e, module), \":\");\tvsprintf(e+strlen(e), fmt, ap);\tstrcat(e, \".\");\tMessageBox(GetActiveWindow(), e, \"LibTIFF Error\", MB_OK|MB_ICONSTOP);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*XTIFFFdOpen(int fd, const char* name, const char* mode){\t\t_XTIFFInitialize();\t\t\treturn TIFFFdOpen(fd, name, mode);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize){\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFReadData(TIFF* tif){\tuint16 config;\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\tif (TIFFIsTiled(tif)) {\t\tif (config == PLANARCONFIG_CONTIG)\t\t\tTIFFReadContigTileData(tif);\t\telse\t\t\tTIFFReadSeparateTileData(tif);\t} else {\t\tif (config == PLANARCONFIG_CONTIG)\t\t\tTIFFReadContigStripData(tif);\t\telse\t\t\tTIFFReadSeparateStripData(tif);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "double_TIFFUInt64ToDouble(uint64 ui64){\t_Int64 i;\ti.value = ui64;\tif (i.part.high >= 0) {\t\treturn (double)i.value;\t} else {\t\tlong double df;\t\tdf = (long double)i.value;\t\tdf += 18446744073709551616.0; \t\treturn (double)df;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int t2p_tile_is_bottom_edge(T2P_TILES tiles, ttile_t tile){\tif( ((tile+1) > (tiles.tiles_tilecount-tiles.tiles_tilecountx) )\t\t&& (tiles.tiles_edgetilelength != 0) ){\t\treturn(1);\t} else {\t\treturn(0);\t}} */int t2p_tile_is_bottom_edge(T2P_TILES tiles, ttile_t tile){\tif( ((tile+1) > (tiles.tiles_tilecount-tiles.tiles_tilecountx) )\t\t&& (tiles.tiles_edgetilelength != 0) ){\t\treturn(1);\t} else {\t\treturn(0);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "    { setByteArray((void**) cpp, (void*) cp, strlen(cp)+1, 1); }void _TIFFsetNString(char** cpp, char* cp, uint32 n)    { setByteArray((void**) cpp, (void*) cp, n, 1); }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intprocessCropSelections(struct image_data *image, struct crop_mask *crop,                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])  {  int       i;  uint32    width, length, total_width, total_length;  tsize_t   cropsize;  unsigned  char *crop_buff = NULL;  unsigned  char *read_buff = NULL;  unsigned  char *next_buff = NULL;  tsize_t   prev_cropsize = 0;  read_buff = *read_buff_ptr;  if (crop->img_mode == COMPOSITE_IMAGES)    {    cropsize = crop->bufftotal;    crop_buff = seg_buffs[0].buffer;     if (!crop_buff)      crop_buff = (unsigned char *)_TIFFmalloc(cropsize);    else      {      prev_cropsize = seg_buffs[0].size;      if (prev_cropsize < cropsize)        {        next_buff = _TIFFrealloc(crop_buff, cropsize);        if (! next_buff)          {          _TIFFfree (crop_buff);          crop_buff = (unsigned char *)_TIFFmalloc(cropsize);          }        else          crop_buff = next_buff;        }      }    if (!crop_buff)      {      TIFFError(\"processCropSelections\", \"Unable to allocate/reallocate crop buffer\");      return (-1);      }    _TIFFmemset(crop_buff, 0, cropsize);    seg_buffs[0].buffer = crop_buff;    seg_buffs[0].size = cropsize;        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)      return (1);    if (crop->crop_mode & CROP_INVERT)      {      switch (crop->photometric)        {                case PHOTOMETRIC_MINISWHITE:        case PHOTOMETRIC_MINISBLACK:\t     image->photometric = crop->photometric;\t     break;        case INVERT_DATA_ONLY:        case INVERT_DATA_AND_TAG:             if (invertImage(image->photometric, image->spp, image->bps,                              crop->combined_width, crop->combined_length, crop_buff))               {               TIFFError(\"processCropSelections\",                          \"Failed to invert colorspace for composite regions\");               return (-1);               }             if (crop->photometric == INVERT_DATA_AND_TAG)               {               switch (image->photometric)                 {                 case PHOTOMETRIC_MINISWHITE: \t              image->photometric = PHOTOMETRIC_MINISBLACK;\t              break;                 case PHOTOMETRIC_MINISBLACK: \t              image->photometric = PHOTOMETRIC_MINISWHITE;\t              break;                 default:\t              break;\t         }\t       }             break;        default: break;        }      }        if (crop->crop_mode & CROP_MIRROR)      {      if (mirrorImage(image->spp, image->bps, crop->mirror,                       crop->combined_width, crop->combined_length, crop_buff))        {        TIFFError(\"processCropSelections\", \"Failed to mirror composite regions %s\", \t         (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");        return (-1);        }      }    if (crop->crop_mode & CROP_ROTATE)       {      if (rotateImage(crop->rotation, image, &crop->combined_width,                       &crop->combined_length, &crop_buff))        {        TIFFError(\"processCropSelections\",                   \"Failed to rotate composite regions by %d degrees\", crop->rotation);        return (-1);        }      seg_buffs[0].buffer = crop_buff;      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)                            * image->spp) * crop->combined_length;       }    }  else      {    total_width = total_length = 0;    for (i = 0; i < crop->selections; i++)      {      cropsize = crop->bufftotal;      crop_buff = seg_buffs[i].buffer;       if (!crop_buff)        crop_buff = (unsigned char *)_TIFFmalloc(cropsize);      else        {        prev_cropsize = seg_buffs[0].size;        if (prev_cropsize < cropsize)          {          next_buff = _TIFFrealloc(crop_buff, cropsize);          if (! next_buff)            {            _TIFFfree (crop_buff);            crop_buff = (unsigned char *)_TIFFmalloc(cropsize);            }          else            crop_buff = next_buff;          }        }      if (!crop_buff)        {        TIFFError(\"processCropSelections\", \"Unable to allocate/reallocate crop buffer\");        return (-1);        }      _TIFFmemset(crop_buff, 0, cropsize);      seg_buffs[i].buffer = crop_buff;      seg_buffs[i].size = cropsize;      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))        {\tTIFFError(\"processCropSelections\", \"Unable to extract cropped region %d from image\", i);        return (-1);        }      width  = crop->regionlist[i].width;      length = crop->regionlist[i].length;      if (crop->crop_mode & CROP_INVERT)        {        switch (crop->photometric)          {                    case PHOTOMETRIC_MINISWHITE:          case PHOTOMETRIC_MINISBLACK:\t       image->photometric = crop->photometric;\t       break;          case INVERT_DATA_ONLY:          case INVERT_DATA_AND_TAG:               if (invertImage(image->photometric, image->spp, image->bps,                                width, length, crop_buff))                 {                 TIFFError(\"processCropSelections\",                            \"Failed to invert colorspace for region\");                 return (-1);                 }               if (crop->photometric == INVERT_DATA_AND_TAG)                 {                 switch (image->photometric)                   {                   case PHOTOMETRIC_MINISWHITE: \t                image->photometric = PHOTOMETRIC_MINISBLACK;\t                break;                   case PHOTOMETRIC_MINISBLACK: \t                image->photometric = PHOTOMETRIC_MINISWHITE;\t                break;                   default:\t                break;\t           }\t         }               break;          default: break;          }        }      if (crop->crop_mode & CROP_MIRROR)        {        if (mirrorImage(image->spp, image->bps, crop->mirror,                         width, length, crop_buff))          {          TIFFError(\"processCropSelections\", \"Failed to mirror crop region %s\", \t           (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");          return (-1);          }        }      if (crop->crop_mode & CROP_ROTATE)         {\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \t\t\t&crop->regionlist[i].length, &crop_buff))          {          TIFFError(\"processCropSelections\",                     \"Failed to rotate crop region by %d degrees\", crop->rotation);          return (-1);          }        total_width  += crop->regionlist[i].width;        total_length += crop->regionlist[i].length;        crop->combined_width = total_width;        crop->combined_length = total_length;        seg_buffs[i].buffer = crop_buff;        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)                               * image->spp) * crop->regionlist[i].length;         }      }    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidSetNameLabel(){    char buffer[BUFSIZ];    Arg args[1];    if (tfMultiPage)        sprintf(buffer, \"%s - page %d\", fileName, tfDirectory);    else        strcpy(buffer, fileName);    XtSetArg(args[0], XtNlabel, buffer);    XtSetValues(labelWidget, args, 1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void t2p_unmapproc(thandle_t handle, void *data, toff_t offset){ \t(void) handle, (void) data, (void) offset;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidFax3BadLength(const char* module, TIFF* tif, uint32 line, uint32 a0, uint32 lastx){\tTIFFWarningExt(tif->tif_clientdata, module, \"%s: %s at line %lu of %s %lu (got %lu, expected %lu)\",\t    tif->tif_name,\t    a0 < lastx ? \"Premature EOL\" : \"Line length mismatch\",\t    (unsigned long) line, isTiled(tif) ? \"tile\" : \"strip\",        (unsigned long) (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),        (unsigned long) a0, lastx);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcvtRational(TIFF* tif, TIFFDirEntry* dir, uint32 num, uint32 denom, float* rv){\tif (denom == 0) {\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t    \"%s: Rational with zero denominator (num = %lu)\",\t\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name, num);\t\treturn (0);\t} else {\t\tif (dir->tdir_type == TIFF_RATIONAL)\t\t\t*rv = ((float)num / (float)denom);\t\telse\t\t\t*rv = ((float)(int32)num / (float)(int32)denom);\t\treturn (1);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int readContigTilesIntoBuffer (TIFF* in, uint8* buf,                                       uint32 imagelength,                                       uint32 imagewidth,                                       uint32 tw, uint32 tl,                                      tsample_t spp, uint16 bps)  {  int status = 1;  tsample_t sample = 0;  tsample_t count = spp;   uint32 row, col, trow;  uint32 nrow, ncol;  uint32 dst_rowsize, shift_width;  uint32 bytes_per_sample, bytes_per_pixel;  uint32 trailing_bits, prev_trailing_bits;  uint32 tile_rowsize  = TIFFTileRowSize(in);  uint32 src_offset, dst_offset;  uint32 row_offset, col_offset;  uint8 *bufp = (uint8*) buf;  unsigned char *src = NULL;  unsigned char *dst = NULL;  tsize_t tbytes = 0, tile_buffsize = 0;  tsize_t tilesize = TIFFTileSize(in);  unsigned char *tilebuf = NULL;  bytes_per_sample = (bps + 7) / 8;   bytes_per_pixel  = ((bps * spp) + 7) / 8;  if ((bps % 8) == 0)    shift_width = 0;  else    {    if (bytes_per_pixel < (bytes_per_sample + 1))      shift_width = bytes_per_pixel;    else      shift_width = bytes_per_sample + 1;    }  tile_buffsize = tilesize;  if (tilesize < (tsize_t)(tl * tile_rowsize))    {#ifdef DEBUG2    TIFFError(\"readContigTilesIntoBuffer\",\t      \"Tilesize %lu is too small, using alternate calculation %u\",              tilesize, tl * tile_rowsize);#endif    tile_buffsize = tl * tile_rowsize;    }   tilebuf = _TIFFmalloc(tile_buffsize);  if (tilebuf == 0)    return 0;  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;    for (row = 0; row < imagelength; row += tl)    {    nrow = (row + tl > imagelength) ? imagelength - row : tl;    for (col = 0; col < imagewidth; col += tw)      {      tbytes = TIFFReadTile(in, tilebuf, col, row, 0, 0);      if (tbytes < tilesize  && !ignore)        {\tTIFFError(TIFFFileName(in),\t\t  \"Error, can't read tile at row %lu col %lu, Read %lu bytes of %lu\",\t\t  (unsigned long) col, (unsigned long) row, (unsigned long)tbytes,                  (unsigned long)tilesize);\t\t  status = 0;                  _TIFFfree(tilebuf);\t\t  return status;\t}            row_offset = row * dst_rowsize;      col_offset = ((col * bps * spp) + 7)/ 8;      bufp = buf + row_offset + col_offset;      if (col + tw > imagewidth)\tncol = imagewidth - col;      else        ncol = tw;                  if (((bps % 8) == 0) && (count == spp))        {\tfor (trow = 0; trow < nrow; trow++)          {\t  src_offset = trow * tile_rowsize;\t  _TIFFmemcpy (bufp, tilebuf + src_offset, (ncol * spp * bps) / 8);          bufp += (imagewidth * bps * spp) / 8;\t  }        }      else        {\t        prev_trailing_bits = trailing_bits = 0;        trailing_bits = (ncol * bps * spp) % 8;\t\tfor (trow = 0; trow < nrow; trow++)          {\t  src_offset = trow * tile_rowsize;          src = tilebuf + src_offset;\t  dst_offset = (row + trow) * dst_rowsize;          dst = buf + dst_offset + col_offset;          switch (shift_width)            {            case 0: if (extractContigSamplesBytes (src, dst, ncol, sample,                                                   spp, bps, count, 0, ncol))                      {\t\t      TIFFError(\"readContigTilesIntoBuffer\",                                \"Unable to extract row %d from tile %lu\", \t\t\t\trow, (unsigned long)TIFFCurrentTile(in));\t\t      return 1;\t\t      }\t\t    break;            case 1: if (bps == 1)                      {                       if (extractContigSamplesShifted8bits (src, dst, ncol,                                                            sample, spp,                                                            bps, count,                                                            0, ncol,                                                            prev_trailing_bits))                        {\t\t        TIFFError(\"readContigTilesIntoBuffer\",                                  \"Unable to extract row %d from tile %lu\", \t\t\t\t  row, (unsigned long)TIFFCurrentTile(in));\t\t        return 1;\t\t        }\t\t      break;\t\t      }                    else                      if (extractContigSamplesShifted16bits (src, dst, ncol,                                                             sample, spp,                                                             bps, count,                                                             0, ncol,                                                             prev_trailing_bits))                        {\t\t        TIFFError(\"readContigTilesIntoBuffer\",                                  \"Unable to extract row %d from tile %lu\", \t\t\t  \t  row, (unsigned long)TIFFCurrentTile(in));\t\t        return 1;\t\t        }\t            break;            case 2: if (extractContigSamplesShifted24bits (src, dst, ncol,                                                           sample, spp,                                                           bps, count,                                                           0, ncol,                                                           prev_trailing_bits))                      {\t\t      TIFFError(\"readContigTilesIntoBuffer\",                                \"Unable to extract row %d from tile %lu\", \t\t  \t        row, (unsigned long)TIFFCurrentTile(in));\t\t      return 1;\t\t      }\t\t    break;            case 3:            case 4:            case 5: if (extractContigSamplesShifted32bits (src, dst, ncol,                                                           sample, spp,                                                           bps, count,                                                           0, ncol,                                                           prev_trailing_bits))                      {\t\t      TIFFError(\"readContigTilesIntoBuffer\",                                \"Unable to extract row %d from tile %lu\", \t\t\t        row, (unsigned long)TIFFCurrentTile(in));\t\t      return 1;\t\t      }\t\t    break;            default: TIFFError(\"readContigTilesIntoBuffer\", \"Unsupported bit depth %d\", bps);\t\t     return 1;\t    }          }        prev_trailing_bits += trailing_bits;        \t\t}      }    }  _TIFFfree(tilebuf);  return status;  }",
        "label": 1,
        "cve": "cve-2016-9539"
    },
    {
        "code": "static intPredictorSetupDecode(TIFF* tif){\tTIFFPredictorState* sp = PredictorState(tif);\tTIFFDirectory* td = &tif->tif_dir;\t\t\t\tif (!(*sp->setupdecode)(tif) || !PredictorSetup(tif))\t\treturn 0;\tif (sp->predictor == 2) {\t\tswitch (td->td_bitspersample) {\t\t\tcase 8:  sp->decodepfunc = horAcc8; break;\t\t\tcase 16: sp->decodepfunc = horAcc16; break;\t\t\tcase 32: sp->decodepfunc = horAcc32; break;\t\t}\t\t                if( tif->tif_decoderow != PredictorDecodeRow )                {                    sp->decoderow = tif->tif_decoderow;                    tif->tif_decoderow = PredictorDecodeRow;                    sp->decodestrip = tif->tif_decodestrip;                    tif->tif_decodestrip = PredictorDecodeTile;                    sp->decodetile = tif->tif_decodetile;                    tif->tif_decodetile = PredictorDecodeTile;                }\t\t\t\tif (tif->tif_flags & TIFF_SWAB) {\t\t\tif (sp->decodepfunc == horAcc16) {\t\t\t\tsp->decodepfunc = swabHorAcc16;\t\t\t\ttif->tif_postdecode = _TIFFNoPostDecode;            } else if (sp->decodepfunc == horAcc32) {\t\t\t\tsp->decodepfunc = swabHorAcc32;\t\t\t\ttif->tif_postdecode = _TIFFNoPostDecode;            }\t\t}\t}\telse if (sp->predictor == 3) {\t\tsp->decodepfunc = fpAcc;\t\t                if( tif->tif_decoderow != PredictorDecodeRow )                {                    sp->decoderow = tif->tif_decoderow;                    tif->tif_decoderow = PredictorDecodeRow;                    sp->decodestrip = tif->tif_decodestrip;                    tif->tif_decodestrip = PredictorDecodeTile;                    sp->decodetile = tif->tif_decodetile;                    tif->tif_decodetile = PredictorDecodeTile;                }\t\t\t\tif (tif->tif_flags & TIFF_SWAB) {\t\t\ttif->tif_postdecode = _TIFFNoPostDecode;\t\t}\t\t\t}\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover){\tstatic const char module[] = \"TIFFFetchNormalTag\";\tenum TIFFReadDirEntryErr err;\tuint32 fii;\tconst TIFFField* fip = NULL;\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);        if( fii == FAILED_FII )        {            TIFFErrorExt(tif->tif_clientdata, \"TIFFFetchNormalTag\",                         \"No definition found for tag %d\",                         dp->tdir_tag);            return 0;        }\tfip=tif->tif_fields[fii];\tassert(fip != NULL); \tassert(fip->set_field_type!=TIFF_SETGET_OTHER);  \tassert(fip->set_field_type!=TIFF_SETGET_INT);    \terr=TIFFReadDirEntryErrOk;\tswitch (fip->set_field_type)\t{\t\tcase TIFF_SETGET_UNDEFINED:\t\t\tbreak;\t\tcase TIFF_SETGET_ASCII:\t\t\t{\t\t\t\tuint8* data;\t\t\t\tassert(fip->field_passcount==0);\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tuint8* ma;\t\t\t\t\tuint32 mb;\t\t\t\t\tint n;\t\t\t\t\tma=data;\t\t\t\t\tmb=0;\t\t\t\t\twhile (mb<(uint32)dp->tdir_count)\t\t\t\t\t{\t\t\t\t\t\tif (*ma==0)\t\t\t\t\t\t\tbreak;\t\t\t\t\t\tma++;\t\t\t\t\t\tmb++;\t\t\t\t\t}\t\t\t\t\tif (mb+1<(uint32)dp->tdir_count)\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" contains null byte in value; value incorrectly truncated during reading due to implementation limitations\",fip->field_name);\t\t\t\t\telse if (mb+1>(uint32)dp->tdir_count)\t\t\t\t\t{\t\t\t\t\t\tuint8* o;\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte\",fip->field_name);\t\t\t\t\t\tif ((uint32)dp->tdir_count+1!=dp->tdir_count+1)\t\t\t\t\t\t\to=NULL;\t\t\t\t\t\telse\t\t\t\t\t\t\to=_TIFFmalloc((uint32)dp->tdir_count+1);\t\t\t\t\t\tif (o==NULL)\t\t\t\t\t\t{\t\t\t\t\t\t\tif (data!=NULL)\t\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\t\treturn(0);\t\t\t\t\t\t}\t\t\t\t\t\t_TIFFmemcpy(o,data,(uint32)dp->tdir_count);\t\t\t\t\t\to[(uint32)dp->tdir_count]=0;\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tdata=o;\t\t\t\t\t}\t\t\t\t\tn=TIFFSetField(tif,dp->tdir_tag,data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!n)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_UINT8:\t\t\t{\t\t\t\tuint8 data=0;\t\t\t\tassert(fip->field_readcount==1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\terr=TIFFReadDirEntryByte(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_UINT16:\t\t\t{\t\t\t\tuint16 data;\t\t\t\tassert(fip->field_readcount==1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\terr=TIFFReadDirEntryShort(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_UINT32:\t\t\t{\t\t\t\tuint32 data;\t\t\t\tassert(fip->field_readcount==1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\terr=TIFFReadDirEntryLong(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_UINT64:\t\t\t{\t\t\t\tuint64 data;\t\t\t\tassert(fip->field_readcount==1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\terr=TIFFReadDirEntryLong8(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_FLOAT:\t\t\t{\t\t\t\tfloat data;\t\t\t\tassert(fip->field_readcount==1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\terr=TIFFReadDirEntryFloat(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_DOUBLE:\t\t\t{\t\t\t\tdouble data;\t\t\t\tassert(fip->field_readcount==1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\terr=TIFFReadDirEntryDouble(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_IFD8:\t\t\t{\t\t\t\tuint64 data;\t\t\t\tassert(fip->field_readcount==1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\terr=TIFFReadDirEntryIfd8(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_UINT16_PAIR:\t\t\t{\t\t\t\tuint16* data;\t\t\t\tassert(fip->field_readcount==2);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\tif (dp->tdir_count!=2) {\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\t\t\t\t\t\t       \"incorrect count for field \\\"%s\\\", expected 2, got %d\",\t\t\t\t\t\t       fip->field_name,(int)dp->tdir_count);\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data[0],data[1]);\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C0_UINT8:\t\t\t{\t\t\t\tuint8* data;\t\t\t\tassert(fip->field_readcount>=1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount) {\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\t\t\t\t\t\t       \"incorrect count for field \\\"%s\\\", expected %d, got %d\",\t\t\t\t\t\t       fip->field_name,(int) fip->field_readcount, (int)dp->tdir_count);\t\t\t\t\treturn 0;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C0_UINT16:\t\t\t{\t\t\t\tuint16* data;\t\t\t\tassert(fip->field_readcount>=1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)                                    ;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C0_UINT32:\t\t\t{\t\t\t\tuint32* data;\t\t\t\tassert(fip->field_readcount>=1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)                                    ;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C0_FLOAT:\t\t\t{\t\t\t\tfloat* data;\t\t\t\tassert(fip->field_readcount>=1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)                                    ;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C16_ASCII:\t\t\t{\t\t\t\tuint8* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\tif (dp->tdir_count>0xFFFF)\t\t\t\t\terr=TIFFReadDirEntryErrCount;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C16_UINT8:\t\t\t{\t\t\t\tuint8* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\tif (dp->tdir_count>0xFFFF)\t\t\t\t\terr=TIFFReadDirEntryErrCount;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C16_UINT16:\t\t\t{\t\t\t\tuint16* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\tif (dp->tdir_count>0xFFFF)\t\t\t\t\terr=TIFFReadDirEntryErrCount;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C16_UINT32:\t\t\t{\t\t\t\tuint32* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\tif (dp->tdir_count>0xFFFF)\t\t\t\t\terr=TIFFReadDirEntryErrCount;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C16_UINT64:\t\t\t{\t\t\t\tuint64* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\tif (dp->tdir_count>0xFFFF)\t\t\t\t\terr=TIFFReadDirEntryErrCount;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryLong8Array(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C16_FLOAT:\t\t\t{\t\t\t\tfloat* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\tif (dp->tdir_count>0xFFFF)\t\t\t\t\terr=TIFFReadDirEntryErrCount;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C16_DOUBLE:\t\t\t{\t\t\t\tdouble* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\tif (dp->tdir_count>0xFFFF)\t\t\t\t\terr=TIFFReadDirEntryErrCount;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryDoubleArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C16_IFD8:\t\t\t{\t\t\t\tuint64* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\tif (dp->tdir_count>0xFFFF)\t\t\t\t\terr=TIFFReadDirEntryErrCount;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryIfd8Array(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_ASCII:\t\t\t{\t\t\t\tuint8* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_UINT8:\t\t\t{\t\t\t\tuint8* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_SINT8:\t\t\t{\t\t\t\tint8* data = NULL;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntrySbyteArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_UINT16:\t\t\t{\t\t\t\tuint16* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_SINT16:\t\t\t{\t\t\t\tint16* data = NULL;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntrySshortArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_UINT32:\t\t\t{\t\t\t\tuint32* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_SINT32:\t\t\t{\t\t\t\tint32* data = NULL;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntrySlongArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_UINT64:\t\t\t{\t\t\t\tuint64* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntryLong8Array(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_SINT64:\t\t\t{\t\t\t\tint64* data = NULL;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntrySlong8Array(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_FLOAT:\t\t\t{\t\t\t\tfloat* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_DOUBLE:\t\t\t{\t\t\t\tdouble* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntryDoubleArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_IFD8:\t\t\t{\t\t\t\tuint64* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntryIfd8Array(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tdefault:\t\t\tassert(0);    \t\t\tbreak;\t}\tif (err!=TIFFReadDirEntryErrOk)\t{\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip->field_name,recover);\t\treturn(0);\t}\treturn(1);}",
        "label": 1,
        "cve": "cve-2016-9448"
    },
    {
        "code": "static intswabHorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc){\tuint32* wp = (uint32*) cp0;\ttmsize_t wc = cc / 4;        TIFFSwabArrayOfLong(wp, wc);\treturn horAcc32(tif, cp0, cc);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidwin3WarningHandler(const char* module, const char* fmt, va_list ap){\tchar e[512] = { '\\0' };\tif (module != NULL)\t\tstrcat(strcpy(e, module), \":\");\tvsprintf(e+strlen(e), fmt, ap);\tstrcat(e, \".\");\tMessageBox(GetActiveWindow(), e, \"LibTIFF Warning\",\t    MB_OK|MB_ICONEXCLAMATION);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFmemcpy(tdata_t d, const tdata_t s, tsize_t c){\tif (c > 0xFFFF)\t\thmemcpy((void _huge*) d, (void _huge*) s, c);\telse\t\t(void) memcpy(d, s, (size_t) c);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int_TIFFNoStripEncode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s){\t(void) pp; (void) cc; (void) s;\treturn (TIFFNoEncode(tif, \"strip\"));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFInitCCITTRLE(TIFF* tif, int scheme){\t(void) scheme;\tif (InitCCITTFax3(tif)) {\t\t\t\ttif->tif_decoderow = Fax3DecodeRLE;\t\ttif->tif_decodestrip = Fax3DecodeRLE;\t\ttif->tif_decodetile = Fax3DecodeRLE;\t\t\t\treturn TIFFSetField(tif, TIFFTAG_FAXMODE,\t\t    FAXMODE_NORTC|FAXMODE_NOEOL|FAXMODE_BYTEALIGN);\t} else\t\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidatariErrorHandler(const char* module, const char* fmt, va_list ap){\tif (module != NULL)\t\tfprintf(stderr, \"%s: \", module);\tvfprintf(stderr, fmt, ap);\tfprintf(stderr, \".\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int_TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c){\treturn (memcmp(p1, p2, (size_t) c));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tdata_t_TIFFrealloc(tdata_t p, tsize_t s){\treturn (realloc(p, (size_t) s));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intgtStripContig(TIFFImageIter* img, void *udata, uint32 w, uint32 h){    TIFF* tif = img->tif;    ImageIterTileContigRoutine callback = img->callback.contig;    uint16 orientation;    uint32 row, nrow;    u_char* buf;    uint32 rowsperstrip;    uint32 imagewidth = img->width;    tsize_t scanline;    int32 fromskew;    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));    if (buf == 0) {\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\treturn (0);    }    orientation = img->orientation;    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);    scanline = TIFFScanlineSize(tif);    fromskew = (w < imagewidth ? imagewidth - w : 0);    for (row = 0; row < h; row += rowsperstrip) {\tnrow = (row + rowsperstrip > h ? h - row : rowsperstrip);\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 0),\t    buf, nrow*scanline) < 0 && img->stoponerr)\t\tbreak;\t(*callback)(img, udata, 0, row, w, nrow, fromskew, buf);    }    _TIFFfree(buf);    return (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFDefaultTransferFunction(TIFFDirectory* td){\tuint16 **tf = td->td_transferfunction;\ttmsize_t i, n, nbytes;\ttf[0] = tf[1] = tf[2] = 0;\tif (td->td_bitspersample >= sizeof(tmsize_t) * 8 - 2)\t\treturn 0;\tn = ((tmsize_t)1)<<td->td_bitspersample;\tnbytes = n * sizeof (uint16);\tif (!(tf[0] = (uint16 *)_TIFFmalloc(nbytes)))\t\treturn 0;\ttf[0][0] = 0;\tfor (i = 1; i < n; i++) {\t\tdouble t = (double)i/((double) n-1.);\t\ttf[0][i] = (uint16)floor(65535.*pow(t, 2.2) + .5);\t}\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\t\tif (!(tf[1] = (uint16 *)_TIFFmalloc(nbytes)))\t\t\tgoto bad;\t\t_TIFFmemcpy(tf[1], tf[0], nbytes);\t\tif (!(tf[2] = (uint16 *)_TIFFmalloc(nbytes)))\t\t\tgoto bad;\t\t_TIFFmemcpy(tf[2], tf[0], nbytes);\t}\treturn 1;bad:\tif (tf[0])\t\t_TIFFfree(tf[0]);\tif (tf[1])\t\t_TIFFfree(tf[1]);\tif (tf[2])\t\t_TIFFfree(tf[2]);\ttf[0] = tf[1] = tf[2] = 0;\treturn 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidhorizontalDifference16(unsigned short *ip, int n, int stride, \tunsigned short *wp, uint16 *From14){    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;    mask = CODE_MASK;    if (n >= stride) {\tif (stride == 3) {\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\t    b2 = wp[2] = CLAMP(ip[2]);\t    n -= 3;\t    while (n > 0) {\t\tn -= 3;\t\twp += 3;\t\tip += 3;\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\t    }\t} else if (stride == 4) {\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\t    n -= 4;\t    while (n > 0) {\t\tn -= 4;\t\twp += 4;\t\tip += 4;\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\t\ta1 = CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\t    }\t} else {        REPEAT(stride, wp[0] = CLAMP(ip[0]); wp++; ip++)\t    n -= stride;\t    while (n > 0) {            REPEAT(stride,                wp[0] = (uint16)((CLAMP(ip[0])-CLAMP(ip[-stride])) & mask);                wp++; ip++)            n -= stride;        }\t}    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "uint32 TIFFGetTagListEntry( TIFF *tif, int tag_index ){    TIFFDirectory* td = &tif->tif_dir;    if( tag_index < 0 || tag_index >= td->td_customValueCount )        return (uint32)(-1);    else        return td->td_customValues[tag_index].info->field_tag;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_tiffDummyMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize){\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*TIFFOpen(const char* name, const char* mode){\tstatic const char module[] = \"TIFFOpen\";\tint m, fd;        TIFF *ret;\tm = _TIFFgetMode(mode, module);\tif (m == -1)\t\treturn ((TIFF*)0);\tfd = open(name, m|O_BINARY, 0666);\tif (fd < 0) {\t\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\t\treturn ((TIFF*)0);\t}\treturn (TIFFFdOpen(fd, name, mode));        ret = TIFFFdOpen(fd, name, mode);        if (ret == NULL) close(fd);        return ret;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int mfs_write (int fd, void *clnt_buf, int size){    int ret;    if (fds[fd] == -1 || buf_mode[fd] == 'r')    {                ret = -1;        errno = EBADF;    }    else if (buf_mode[fd] == 'w')    {                if (buf_off[fd] + size > buf_size[fd])        {                   extend_mem_file (fd, buf_off[fd] + size);            buf_size[fd] = (buf_off[fd] + size);        }        memcpy ((buf[fd] + buf_off[fd]), clnt_buf, size);        buf_off[fd] = buf_off[fd] + size;        ret = size;    }    else    {                if (buf_off[fd] != buf_size[fd])            buf_off[fd] = buf_size[fd];        extend_mem_file (fd, buf_off[fd] + size);        buf_size[fd] += size;        memcpy ((buf[fd] + buf_off[fd]), clnt_buf, size);        buf_off[fd] = buf_off[fd] + size;        ret = size;    }    return (ret);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static introtateContigSamples32bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,                           uint32 length,   uint32 col, uint8 *src, uint8 *dst)  {  int    ready_bits = 0 ;    uint32 row, rowsize, bit_offset;  uint32 src_byte, src_bit;  uint32 longbuff1 = 0, longbuff2 = 0;  uint64 maskbits = 0, matchbits = 0;  uint64 buff1 = 0, buff2 = 0, buff3 = 0;  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;  uint8   *next;  tsample_t sample;  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"rotateContigSamples24bits\",\"Invalid src or destination buffer\");    return (1);    }              rowsize = ((bps * spp * width) + 7) / 8;  ready_bits = 0;  maskbits =  (uint64)-1 >> (64 - bps);  buff1 = buff2 = 0;  for (row = 0; row < length; row++)    {    bit_offset = col * bps * spp;    for (sample = 0; sample < spp; sample++)      {      if (sample == 0)        {        src_byte = bit_offset / 8;        src_bit  = bit_offset % 8;        }      else        {        src_byte = (bit_offset + (sample * bps)) / 8;        src_bit  = (bit_offset + (sample * bps)) % 8;        }      switch (rotation)\t{        case  90: next = src + src_byte - (row * rowsize);                  break;        case 270: next = src + src_byte + (row * rowsize);\t          break;\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);                  return (1);        }      matchbits = maskbits << (64 - src_bit - bps);       if (little_endian)        {\tlongbuff1 = (next[0] << 24) | (next[1] << 16) | (next[2] << 8) | next[3];        longbuff2 = longbuff1;        }      else        {\tlongbuff1 = (next[3] << 24) | (next[2] << 16) | (next[1] << 8) | next[0];        longbuff2 = longbuff1;\t}      buff3 = ((uint64)longbuff1 << 32) | longbuff2;      buff1 = (buff3 & matchbits) << (src_bit);      if (ready_bits < 32)        {         bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;        buff2 = (buff2 | (buff1 >> ready_bits));        }      else         {        bytebuff1 = (buff2 >> 56);        *dst++ = bytebuff1;        bytebuff2 = (buff2 >> 48);        *dst++ = bytebuff2;        bytebuff3 = (buff2 >> 40);        *dst++ = bytebuff3;        bytebuff4 = (buff2 >> 32);        *dst++ = bytebuff4;        ready_bits -= 32;                buff2 = ((buff2 << 32) | (buff1 >> ready_bits));        }      ready_bits += bps;      }    }  while (ready_bits > 0)    {    bytebuff1 = (buff2 >> 56);    *dst++ = bytebuff1;    buff2 = (buff2 << 8);    ready_bits -= 8;    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intJPEGSetupEncode(TIFF* tif){\tJPEGState* sp = JState(tif);\tTIFFDirectory *td = &tif->tif_dir;\tstatic const char module[] = \"JPEGSetupEncode\";#if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG)        if( tif->tif_dir.td_bitspersample == 12 )            return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 1 );#endif        JPEGInitializeLibJPEG( tif, FALSE );\tassert(sp != NULL);\tassert(!sp->cinfo.comm.is_decompressor);\tsp->photometric = td->td_photometric;\t\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\t\tsp->cinfo.c.input_components = td->td_samplesperpixel;\t\tif (sp->photometric == PHOTOMETRIC_YCBCR) {\t\t\tif (sp->jpegcolormode == JPEGCOLORMODE_RGB) {\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\t\t\t} else {\t\t\t\tsp->cinfo.c.in_color_space = JCS_YCbCr;\t\t\t}\t\t} else {\t\t\tif ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1)\t\t\t\tsp->cinfo.c.in_color_space = JCS_GRAYSCALE;\t\t\telse if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3)\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\t\t\telse if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4)\t\t\t\tsp->cinfo.c.in_color_space = JCS_CMYK;\t\t\telse\t\t\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\t\t}\t} else {\t\tsp->cinfo.c.input_components = 1;\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\t}\tif (!TIFFjpeg_set_defaults(sp))\t\treturn (0);\t\tswitch (sp->photometric) {\tcase PHOTOMETRIC_YCBCR:\t\tsp->h_sampling = td->td_ycbcrsubsampling[0];\t\tsp->v_sampling = td->td_ycbcrsubsampling[1];\t\t\t\t{\t\t\tfloat *ref;\t\t\tif (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\t\t\t\t\t  &ref)) {\t\t\t\tfloat refbw[6];\t\t\t\tlong top = 1L << td->td_bitspersample;\t\t\t\trefbw[0] = 0;\t\t\t\trefbw[1] = (float)(top-1L);\t\t\t\trefbw[2] = (float)(top>>1);\t\t\t\trefbw[3] = refbw[1];\t\t\t\trefbw[4] = refbw[2];\t\t\t\trefbw[5] = refbw[1];\t\t\t\tTIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\t\t\t\t\t     refbw);\t\t\t}\t\t}\t\tbreak;\tcase PHOTOMETRIC_PALETTE:\t\t\tcase PHOTOMETRIC_MASK:\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t  \"PhotometricInterpretation %d not allowed for JPEG\",\t\t\t  (int) sp->photometric);\t\treturn (0);\tdefault:\t\t\t\tsp->h_sampling = 1;\t\tsp->v_sampling = 1;\t\tbreak;\t}\t\t#ifdef JPEG_LIB_MK1        \tif (td->td_bitspersample != 8 && td->td_bitspersample != 12) #else\tif (td->td_bitspersample != BITS_IN_JSAMPLE )#endif\t{\t\tTIFFErrorExt(tif->tif_clientdata, module, \"BitsPerSample %d not allowed for JPEG\",\t\t\t  (int) td->td_bitspersample);\t\treturn (0);\t}\tsp->cinfo.c.data_precision = td->td_bitspersample;#ifdef JPEG_LIB_MK1        sp->cinfo.c.bits_in_jsample = td->td_bitspersample;#endif\tif (isTiled(tif)) {\t\tif ((td->td_tilelength % (sp->v_sampling * DCTSIZE)) != 0) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t  \"JPEG tile height must be multiple of %d\",\t\t\t\t  sp->v_sampling * DCTSIZE);\t\t\treturn (0);\t\t}\t\tif ((td->td_tilewidth % (sp->h_sampling * DCTSIZE)) != 0) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t  \"JPEG tile width must be multiple of %d\",\t\t\t\t  sp->h_sampling * DCTSIZE);\t\t\treturn (0);\t\t}\t} else {\t\tif (td->td_rowsperstrip < td->td_imagelength &&\t\t    (td->td_rowsperstrip % (sp->v_sampling * DCTSIZE)) != 0) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t  \"RowsPerStrip must be multiple of %d for JPEG\",\t\t\t\t  sp->v_sampling * DCTSIZE);\t\t\treturn (0);\t\t}\t}\t\tif (sp->jpegtablesmode & (JPEGTABLESMODE_QUANT|JPEGTABLESMODE_HUFF)) {                if( sp->jpegtables == NULL                    || memcmp(sp->jpegtables,\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0 )                {                        if (!prepare_JPEGTables(tif))                                return (0);                                                                        tif->tif_flags |= TIFF_DIRTYDIRECT;                        TIFFSetFieldBit(tif, FIELD_JPEGTABLES);                }\t} else {\t\t\t\t\t\tTIFFClrFieldBit(tif, FIELD_JPEGTABLES);\t}\t\tTIFFjpeg_data_dest(sp, tif);\treturn (1);}",
        "label": 1,
        "cve": "cve-2017-7595"
    },
    {
        "code": "void_TIFFmemcpy(void* d, const void* s, tmsize_t c){\tmemcpy(d, s, (size_t) c);}",
        "label": 1,
        "cve": "cve-2016-10092"
    },
    {
        "code": "static intprocessCompressOptions(char* opt){\tif (streq(opt, \"none\"))\t\tcompression = COMPRESSION_NONE;\telse if (streq(opt, \"packbits\"))\t\tcompression = COMPRESSION_PACKBITS;\telse if (strneq(opt, \"jpeg\", 4)) {\t\tchar* cp = strchr(opt, ':');                compression = COMPRESSION_JPEG;                while( cp )                {                    if (isdigit((int)cp[1]))\t\t\tquality = atoi(cp+1);                    else if (cp[1] == 'r' )\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;                    else                        usage();                    cp = strchr(cp+1,':');                }\t} else if (strneq(opt, \"lzw\", 3)) {\t\tchar* cp = strchr(opt, ':');\t\tif (cp)\t\t\tpredictor = atoi(cp+1);\t\tcompression = COMPRESSION_LZW;\t} else if (strneq(opt, \"zip\", 3)) {\t\tchar* cp = strchr(opt, ':');\t\tif (cp)\t\t\tpredictor = atoi(cp+1);\t\tcompression = COMPRESSION_DEFLATE;\t} else\t\treturn (0);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPredictorVSetField(TIFF* tif, uint32 tag, va_list ap){\tTIFFPredictorState *sp = PredictorState(tif);\tassert(sp != NULL);\tassert(sp->vsetparent != NULL);\tswitch (tag) {\tcase TIFFTAG_PREDICTOR:\t\tsp->predictor = (uint16) va_arg(ap, uint16_vap);\t\tTIFFSetFieldBit(tif, FIELD_PREDICTOR);\t\tbreak;\tdefault:\t\treturn (*sp->vsetparent)(tif, tag, ap);\t}\ttif->tif_flags |= TIFF_DIRTYDIRECT;\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void TIFFWriteOvrRow( TIFFOvrCache * psCache ){    int\t\tnRet, iTileX, iTileY = psCache->nBlockOffset;    unsigned char *pabyData;    toff_t\tnBaseDirOffset;    uint32      RowsInStrip;    if( TIFFIsByteSwapped(psCache->hTIFF) )    {        if( psCache->nBitsPerPixel == 16 )            TIFFSwabArrayOfShort( (uint16 *) psCache->pabyRow1Blocks,                      (psCache->nBytesPerBlock * psCache->nSamples) / 2 );        else if( psCache->nBitsPerPixel == 32 )            TIFFSwabArrayOfLong( (uint32 *) psCache->pabyRow1Blocks,                         (psCache->nBytesPerBlock * psCache->nSamples) / 4 );        else if( psCache->nBitsPerPixel == 64 )            TIFFSwabArrayOfDouble( (double *) psCache->pabyRow1Blocks,                         (psCache->nBytesPerBlock * psCache->nSamples) / 8 );    }    nBaseDirOffset = TIFFCurrentDirOffset( psCache->hTIFF );    nRet = TIFFSetSubDirectory( psCache->hTIFF, psCache->nDirOffset );    assert( nRet == 1 );\tfor( iTileX = 0; iTileX < psCache->nBlocksPerRow; iTileX++ )\t{\t\tint nTileID;\t\tif (psCache->nPlanarConfig == PLANARCONFIG_SEPARATE)\t\t{\t\t\tint iSample;\t\t\tfor( iSample = 0; iSample < psCache->nSamples; iSample++ )\t\t\t{\t\t\t\tpabyData = TIFFGetOvrBlock( psCache, iTileX, iTileY, iSample );\t\t\t\tif( psCache->bTiled )\t\t\t\t{\t\t\t\t\tnTileID = TIFFComputeTile( psCache->hTIFF,\t\t\t\t\t    iTileX * psCache->nBlockXSize,\t\t\t\t\t    iTileY * psCache->nBlockYSize,\t\t\t\t\t    0, (tsample_t) iSample );\t\t\t\t\tTIFFWriteEncodedTile( psCache->hTIFF, nTileID,\t\t\t\t\t    pabyData,\t\t\t\t\t    TIFFTileSize(psCache->hTIFF) );\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tnTileID = TIFFComputeStrip( psCache->hTIFF,\t\t\t\t\t    iTileY * psCache->nBlockYSize,\t\t\t\t\t    (tsample_t) iSample );\t\t\t\t\tRowsInStrip=psCache->nBlockYSize;\t\t\t\t\tif ((iTileY+1)*psCache->nBlockYSize>psCache->nYSize)\t\t\t\t\t\tRowsInStrip=psCache->nYSize-iTileY*psCache->nBlockYSize;\t\t\t\t\tTIFFWriteEncodedStrip( psCache->hTIFF, nTileID,\t\t\t\t\t    pabyData,\t\t\t\t\t    TIFFVStripSize(psCache->hTIFF,RowsInStrip) );\t\t\t\t}\t\t\t}\t\t}\t\telse\t\t{\t\t\tpabyData = TIFFGetOvrBlock( psCache, iTileX, iTileY, 0 );\t\t\tif( psCache->bTiled )\t\t\t{\t\t\t\tnTileID = TIFFComputeTile( psCache->hTIFF,\t\t\t\t    iTileX * psCache->nBlockXSize,\t\t\t\t    iTileY * psCache->nBlockYSize,\t\t\t\t    0, 0 );\t\t\t\tTIFFWriteEncodedTile( psCache->hTIFF, nTileID,\t\t\t\t    pabyData,\t\t\t\t    TIFFTileSize(psCache->hTIFF) );\t\t\t}\t\t\telse\t\t\t{\t\t\t\tnTileID = TIFFComputeStrip( psCache->hTIFF,\t\t\t\t    iTileY * psCache->nBlockYSize,\t\t\t\t    0 );\t\t\t\tRowsInStrip=psCache->nBlockYSize;\t\t\t\tif ((iTileY+1)*psCache->nBlockYSize>psCache->nYSize)\t\t\t\t\tRowsInStrip=psCache->nYSize-iTileY*psCache->nBlockYSize;\t\t\t\tTIFFWriteEncodedStrip( psCache->hTIFF, nTileID,\t\t\t\t    pabyData,\t\t\t\t    TIFFVStripSize(psCache->hTIFF,RowsInStrip) );\t\t\t}\t\t}\t}\t    pabyData = psCache->pabyRow1Blocks;    psCache->pabyRow1Blocks = psCache->pabyRow2Blocks;    psCache->pabyRow2Blocks = pabyData;    _TIFFmemset( pabyData, 0, psCache->nBytesPerRow );    psCache->nBlockOffset++;    TIFFFlush( psCache->hTIFF );        TIFFSetSubDirectory( psCache->hTIFF, nBaseDirOffset );    }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFReadContigStripData(TIFF* tif){\tunsigned char *buf;\ttsize_t scanline = TIFFScanlineSize(tif);\tbuf = (unsigned char *)_TIFFmalloc(TIFFStripSize(tif));\tif (buf) {\t\tuint32 row, h=0;\t\tuint32 rowsperstrip = (uint32)-1;\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\t\tfor (row = 0; row < h; row += rowsperstrip) {\t\t\tuint32 nrow = (row+rowsperstrip > h ?\t\t\t    h-row : rowsperstrip);\t\t\ttstrip_t strip = TIFFComputeStrip(tif, row, 0);\t\t\tif (TIFFReadEncodedStrip(tif, strip, buf, nrow*scanline) < 0) {\t\t\t\tif (stoponerr)\t\t\t\t\tbreak;\t\t\t} else if (showdata)\t\t\t\tShowStrip(strip, buf, nrow, scanline);\t\t}\t\t_TIFFfree(buf);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s){\tstatic const char module[] = \"PixarLogDecode\";\tTIFFDirectory *td = &tif->tif_dir;\tPixarLogState* sp = DecoderState(tif);\ttmsize_t i;\ttmsize_t nsamples;\tint llen;\tuint16 *up;\tswitch (sp->user_datafmt) {\tcase PIXARLOGDATAFMT_FLOAT:\t\tnsamples = occ / sizeof(float);\t \t\tbreak;\tcase PIXARLOGDATAFMT_16BIT:\tcase PIXARLOGDATAFMT_12BITPICIO:\tcase PIXARLOGDATAFMT_11BITLOG:\t\tnsamples = occ / sizeof(uint16);  \t\tbreak;\tcase PIXARLOGDATAFMT_8BIT:\tcase PIXARLOGDATAFMT_8BITABGR:\t\tnsamples = occ;\t\tbreak;\tdefault:\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\"%d bit input not supported in PixarLog\",\t\t\ttd->td_bitspersample);\t\treturn 0;\t}\tllen = sp->stride * td->td_imagewidth;\t(void) s;\tassert(sp != NULL);\tsp->stream.next_out = (unsigned char *) sp->tbuf;\tassert(sizeof(sp->stream.avail_out)==4);   \tsp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));\tif (sp->stream.avail_out != nsamples * sizeof(uint16))\t{\t\tTIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\");\t\treturn (0);\t}\tdo {\t\tint state = inflate(&sp->stream, Z_PARTIAL_FLUSH);\t\tif (state == Z_STREAM_END) {\t\t\tbreak;\t\t\t \t\t}\t\tif (state == Z_DATA_ERROR) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"Decoding error at scanline %lu, %s\",\t\t\t    (unsigned long) tif->tif_row, sp->stream.msg);\t\t\tif (inflateSync(&sp->stream) != Z_OK)\t\t\t\treturn (0);\t\t\tcontinue;\t\t}\t\tif (state != Z_OK) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"ZLib error: %s\",\t\t\t    sp->stream.msg);\t\t\treturn (0);\t\t}\t} while (sp->stream.avail_out > 0);\t \tif (sp->stream.avail_out != 0) {\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t    \"Not enough data at scanline %lu (short \" TIFF_UINT64_FORMAT \" bytes)\",\t\t    (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);\t\treturn (0);\t}\tup = sp->tbuf;\t \tif (tif->tif_flags & TIFF_SWAB)\t\tTIFFSwabArrayOfShort(up, nsamples);\t \tif (nsamples % llen) { \t\tTIFFWarningExt(tif->tif_clientdata, module,\t\t\t\"stride %lu is not a multiple of sample count, \"\t\t\t\"%lu, data truncated.\", (unsigned long) llen, (unsigned long) nsamples);\t\tnsamples -= nsamples % llen;\t}\tfor (i = 0; i < nsamples; i += llen, up += llen) {\t\tswitch (sp->user_datafmt)  {\t\tcase PIXARLOGDATAFMT_FLOAT:\t\t\thorizontalAccumulateF(up, llen, sp->stride,\t\t\t\t\t(float *)op, sp->ToLinearF);\t\t\top += llen * sizeof(float);\t\t\tbreak;\t\tcase PIXARLOGDATAFMT_16BIT:\t\t\thorizontalAccumulate16(up, llen, sp->stride,\t\t\t\t\t(uint16 *)op, sp->ToLinear16);\t\t\top += llen * sizeof(uint16);\t\t\tbreak;\t\tcase PIXARLOGDATAFMT_12BITPICIO:\t\t\thorizontalAccumulate12(up, llen, sp->stride,\t\t\t\t\t(int16 *)op, sp->ToLinearF);\t\t\top += llen * sizeof(int16);\t\t\tbreak;\t\tcase PIXARLOGDATAFMT_11BITLOG:\t\t\thorizontalAccumulate11(up, llen, sp->stride,\t\t\t\t\t(uint16 *)op);\t\t\top += llen * sizeof(uint16);\t\t\tbreak;\t\tcase PIXARLOGDATAFMT_8BIT:\t\t\thorizontalAccumulate8(up, llen, sp->stride,\t\t\t\t\t(unsigned char *)op, sp->ToLinear8);\t\t\top += llen * sizeof(unsigned char);\t\t\tbreak;\t\tcase PIXARLOGDATAFMT_8BITABGR:\t\t\thorizontalAccumulate8abgr(up, llen, sp->stride,\t\t\t\t\t(unsigned char *)op, sp->ToLinear8);\t\t\top += llen * sizeof(unsigned char);\t\t\tbreak;\t\tdefault:\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t  \"Unsupported bits/sample: %d\",\t\t\t\t  td->td_bitspersample);\t\t\treturn (0);\t\t}\t}\treturn (1);}",
        "label": 1,
        "cve": "CVE-2016-5314"
    },
    {
        "code": "tdata_t_TIFFmalloc(tsize_t s){\treturn ((tdata_t)GlobalAlloc(GMEM_FIXED, s));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFNoEncode(TIFF* tif, const char* method){\tconst TIFFCodec* c = TIFFFindCODEC(tif->tif_dir.td_compression);\tif (c) { \t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\t     \"%s %s encoding is not implemented\",\t\t\t     c->name, method);\t} else { \t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\t\"Compression scheme %u %s encoding is not implemented\",\t\t\t     tif->tif_dir.td_compression, method);\t}\treturn (-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidPrintData(FILE* fd, uint16 type, uint32 count, unsigned char* data){\tchar* sep = \"\";\tswitch (type) {\tcase TIFF_BYTE:\t\twhile (count-- > 0)\t\t\tfprintf(fd, bytefmt, sep, *data++), sep = \" \";\t\tbreak;\tcase TIFF_SBYTE:\t\twhile (count-- > 0)\t\t\tfprintf(fd, sbytefmt, sep, *(char *)data++), sep = \" \";\t\tbreak;\tcase TIFF_UNDEFINED:\t\twhile (count-- > 0)\t\t\tfprintf(fd, bytefmt, sep, *data++), sep = \" \";\t\tbreak;\tcase TIFF_ASCII:\t\tPrintASCII(fd, count, data);\t\tbreak;\tcase TIFF_SHORT: {\t\tuint16 *wp = (uint16*)data;\t\twhile (count-- > 0)\t\t\tfprintf(fd, shortfmt, sep, *wp++), sep = \" \";\t\tbreak;\t}\tcase TIFF_SSHORT: {\t\tint16 *wp = (int16*)data;\t\twhile (count-- > 0)\t\t\tfprintf(fd, sshortfmt, sep, *wp++), sep = \" \";\t\tbreak;\t}\tcase TIFF_LONG: {\t\tuint32 *lp = (uint32*)data;\t\twhile (count-- > 0) {\t\t\tfprintf(fd, longfmt, sep, (unsigned long) *lp++);\t\t\tsep = \" \";\t\t}\t\tbreak;\t}\tcase TIFF_SLONG: {\t\tint32 *lp = (int32*)data;\t\twhile (count-- > 0)\t\t\tfprintf(fd, slongfmt, sep, (long) *lp++), sep = \" \";\t\tbreak;\t}\tcase TIFF_LONG8: {\t\tuint64 *llp = (uint64*)data;\t\twhile (count-- > 0) {                        uint64 val;                        memcpy(&val, llp, sizeof(uint64));                        llp ++;\t\t\tfprintf(fd, long8fmt, sep, val);\t\t\tsep = \" \";\t\t}\t\tbreak;\t}\tcase TIFF_SLONG8: {\t\tint64 *llp = (int64*)data;\t\twhile (count-- > 0) {                        int64 val;                        memcpy(&val, llp, sizeof(int64));                        llp ++;                        fprintf(fd, slong8fmt, sep, val);                        sep = \" \";                }\t\tbreak;\t}\tcase TIFF_RATIONAL: {\t\tuint32 *lp = (uint32*)data;\t\twhile (count-- > 0) {\t\t\tif (lp[1] == 0)\t\t\t\tfprintf(fd, \"%sNan (%lu/%lu)\", sep,\t\t\t\t    (unsigned long) lp[0],\t\t\t\t    (unsigned long) lp[1]);\t\t\telse\t\t\t\tfprintf(fd, rationalfmt, sep,\t\t\t\t    (double)lp[0] / (double)lp[1]);\t\t\tsep = \" \";\t\t\tlp += 2;\t\t}\t\tbreak;\t}\tcase TIFF_SRATIONAL: {\t\tint32 *lp = (int32*)data;\t\twhile (count-- > 0) {\t\t\tif (lp[1] == 0)\t\t\t\tfprintf(fd, \"%sNan (%ld/%ld)\", sep,\t\t\t\t    (long) lp[0], (long) lp[1]);\t\t\telse\t\t\t\tfprintf(fd, srationalfmt, sep,\t\t\t\t    (double)lp[0] / (double)lp[1]);\t\t\tsep = \" \";\t\t\tlp += 2;\t\t}\t\tbreak;\t}\tcase TIFF_FLOAT: {\t\tfloat *fp = (float *)data;\t\twhile (count-- > 0)\t\t\tfprintf(fd, floatfmt, sep, *fp++), sep = \" \";\t\tbreak;\t}\tcase TIFF_DOUBLE: {\t\tdouble *dp = (double *)data;\t\twhile (count-- > 0)\t\t\tfprintf(fd, doublefmt, sep, *dp++), sep = \" \";\t\tbreak;\t}\tcase TIFF_IFD: {\t\tuint32 *lp = (uint32*)data;\t\twhile (count-- > 0) {\t\t\tfprintf(fd, ifdfmt, sep, (unsigned long) *lp++);\t\t\tsep = \" \";\t\t}\t\tbreak;\t}\tcase TIFF_IFD8: {\t\tuint64 *llp = (uint64*)data;\t\twhile (count-- > 0) {#if defined(__WIN32__) && defined(_MSC_VER)\t\t\tfprintf(fd, ifd8fmt, sep, (unsigned __int64) *llp++);#else\t\t\tfprintf(fd, ifd8fmt, sep, (unsigned long long) *llp++);#endif\t\t\tsep = \" \";\t\t}\t\tbreak;\t}\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length,                                          uint32 width, uint16 spp,                                         struct dump_opts *dump)  {  int i, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;  uint32 j;  int32  bytes_read = 0;  uint16 bps, planar;  uint32 nstrips;  uint32 strips_per_sample;  uint32 src_rowsize, dst_rowsize, rows_processed, rps;  uint32 rows_this_strip = 0;  tsample_t s;  tstrip_t  strip;  tsize_t scanlinesize = TIFFScanlineSize(in);  tsize_t stripsize    = TIFFStripSize(in);  unsigned char *srcbuffs[MAX_SAMPLES];  unsigned char *buff = NULL;  unsigned char *dst = NULL;  if (obuf == NULL)    {    TIFFError(\"readSeparateStripsIntoBuffer\",\"Invalid buffer argument\");    return (0);    }  memset (srcbuffs, '\\0', sizeof(srcbuffs));  TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);  TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);  if (rps > length)    rps = length;  bytes_per_sample = (bps + 7) / 8;   bytes_per_pixel  = ((bps * spp) + 7) / 8;  if (bytes_per_pixel < (bytes_per_sample + 1))    shift_width = bytes_per_pixel;  else    shift_width = bytes_per_sample + 1;  src_rowsize = ((bps * width) + 7) / 8;  dst_rowsize = ((bps * width * spp) + 7) / 8;  dst = obuf;  if ((dump->infile != NULL) && (dump->level == 3))    {    dump_info  (dump->infile, dump->format, \"\",                 \"Image width %d, length %d, Scanline size, %4d bytes\",                width, length,  scanlinesize);    dump_info  (dump->infile, dump->format, \"\",                 \"Bits per sample %d, Samples per pixel %d, Shift width %d\",\t\tbps, spp, shift_width);    }    nstrips = TIFFNumberOfStrips(in);  strips_per_sample = nstrips /spp;  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)    {    srcbuffs[s] = NULL;    buff = _TIFFmalloc(stripsize);    if (!buff)      {      TIFFError (\"readSeparateStripsIntoBuffer\",                  \"Unable to allocate strip read buffer for sample %d\", s);      for (i = 0; i < s; i++)        _TIFFfree (srcbuffs[i]);      return 0;      }    srcbuffs[s] = buff;    }  rows_processed = 0;  for (j = 0; (j < strips_per_sample) && (result == 1); j++)    {    for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)      {      buff = srcbuffs[s];      strip = (s * strips_per_sample) + j;       bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);      rows_this_strip = bytes_read / src_rowsize;      if (bytes_read < 0 && !ignore)        {        TIFFError(TIFFFileName(in),\t          \"Error, can't read strip %lu for sample %d\",         \t   (unsigned long) strip, s + 1);        result = 0;        break;        }#ifdef DEVELMODE      TIFFError(\"\", \"Strip %2d, read %5d bytes for %4d scanlines, shift width %d\", \t\tstrip, bytes_read, rows_this_strip, shift_width);#endif      }    if (rps > rows_this_strip)      rps = rows_this_strip;    dst = obuf + (dst_rowsize * rows_processed);    if ((bps % 8) == 0)      {      if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,                                       spp, bps, dump->infile,                                        dump->format, dump->level))        {        result = 0;        break;\t}      }    else      {      switch (shift_width)        {        case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,                                                 spp, bps, dump->infile,                                                 dump->format, dump->level))\t          {                  result = 0;                  break;      \t          }\t        break;        case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps,                                                  spp, bps, dump->infile,                                                  dump->format, dump->level))\t          {                  result = 0;                  break;\t\t  }\t        break;        case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps,                                                  spp, bps, dump->infile,                                                  dump->format, dump->level))\t          {                  result = 0;                  break;       \t          }                break;        case 4:         case 5:        case 6:        case 7:        case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps,                                                  spp, bps, dump->infile,                                                  dump->format, dump->level))\t          {                  result = 0;                  break;\t\t  }\t        break;        default: TIFFError (\"readSeparateStripsIntoBuffer\", \"Unsupported bit depth: %d\", bps);                  result = 0;                  break;        }      }    if ((rows_processed + rps) > length)      {      rows_processed = length;      rps = length - rows_processed;      }    else      rows_processed += rps;    }    for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)    {    buff = srcbuffs[s];    if (buff != NULL)      _TIFFfree(buff);    }  return (result);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFSwabLong8(uint64* lp){\tregister unsigned char* cp = (unsigned char*) lp;\tunsigned char t;\tassert(sizeof(uint64)==8);\tt = cp[7]; cp[7] = cp[0]; cp[0] = t;\tt = cp[6]; cp[6] = cp[1]; cp[1] = t;\tt = cp[5]; cp[5] = cp[2]; cp[2] = t;\tt = cp[4]; cp[4] = cp[3]; cp[3] = t;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intextractContigSamples32bits (uint8 *in, uint8 *out, uint32 cols,                            tsample_t sample, uint16 spp, uint16 bps,  \t\t\t    tsample_t count, uint32 start, uint32 end)  {  int    ready_bits = 0, sindex = 0 ;  uint32 col, src_byte, src_bit, bit_offset;  uint32 longbuff1 = 0, longbuff2 = 0;  uint64 maskbits = 0, matchbits = 0;  uint64 buff1 = 0, buff2 = 0, buff3 = 0;  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;  uint8 *src = in;  uint8 *dst = out;  if ((in == NULL) || (out == NULL))    {    TIFFError(\"extractContigSamples32bits\",\"Invalid input or output buffer\");    return (1);    }  if ((start > end) || (start > cols))    {    TIFFError (\"extractContigSamples32bits\",                \"Invalid start column value %d ignored\", start);    start = 0;    }  if ((end == 0) || (end > cols))    {    TIFFError (\"extractContigSamples32bits\",                \"Invalid end column value %d ignored\", end);    end = cols;    }     ready_bits = 0;  maskbits =  (uint64)-1 >> ( 64 - bps);  for (col = start; col < end; col++)    {        bit_offset = col * bps * spp;    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)      {      if (sindex == 0)        {        src_byte = bit_offset / 8;        src_bit  = bit_offset % 8;        }      else        {        src_byte = (bit_offset + (sindex * bps)) / 8;        src_bit  = (bit_offset + (sindex * bps)) % 8;        }      src = in + src_byte;      matchbits = maskbits << (64 - src_bit - bps);       if (little_endian)        {\tlongbuff1 = (src[0] << 24) | (src[1] << 16)  | (src[2] << 8) | src[3];\tlongbuff2 = longbuff1;        }      else        {\tlongbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\tlongbuff2 = longbuff1;\t}      buff3 = ((uint64)longbuff1 << 32) | longbuff2;      buff1 = (buff3 & matchbits) << (src_bit);            if (ready_bits >= 32)        {        bytebuff1 = (buff2 >> 56);        *dst++ = bytebuff1;        bytebuff2 = (buff2 >> 48);        *dst++ = bytebuff2;        bytebuff3 = (buff2 >> 40);        *dst++ = bytebuff3;        bytebuff4 = (buff2 >> 32);        *dst++ = bytebuff4;        ready_bits -= 32;                buff2 = ((buff2 << 32) | (buff1 >> ready_bits));        }      else        {         bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;        buff2 = (buff2 | (buff1 >> ready_bits));        }      ready_bits += bps;      }    }  while (ready_bits > 0)    {    bytebuff1 = (buff2 >> 56);    *dst++ = bytebuff1;    buff2 = (buff2 << 8);    ready_bits -= 8;    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFSetField(TIFF* tif, ttag_t tag, ...){\tva_list ap;\tint status;\tva_start(ap, tag);\tstatus = TIFFVSetField(tif, tag, ap);\tva_end(ap);\treturn (status);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFFlushData1(TIFF* tif){\tif (tif->tif_rawcc > 0 && tif->tif_flags & TIFF_BUF4WRITE ) {\t\tif (!isFillOrder(tif, tif->tif_dir.td_fillorder) &&\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\t\t\tTIFFReverseBits((uint8*)tif->tif_rawdata,\t\t\t    tif->tif_rawcc);\t\tif (!TIFFAppendToStrip(tif,\t\t    isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip,\t\t    tif->tif_rawdata, tif->tif_rawcc))\t\t\treturn (0);\t\ttif->tif_rawcc = 0;\t\ttif->tif_rawcp = tif->tif_rawdata;\t}\treturn (1);}",
        "label": 1,
        "cve": "cve-2016-9534"
    },
    {
        "code": "void_TIFFfree(tdata_t p){\tfree(p);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void TIFFBuildOverviews( TIFF *hTIFF, int nOverviews, int * panOvList,                         int bUseSubIFDs, const char *pszResampleMethod,                         int (*pfnProgress)( double, void * ),                         void * pProgressData ){    TIFFOvrCache\t**papoRawBIs;    uint32\t\tnXSize, nYSize, nBlockXSize, nBlockYSize;    uint16\t\tnBitsPerPixel, nPhotometric, nCompressFlag, nSamples,        nPlanarConfig, nSampleFormat;    int         bSubsampled;    uint16      nHorSubsampling, nVerSubsampling;    int\t\t\tbTiled, nSXOff, nSYOff, i;    unsigned char\t*pabySrcTile;    uint16\t\t*panRedMap, *panGreenMap, *panBlueMap;    TIFFErrorHandler    pfnWarning;    (void) pfnProgress;    (void) pProgressData;    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );    TIFFGetField( hTIFF, TIFFTAG_BITSPERSAMPLE, &nBitsPerPixel );        TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSamples );    TIFFGetFieldDefaulted( hTIFF, TIFFTAG_PLANARCONFIG, &nPlanarConfig );    TIFFGetFieldDefaulted( hTIFF, TIFFTAG_PHOTOMETRIC, &nPhotometric );    TIFFGetFieldDefaulted( hTIFF, TIFFTAG_COMPRESSION, &nCompressFlag );    TIFFGetFieldDefaulted( hTIFF, TIFFTAG_SAMPLEFORMAT, &nSampleFormat );    if( nPhotometric == PHOTOMETRIC_YCBCR || nPhotometric == PHOTOMETRIC_ITULAB )    {        if( nBitsPerPixel != 8 || nSamples != 3 || nPlanarConfig != PLANARCONFIG_CONTIG ||            nSampleFormat != SAMPLEFORMAT_UINT)        {                        TIFFErrorExt( TIFFClientdata(hTIFF), \"TIFFBuildOverviews\",                          \"File `%s' has an unsupported subsampling configuration.\\n\",                          TIFFFileName(hTIFF) );                        return;        }        bSubsampled = 1;        TIFFGetField( hTIFF, TIFFTAG_YCBCRSUBSAMPLING, &nHorSubsampling, &nVerSubsampling );            }    else    {        if( nBitsPerPixel < 8 )        {                        TIFFErrorExt( TIFFClientdata(hTIFF), \"TIFFBuildOverviews\",                          \"File `%s' has samples of %d bits per sample.  Sample\\n\"                          \"sizes of less than 8 bits per sample are not supported.\\n\",                          TIFFFileName(hTIFF), nBitsPerPixel );            return;        }        bSubsampled = 0;        nHorSubsampling = 1;        nVerSubsampling = 1;    }    pfnWarning = TIFFSetWarningHandler( NULL );    if( TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP, &(nBlockYSize) ) )    {        nBlockXSize = nXSize;        bTiled = FALSE;    }    else    {        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &nBlockXSize );        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &nBlockYSize );        bTiled = TRUE;    }    if( TIFFGetField( hTIFF, TIFFTAG_COLORMAP,                      &panRedMap, &panGreenMap, &panBlueMap ) )    {        uint16\t\t*panRed2, *panGreen2, *panBlue2;        int             nColorCount = 1 << nBitsPerPixel;        panRed2 = (uint16 *) _TIFFmalloc(2*nColorCount);        panGreen2 = (uint16 *) _TIFFmalloc(2*nColorCount);        panBlue2 = (uint16 *) _TIFFmalloc(2*nColorCount);        memcpy( panRed2, panRedMap, 2 * nColorCount );        memcpy( panGreen2, panGreenMap, 2 * nColorCount );        memcpy( panBlue2, panBlueMap, 2 * nColorCount );        panRedMap = panRed2;        panGreenMap = panGreen2;        panBlueMap = panBlue2;    }    else    {        panRedMap = panGreenMap = panBlueMap = NULL;    }    papoRawBIs = (TIFFOvrCache **) _TIFFmalloc(nOverviews*sizeof(void*));    for( i = 0; i < nOverviews; i++ )    {        uint32  nOXSize, nOYSize, nOBlockXSize, nOBlockYSize;        toff_t  nDirOffset;        nOXSize = (nXSize + panOvList[i] - 1) / panOvList[i];        nOYSize = (nYSize + panOvList[i] - 1) / panOvList[i];        nOBlockXSize = MIN(nBlockXSize,nOXSize);        nOBlockYSize = MIN(nBlockYSize,nOYSize);        if( bTiled )        {            if( (nOBlockXSize % 16) != 0 )                nOBlockXSize = nOBlockXSize + 16 - (nOBlockXSize % 16);            if( (nOBlockYSize % 16) != 0 )                nOBlockYSize = nOBlockYSize + 16 - (nOBlockYSize % 16);        }        nDirOffset = TIFF_WriteOverview( hTIFF, nOXSize, nOYSize,                                         nBitsPerPixel, nPlanarConfig,                                         nSamples, nOBlockXSize, nOBlockYSize,                                         bTiled, nCompressFlag, nPhotometric,                                         nSampleFormat,                                         panRedMap, panGreenMap, panBlueMap,                                         bUseSubIFDs,                                         nHorSubsampling, nVerSubsampling );        papoRawBIs[i] = TIFFCreateOvrCache( hTIFF, nDirOffset );    }    if( panRedMap != NULL )    {        _TIFFfree( panRedMap );        _TIFFfree( panGreenMap );        _TIFFfree( panBlueMap );    }    if( bTiled )        pabySrcTile = (unsigned char *) _TIFFmalloc(TIFFTileSize(hTIFF));    else        pabySrcTile = (unsigned char *) _TIFFmalloc(TIFFStripSize(hTIFF));    for( nSYOff = 0; nSYOff < (int) nYSize; nSYOff += nBlockYSize )    {        for( nSXOff = 0; nSXOff < (int) nXSize; nSXOff += nBlockXSize )        {                        TIFF_ProcessFullResBlock( hTIFF, nPlanarConfig,                                      bSubsampled,nHorSubsampling,nVerSubsampling,                                      nOverviews, panOvList,                                      nBitsPerPixel, nSamples, papoRawBIs,                                      nSXOff, nSYOff, pabySrcTile,                                      nBlockXSize, nBlockYSize,                                      nSampleFormat, pszResampleMethod );        }    }    _TIFFfree( pabySrcTile );    for( i = 0; i < nOverviews; i++ )    {        TIFFDestroyOvrCache( papoRawBIs[i] );    }    if( papoRawBIs != NULL )        _TIFFfree( papoRawBIs );    TIFFSetWarningHandler( pfnWarning );}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int t2p_process_jpeg_strip(\tunsigned char* strip, \ttsize_t* striplength, \tunsigned char* buffer, \ttsize_t* bufferoffset, \ttstrip_t no, \tuint32 height){\ttsize_t i=0;\twhile (i < *striplength) {\t\ttsize_t datalen;\t\tuint16 ri;\t\tuint16 v_samp;\t\tuint16 h_samp;\t\tint j;\t\tint ncomp;\t\t\t\tif (strip[i] != 0xff)\t\t\treturn(0);\t\ti++;\t\twhile (i < *striplength && strip[i] == 0xff)\t\t\ti++;\t\tif (i >= *striplength)\t\t\treturn(0);\t\t\t\tif (strip[i] == 0xd8)\t\t\tdatalen = 0;\t\telse {\t\t\tif ((*striplength - i) <= 2)\t\t\t\treturn(0);\t\t\tdatalen = (strip[i+1] << 8) | strip[i+2];\t\t\tif (datalen < 2 || datalen >= (*striplength - i))\t\t\t\treturn(0);\t\t}\t\tswitch( strip[i] ){\t\t\tcase 0xd8:\t\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), 2);\t\t\t\t*bufferoffset+=2;\t\t\t\tbreak;\t\t\tcase 0xc0:\t\t\t\tcase 0xc1:\t\t\t\tcase 0xc3:\t\t\t\tcase 0xc9:\t\t\t\tcase 0xca:\t\t\t\t\tif(no==0){\t\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\t\t\t\t\tncomp = buffer[*bufferoffset+9];\t\t\t\t\tif (ncomp < 1 || ncomp > 4)\t\t\t\t\t\treturn(0);\t\t\t\t\tv_samp=1;\t\t\t\t\th_samp=1;\t\t\t\t\tfor(j=0;j<ncomp;j++){\t\t\t\t\t\tuint16 samp = buffer[*bufferoffset+11+(3*j)];\t\t\t\t\t\tif( (samp>>4) > h_samp) \t\t\t\t\t\t\th_samp = (samp>>4);\t\t\t\t\t\tif( (samp & 0x0f) > v_samp) \t\t\t\t\t\t\tv_samp = (samp & 0x0f);\t\t\t\t\t}\t\t\t\t\tv_samp*=8;\t\t\t\t\th_samp*=8;\t\t\t\t\tri=((( ((uint16)(buffer[*bufferoffset+5])<<8) | \t\t\t\t\t(uint16)(buffer[*bufferoffset+6]) )+v_samp-1)/ \t\t\t\t\tv_samp);\t\t\t\t\tri*=((( ((uint16)(buffer[*bufferoffset+7])<<8) | \t\t\t\t\t(uint16)(buffer[*bufferoffset+8]) )+h_samp-1)/ \t\t\t\t\th_samp);\t\t\t\t\tbuffer[*bufferoffset+5]=                                          (unsigned char) ((height>>8) & 0xff);\t\t\t\t\tbuffer[*bufferoffset+6]=                                            (unsigned char) (height & 0xff);\t\t\t\t\t*bufferoffset+=datalen+2;\t\t\t\t\t\t\t\t\t\tbuffer[(*bufferoffset)++]=0xff;\t\t\t\t\tbuffer[(*bufferoffset)++]=0xdd;\t\t\t\t\tbuffer[(*bufferoffset)++]=0x00;\t\t\t\t\tbuffer[(*bufferoffset)++]=0x04;\t\t\t\t\tbuffer[(*bufferoffset)++]=(ri >> 8) & 0xff;\t\t\t\t\tbuffer[(*bufferoffset)++]= ri & 0xff;\t\t\t\t}\t\t\t\tbreak;\t\t\tcase 0xc4: \t\t\tcase 0xdb: \t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\t\t\t\t*bufferoffset+=datalen+2;\t\t\t\tbreak;\t\t\tcase 0xda: \t\t\t\tif(no==0){\t\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\t\t\t\t\t*bufferoffset+=datalen+2;\t\t\t\t} else {\t\t\t\t\tbuffer[(*bufferoffset)++]=0xff;\t\t\t\t\tbuffer[(*bufferoffset)++]=                                            (unsigned char)(0xd0 | ((no-1)%8));\t\t\t\t}\t\t\t\ti += datalen + 1;\t\t\t\t\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i]), *striplength - i);\t\t\t\t*bufferoffset+= *striplength - i;\t\t\t\treturn(1);\t\t\tdefault:\t\t\t\t\t\t\t\tbreak;\t\t}\t\ti += datalen + 1;\t}\t\treturn(0);}",
        "label": 1,
        "cve": "cve-2016-9536"
    },
    {
        "code": "static int dump_short (FILE *dumpfile, int format, char *dump_tag, uint16 data)  {  int j, k;  char  dump_array[20];  unsigned char bitset;  if (dumpfile == NULL)    {    TIFFError (\"\", \"Invalid FILE pointer for dump file\");    return (1);    }  if (format == DUMP_TEXT)    {    fprintf (dumpfile,\" %s  \", dump_tag);    for (j = 0, k = 15; k >= 0; j++, k--)      {      bitset = data & (((unsigned char)1 << k)) ? 1 : 0;      sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");      if ((k % 8) == 0)          sprintf(&dump_array[++j], \" \");      }    dump_array[17] = '\\0';    fprintf (dumpfile,\" %s\\n\", dump_array);    }  else    {    if ((fwrite (&data, 2, 1, dumpfile)) != 2)      {      TIFFError (\"\", \"Unable to write binary data to dump file\");      return (1);      }    }  return (0);  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFError(const char* module, const char* fmt, ...){\tva_list ap;\tva_start(ap, fmt);\tif (_TIFFerrorHandler)\t\t(*_TIFFerrorHandler)(module, fmt, ap);\tif (_TIFFerrorHandlerExt)\t\t(*_TIFFerrorHandlerExt)(0, module, fmt, ap);\tva_end(ap);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidFax3PrintDir(TIFF* tif, FILE* fd, long flags){\tFax3BaseState* sp = Fax3State(tif);\t(void) flags;\tif (TIFFFieldSet(tif,FIELD_OPTIONS)) {\t\tconst char* sep = \" \";\t\tif (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX4) {\t\t\tfprintf(fd, \"  Group 4 Options:\");\t\t\tif (sp->groupoptions & GROUP4OPT_UNCOMPRESSED)\t\t\t\tfprintf(fd, \"%suncompressed data\", sep);\t\t} else {\t\t\tfprintf(fd, \"  Group 3 Options:\");\t\t\tif (sp->groupoptions & GROUP3OPT_2DENCODING)\t\t\t\tfprintf(fd, \"%s2-d encoding\", sep), sep = \"+\";\t\t\tif (sp->groupoptions & GROUP3OPT_FILLBITS)\t\t\t\tfprintf(fd, \"%sEOL padding\", sep), sep = \"+\";\t\t\tif (sp->groupoptions & GROUP3OPT_UNCOMPRESSED)\t\t\t\tfprintf(fd, \"%suncompressed data\", sep);\t\t}\t\tfprintf(fd, \" (%lu = 0x%lx)\\n\",                        (unsigned long) sp->groupoptions,                        (unsigned long) sp->groupoptions);\t}\tif (TIFFFieldSet(tif,FIELD_CLEANFAXDATA)) {\t\tfprintf(fd, \"  Fax Data:\");\t\tswitch (sp->cleanfaxdata) {\t\tcase CLEANFAXDATA_CLEAN:\t\t\tfprintf(fd, \" clean\");\t\t\tbreak;\t\tcase CLEANFAXDATA_REGENERATED:\t\t\tfprintf(fd, \" receiver regenerated\");\t\t\tbreak;\t\tcase CLEANFAXDATA_UNCLEAN:\t\t\tfprintf(fd, \" uncorrected errors\");\t\t\tbreak;\t\t}\t\tfprintf(fd, \" (%u = 0x%x)\\n\",\t\t    sp->cleanfaxdata, sp->cleanfaxdata);\t}\tif (TIFFFieldSet(tif,FIELD_BADFAXLINES))\t\tfprintf(fd, \"  Bad Fax Lines: %lu\\n\",                        (unsigned long) sp->badfaxlines);\tif (TIFFFieldSet(tif,FIELD_BADFAXRUN))\t\tfprintf(fd, \"  Consecutive Bad Fax Lines: %lu\\n\",\t\t    (unsigned long) sp->badfaxrun);\tif (TIFFFieldSet(tif,FIELD_RECVPARAMS))\t\tfprintf(fd, \"  Fax Receive Parameters: %08lx\\n\",\t\t   (unsigned long) sp->recvparams);\tif (TIFFFieldSet(tif,FIELD_SUBADDRESS))\t\tfprintf(fd, \"  Fax SubAddress: %s\\n\", sp->subaddress);\tif (TIFFFieldSet(tif,FIELD_RECVTIME))\t\tfprintf(fd, \"  Fax Receive Time: %lu secs\\n\",\t\t    (unsigned long) sp->recvtime);\tif (TIFFFieldSet(tif,FIELD_FAXDCS))\t\tfprintf(fd, \"  Fax DCS: %s\\n\", sp->faxdcs);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "main(int argc, char **argv){    char emsg[1024];    TIFFImageIter img;    int ok;    int stop = 1;    TIFF *tif;    unsigned long nx, ny;    unsigned short BitsPerSample, SamplesPerPixel;    int isColorMapped, isPliFile;    unsigned char *ColorMap;    unsigned char *data;    if (argc < 2) {\tfprintf(stderr,\"usage: %s tiff_file\\n\",argv[0]);\texit(1);    }    tif = (TIFF *)PLIGetImage(argv[1], (void *) &data, &ColorMap, \t\t\t      &nx, &ny, &BitsPerSample, &SamplesPerPixel, \t\t\t      &isColorMapped, &isPliFile);    if (tif != NULL) {\tif (TIFFImageIterBegin(&img, tif, stop, emsg)) {\t    \t    if (img.isContig) {\t\timg.callback = TestContigCallback;\t    } else {\t\timg.callback = TestSepCallback;\t    }\t    ok = TIFFImageIterGet(&img, NULL, img.width, img.height);\t    TIFFImageIterEnd(&img);\t} else {\t    TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), emsg);\t}    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidTIFFSetupShortLong(TIFF* tif, ttag_t tag, TIFFDirEntry* dir, uint32 v){\tdir->tdir_tag = tag;\tdir->tdir_count = 1;\tif (v > 0xffffL) {\t\tdir->tdir_type = (short) TIFF_LONG;\t\tdir->tdir_offset = v;\t} else {\t\tdir->tdir_type = (short) TIFF_SHORT;\t\tdir->tdir_offset = TIFFInsertData(tif, (int) TIFF_SHORT, v);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength)  {  uint32 row, nrows, rowsperstrip;  tstrip_t strip = 0;  tsize_t stripsize;  TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);  for (row = 0; row < imagelength; row += rowsperstrip)    {    nrows = (row + rowsperstrip > imagelength) ?\t     imagelength - row : rowsperstrip;    stripsize = TIFFVStripSize(out, nrows);    if (TIFFWriteEncodedStrip(out, strip++, buf, stripsize) < 0)      {      TIFFError(TIFFFileName(out), \"Error, can't write strip %u\", strip - 1);      return 1;      }    buf += stripsize;    }  return 0;  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intFax3Encode(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s){\tFax3CodecState* sp = EncoderState(tif);\t(void) s;\twhile ((long)cc > 0) {\t\tif ((sp->b.mode & FAXMODE_NOEOL) == 0)\t\t\tFax3PutEOL(tif);\t\tif (is2DEncoding(sp)) {\t\t\tif (sp->tag == G3_1D) {\t\t\t\tif (!Fax3Encode1DRow(tif, bp, sp->b.rowpixels))\t\t\t\t\treturn (0);\t\t\t\tsp->tag = G3_2D;\t\t\t} else {\t\t\t\tif (!Fax3Encode2DRow(tif, bp, sp->refline,                                                     sp->b.rowpixels))\t\t\t\t\treturn (0);\t\t\t\tsp->k--;\t\t\t}\t\t\tif (sp->k == 0) {\t\t\t\tsp->tag = G3_1D;\t\t\t\tsp->k = sp->maxk-1;\t\t\t} else\t\t\t\t_TIFFmemcpy(sp->refline, bp, sp->b.rowbytes);\t\t} else {\t\t\tif (!Fax3Encode1DRow(tif, bp, sp->b.rowpixels))\t\t\t\treturn (0);\t\t}\t\tbp += sp->b.rowbytes;\t\tcc -= sp->b.rowbytes;\t}\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intprocessCompressOptions(char* opt){\tif (strcmp(opt, \"none\") == 0)\t\tcompression = COMPRESSION_NONE;\telse if (strcmp(opt, \"packbits\") == 0)\t\tcompression = COMPRESSION_PACKBITS;\telse if (strncmp(opt, \"jpeg\", 4) == 0) {\t\tchar* cp = strchr(opt, ':');                compression = COMPRESSION_JPEG;                while( cp )                {                    if (isdigit((int)cp[1]))\t\t\tquality = atoi(cp+1);                    else if (cp[1] == 'r' )\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;                    else                        usage();                    cp = strchr(cp+1,':');                }\t} else if (strncmp(opt, \"lzw\", 3) == 0) {\t\tchar* cp = strchr(opt, ':');\t\tif (cp)\t\t\tpredictor = atoi(cp+1);\t\tcompression = COMPRESSION_LZW;\t} else if (strncmp(opt, \"zip\", 3) == 0) {\t\tchar* cp = strchr(opt, ':');\t\tif (cp)\t\t\tpredictor = atoi(cp+1);\t\tcompression = COMPRESSION_DEFLATE;\t} else\t\treturn (0);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tsize_t _tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size){\treturn (_hread(fd, buf, size));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFVSetField(TIFF* tif, ttag_t tag, va_list ap){\treturn OkToChangeTag(tif, tag) ?\t    (*tif->tif_tagmethods.vsetfield)(tif, tag, ap) : 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPixarLogGuessDataFmt(TIFFDirectory *td){\tint guess = PIXARLOGDATAFMT_UNKNOWN;\tint format = td->td_sampleformat;\t\tswitch (td->td_bitspersample) {\t case 32:\t\tif (format == SAMPLEFORMAT_IEEEFP)\t\t\tguess = PIXARLOGDATAFMT_FLOAT;\t\tbreak;\t case 16:\t\tif (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_UINT)\t\t\tguess = PIXARLOGDATAFMT_16BIT;\t\tbreak;\t case 12:\t\tif (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_INT)\t\t\tguess = PIXARLOGDATAFMT_12BITPICIO;\t\tbreak;\t case 11:\t\tif (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_UINT)\t\t\tguess = PIXARLOGDATAFMT_11BITLOG;\t\tbreak;\t case 8:\t\tif (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_UINT)\t\t\tguess = PIXARLOGDATAFMT_8BIT;\t\tbreak;\t}\treturn guess;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intFax3VSetField(TIFF* tif, ttag_t tag, va_list ap){\tFax3BaseState* sp = Fax3State(tif);\tassert(sp != 0);\tassert(sp->vsetparent != 0);\tswitch (tag) {\tcase TIFFTAG_FAXMODE:\t\tsp->mode = va_arg(ap, int);\t\treturn (1);\t\t\t\tcase TIFFTAG_FAXFILLFUNC:\t\tDecoderState(tif)->fill = va_arg(ap, TIFFFaxFillFunc);\t\treturn (1);\t\t\t\tcase TIFFTAG_GROUP3OPTIONS:\t\t\t\tif (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX3)\t\t\tsp->groupoptions = va_arg(ap, uint32);\t\tbreak;\tcase TIFFTAG_GROUP4OPTIONS:\t\t\t\tif (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX4)\t\t\tsp->groupoptions = va_arg(ap, uint32);\t\tbreak;\tcase TIFFTAG_BADFAXLINES:\t\tsp->badfaxlines = va_arg(ap, uint32);\t\tbreak;\tcase TIFFTAG_CLEANFAXDATA:\t\tsp->cleanfaxdata = (uint16) va_arg(ap, int);\t\tbreak;\tcase TIFFTAG_CONSECUTIVEBADFAXLINES:\t\tsp->badfaxrun = va_arg(ap, uint32);\t\tbreak;\tcase TIFFTAG_FAXRECVPARAMS:\t\tsp->recvparams = va_arg(ap, uint32);\t\tbreak;\tcase TIFFTAG_FAXSUBADDRESS:\t\t_TIFFsetString(&sp->subaddress, va_arg(ap, char*));\t\tbreak;\tcase TIFFTAG_FAXRECVTIME:\t\tsp->recvtime = va_arg(ap, uint32);\t\tbreak;\tcase TIFFTAG_FAXDCS:\t\t_TIFFsetString(&sp->faxdcs, va_arg(ap, char*));\t\tbreak;\tdefault:\t\treturn (*sp->vsetparent)(tif, tag, ap);\t}\tTIFFSetFieldBit(tif, _TIFFFieldWithTag(tif, tag)->field_bit);\ttif->tif_flags |= TIFF_DIRTYDIRECT;\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int update_output_file (TIFF **tiffout, char *mode, int autoindex,                    char *outname, unsigned int *page)  {  static int findex = 0;      char  *sep;  char   filenum[16];  char   export_ext[16];  char   exportname[PATH_MAX];  if (autoindex && (*tiffout != NULL))    {           TIFFClose (*tiffout);    *tiffout = NULL;    }  strcpy (export_ext, \".tiff\");  memset (exportname, '\\0', PATH_MAX);    strncpy (exportname, outname, PATH_MAX - 16);  if (*tiffout == NULL)       {    if (autoindex)      {       findex++;      if ((sep = strstr(exportname, \".tif\")) || (sep = strstr(exportname, \".TIF\")))        {        strncpy (export_ext, sep, 5);        *sep = '\\0';        }      else        strncpy (export_ext, \".tiff\", 5);      export_ext[5] = '\\0';            if (findex > MAX_EXPORT_PAGES)\t{\tTIFFError(\"update_output_file\", \"Maximum of %d pages per file exceeded\", MAX_EXPORT_PAGES);        return 1;        }      snprintf(filenum, sizeof(filenum), \"-%03d%s\", findex, export_ext);      filenum[14] = '\\0';      strncat (exportname, filenum, 15);      }    exportname[PATH_MAX - 1] = '\\0';    *tiffout = TIFFOpen(exportname, mode);    if (*tiffout == NULL)      {      TIFFError(\"update_output_file\", \"Unable to open output file %s\", exportname);      return 1;      }    *page = 0;     return 0;    }  else     (*page)++;  return 0;  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFClose(TIFF* tif){\tTIFFCloseProc closeproc = tif->tif_closeproc;\tthandle_t fd = tif->tif_clientdata;\tTIFFCleanup(tif);\t(void) (*closeproc)(fd);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intcreate_image_striped(const char *name, uint32 width, uint32 length,\t\t      uint32 rowsperstrip, uint16 compression,\t\t      uint16 spp, uint16 bps, uint16 photometric,\t\t      uint16 sampleformat, uint16 planarconfig,\t\t      const tdata_t array, const tsize_t size){\tTIFF\t\t*tif;\t\ttif = TIFFOpen(name, \"w\");\tif (!tif)\t\tgoto openfailure;\tif (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) {\t\tfprintf (stderr, \"Can't set ImageWidth tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) {\t\tfprintf (stderr, \"Can't set ImageLength tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps)) {\t\tfprintf (stderr, \"Can't set BitsPerSample tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, spp)) {\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip)) {\t\tfprintf (stderr, \"Can't set RowsPerStrip tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, planarconfig)) {\t\tfprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric)) {\t\tfprintf (stderr, \"Can't set PhotometricInterpretation tag.\\n\");\t\tgoto failure;\t}\tif (write_strips(tif, array, size) < 0) {\t\tfprintf (stderr, \"Can't write image data.\\n\");\t\tgoto failure;\t}\tTIFFClose(tif);\treturn 0;failure:\tTIFFClose(tif);openfailure:\tfprintf (stderr, \"Can't create test TIFF file %s:\\n\"\"    ImageWidth=%ld, ImageLength=%ld, RowsPerStrip=%ld, Compression=%d,\\n\"\"    BitsPerSample=%d, SamplesPerPixel=%d, SampleFormat=%d,\\n\"\"    PlanarConfiguration=%d, PhotometricInterpretation=%d.\\n\",\t\t name, (long) width, (long) length, (long) rowsperstrip,                 compression, bps, spp, sampleformat, planarconfig,\t\t photometric);\treturn -1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intNotConfigured(TIFF* tif, int scheme){\t(void) scheme;\ttif->tif_fixuptags = _notConfigured;\ttif->tif_decodestatus = FALSE;\ttif->tif_setupdecode = _notConfigured;\ttif->tif_encodestatus = FALSE;\ttif->tif_setupencode = _notConfigured;\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intextractContigSamplesShifted16bits (uint8 *in, uint8 *out, uint32 cols,                                    tsample_t sample, uint16 spp, uint16 bps,   \t\t\t           tsample_t count, uint32 start, uint32 end, \t                           int shift)  {  int    ready_bits = 0, sindex = 0;  uint32 col, src_byte, src_bit, bit_offset;  uint16 maskbits = 0, matchbits = 0;  uint16 buff1 = 0, buff2 = 0;  uint8  bytebuff = 0;  uint8 *src = in;  uint8 *dst = out;  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"extractContigSamplesShifted16bits\",\"Invalid input or output buffer\");    return (1);    }  if ((start > end) || (start > cols))    {    TIFFError (\"extractContigSamplesShifted16bits\",                \"Invalid start column value %d ignored\", start);    start = 0;    }  if ((end == 0) || (end > cols))    {    TIFFError (\"extractContigSamplesShifted16bits\",                \"Invalid end column value %d ignored\", end);    end = cols;    }  ready_bits = shift;  maskbits = (uint16)-1 >> (16 - bps);  for (col = start; col < end; col++)    {        bit_offset = col * bps * spp;    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)      {      if (sindex == 0)        {        src_byte = bit_offset / 8;        src_bit  = bit_offset % 8;        }      else        {        src_byte = (bit_offset + (sindex * bps)) / 8;        src_bit  = (bit_offset + (sindex * bps)) % 8;        }      src = in + src_byte;      matchbits = maskbits << (16 - src_bit - bps);       if (little_endian)        buff1 = (src[0] << 8) | src[1];      else        buff1 = (src[1] << 8) | src[0];      if ((col == start) && (sindex == sample))        buff2 = buff1 & ((uint16)-1) << (8 - shift);      buff1 = (buff1 & matchbits) << (src_bit);      if (ready_bits < 8)         buff2 = buff2 | (buff1 >> ready_bits);      else          {        bytebuff = (buff2 >> 8);        *dst++ = bytebuff;        ready_bits -= 8;                buff2 = ((buff2 << 8) | (buff1 >> ready_bits));        }      ready_bits += bps;      }    }    while (ready_bits > 0)    {    bytebuff = (buff2 >> 8);    *dst++ = bytebuff;    ready_bits -= 8;    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intLZWPostEncode(TIFF* tif){\tregister LZWCodecState *sp = EncoderState(tif);\tuint8* op = tif->tif_rawcp;\tlong nextbits = sp->lzw_nextbits;\tunsigned long nextdata = sp->lzw_nextdata;\tlong outcount = sp->enc_outcount;\tint nbits = sp->lzw_nbits;\tif (op > sp->enc_rawlimit) {\t\ttif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata);\t\tif( !TIFFFlushData1(tif) )                    return 0;\t\top = tif->tif_rawdata;\t}\tif (sp->enc_oldcode != (hcode_t) -1) {                int free_ent = sp->lzw_free_ent;\t\tPutNextCode(op, sp->enc_oldcode);\t\tsp->enc_oldcode = (hcode_t) -1;                free_ent ++;                if (free_ent == CODE_MAX-1) {                                                outcount = 0;                        PutNextCode(op, CODE_CLEAR);                        nbits = BITS_MIN;                } else {                                                if (free_ent > sp->lzw_maxcode) {                                nbits++;                                assert(nbits <= BITS_MAX);                        }                }\t}\tPutNextCode(op, CODE_EOI);        \tif (nextbits > 0) \t\t*op++ = (unsigned char)((nextdata << (8-nextbits))&0xff);\ttif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "INLINE static voidieeetod(double *dp){\tdouble_t source;\tlong sign,exp,mant;\tdouble dmant;\tsource.ieee = ((double_t*)dp)->ieee;\tsign = source.ieee.sign;\texp = source.ieee.exp;\tmant = source.ieee.mant;\tif (exp == 2047) {\t\tif (mant)\t\t\t\t\t\t*dp = HUGE_VAL;\t\telse\t\t\t\t\t\t\t*dp = (sign ? -HUGE_VAL : HUGE_VAL);\t\treturn;\t}\tif (!exp) {\t\tif (!(mant || source.ieee.mant2)) {\t\t\t\t*dp=0;\t\t\treturn;\t\t} else {\t\t\t\t\t\t\t\t\texp= -1022;\t\t}\t} else {\t\tmant |= 1<<20;\t\texp -= 1023;\t}\tdmant = (((double) mant) +\t\t((double) source.ieee.mant2) / (((double) (1<<16)) *\t\t((double) (1<<16)))) / (double) (1<<20);\tdmant = ldexp(dmant, exp);\tif (sign)\t\tdmant= -dmant;\t*dp = dmant;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFFillStrip(TIFF* tif, uint32 strip){\tstatic const char module[] = \"TIFFFillStrip\";\tTIFFDirectory *td = &tif->tif_dir;        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)            return 0;\tif ((tif->tif_flags&TIFF_NOREADRAW)==0)\t{\t\tuint64 bytecount = td->td_stripbytecount[strip];\t\tif ((int64)bytecount <= 0) {#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t\"Invalid strip byte count %I64u, strip %lu\",\t\t\t\t     (unsigned __int64) bytecount,\t\t\t\t     (unsigned long) strip);#else\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t\"Invalid strip byte count %llu, strip %lu\",\t\t\t\t     (unsigned long long) bytecount,\t\t\t\t     (unsigned long) strip);#endif\t\t\treturn (0);\t\t}\t\tif (isMapped(tif) &&\t\t    (isFillOrder(tif, td->td_fillorder)\t\t    || (tif->tif_flags & TIFF_NOBITREV))) {\t\t\t\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {\t\t\t\t_TIFFfree(tif->tif_rawdata);\t\t\t\ttif->tif_rawdata = NULL;\t\t\t\ttif->tif_rawdatasize = 0;\t\t\t}\t\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\t\t\t\t\t\tif (bytecount > (uint64)tif->tif_size ||\t\t\t    td->td_stripoffset[strip] > (uint64)tif->tif_size - bytecount) {\t\t\t\t#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t\t\"Read error on strip %lu; \"\t\t\t\t\t\"got %I64u bytes, expected %I64u\",\t\t\t\t\t(unsigned long) strip,\t\t\t\t\t(unsigned __int64) tif->tif_size - td->td_stripoffset[strip],\t\t\t\t\t(unsigned __int64) bytecount);#else\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t\t\"Read error on strip %lu; \"\t\t\t\t\t\"got %llu bytes, expected %llu\",\t\t\t\t\t(unsigned long) strip,\t\t\t\t\t(unsigned long long) tif->tif_size - td->td_stripoffset[strip],\t\t\t\t\t(unsigned long long) bytecount);#endif\t\t\t\ttif->tif_curstrip = NOSTRIP;\t\t\t\treturn (0);\t\t\t}\t\t\ttif->tif_rawdatasize = (tmsize_t)bytecount;\t\t\ttif->tif_rawdata = tif->tif_base + (tmsize_t)td->td_stripoffset[strip];                        tif->tif_rawdataoff = 0;                        tif->tif_rawdataloaded = (tmsize_t) bytecount;\t\t\t\t\t\ttif->tif_flags |= TIFF_BUFFERMMAP;\t\t} else {\t\t\t\t\t\ttmsize_t bytecountm;\t\t\tbytecountm=(tmsize_t)bytecount;\t\t\tif ((uint64)bytecountm!=bytecount)\t\t\t{\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\t\t\t\treturn(0);\t\t\t}\t\t\tif (bytecountm > tif->tif_rawdatasize) {\t\t\t\ttif->tif_curstrip = NOSTRIP;\t\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) == 0) {\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t\t    \"Data buffer too small to hold strip %lu\",\t\t\t\t\t    (unsigned long) strip);\t\t\t\t\treturn (0);\t\t\t\t}\t\t\t\tif (!TIFFReadBufferSetup(tif, 0, bytecountm))\t\t\t\t\treturn (0);\t\t\t}\t\t\tif (tif->tif_flags&TIFF_BUFFERMMAP) {\t\t\t\ttif->tif_curstrip = NOSTRIP;\t\t\t\tif (!TIFFReadBufferSetup(tif, 0, bytecountm))\t\t\t\t\treturn (0);\t\t\t}\t\t\tif (TIFFReadRawStrip1(tif, strip, tif->tif_rawdata,\t\t\t\tbytecountm, module) != bytecountm)\t\t\t\treturn (0);                        tif->tif_rawdataoff = 0;                        tif->tif_rawdataloaded = bytecountm;                        \t\t\tif (!isFillOrder(tif, td->td_fillorder) &&\t\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\t\t\t\tTIFFReverseBits(tif->tif_rawdata, bytecountm);                }\t}\treturn (TIFFStartStrip(tif, strip));}",
        "label": 1,
        "cve": "cve-2016-10270"
    },
    {
        "code": "static voidcpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type){\tswitch (type) {\tcase TIFF_SHORT:\t\tif (count == 1) {\t\t\tuint16 shortv;\t\t\tCopyField(tag, shortv);\t\t} else if (count == 2) {\t\t\tuint16 shortv1, shortv2;\t\t\tCopyField2(tag, shortv1, shortv2);\t\t} else if (count == 4) {\t\t\tuint16 *tr, *tg, *tb, *ta;\t\t\tCopyField4(tag, tr, tg, tb, ta);\t\t} else if (count == (uint16) -1) {\t\t\tuint16 shortv1;\t\t\tuint16* shortav;\t\t\tCopyField2(tag, shortv1, shortav);\t\t}\t\tbreak;\tcase TIFF_LONG:\t\t{ uint32 longv;\t\t  CopyField(tag, longv);\t\t}\t\tbreak;\tcase TIFF_RATIONAL:\t\tif (count == 1) {\t\t\tfloat floatv;\t\t\tCopyField(tag, floatv);\t\t} else if (count == (uint16) -1) {\t\t\tfloat* floatav;\t\t\tCopyField(tag, floatav);\t\t}\t\tbreak;\tcase TIFF_ASCII:\t\t{ char* stringv;\t\t  CopyField(tag, stringv);\t\t}\t\tbreak;\tcase TIFF_DOUBLE:\t\tif (count == 1) {\t\t\tdouble doublev;\t\t\tCopyField(tag, doublev);\t\t} else if (count == (uint16) -1) {\t\t\tdouble* doubleav;\t\t\tCopyField(tag, doubleav);\t\t}\t\tbreak;          default:                TIFFError(TIFFFileName(in),                          \"Data type %d is not supported, tag %d skipped.\",                          tag, type);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static inthorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc){\tTIFFPredictorState* sp = PredictorState(tif);\ttmsize_t stride = sp->stride;\tuint32 *wp = (uint32*) cp0;\ttmsize_t wc = cc/4;    if((cc%(4*stride))!=0)    {        TIFFErrorExt(tif->tif_clientdata, \"horDiff32\",                     \"%s\", \"(cc%(4*stride))!=0\");        return 0;    }\tif (wc > stride) {\t\twc -= stride;\t\twp += wc - 1;\t\tdo {\t\t\tREPEAT4(stride, wp[stride] -= wp[0]; wp--)\t\t\twc -= stride;\t\t} while (wc > 0);\t}\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intCheckShortArrayTag(TIFF* tif1, TIFF* tif2, int tag, char* name){\tuint16 n1, *a1;\tuint16 n2, *a2;\tif (TIFFGetField(tif1, tag, &n1, &a1)) {\t\tif (!TIFFGetField(tif2, tag, &n2, &a2)) {\t\t\tprintf(\"%s tag appears only in %s\\n\",\t\t\t    name, TIFFFileName(tif1));\t\t\treturn (0);\t\t}\t\tif (n1 == n2) {\t\t\tchar* sep;\t\t\tuint16 i;\t\t\tif (memcmp(a1, a2, n1 * sizeof(uint16)) == 0)\t\t\t\treturn (1);\t\t\tprintf(\"%s: value mismatch, <%u:\", name, n1);\t\t\tsep = \"\";\t\t\tfor (i = 0; i < n1; i++)\t\t\t\tprintf(\"%s%u\", sep, a1[i]), sep = \",\";\t\t\tprintf(\"> and <%u: \", n2);\t\t\tsep = \"\";\t\t\tfor (i = 0; i < n2; i++)\t\t\t\tprintf(\"%s%u\", sep, a2[i]), sep = \",\";\t\t\tprintf(\">\\n\");\t\t} else\t\t\tprintf(\"%s: %u items in %s, %u items in %s\", name,\t\t\t    n1, TIFFFileName(tif1),\t\t\t    n2, TIFFFileName(tif2)\t\t\t);\t} else if (TIFFGetField(tif2, tag, &n2, &a2))\t\tprintf(\"%s tag appears only in %s\\n\", name, TIFFFileName(tif2));\telse\t\treturn (1);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tdata_t_TIFFrealloc(tdata_t p, tsize_t s){\treturn (realloc(p, (size_t) s));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidPreviousProc(){    PageProc(ButtonPreviousPage);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intfsdither(TIFF* in, TIFF* out){\tunsigned char *outline, *inputline, *inptr;\tshort *thisline, *nextline, *tmpptr;\tregister unsigned char\t*outptr;\tregister short *thisptr, *nextptr;\tregister uint32 i, j;\tuint32 imax, jmax;\tint lastline, lastpixel;\tint bit;\ttsize_t outlinesize;\tint errcode = 0;\timax = imagelength - 1;\tjmax = imagewidth - 1;\tinputline = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\tthisline = (short *)_TIFFmalloc(TIFFSafeMultiply(tmsize_t, imagewidth, sizeof (short)));\tnextline = (short *)_TIFFmalloc(TIFFSafeMultiply(tmsize_t, imagewidth, sizeof (short)));\toutlinesize = TIFFScanlineSize(out);\toutline = (unsigned char *) _TIFFmalloc(outlinesize);\tif (! (inputline && thisline && nextline && outline)) {\t    fprintf(stderr, \"Out of memory.\\n\");\t    goto skip_on_error;\t}\t\tif (TIFFReadScanline(in, inputline, 0, 0) <= 0)            goto skip_on_error;\tinptr = inputline;\tnextptr = nextline;\tfor (j = 0; j < imagewidth; ++j)\t\t*nextptr++ = *inptr++;\tfor (i = 1; i < imagelength; ++i) {\t\ttmpptr = thisline;\t\tthisline = nextline;\t\tnextline = tmpptr;\t\tlastline = (i == imax);\t\tif (TIFFReadScanline(in, inputline, i, 0) <= 0)\t\t\tgoto skip_on_error;\t\tinptr = inputline;\t\tnextptr = nextline;\t\tfor (j = 0; j < imagewidth; ++j)\t\t\t*nextptr++ = *inptr++;\t\tthisptr = thisline;\t\tnextptr = nextline;\t\t_TIFFmemset(outptr = outline, 0, outlinesize);\t\tbit = 0x80;\t\tfor (j = 0; j < imagewidth; ++j) {\t\t\tregister int v;\t\t\tlastpixel = (j == jmax);\t\t\tv = *thisptr++;\t\t\tif (v < 0)\t\t\t\tv = 0;\t\t\telse if (v > 255)\t\t\t\tv = 255;\t\t\tif (v > threshold) {\t\t\t\t*outptr |= bit;\t\t\t\tv -= 255;\t\t\t}\t\t\tbit >>= 1;\t\t\tif (bit == 0) {\t\t\t\toutptr++;\t\t\t\tbit = 0x80;\t\t\t}\t\t\tif (!lastpixel)\t\t\t\tthisptr[0] += v * 7 / 16;\t\t\tif (!lastline) {\t\t\t\tif (j != 0)\t\t\t\t\tnextptr[-1] += v * 3 / 16;\t\t\t\t*nextptr++ += v * 5 / 16;\t\t\t\tif (!lastpixel)\t\t\t\t\tnextptr[0] += v / 16;\t\t\t}\t\t}\t\tif (TIFFWriteScanline(out, outline, i-1, 0) < 0)\t\t\tgoto skip_on_error;\t}\tgoto exit_label;  skip_on_error:\terrcode = 1;  exit_label:\t_TIFFfree(inputline);\t_TIFFfree(thisline);\t_TIFFfree(nextline);\t_TIFFfree(outline);\treturn errcode;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteRational(TIFF* tif,    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, float v){\treturn (TIFFWriteRationalArray(tif, type, tag, dir, 1, &v));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static inthorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc){\ttmsize_t stride = PredictorState(tif)->stride;\tuint32* wp = (uint32*) cp0;\ttmsize_t wc = cc / 4;    if((cc%(4*stride))!=0)    {        TIFFErrorExt(tif->tif_clientdata, \"horAcc32\",                     \"%s\", \"cc%(4*stride))!=0\");        return 0;    }\tif (wc > stride) {\t\twc -= stride;\t\tdo {\t\t\tREPEAT4(stride, wp[stride] += wp[0]; wp++)\t\t\twc -= stride;\t\t} while (wc > 0);\t}\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(void){\tchar buf[BUFSIZ];\tint i;\tsetbuf(stderr, buf);        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\tfor (i = 0; stuff[i] != NULL; i++)\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\texit(-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intloadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)  {  uint32   i;  float    xres = 0.0, yres = 0.0;  uint16   nstrips = 0, ntiles = 0, planar = 0;  uint16   bps = 0, spp = 0, res_unit = 0;  uint16   orientation = 0;  uint16   input_compression = 0, input_photometric = 0;  uint16   subsampling_horiz, subsampling_vert;  uint32   width = 0, length = 0;  uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;  uint32   tw = 0, tl = 0;         uint32   tile_rowsize = 0;  unsigned char *read_buff = NULL;  unsigned char *new_buff  = NULL;  int      readunit = 0;  static   uint32  prev_readsize = 0;  TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);  TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);  TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);  if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))    TIFFError(\"loadImage\",\"Image lacks Photometric interpreation tag\");  if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))    TIFFError(\"loadimage\",\"Image lacks image width tag\");  if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))    TIFFError(\"loadimage\",\"Image lacks image length tag\");  TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);  TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);  if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))    res_unit = RESUNIT_INCH;  if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))    input_compression = COMPRESSION_NONE;#ifdef DEBUG2  char compressionid[16];  switch (input_compression)    {    case COMPRESSION_NONE:\t\t strcpy (compressionid, \"None/dump\");         break;             case COMPRESSION_CCITTRLE:\t  \t strcpy (compressionid, \"Huffman RLE\");         break;             case COMPRESSION_CCITTFAX3:\t  \t strcpy (compressionid, \"Group3 Fax\");         break;             case COMPRESSION_CCITTFAX4:\t  \t strcpy (compressionid, \"Group4 Fax\");         break;             case COMPRESSION_LZW:\t  \t strcpy (compressionid, \"LZW\");         break;             case COMPRESSION_OJPEG:\t  \t strcpy (compressionid, \"Old Jpeg\");         break;             case COMPRESSION_JPEG:\t  \t strcpy (compressionid, \"New Jpeg\");         break;             case COMPRESSION_NEXT:\t  \t strcpy (compressionid, \"Next RLE\");         break;             case COMPRESSION_CCITTRLEW:   \t strcpy (compressionid, \"CITTRLEW\");         break;             case COMPRESSION_PACKBITS:\t  \t strcpy (compressionid, \"Mac Packbits\");         break;             case COMPRESSION_THUNDERSCAN: \t strcpy (compressionid, \"Thunderscan\");         break;             case COMPRESSION_IT8CTPAD:\t  \t strcpy (compressionid, \"IT8 padded\");         break;             case COMPRESSION_IT8LW:\t  \t strcpy (compressionid, \"IT8 RLE\");         break;             case COMPRESSION_IT8MP:\t  \t strcpy (compressionid, \"IT8 mono\");         break;             case COMPRESSION_IT8BL:\t  \t strcpy (compressionid, \"IT8 lineart\");         break;             case COMPRESSION_PIXARFILM:\t  \t strcpy (compressionid, \"Pixar 10 bit\");         break;             case COMPRESSION_PIXARLOG:\t  \t strcpy (compressionid, \"Pixar 11bit\");         break;             case COMPRESSION_DEFLATE:\t  \t strcpy (compressionid, \"Deflate\");         break;             case COMPRESSION_ADOBE_DEFLATE: \t strcpy (compressionid, \"Adobe deflate\");         break;             default:\t strcpy (compressionid, \"None/unknown\");         break;             }  TIFFError(\"loadImage\", \"Input compression %s\", compressionid);#endif  scanlinesize = TIFFScanlineSize(in);  image->bps = bps;  image->spp = spp;  image->planar = planar;  image->width = width;  image->length = length;  image->xres = xres;  image->yres = yres;  image->res_unit = res_unit;  image->compression = input_compression;  image->photometric = input_photometric;#ifdef DEBUG2  char photometricid[12];  switch (input_photometric)    {    case PHOTOMETRIC_MINISWHITE:         strcpy (photometricid, \"MinIsWhite\");         break;    case PHOTOMETRIC_MINISBLACK:         strcpy (photometricid, \"MinIsBlack\");         break;    case PHOTOMETRIC_RGB:         strcpy (photometricid, \"RGB\");         break;    case PHOTOMETRIC_PALETTE:         strcpy (photometricid, \"Palette\");         break;    case PHOTOMETRIC_MASK:         strcpy (photometricid, \"Mask\");         break;    case PHOTOMETRIC_SEPARATED:         strcpy (photometricid, \"Separated\");         break;    case PHOTOMETRIC_YCBCR:         strcpy (photometricid, \"YCBCR\");         break;    case PHOTOMETRIC_CIELAB:         strcpy (photometricid, \"CIELab\");         break;    case PHOTOMETRIC_ICCLAB:         strcpy (photometricid, \"ICCLab\");         break;    case PHOTOMETRIC_ITULAB:         strcpy (photometricid, \"ITULab\");         break;    case PHOTOMETRIC_LOGL:         strcpy (photometricid, \"LogL\");         break;    case PHOTOMETRIC_LOGLUV:         strcpy (photometricid, \"LOGLuv\");         break;    default:         strcpy (photometricid, \"Unknown\");         break;    }  TIFFError(\"loadImage\", \"Input photometric interpretation %s\", photometricid);#endif  image->orientation = orientation;  switch (orientation)    {    case 0:    case ORIENTATION_TOPLEFT:         image->adjustments = 0;\t break;    case ORIENTATION_TOPRIGHT:         image->adjustments = MIRROR_HORIZ;\t break;    case ORIENTATION_BOTRIGHT:         image->adjustments = ROTATECW_180;\t break;    case ORIENTATION_BOTLEFT:         image->adjustments = MIRROR_VERT; \t break;    case ORIENTATION_LEFTTOP:         image->adjustments = MIRROR_VERT | ROTATECW_90;\t break;    case ORIENTATION_RIGHTTOP:         image->adjustments = ROTATECW_90;\t break;    case ORIENTATION_RIGHTBOT:         image->adjustments = MIRROR_VERT | ROTATECW_270;\t break;     case ORIENTATION_LEFTBOT:         image->adjustments = ROTATECW_270;\t break;    default:         image->adjustments = 0;         image->orientation = ORIENTATION_TOPLEFT;   }  if ((bps == 0) || (spp == 0))    {    TIFFError(\"loadImage\", \"Invalid samples per pixel (%d) or bits per sample (%d)\",\t       spp, bps);    return (-1);    }  if (TIFFIsTiled(in))    {    readunit = TILE;    tlsize = TIFFTileSize(in);    ntiles = TIFFNumberOfTiles(in);    TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);    TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);    tile_rowsize  = TIFFTileRowSize(in);          buffsize = tlsize * ntiles;            if (buffsize < (uint32)(ntiles * tl * tile_rowsize))      {      buffsize = ntiles * tl * tile_rowsize;#ifdef DEBUG2      TIFFError(\"loadImage\",\t        \"Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu\",                tlsize, (unsigned long)buffsize);#endif      }        if (dump->infile != NULL)      dump_info (dump->infile, dump->format, \"\",                  \"Tilesize: %u, Number of Tiles: %u, Tile row size: %u\",                 tlsize, ntiles, tile_rowsize);    }  else    {    readunit = STRIP;    TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);    stsize = TIFFStripSize(in);    nstrips = TIFFNumberOfStrips(in);    buffsize = stsize * nstrips;        if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))      {      buffsize =  ((length * width * spp * bps) + 7) / 8;#ifdef DEBUG2      TIFFError(\"loadImage\",\t        \"Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu\",                stsize, (unsigned long)buffsize);#endif      }        if (dump->infile != NULL)      dump_info (dump->infile, dump->format, \"\",                 \"Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u\",\t\t stsize, nstrips, rowsperstrip, scanlinesize);    }    if (input_compression == COMPRESSION_JPEG)    {      jpegcolormode = JPEGCOLORMODE_RGB;    TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);    }    else     {       if (input_photometric == PHOTOMETRIC_YCBCR)      {      TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING, \t\t           &subsampling_horiz, &subsampling_vert);      if (subsampling_horiz != 1 || subsampling_vert != 1)        {\tTIFFError(\"loadImage\", \t\t\"Can't copy/convert subsampled image with subsampling %d horiz %d vert\",                subsampling_horiz, subsampling_vert);        return (-1);        }\t}    }   read_buff = *read_ptr;      if (!read_buff)    read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);  else    {    if (prev_readsize < buffsize)      {      new_buff = _TIFFrealloc(read_buff, buffsize+3);      if (!new_buff)        {\tfree (read_buff);        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);        }      else        read_buff = new_buff;      }    }  if (!read_buff)    {    TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");    return (-1);    }  read_buff[buffsize] = 0;  read_buff[buffsize+1] = 0;  read_buff[buffsize+2] = 0;  prev_readsize = buffsize;  *read_ptr = read_buff;    switch (readunit) {    case STRIP:         if (planar == PLANARCONFIG_CONTIG)           {\t     if (!(readContigStripsIntoBuffer(in, read_buff)))\t     {\t     TIFFError(\"loadImage\", \"Unable to read contiguous strips into buffer\");\t     return (-1);             }           }         else           {\t   if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump)))\t     {\t     TIFFError(\"loadImage\", \"Unable to read separate strips into buffer\");\t     return (-1);             }           }         break;    case TILE:         if (planar == PLANARCONFIG_CONTIG)           {\t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\t     {\t     TIFFError(\"loadImage\", \"Unable to read contiguous tiles into buffer\");\t     return (-1);             }           }         else           {\t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\t     {\t     TIFFError(\"loadImage\", \"Unable to read separate tiles into buffer\");\t     return (-1);             }           }         break;    default: TIFFError(\"loadImage\", \"Unsupported image file format\");          return (-1);          break;    }  if ((dump->infile != NULL) && (dump->level == 2))    {    dump_info  (dump->infile, dump->format, \"loadImage\",                 \"Image width %d, length %d, Raw image data, %4d bytes\",                width, length,  buffsize);    dump_info  (dump->infile, dump->format, \"\",                 \"Bits per sample %d, Samples per pixel %d\", bps, spp);    for (i = 0; i < length; i++)      dump_buffer(dump->infile, dump->format, 1, scanlinesize,                   i, read_buff + (i * scanlinesize));    }  return (0);  }   ",
        "label": 1,
        "cve": "cve-2016-3991"
    },
    {
        "code": "intmain(void){    int failure = 0;    failure |= test_packbits();        failure |= rewrite_test( \"rewrite1.tif\", 10, 0, 100 );    failure |= rewrite_test( \"rewrite2.tif\", 10, 1, 100 );        failure |= rewrite_test( \"rewrite3.tif\", 1, 0, 100 );    failure |= rewrite_test( \"rewrite4.tif\", 1, 1, 100 );        failure |= rewrite_test( \"rewrite5.tif\", 1000, 1, 0x6000000000ULL );    failure |= rewrite_test( \"rewrite6.tif\", 1, 1, 0x6000000000ULL );    return failure;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFfree(tdata_t p){\tDisposePtr(p);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFmemset(tdata_t p, int v, tsize_t c){\tmemset(p, v, (size_t) c);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteDoubleArray(TIFF* tif,    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, double* v){\tdir->tdir_tag = tag;\tdir->tdir_type = (short) type;\tdir->tdir_count = n;\tTIFFCvtNativeToIEEEDouble(tif, n, v);\treturn (TIFFWriteData(tif, dir, (char*) v));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFWriteScanline(TIFF* tif, tdata_t buf, uint32 row, tsample_t sample){\tstatic const char module[] = \"TIFFWriteScanline\";\tregister TIFFDirectory *td;\tint status, imagegrew = 0;\ttstrip_t strip;\tif (!WRITECHECKSTRIPS(tif, module))\t\treturn (-1);\t \tif (!BUFFERCHECK(tif))\t\treturn (-1);\ttd = &tif->tif_dir;\t \tif (row >= td->td_imagelength) {\t \t\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE) {\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\"Can not change \\\"ImageLength\\\" when using separate planes\");\t\t\treturn (-1);\t\t}\t\ttd->td_imagelength = row+1;\t\timagegrew = 1;\t}\t \tif (td->td_planarconfig == PLANARCONFIG_SEPARATE) {\t\tif (sample >= td->td_samplesperpixel) {\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\t    \"%d: Sample out of range, max %d\",\t\t\t    sample, td->td_samplesperpixel);\t\t\treturn (-1);\t\t}\t\tstrip = sample*td->td_stripsperimage + row/td->td_rowsperstrip;\t} else\t\tstrip = row / td->td_rowsperstrip;\t \tif (strip >= td->td_nstrips && !TIFFGrowStrips(tif, 1, module))\t\treturn (-1);\tif (strip != tif->tif_curstrip) {\t\t \t\tif (!TIFFFlushData(tif))\t\t\treturn (-1);\t\ttif->tif_curstrip = strip;\t\t \t\tif (strip >= td->td_stripsperimage && imagegrew)\t\t\ttd->td_stripsperimage =\t\t\t    TIFFhowmany(td->td_imagelength,td->td_rowsperstrip);\t\ttif->tif_row =\t\t    (strip % td->td_stripsperimage) * td->td_rowsperstrip;\t\tif ((tif->tif_flags & TIFF_CODERSETUP) == 0) {\t\t\tif (!(*tif->tif_setupencode)(tif))\t\t\t\treturn (-1);\t\t\ttif->tif_flags |= TIFF_CODERSETUP;\t\t}        \t\ttif->tif_rawcc = 0;\t\ttif->tif_rawcp = tif->tif_rawdata;\t\tif( td->td_stripbytecount[strip] > 0 )\t\t{\t\t\t \t\t\ttd->td_stripbytecount[strip] = 0;\t\t\t \t\t\ttif->tif_curoff = 0;\t\t}\t\tif (!(*tif->tif_preencode)(tif, sample))\t\t\treturn (-1);\t\ttif->tif_flags |= TIFF_POSTENCODE;\t}\t \tif (row != tif->tif_row) {\t\tif (row < tif->tif_row) {\t\t\t \t\t\ttif->tif_row = (strip % td->td_stripsperimage) *\t\t\t    td->td_rowsperstrip;\t\t\ttif->tif_rawcp = tif->tif_rawdata;\t\t}\t\t \t\tif (!(*tif->tif_seek)(tif, row - tif->tif_row))\t\t\treturn (-1);\t\ttif->tif_row = row;\t}                 tif->tif_postdecode( tif, (tidata_t) buf, tif->tif_scanlinesize );\tstatus = (*tif->tif_encoderow)(tif, (tidata_t) buf,\t    tif->tif_scanlinesize, sample);         \ttif->tif_row = row + 1;\treturn (status);}",
        "label": 1,
        "cve": "CVE-2018-10779"
    },
    {
        "code": "voidTIFFReadData(TIFF* tif){\tuint16 config = PLANARCONFIG_CONTIG;\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\tif (TIFFIsTiled(tif)) {\t\tif (config == PLANARCONFIG_CONTIG)\t\t\tTIFFReadContigTileData(tif);\t\telse\t\t\tTIFFReadSeparateTileData(tif);\t} else {\t\tif (config == PLANARCONFIG_CONTIG)\t\t\tTIFFReadContigStripData(tif);\t\telse\t\t\tTIFFReadSeparateStripData(tif);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static toff_t_tiffSeekProc(thandle_t fd, toff_t off, int whence){\tDWORD dwMoveMethod, dwMoveHigh;                if( off == 0xFFFFFFFF )            return 0xFFFFFFFF;\tswitch(whence)\t{\tcase SEEK_SET:\t\tdwMoveMethod = FILE_BEGIN;\t\tbreak;\tcase SEEK_CUR:\t\tdwMoveMethod = FILE_CURRENT;\t\tbreak;\tcase SEEK_END:\t\tdwMoveMethod = FILE_END;\t\tbreak;\tdefault:\t\tdwMoveMethod = FILE_BEGIN;\t\tbreak;\t}        dwMoveHigh = 0;\treturn ((toff_t)SetFilePointer(fd, (LONG) off, (PLONG)&dwMoveHigh,                                       dwMoveMethod));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidPrintFloatDiff(uint32 row, int sample, uint32 pix, double w1, double w2){\tif (sample < 0)\t\tsample = 0;\tswitch (bitspersample) {\tcase 32: \t\tprintf(\"Scanline %lu, pixel %lu, sample %d: %g %g\\n\",\t\t    (long) row, (long) pix, sample, w1, w2);\t\tif (--stopondiff == 0)\t\t\texit(1);\t\tbreak;\tdefault:\t\tbreak;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidQuitProc(void){    exit(0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int writeBufferToSeparateStrips (TIFF* out, uint8* buf, \t\t\t     uint32 length, uint32 width, uint16 spp,\t\t\t     struct dump_opts *dump)  {  uint8   *src;  uint16   bps;  uint32   row, nrows, rowsize, rowsperstrip;  uint32   bytes_per_sample;  tsample_t s;  tstrip_t strip = 0;  tsize_t  stripsize = TIFFStripSize(out);  tsize_t  rowstripsize,  scanlinesize = TIFFScanlineSize(out);  tsize_t  total_bytes = 0;  tdata_t  obuf;  (void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);  (void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);  bytes_per_sample = (bps + 7) / 8;  rowsize = ((bps * spp * width) + 7) / 8;   rowstripsize = rowsperstrip * bytes_per_sample * (width + 1);   obuf = _TIFFmalloc (rowstripsize);  if (obuf == NULL)    return 1;    for (s = 0; s < spp; s++)    {    for (row = 0; row < length; row += rowsperstrip)      {      nrows = (row + rowsperstrip > length) ? length - row : rowsperstrip;      stripsize = TIFFVStripSize(out, nrows);      src = buf + (row * rowsize);      total_bytes += stripsize;      memset (obuf, '\\0', rowstripsize);      if (extractContigSamplesToBuffer(obuf, src, nrows, width, s, spp, bps, dump))        {        _TIFFfree(obuf);        return 1;\t}      if ((dump->outfile != NULL) && (dump->level == 1))        {        dump_info(dump->outfile, dump->format,\"\",                   \"Sample %2d, Strip: %2d, bytes: %4d, Row %4d, bytes: %4d, Input offset: %6d\",                   s + 1, strip + 1, stripsize, row + 1, scanlinesize, src - buf);        dump_buffer(dump->outfile, dump->format, nrows, scanlinesize, row, obuf);\t}      if (TIFFWriteEncodedStrip(out, strip++, obuf, stripsize) < 0)        {\tTIFFError(TIFFFileName(out), \"Error, can't write strip %u\", strip - 1);\t_TIFFfree(obuf);\treturn 1;\t}      }    }        _TIFFfree(obuf);  return 0;}",
        "label": 1,
        "cve": "cve-2016-9532"
    },
    {
        "code": "static intcpStrips(TIFF* in, TIFF* out){\ttmsize_t bufsize  = TIFFStripSize(in);\tunsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);\tif (buf) {\t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\t\tuint64 *bytecounts;\t\tif (!TIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts)) {\t\t\tfprintf(stderr, \"tiffsplit: strip byte counts are missing\\n\");                        _TIFFfree(buf);\t\t\treturn (0);\t\t}\t\tfor (s = 0; s < ns; s++) {\t\t\tif (bytecounts[s] > (uint64)bufsize) {\t\t\t\tbuf = (unsigned char *)_TIFFrealloc(buf, (tmsize_t)bytecounts[s]);\t\t\t\tif (!buf)\t\t\t\t\treturn (0);\t\t\t\tbufsize = (tmsize_t)bytecounts[s];\t\t\t}\t\t\tif (TIFFReadRawStrip(in, s, buf, (tmsize_t)bytecounts[s]) < 0 ||\t\t\t    TIFFWriteRawStrip(out, s, buf, (tmsize_t)bytecounts[s]) < 0) {\t\t\t\t_TIFFfree(buf);\t\t\t\treturn (0);\t\t\t}\t\t}\t\t_TIFFfree(buf);\t\treturn (1);\t}\treturn (0);}",
        "label": 1,
        "cve": "cve-2016-9273"
    },
    {
        "code": "tdata_t_TIFFmalloc(tsize_t s){\treturn (malloc((size_t) s));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFmemcpy(void* d, const tdata_t s, tsize_t c){\tCopyMemory(d, s, c);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intLogL16Decode(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s){\tLogLuvState* sp = DecoderState(tif);\tint shft, i, npixels;\tu_char* bp;\tint16* tp;\tint16 b;\tint cc, rc;\tassert(s == 0);\tassert(sp != NULL);\tnpixels = occ / sp->pixel_size;\tif (sp->user_datafmt == SGILOGDATAFMT_16BIT)\t\ttp = (int16*) op;\telse {\t\tassert(sp->tbuflen >= npixels);\t\ttp = (int16*) sp->tbuf;\t}\t_TIFFmemset((tdata_t) tp, 0, npixels*sizeof (tp[0]));\tbp = (u_char*) tif->tif_rawcp;\tcc = tif->tif_rawcc;\t\t\t\t\t\tfor (shft = 2*8; (shft -= 8) >= 0; ) {\t\tfor (i = 0; i < npixels && cc > 0; )\t\t\tif (*bp >= 128) {\t\t\t\t\t\trc = *bp++ + (2-128);\t\t\t\tb = (int16)(*bp++ << shft);\t\t\t\tcc -= 2;\t\t\t\twhile (rc--)\t\t\t\t\ttp[i++] |= b;\t\t\t} else {\t\t\t\t\t\t\trc = *bp++;\t\t\t\t\t\twhile (--cc && rc--)\t\t\t\t\ttp[i++] |= (int16)*bp++ << shft;\t\t\t}\t\tif (i != npixels) {\t\t\tTIFFError(tif->tif_name,\t\t\"LogL16Decode: Not enough data at row %d (short %d pixels)\",\t\t\t    tif->tif_row, npixels - i);\t\t\ttif->tif_rawcp = (tidata_t) bp;\t\t\ttif->tif_rawcc = cc;\t\t\treturn (0);\t\t}\t}\t(*sp->tfunc)(sp, op, npixels);\ttif->tif_rawcp = (tidata_t) bp;\ttif->tif_rawcc = cc;\treturn (1);}",
        "label": 1,
        "cve": "cve-2004-0803_3"
    },
    {
        "code": "static intNeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s){\tstatic const char module[] = \"NeXTDecode\";\tunsigned char *bp, *op;\ttmsize_t cc;\tuint8* row;\ttmsize_t scanline, n;\t(void) s;\t\tfor (op = (unsigned char*) buf, cc = occ; cc-- > 0;)\t\t*op++ = 0xff;\tbp = (unsigned char *)tif->tif_rawcp;\tcc = tif->tif_rawcc;\tscanline = tif->tif_scanlinesize;\tif (occ % scanline)\t{\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\t\treturn (0);\t}\tfor (row = buf; occ > 0; occ -= scanline, row += scanline) {\t\tn = *bp++, cc--;\t\tswitch (n) {\t\tcase LITERALROW:\t\t\t\t\t\tif (cc < scanline)\t\t\t\tgoto bad;\t\t\t_TIFFmemcpy(row, bp, scanline);\t\t\tbp += scanline;\t\t\tcc -= scanline;\t\t\tbreak;\t\tcase LITERALSPAN: {\t\t\ttmsize_t off;\t\t\t\t\t\toff = (bp[0] * 256) + bp[1];\t\t\tn = (bp[2] * 256) + bp[3];\t\t\tif (cc < 4+n || off+n > scanline)\t\t\t\tgoto bad;\t\t\t_TIFFmemcpy(row+off, bp+4, n);\t\t\tbp += 4+n;\t\t\tcc -= 4+n;\t\t\tbreak;\t\t}\t\tdefault: {\t\t\tuint32 npixels = 0, grey;\t\t\tuint32 imagewidth = tif->tif_dir.td_imagewidth;\t\t\t\t\t\top = row;\t\t\tfor (;;) {\t\t\t\tgrey = (uint32)((n>>6) & 0x3);\t\t\t\tn &= 0x3f;\t\t\t\t\t\t\t\twhile (n-- > 0 && npixels < imagewidth)\t\t\t\t\tSETPIXEL(op, grey);\t\t\t\tif (npixels >= imagewidth)\t\t\t\t\tbreak;\t\t\t\tif (cc == 0)\t\t\t\t\tgoto bad;\t\t\t\tn = *bp++, cc--;\t\t\t}\t\t\tbreak;\t\t}\t\t}\t}\ttif->tif_rawcp = (uint8*) bp;\ttif->tif_rawcc = cc;\treturn (1);bad:\tTIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\",\t    (long) tif->tif_row);\treturn (0);}",
        "label": 1,
        "cve": "cve-2015-1547"
    },
    {
        "code": "static voidmsdosErrorHandler(const char* module, const char* fmt, va_list ap){\tif (module != NULL)\t\tfprintf(stderr, \"%s: \", module);\tvfprintf(stderr, fmt, ap);\tfprintf(stderr, \".\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tsize_t t2p_write_pdf_string(char* pdfstr, TIFF* output){\ttsize_t written=0;\tuint32 i=0;\tchar buffer[5];\tuint32 len=0;\t\tlen=strlen(pdfstr);\twritten += TIFFWriteFile(output, (tdata_t) \"(\", 1);\tfor (i=0;i<len;i++){\t\tif((pdfstr[i]&0x80) || (pdfstr[i]==127) || (pdfstr[i]<32)){\t\t\tsprintf(buffer, \"\\\\%.3o\", pdfstr[i]);\t\t\twritten += TIFFWriteFile(output, (tdata_t) buffer, 4);\t\t} else {\t\t\tswitch (pdfstr[i]){\t\t\t\tcase 0x08:\t\t\t\t\twritten += TIFFWriteFile(output, (tdata_t) \"\\\\b\", 2);\t\t\t\t\tbreak;\t\t\t\tcase 0x09:\t\t\t\t\twritten += TIFFWriteFile(output, (tdata_t) \"\\\\t\", 2);\t\t\t\t\tbreak;\t\t\t\tcase 0x0A:\t\t\t\t\twritten += TIFFWriteFile(output, (tdata_t) \"\\\\n\", 2);\t\t\t\t\tbreak;\t\t\t\tcase 0x0C:\t\t\t\t\twritten += TIFFWriteFile(output, (tdata_t) \"\\\\f\", 2);\t\t\t\t\tbreak;\t\t\t\tcase 0x0D:\t\t\t\t\twritten += TIFFWriteFile(output, (tdata_t) \"\\\\r\", 2);\t\t\t\t\tbreak;\t\t\t\tcase 0x28:\t\t\t\t\twritten += TIFFWriteFile(output, (tdata_t) \"\\\\(\", 2);\t\t\t\t\tbreak;\t\t\t\tcase 0x29:\t\t\t\t\twritten += TIFFWriteFile(output, (tdata_t) \"\\\\)\", 2);\t\t\t\t\tbreak;\t\t\t\tcase 0x5C:\t\t\t\t\twritten += TIFFWriteFile(output, (tdata_t) \"\\\\\\\\\", 2);\t\t\t\t\tbreak;\t\t\t\tdefault:\t\t\t\t\twritten += TIFFWriteFile(output, (tdata_t) &pdfstr[i], 1);\t\t\t}\t\t}\t}\twritten += TIFFWriteFile(output, (tdata_t) \") \", 1);\treturn(written);}",
        "label": 1,
        "cve": "cve-2006-2193"
    },
    {
        "code": "intmain(int argc, char* argv[]){    TIFF *tiff;    int  arg_index;    if (argc < 2)        usage();    tiff = TIFFOpen(argv[argc-1], \"r+\");    if (tiff == NULL)        return 2;    for( arg_index = 1; arg_index < argc-1; arg_index++ ) {\tif (strcmp(argv[arg_index],\"-d\") == 0 && arg_index < argc-2) {\t    arg_index++;\t    if( TIFFSetDirectory(tiff, atoi(argv[arg_index]) ) != 1 )            {               fprintf( stderr, \"Failed to set directory=%s\\n\", argv[arg_index] );               return 6;            }\t    arg_index++;\t}\tif (strcmp(argv[arg_index],\"-sd\") == 0 && arg_index < argc-2) {\t    arg_index++;\t    if( TIFFSetSubDirectory(tiff, atoi(argv[arg_index]) ) != 1 )            {               fprintf( stderr, \"Failed to set sub directory=%s\\n\", argv[arg_index] );               return 7;            }\t    arg_index++;\t}        if (strcmp(argv[arg_index],\"-s\") == 0 && arg_index < argc-3) {            const TIFFField *fip;            const char *tagname;            arg_index++;            tagname = argv[arg_index];            fip = GetField(tiff, tagname);            if (!fip)                return 3;            arg_index++;            if (TIFFFieldDataType(fip) == TIFF_ASCII) {                if (TIFFSetField(tiff, TIFFFieldTag(fip), argv[arg_index]) != 1)                    fprintf( stderr, \"Failed to set %s=%s\\n\",                             TIFFFieldName(fip), argv[arg_index] );            } else if (TIFFFieldWriteCount(fip) > 0\t\t       || TIFFFieldWriteCount(fip) == TIFF_VARIABLE) {                int     ret = 1;                short   wc;                if (TIFFFieldWriteCount(fip) == TIFF_VARIABLE)                        wc = atoi(argv[arg_index++]);                else                        wc = TIFFFieldWriteCount(fip);                if (argc - arg_index < wc) {                    fprintf( stderr,                             \"Number of tag values is not enough. \"                             \"Expected %d values for %s tag, got %d\\n\",                             wc, TIFFFieldName(fip), argc - arg_index);                    return 4;                }                if (wc > 1) {                        int     i, size;                        void    *array;                        switch (TIFFFieldDataType(fip)) {                                                                case TIFF_BYTE:                                case TIFF_ASCII:                                case TIFF_SBYTE:                                case TIFF_UNDEFINED:\t\t\t\tdefault:                                    size = 1;                                    break;                                case TIFF_SHORT:                                case TIFF_SSHORT:                                    size = 2;                                    break;                                case TIFF_LONG:                                case TIFF_SLONG:                                case TIFF_FLOAT:                                case TIFF_IFD:                                case TIFF_RATIONAL:                                case TIFF_SRATIONAL:                                    size = 4;                                    break;                                case TIFF_DOUBLE:                                    size = 8;                                    break;                        }                        array = _TIFFmalloc(wc * size);                        if (!array) {                                fprintf(stderr, \"No space for %s tag\\n\",                                        tagname);                                return 4;                        }                        switch (TIFFFieldDataType(fip)) {                            case TIFF_BYTE:                                for (i = 0; i < wc; i++)                                    ((uint8 *)array)[i] = atoi(argv[arg_index+i]);                                break;                            case TIFF_SHORT:                                for (i = 0; i < wc; i++)                                    ((uint16 *)array)[i] = atoi(argv[arg_index+i]);                                break;                            case TIFF_SBYTE:                                for (i = 0; i < wc; i++)                                    ((int8 *)array)[i] = atoi(argv[arg_index+i]);                                break;                            case TIFF_SSHORT:                                for (i = 0; i < wc; i++)                                    ((int16 *)array)[i] = atoi(argv[arg_index+i]);                                break;                            case TIFF_LONG:                                for (i = 0; i < wc; i++)                                    ((uint32 *)array)[i] = atol(argv[arg_index+i]);                                break;                            case TIFF_SLONG:                            case TIFF_IFD:                                for (i = 0; i < wc; i++)                                    ((uint32 *)array)[i] = atol(argv[arg_index+i]);                                break;                            case TIFF_DOUBLE:                                for (i = 0; i < wc; i++)                                    ((double *)array)[i] = atof(argv[arg_index+i]);                                break;                            case TIFF_RATIONAL:                            case TIFF_SRATIONAL:                            case TIFF_FLOAT:                                for (i = 0; i < wc; i++)                                    ((float *)array)[i] = (float)atof(argv[arg_index+i]);                                break;                            default:                                break;                        }                        if (TIFFFieldPassCount(fip)) {                                ret = TIFFSetField(tiff, TIFFFieldTag(fip),                                                   wc, array);                        } else if (TIFFFieldTag(fip) == TIFFTAG_PAGENUMBER\t\t\t\t   || TIFFFieldTag(fip) == TIFFTAG_HALFTONEHINTS\t\t\t\t   || TIFFFieldTag(fip) == TIFFTAG_YCBCRSUBSAMPLING\t\t\t\t   || TIFFFieldTag(fip) == TIFFTAG_DOTRANGE) {       \t\t\t\tif (TIFFFieldDataType(fip) == TIFF_BYTE) {\t\t\t\t\tret = TIFFSetField(tiff, TIFFFieldTag(fip),\t\t\t\t\t\t((uint8 *)array)[0], ((uint8 *)array)[1]);\t\t\t\t} else if (TIFFFieldDataType(fip) == TIFF_SHORT) {\t\t\t\t\tret = TIFFSetField(tiff, TIFFFieldTag(fip),\t\t\t\t\t\t((uint16 *)array)[0], ((uint16 *)array)[1]);\t\t\t\t}\t\t\t} else {                                ret = TIFFSetField(tiff, TIFFFieldTag(fip),                                                   array);                        }                        _TIFFfree(array);                } else {                        switch (TIFFFieldDataType(fip)) {                            case TIFF_BYTE:                            case TIFF_SHORT:                            case TIFF_SBYTE:                            case TIFF_SSHORT:                                ret = TIFFSetField(tiff, TIFFFieldTag(fip),                                                   atoi(argv[arg_index++]));                                break;                            case TIFF_LONG:                            case TIFF_SLONG:                            case TIFF_IFD:                                ret = TIFFSetField(tiff, TIFFFieldTag(fip),                                                   atol(argv[arg_index++]));                                break;                            case TIFF_DOUBLE:                                ret = TIFFSetField(tiff, TIFFFieldTag(fip),                                                   atof(argv[arg_index++]));                                break;                            case TIFF_RATIONAL:                            case TIFF_SRATIONAL:                            case TIFF_FLOAT:                                ret = TIFFSetField(tiff, TIFFFieldTag(fip),                                                   (float)atof(argv[arg_index++]));                                break;                            default:                                break;                        }                }                if (ret != 1)                    fprintf(stderr, \"Failed to set %s\\n\", TIFFFieldName(fip));                arg_index += wc;            }        } else if (strcmp(argv[arg_index],\"-sf\") == 0 && arg_index < argc-3) {            FILE    *fp;            const TIFFField *fip;            char    *text;            size_t  len;            arg_index++;            fip = GetField(tiff, argv[arg_index]);            if (!fip)                return 3;            if (TIFFFieldDataType(fip) != TIFF_ASCII) {                fprintf( stderr,                         \"Only ASCII tags can be set from file. \"                         \"%s is not ASCII tag.\\n\", TIFFFieldName(fip) );                return 5;            }            arg_index++;            fp = fopen( argv[arg_index], \"rt\" );            if(fp == NULL) {                perror( argv[arg_index] );                continue;            }            text = (char *) malloc(1000000);            len = fread( text, 1, 999999, fp );            text[len] = '\\0';            fclose( fp );            if(TIFFSetField( tiff, TIFFFieldTag(fip), text ) != 1) {                fprintf(stderr, \"Failed to set %s from file %s\\n\",                         TIFFFieldName(fip), argv[arg_index]);            }            _TIFFfree( text );            arg_index++;        } else {            fprintf(stderr, \"Unrecognised option: %s\\n\",                    argv[arg_index]);            usage();        }    }    TIFFRewriteDirectory(tiff);    TIFFClose(tiff);    return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intextractImageSection(struct image_data *image, struct pageseg *section,                     unsigned char *src_buff, unsigned char *sect_buff)  {  unsigned  char  bytebuff1, bytebuff2;#ifdef DEVELMODE  #endif  uint32    img_width, img_rowsize;#ifdef DEVELMODE  uint32    img_length;#endif  uint32    j, shift1, shift2, trailing_bits;  uint32    row, first_row, last_row, first_col, last_col;  uint32    src_offset, dst_offset, row_offset, col_offset;  uint32    offset1, offset2, full_bytes;  uint32    sect_width;#ifdef DEVELMODE  uint32    sect_length;#endif  uint16    bps, spp;#ifdef DEVELMODE  int      k;  unsigned char bitset;  static char *bitarray = NULL;#endif  img_width = image->width;#ifdef DEVELMODE  img_length = image->length;#endif  bps = image->bps;  spp = image->spp;#ifdef DEVELMODE    #endif  src_offset = 0;  dst_offset = 0;#ifdef DEVELMODE  if (bitarray == NULL)    {    if ((bitarray = (char *)malloc(img_width)) == NULL)      {      TIFFError (\"\", \"DEBUG: Unable to allocate debugging bitarray\");      return (-1);      }    }#endif    first_row = section->y1;  last_row  = section->y2;  first_col = section->x1;  last_col  = section->x2;  sect_width = last_col - first_col + 1;#ifdef DEVELMODE  sect_length = last_row - first_row + 1;#endif  img_rowsize = ((img_width * bps + 7) / 8) * spp;  full_bytes = (sect_width * spp * bps) / 8;     trailing_bits = (sect_width * bps) % 8;#ifdef DEVELMODE    TIFFError (\"\", \"First row: %d, last row: %d, First col: %d, last col: %d\\n\",           first_row, last_row, first_col, last_col);    TIFFError (\"\", \"Image width: %d, Image length: %d, bps: %d, spp: %d\\n\",\t   img_width, img_length, bps, spp);    TIFFError (\"\", \"Sect  width: %d,  Sect length: %d, full bytes: %d trailing bits %d\\n\",            sect_width, sect_length, full_bytes, trailing_bits);#endif  if ((bps % 8) == 0)    {    col_offset = first_col * spp * bps / 8;    for (row = first_row; row <= last_row; row++)      {            row_offset = row * img_rowsize;      src_offset = row_offset + col_offset;#ifdef DEVELMODE        TIFFError (\"\", \"Src offset: %8d, Dst offset: %8d\", src_offset, dst_offset); #endif      _TIFFmemcpy (sect_buff + dst_offset, src_buff + src_offset, full_bytes);      dst_offset += full_bytes;      }            }  else    {     shift1  = spp * ((first_col * bps) % 8);    shift2  = spp * ((last_col * bps) % 8);    for (row = first_row; row <= last_row; row++)      {            row_offset = row * img_rowsize;      offset1 = row_offset + (first_col * bps / 8);      offset2 = row_offset + (last_col * bps / 8);#ifdef DEVELMODE      for (j = 0, k = 7; j < 8; j++, k--)        {        bitset = *(src_buff + offset1) & (((unsigned char)1 << k)) ? 1 : 0;        sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");        }      sprintf(&bitarray[8], \" \");      sprintf(&bitarray[9], \" \");      for (j = 10, k = 7; j < 18; j++, k--)        {        bitset = *(src_buff + offset2) & (((unsigned char)1 << k)) ? 1 : 0;        sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");        }      bitarray[18] = '\\0';      TIFFError (\"\", \"Row: %3d Offset1: %d,  Shift1: %d,    Offset2: %d,  Shift2:  %d\\n\",                  row, offset1, shift1, offset2, shift2); #endif      bytebuff1 = bytebuff2 = 0;      if (shift1 == 0)         {\t_TIFFmemcpy (sect_buff + dst_offset, src_buff + offset1, full_bytes);#ifdef DEVELMODE\tTIFFError (\"\", \"        Alligned data src offset1: %8d, Dst offset: %8d\\n\", offset1, dst_offset); \tsprintf(&bitarray[18], \"\\n\");\tsprintf(&bitarray[19], \"\\t\");        for (j = 20, k = 7; j < 28; j++, k--)          {          bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;          sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");          }        bitarray[28] = ' ';        bitarray[29] = ' ';#endif        dst_offset += full_bytes;        if (trailing_bits != 0)          {\t  bytebuff2 = src_buff[offset2] & ((unsigned char)255 << (7 - shift2));          sect_buff[dst_offset] = bytebuff2;#ifdef DEVELMODE\t  TIFFError (\"\", \"        Trailing bits src offset:  %8d, Dst offset: %8d\\n\",                               offset2, dst_offset);           for (j = 30, k = 7; j < 38; j++, k--)            {            bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;            sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");            }          bitarray[38] = '\\0';          TIFFError (\"\", \"\\tFirst and last bytes before and after masking:\\n\\t%s\\n\\n\", bitarray);#endif          dst_offset++;          }        }      else           {#ifdef DEVELMODE\t  TIFFError (\"\", \"        Unalligned data src offset: %8d, Dst offset: %8d\\n\", offset1 , dst_offset); #endif        for (j = 0; j <= full_bytes; j++)           {\t  bytebuff1 = src_buff[offset1 + j] & ((unsigned char)255 >> shift1);\t  bytebuff2 = src_buff[offset1 + j + 1] & ((unsigned char)255 << (7 - shift1));          sect_buff[dst_offset + j] = (bytebuff1 << shift1) | (bytebuff2 >> (8 - shift1));          }#ifdef DEVELMODE\tsprintf(&bitarray[18], \"\\n\");\tsprintf(&bitarray[19], \"\\t\");        for (j = 20, k = 7; j < 28; j++, k--)          {          bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;          sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");          }        bitarray[28] = ' ';        bitarray[29] = ' ';#endif        dst_offset += full_bytes;        if (trailing_bits != 0)          {#ifdef DEVELMODE\t    TIFFError (\"\", \"        Trailing bits   src offset: %8d, Dst offset: %8d\\n\", offset1 + full_bytes, dst_offset); #endif\t  if (shift2 > shift1)            {\t    bytebuff1 = src_buff[offset1 + full_bytes] & ((unsigned char)255 << (7 - shift2));            bytebuff2 = bytebuff1 & ((unsigned char)255 << shift1);            sect_buff[dst_offset] = bytebuff2;#ifdef DEVELMODE\t    TIFFError (\"\", \"        Shift2 > Shift1\\n\"); #endif            }          else            {\t    if (shift2 < shift1)              {              bytebuff2 = ((unsigned char)255 << (shift1 - shift2 - 1));\t      sect_buff[dst_offset] &= bytebuff2;#ifdef DEVELMODE\t      TIFFError (\"\", \"        Shift2 < Shift1\\n\"); #endif              }#ifdef DEVELMODE            else\t      TIFFError (\"\", \"        Shift2 == Shift1\\n\"); #endif            }\t  }#ifdef DEVELMODE\t  sprintf(&bitarray[28], \" \");\t  sprintf(&bitarray[29], \" \");          for (j = 30, k = 7; j < 38; j++, k--)            {            bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;            sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");            }          bitarray[38] = '\\0';          TIFFError (\"\", \"\\tFirst and last bytes before and after masking:\\n\\t%s\\n\\n\", bitarray);#endif        dst_offset++;        }      }    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intFax3PreDecode(TIFF* tif, tsample_t s){\tFax3CodecState* sp = DecoderState(tif);\t(void) s;\tassert(sp != NULL);\tsp->bit = 0;\t\t\t\tsp->data = 0;\tsp->EOLcnt = 0;\t\t\t\t\tsp->bitmap =\t    TIFFGetBitRevTable(tif->tif_dir.td_fillorder != FILLORDER_LSB2MSB);\tif (sp->refruns) {\t\t\t\tsp->refruns[0] = (uint32) sp->b.rowpixels;\t\tsp->refruns[1] = 0;\t}\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchPerSampleAnys(TIFF* tif, TIFFDirEntry* dir, double* pl){\tint samples = (int) tif->tif_dir.td_samplesperpixel;\tint status = 0;\tif (CheckDirCount(tif, dir, (uint32) samples)) {\t\tdouble buf[10];\t\tdouble* v = buf;\t\tif (samples > NITEMS(buf))\t\t\tv = (double*) _TIFFmalloc(samples * sizeof (double));\t\tif (TIFFFetchAnyArray(tif, dir, v)) {\t\t\tint i;\t\t\tfor (i = 1; i < samples; i++)\t\t\t\tif (v[i] != v[0]) {\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\"Cannot handle different per-sample values for field \\\"%s\\\"\",\t\t\t   _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t*pl = v[0];\t\t\tstatus = 1;\t\t}\tbad:\t\tif (v != buf)\t\t\t_TIFFfree(v);\t}\treturn (status);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(void){\tchar buf[BUFSIZ];\tint i;\tsetbuf(stderr, buf);        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\tfor (i = 0; stuff[i] != NULL; i++)\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\texit(-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteRationalArray(TIFF* tif,    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, float* v){\tuint32 i;\tuint32* t;\tint status;\tdir->tdir_tag = tag;\tdir->tdir_type = (short) type;\tdir->tdir_count = n;\tt = (uint32*) _TIFFmalloc(2*n * sizeof (uint32));\tfor (i = 0; i < n; i++) {\t\tfloat fv = v[i];\t\tint sign = 1;\t\tuint32 den;\t\tif (fv < 0) {\t\t\tif (type == TIFF_RATIONAL) {\t\t\t\tTIFFWarning(tif->tif_name,\t\"\\\"%s\\\": Information lost writing value (%g) as (unsigned) RATIONAL\",\t\t\t\t_TIFFFieldWithTag(tif,tag)->field_name, v);\t\t\t\tfv = 0;\t\t\t} else\t\t\t\tfv = -fv, sign = -1;\t\t}\t\tden = 1L;\t\tif (fv > 0) {\t\t\twhile (fv < 1L<<(31-3) && den < 1L<<(31-3))\t\t\t\tfv *= 1<<3, den *= 1L<<3;\t\t}\t\tt[2*i+0] = sign * (fv + 0.5);\t\tt[2*i+1] = den;\t}\tstatus = TIFFWriteData(tif, dir, (char *)t);\t_TIFFfree((char*) t);\treturn (status);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "DECLAREreadFunc(readSeparateTilesIntoBuffer){\tint status = 1;\tuint32 imagew = TIFFRasterScanlineSize(in);\tuint32 tilew = TIFFTileRowSize(in);\tint iskew  = imagew - tilew*spp;\ttsize_t tilesize = TIFFTileSize(in);\ttdata_t tilebuf;\tuint8* bufp = (uint8*) buf;\tuint32 tw, tl;\tuint32 row;\tuint16 bps = 0, bytes_per_sample;\ttilebuf = _TIFFmalloc(tilesize);\tif (tilebuf == 0)\t\treturn 0;\t_TIFFmemset(tilebuf, 0, tilesize);\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\t(void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);        if( bps == 0 )        {            TIFFError(TIFFFileName(in), \"Error, cannot read BitsPerSample\");            status = 0;            goto done;        }        if( (bps % 8) != 0 )        {            TIFFError(TIFFFileName(in), \"Error, cannot handle BitsPerSample that is not a multiple of 8\");            status = 0;            goto done;        }\tbytes_per_sample = bps/8;\tfor (row = 0; row < imagelength; row += tl) {\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\t\tuint32 colb = 0;\t\tuint32 col;\t\tfor (col = 0; col < imagewidth; col += tw) {\t\t\ttsample_t s;\t\t\tfor (s = 0; s < spp; s++) {\t\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, s) < 0\t\t\t\t    && !ignore) {\t\t\t\t\tTIFFError(TIFFFileName(in),\t\t\t\t\t    \"Error, can't read tile at %lu %lu, \"\t\t\t\t\t    \"sample %lu\",\t\t\t\t\t    (unsigned long) col,\t\t\t\t\t    (unsigned long) row,\t\t\t\t\t    (unsigned long) s);\t\t\t\t\tstatus = 0;\t\t\t\t\tgoto done;\t\t\t\t}\t\t\t\t\t\t\t\tif (colb + tilew*spp > imagew) {\t\t\t\t\tuint32 width = imagew - colb;\t\t\t\t\tint oskew = tilew*spp - width;\t\t\t\t\tcpSeparateBufToContigBuf(\t\t\t\t\t    bufp+colb+s*bytes_per_sample,\t\t\t\t\t    tilebuf, nrow,\t\t\t\t\t    width/(spp*bytes_per_sample),\t\t\t\t\t    oskew + iskew,\t\t\t\t\t    oskew/spp, spp,\t\t\t\t\t    bytes_per_sample);\t\t\t\t} else\t\t\t\t\tcpSeparateBufToContigBuf(\t\t\t\t\t    bufp+colb+s*bytes_per_sample,\t\t\t\t\t    tilebuf, nrow, tw,\t\t\t\t\t    iskew, 0, spp,\t\t\t\t\t    bytes_per_sample);\t\t\t}\t\t\tcolb += tilew*spp;\t\t}\t\tbufp += imagew * nrow;\t}done:\t_TIFFfree(tilebuf);\treturn status;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcombineSeparateTileSamples8bits (uint8 *in[], uint8 *out, uint32 cols,                                 uint32 rows, uint32 imagewidth,                                  uint32 tw, uint16 spp, uint16 bps,  \t                         FILE *dumpfile, int format, int level)  {  int    ready_bits = 0;  uint32 src_rowsize, dst_rowsize, src_offset;   uint32 bit_offset;  uint32 row, col, src_byte = 0, src_bit = 0;  uint8  maskbits = 0, matchbits = 0;  uint8  buff1 = 0, buff2 = 0;  tsample_t s;  unsigned char *src = in[0];  unsigned char *dst = out;  char           action[32];  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"combineSeparateTileSamples8bits\",\"Invalid input or output buffer\");    return (1);    }  src_rowsize = ((bps * tw) + 7) / 8;  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;  maskbits =  (uint8)-1 >> ( 8 - bps);  for (row = 0; row < rows; row++)    {    ready_bits = 0;    buff1 = buff2 = 0;    dst = out + (row * dst_rowsize);    src_offset = row * src_rowsize;    for (col = 0; col < cols; col++)      {            bit_offset = col * bps;      src_byte = bit_offset / 8;      src_bit  = bit_offset % 8;      matchbits = maskbits << (8 - src_bit - bps);             for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)        {\tsrc = in[s] + src_offset + src_byte;        buff1 = ((*src) & matchbits) << (src_bit);                if (ready_bits >= 8)          {          *dst++ = buff2;          buff2 = buff1;          ready_bits -= 8;          strcpy (action, \"Flush\");          }        else          {          buff2 = (buff2 | (buff1 >> ready_bits));          strcpy (action, \"Update\");          }        ready_bits += bps;        if ((dumpfile != NULL) && (level == 3))          {          dump_info (dumpfile, format, \"\",                   \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);          dump_byte (dumpfile, format, \"Match bits\", matchbits);          dump_byte (dumpfile, format, \"Src   bits\", *src);          dump_byte (dumpfile, format, \"Buff1 bits\", buff1);          dump_byte (dumpfile, format, \"Buff2 bits\", buff2);          dump_info (dumpfile, format, \"\",\"%s\", action); \t  }        }      }    if (ready_bits > 0)      {      buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));      *dst++ = buff1;      if ((dumpfile != NULL) && (level == 3))        {        dump_info (dumpfile, format, \"\",\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\t         row + 1, col + 1, src_byte, src_bit, dst - out);                 dump_byte (dumpfile, format, \"Final bits\", buff1);        }      }    if ((dumpfile != NULL) && (level >= 2))      {      dump_info (dumpfile, format, \"combineSeparateTileSamples8bits\",\"Output data\");      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));      }    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFWarning(const char* module, const char* fmt, ...){\tva_list ap;\tva_start(ap, fmt);\tif (_TIFFwarningHandler)\t\t(*_TIFFwarningHandler)(module, fmt, ap);\tif (_TIFFwarningHandlerExt)\t\t(*_TIFFwarningHandlerExt)(0, module, fmt, ap);\tva_end(ap);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void t2p_read_tiff_size_tile(T2P* t2p, TIFF* input, ttile_t tile){\tuint64* tbc = NULL;\tuint16 edge=0;#ifdef JPEG_SUPPORT\tunsigned char* jpt;#endif        uint64 k;\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\tif(t2p->pdf_transcode==T2P_TRANSCODE_RAW){\t\tif(edge#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\t\t&& !(t2p->pdf_compression==T2P_COMPRESS_JPEG)#endif\t\t){\t\t\tt2p->tiff_datasize=TIFFTileSize(input);\t\t\tif (t2p->tiff_datasize == 0) {\t\t\t\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t}\t\t\treturn;\t\t} else {\t\t\tTIFFGetField(input, TIFFTAG_TILEBYTECOUNTS, &tbc);\t\t\tk=tbc[tile];#ifdef OJPEG_SUPPORT\t\t\tif(t2p->tiff_compression==COMPRESSION_OJPEG){\t\t\t  \tk = checkAdd64(k, 2048, t2p);\t\t\t}#endif#ifdef JPEG_SUPPORT\t\t\tif(t2p->tiff_compression==COMPRESSION_JPEG) {\t\t\t\tuint32 count = 0;\t\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt)!=0){\t\t\t\t\tif(count > 4){\t\t\t\t\t\tk = checkAdd64(k, count, t2p);\t\t\t\t\t\tk -= 2; \t\t\t\t\t}\t\t\t\t}\t\t\t}#endif\t\t\tt2p->tiff_datasize = (tsize_t) k;\t\t\tif ((uint64) t2p->tiff_datasize != k) {\t\t\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t}\t\t\treturn;\t\t}\t}\tk = TIFFTileSize(input);\tif(t2p->tiff_planar==PLANARCONFIG_SEPARATE){\t\tk = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);\t}\tif (k == 0) {\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t}\tt2p->tiff_datasize = (tsize_t) k;\tif ((uint64) t2p->tiff_datasize != k) {\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\t\tt2p->t2p_error = T2P_ERR_ERROR;\t}\treturn;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intLZWPreEncode(TIFF* tif, uint16 s){\tLZWCodecState *sp = EncoderState(tif);\t(void) s;\tassert(sp != NULL);\tif( sp->enc_hashtab == NULL )        {            tif->tif_setupencode( tif );        }\tsp->lzw_nbits = BITS_MIN;\tsp->lzw_maxcode = MAXCODE(BITS_MIN);\tsp->lzw_free_ent = CODE_FIRST;\tsp->lzw_nextbits = 0;\tsp->lzw_nextdata = 0;\tsp->enc_checkpoint = CHECK_GAP;\tsp->enc_ratio = 0;\tsp->enc_incount = 0;\tsp->enc_outcount = 0;\t\tsp->enc_rawlimit = tif->tif_rawdata + tif->tif_rawdatasize-1 - 4;\tcl_hash(sp);\t\t\tsp->enc_oldcode = (hcode_t) -1;\t\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFLastDirectory(TIFF* tif){\treturn (tif->tif_nextdiroff == 0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFUnRegisterCODEC(TIFFCodec* c){\tcodec_t* cd;\tcodec_t** pcd;\tfor (pcd = &registeredCODECS; (cd = *pcd); pcd = &cd->next)\t\tif (cd->info == c) {\t\t\t*pcd = cd->next;\t\t\t_TIFFfree(cd);\t\t\treturn;\t\t}\tTIFFErrorExt(0, \"TIFFUnRegisterCODEC\",\t    \"Cannot remove compression scheme %s; not registered\", c->name);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "unsigned char *TIFFGetOvrBlock_Subsampled( TIFFOvrCache *psCache,                                            int iTileX, int iTileY ){    int\t\tnRowOffset;    if( iTileY > psCache->nBlockOffset + 1 )        TIFFWriteOvrRow( psCache );    assert( iTileX >= 0 && iTileX < psCache->nBlocksPerRow );    assert( iTileY >= 0 && iTileY < psCache->nBlocksPerColumn );    assert( iTileY >= psCache->nBlockOffset            && iTileY < psCache->nBlockOffset+2 );    assert( psCache->nPlanarConfig != PLANARCONFIG_SEPARATE );    nRowOffset = iTileX * psCache->nBytesPerBlock;    if( iTileY == psCache->nBlockOffset )        return psCache->pabyRow1Blocks + nRowOffset;    else        return psCache->pabyRow2Blocks + nRowOffset;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void tiff2pdf_usage(){\tchar* lines[]={\t\"usage:  tiff2pdf [options] input.tiff\",\t\"options:\",\t\" -o: output to file name\",#ifdef JPEG_SUPPORT\t\" -j: compress with JPEG\", #endif#ifdef ZIP_SUPPORT\t\" -z: compress with Zip/Deflate\",#endif\t\" -q: compression quality\",\t\" -n: no compressed data passthrough\",\t\" -d: do not compress (decompress)\",\t\" -i: invert colors\",\t\" -u: set distance unit, 'i' for inch, 'm' for centimeter\",\t\" -x: set x resolution default in dots per unit\",\t\" -y: set y resolution default in dots per unit\",\t\" -w: width in units\",\t\" -l: length in units\",\t\" -r: 'd' for resolution default, 'o' for resolution override\",\t\" -p: paper size, eg \\\"letter\\\", \\\"legal\\\", \\\"A4\\\"\",  \" -F: make the tiff fill the PDF page\",\t\" -f: set PDF \\\"Fit Window\\\" user preference\",\t\" -e: date, overrides image or current date/time default, YYYYMMDDHHMMSS\",\t\" -c: sets document creator, overrides image software default\",\t\" -a: sets document author, overrides image artist default\",\t\" -t: sets document title, overrides image document name default\",\t\" -s: sets document subject, overrides image image description default\",\t\" -k: sets document keywords\",\t\" -b: set PDF \\\"Interpolate\\\" user preference\",\t\" -h: usage\",\tNULL\t};\tint i=0;\tfprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\tfor (i=0;lines[i]!=NULL;i++){\t\tfprintf(stderr, \"%s\\n\", lines[i]);\t}\treturn;}}void tiff2pdf_usage(){\tchar* lines[]={\t\"usage:  tiff2pdf [options] input.tiff\",\t\"options:\",\t\" -o: output to file name\",#ifdef JPEG_SUPPORT\t\" -j: compress with JPEG\", #endif#ifdef ZIP_SUPPORT\t\" -z: compress with Zip/Deflate\",#endif\t\" -q: compression quality\",\t\" -n: no compressed data passthrough\",\t\" -d: do not compress (decompress)\",\t\" -i: invert colors\",\t\" -u: set distance unit, 'i' for inch, 'm' for centimeter\",\t\" -x: set x resolution default in dots per unit\",\t\" -y: set y resolution default in dots per unit\",\t\" -w: width in units\",\t\" -l: length in units\",\t\" -r: 'd' for resolution default, 'o' for resolution override\",\t\" -p: paper size, eg \\\"letter\\\", \\\"legal\\\", \\\"A4\\\"\",  \" -F: make the tiff fill the PDF page\",\t\" -f: set PDF \\\"Fit Window\\\" user preference\",\t\" -e: date, overrides image or current date/time default, YYYYMMDDHHMMSS\",\t\" -c: sets document creator, overrides image software default\",\t\" -a: sets document author, overrides image artist default\",\t\" -t: sets document title, overrides image document name default\",\t\" -s: sets document subject, overrides image image description default\",\t\" -k: sets document keywords\",\t\" -b: set PDF \\\"Interpolate\\\" user preference\",\t\" -h: usage\",\tNULL\t};\tint i=0;\tfprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\tfor (i=0;lines[i]!=NULL;i++){\t\tfprintf(stderr, \"%s\\n\", lines[i]);\t}\treturn;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(void){\tchar buf[BUFSIZ];\tint i;\tsetbuf(stderr, buf);        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\tfor (i = 0; stuff[i] != NULL; i++)\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\texit(-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int rewrite_test( const char *filename, int length, int bigtiff,                   uint64 base_value ){    TIFF\t\t*tif;    int\t\t\ti;    unsigned char\tbuf[10] = {5,6,7,8,9,10,11,12,13,14};    uint64\t\t*rowoffset, *rowbytes;    uint64\t\t*upd_rowoffset;    uint64\t\t*upd_bytecount;        if( bigtiff )        tif = TIFFOpen(filename, \"w8\");    else        tif = TIFFOpen(filename, \"w4\");    if (!tif) {        fprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename);        return 1;    }    if (!TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS)) {        fprintf (stderr, \"Can't set Compression tag.\\n\");        goto failure;    }    if (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) {        fprintf (stderr, \"Can't set ImageWidth tag.\\n\");        goto failure;    }    if (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) {        fprintf (stderr, \"Can't set ImageLength tag.\\n\");        goto failure;    }    if (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8)) {        fprintf (stderr, \"Can't set BitsPerSample tag.\\n\");        goto failure;    }    if (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1)) {        fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");        goto failure;    }    if (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip)) {        fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");        goto failure;    }    if (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) {        fprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\");        goto failure;    }    for (i = 0; i < length; i++ )    {        if( TIFFWriteScanline( tif, buf, i, 0 ) == -1 )        {            fprintf (stderr, \"Can't write image data.\\n\");            goto failure;        }    }    TIFFClose(tif);        tif = TIFFOpen(filename, \"r+\");    if (!tif) {        fprintf (stderr, \"Can't open test TIFF file %s.\\n\", filename);        return 1;    }    if( !TIFFGetField( tif, TIFFTAG_STRIPOFFSETS, &rowoffset ) )    {        fprintf (stderr, \"Can't fetch STRIPOFFSETS.\\n\");        goto failure;    }    if( !TIFFGetField( tif, TIFFTAG_STRIPBYTECOUNTS, &rowbytes ) )    {        fprintf (stderr, \"Can't fetch STRIPBYTECOUNTS.\\n\");        goto failure;    }    upd_rowoffset = (uint64 *) _TIFFmalloc(sizeof(uint64) * length);    for( i = 0; i < length; i++ )        upd_rowoffset[i] = base_value + i*10;    if( !_TIFFRewriteField( tif, TIFFTAG_STRIPOFFSETS, TIFF_LONG8,                             length, upd_rowoffset ) )    {        fprintf (stderr, \"Can't rewrite STRIPOFFSETS.\\n\");        goto failure;    }    _TIFFfree( upd_rowoffset );    upd_bytecount = (uint64 *) _TIFFmalloc(sizeof(uint64) * length);    for( i = 0; i < length; i++ )        upd_bytecount[i] = 100 + i*10;    if( !_TIFFRewriteField( tif, TIFFTAG_STRIPBYTECOUNTS, TIFF_LONG8,                             length, upd_bytecount ) )    {        fprintf (stderr, \"Can't rewrite STRIPBYTECOUNTS.\\n\");        goto failure;    }    _TIFFfree( upd_bytecount );    TIFFClose(tif);        tif = TIFFOpen(filename, \"r\");    if (!tif) {        fprintf (stderr, \"Can't open test TIFF file %s.\\n\", filename);        return 1;    }    if( !TIFFGetField( tif, TIFFTAG_STRIPOFFSETS, &rowoffset ) )    {        fprintf (stderr, \"Can't fetch STRIPOFFSETS.\\n\");        goto failure;    }    for( i = 0; i < length; i++ )    {        uint64 expect = base_value + i*10;        if( rowoffset[i] != expect )        {            fprintf( stderr,                      \"%s:STRIPOFFSETS[%d]: Got %X:%08X instead of %X:%08X.\\n\",                     filename, i,                      (int) (rowoffset[i] >> 32),                      (int) (rowoffset[i]&0xFFFFFFFF),                      (int) (expect >> 32),                      (int) (expect & 0xFFFFFFFF) );            goto failure;        }    }    if( !TIFFGetField( tif, TIFFTAG_STRIPBYTECOUNTS, &rowbytes ) )    {        fprintf (stderr, \"Can't fetch STRIPBYTECOUNTS.\\n\");        goto failure;    }    for( i = 0; i < length; i++ )    {        uint64 expect = 100 + i*10;        if( rowbytes[i] != expect )        {            fprintf( stderr,                      \"%s:STRIPBYTECOUNTS[%d]: Got %X:%08X instead of %X:%08X.\\n\",                     filename, i,                      (int) (rowbytes[i] >> 32),                      (int) (rowbytes[i] & 0xFFFFFFFF),                      (int) (expect >> 32),                      (int) (expect & 0xFFFFFFFF) );            goto failure;        }    }    TIFFClose( tif );        unlink(filename);    return 0;  failure:        TIFFClose(tif);        return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char* argv[]){\tuint32\twidth, length;\tuint16\tnbands = 1;\t\t        uint16\tdepth = 8;\t\t\tuint32\trowsperstrip = (uint32) -1;        uint16\tphotometric = PHOTOMETRIC_MINISBLACK;\tint\tfd = 0;\t_TIFF_stat_s instat;\tchar\t*outfilename = NULL, *infilename = NULL;\tTIFF\t*out = NULL;\tBMPFileHeader file_hdr;        BMPInfoHeader info_hdr;        int     bmp_type;        uint32  clr_tbl_size, n_clr_elems = 3;        unsigned char *clr_tbl;\tunsigned short *red_tbl = NULL, *green_tbl = NULL, *blue_tbl = NULL;\tuint32\trow, clr;\tint\tc;#if !HAVE_DECL_OPTARG\textern int optind;\textern char* optarg;#endif\twhile ((c = getopt(argc, argv, \"c:r:o:h\")) != -1) {\t\tswitch (c) {\t\tcase 'c':\t\t\t\t\tif (!processCompressOptions(optarg))\t\t\t\tusage();\t\t\tbreak;\t\tcase 'r':\t\t\t\t\trowsperstrip = atoi(optarg);\t\t\tbreak;\t\tcase 'o':\t\t\toutfilename = optarg;\t\t\tbreak;\t\tcase 'h':\t\t\tusage();\t\tdefault:\t\t\tbreak;\t\t}\t}\tif (argc - optind < 2)\t\tusage();\tif (outfilename == NULL)\t\toutfilename = argv[argc-1];\tout = TIFFOpen(outfilename, \"w\");\tif (out == NULL) {\t\tTIFFError(infilename, \"Cannot open file %s for output\",\t\t\t  outfilename);\t\tgoto bad3;\t}\t\twhile (optind < argc-1) {\t\tinfilename = argv[optind];\t\toptind++;\t    \t\tfd = open(infilename, O_RDONLY|O_BINARY, 0);\t\tif (fd < 0) {\t\t\tTIFFError(infilename, \"Cannot open input file\");\t\t\treturn -1;\t\t}\t\tif (read(fd, file_hdr.bType, 2) != 2) {                        TIFFError(infilename, \"Failed to read from file (%s)\",                                  strerror(errno));\t\t\tgoto bad;                }\t\tif(file_hdr.bType[0] != 'B' || file_hdr.bType[1] != 'M') {\t\t\tTIFFError(infilename, \"File is not BMP\");\t\t\tgoto bad;\t\t}                                                                if (_TIFF_lseek_f(fd, 10, SEEK_SET) == (_TIFF_off_t)-1) {                        TIFFError(infilename, \"Failed to seek to offset\");                        goto bad;                }                if (read(fd, &file_hdr.iOffBits, 4) != 4) {                        TIFFError(infilename, \"Failed to read from file (%s)\",                                  strerror(errno));\t\t\tgoto bad;                }#ifdef WORDS_BIGENDIAN\t\tTIFFSwabLong(&file_hdr.iOffBits);#endif\t\tif (_TIFF_fstat_f(fd, &instat) == -1) {                        TIFFError(infilename, \"Failed obtain file information\");                        goto bad;                }\t\tfile_hdr.iSize = instat.st_size;                                                \t\tif (_TIFF_lseek_f(fd, BFH_SIZE, SEEK_SET) == (_TIFF_off_t)-1) {                        TIFFError(infilename, \"Failed to seek to offset\");                        goto bad;                }                if (read(fd, &info_hdr.iSize, 4) != 4) {                        TIFFError(infilename, \"Failed to read from file (%s)\",                                  strerror(errno));\t\t\tgoto bad;                }#ifdef WORDS_BIGENDIAN\t\tTIFFSwabLong(&info_hdr.iSize);#endif\t\tif (info_hdr.iSize == BIH_WIN4SIZE)\t\t\tbmp_type = BMPT_WIN4;\t\telse if (info_hdr.iSize == BIH_OS21SIZE)\t\t\tbmp_type = BMPT_OS21;\t\telse if (info_hdr.iSize == BIH_OS22SIZE\t\t\t || info_hdr.iSize == 16)\t\t\tbmp_type = BMPT_OS22;\t\telse\t\t\tbmp_type = BMPT_WIN5;\t\tif (bmp_type == BMPT_WIN4\t\t    || bmp_type == BMPT_WIN5\t\t    || bmp_type == BMPT_OS22) {\t\t\tif ((read(fd, &info_hdr.iWidth, 4) != 4) ||                            (read(fd, &info_hdr.iHeight, 4) != 4) ||                            (read(fd, &info_hdr.iPlanes, 2) != 2) ||                            (read(fd, &info_hdr.iBitCount, 2) != 2) ||                            (read(fd, &info_hdr.iCompression, 4) != 4) ||                            (read(fd, &info_hdr.iSizeImage, 4) != 4) ||                            (read(fd, &info_hdr.iXPelsPerMeter, 4) != 4) ||                            (read(fd, &info_hdr.iYPelsPerMeter, 4) != 4) ||                            (read(fd, &info_hdr.iClrUsed, 4) != 4) ||                            (read(fd, &info_hdr.iClrImportant, 4) != 4)) {                                TIFFError(infilename, \"Failed to read from file (%s)\",                                          strerror(errno));                                goto bad;                        }#ifdef WORDS_BIGENDIAN\t\t\tTIFFSwabLong((uint32*) &info_hdr.iWidth);\t\t\tTIFFSwabLong((uint32*) &info_hdr.iHeight);\t\t\tTIFFSwabShort((uint16*) &info_hdr.iPlanes);\t\t\tTIFFSwabShort((uint16*) &info_hdr.iBitCount);\t\t\tTIFFSwabLong((uint32*) &info_hdr.iCompression);\t\t\tTIFFSwabLong((uint32*) &info_hdr.iSizeImage);\t\t\tTIFFSwabLong((uint32*) &info_hdr.iXPelsPerMeter);\t\t\tTIFFSwabLong((uint32*) &info_hdr.iYPelsPerMeter);\t\t\tTIFFSwabLong((uint32*) &info_hdr.iClrUsed);\t\t\tTIFFSwabLong((uint32*) &info_hdr.iClrImportant);#endif\t\t\tn_clr_elems = 4;\t\t}\t\tif (bmp_type == BMPT_OS22) {\t\t\t                        n_clr_elems = 3;\t\t}\t\tif (bmp_type == BMPT_OS21) {\t\t\tint16  iShort;\t\t\tif ( read(fd, &iShort, 2) != 2 ) {                                TIFFError(infilename, \"Failed to read from file (%s)\",                                          strerror(errno));                                goto bad;                        }#ifdef WORDS_BIGENDIAN\t\t\tTIFFSwabShort((uint16*) &iShort);#endif\t\t\tinfo_hdr.iWidth = iShort;\t\t\tif ( read(fd, &iShort, 2) != 2 ) {                                TIFFError(infilename, \"Failed to read from file (%s)\",                                          strerror(errno));                                goto bad;                        }#ifdef WORDS_BIGENDIAN\t\t\tTIFFSwabShort((uint16*) &iShort);#endif\t\t\tinfo_hdr.iHeight = iShort;\t\t\tif (read(fd, &iShort, 2) != 2 ) {                                TIFFError(infilename, \"Failed to read from file (%s)\",                                          strerror(errno));                                goto bad;                        }#ifdef WORDS_BIGENDIAN\t\t\tTIFFSwabShort((uint16*) &iShort);#endif\t\t\tinfo_hdr.iPlanes = iShort;\t\t\tif ( read(fd, &iShort, 2) != 2 ) {                                TIFFError(infilename, \"Failed to read from file (%s)\",                                          strerror(errno));                                goto bad;                        }#ifdef WORDS_BIGENDIAN\t\t\tTIFFSwabShort((uint16*) &iShort);#endif\t\t\tinfo_hdr.iBitCount = iShort;\t\t\tinfo_hdr.iCompression = BMPC_RGB;\t\t\tn_clr_elems = 3;\t\t}\t\tif (info_hdr.iBitCount != 1  && info_hdr.iBitCount != 4  &&\t\t    info_hdr.iBitCount != 8  && info_hdr.iBitCount != 16 &&\t\t    info_hdr.iBitCount != 24 && info_hdr.iBitCount != 32) {                        TIFFError(infilename,                                  \"Cannot process BMP file with bit count %d\",                                  info_hdr.iBitCount);                        close(fd);                        return 0;\t\t}\t\twidth = info_hdr.iWidth;\t\tlength = (info_hdr.iHeight > 0) ? info_hdr.iHeight : -info_hdr.iHeight;                if( width <= 0 || length <= 0 )                        {                                TIFFError(infilename,                                          \"Invalid dimensions of BMP file\" );                                close(fd);                                return -1;                        }\t\tswitch (info_hdr.iBitCount)                        {\t\t\tcase 1:\t\t\tcase 4:\t\t\tcase 8:\t\t\t\tnbands = 1;\t\t\t\tdepth = info_hdr.iBitCount;\t\t\t\tphotometric = PHOTOMETRIC_PALETTE;\t\t\t\t\t\t\t\tif (info_hdr.iClrUsed)                                        clr_tbl_size =                                                ((uint32)(1<<depth)<info_hdr.iClrUsed)                                                ? (uint32) (1 << depth)                                                : info_hdr.iClrUsed;\t\t\t\telse                                        clr_tbl_size = 1 << depth;\t\t\t\tclr_tbl = (unsigned char *)\t\t\t\t\t_TIFFmalloc(n_clr_elems * clr_tbl_size);\t\t\t\tif (!clr_tbl) {\t\t\t\t\tTIFFError(infilename,                                                  \"Can't allocate space for color table\");\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t\tif (_TIFF_lseek_f(fd, BFH_SIZE + info_hdr.iSize, SEEK_SET) == (_TIFF_off_t)-1) {                                        TIFFError(infilename, \"Failed to seek to offset\");                                        goto bad;                                }\t\t\t\tif ( read(fd, clr_tbl, n_clr_elems * clr_tbl_size)                                     != (long) (n_clr_elems * clr_tbl_size) ) {                                        TIFFError(infilename, \"Failed to read from file (%s)\",                                                  strerror(errno));                                        goto bad;                                }\t\t\t\tred_tbl = (unsigned short*)\t\t\t\t\t_TIFFmalloc(((tmsize_t)1)<<depth * sizeof(unsigned short));\t\t\t\tif (!red_tbl) {\t\t\t\t\tTIFFError(infilename,                                                  \"Can't allocate space for red component table\");\t\t\t\t\t_TIFFfree(clr_tbl);\t\t\t\t\tgoto bad1;\t\t\t\t}\t\t\t\tgreen_tbl = (unsigned short*)\t\t\t\t\t_TIFFmalloc(((tmsize_t)1)<<depth * sizeof(unsigned short));\t\t\t\tif (!green_tbl) {\t\t\t\t\tTIFFError(infilename,                                                  \"Can't allocate space for green component table\");\t\t\t\t\t_TIFFfree(clr_tbl);\t\t\t\t\tgoto bad2;\t\t\t\t}\t\t\t\tblue_tbl = (unsigned short*)\t\t\t\t\t_TIFFmalloc(((tmsize_t)1)<<depth * sizeof(unsigned short));\t\t\t\tif (!blue_tbl) {\t\t\t\t\tTIFFError(infilename,                                                  \"Can't allocate space for blue component table\");\t\t\t\t\t_TIFFfree(clr_tbl);\t\t\t\t\tgoto bad3;\t\t\t\t}\t\t\t\tfor(clr = 0; clr < clr_tbl_size; clr++) {                                        red_tbl[clr] = 257*clr_tbl[clr*n_clr_elems+2];                                        green_tbl[clr] = 257*clr_tbl[clr*n_clr_elems+1];                                        blue_tbl[clr] = 257*clr_tbl[clr*n_clr_elems];\t\t\t\t}\t\t\t\t_TIFFfree(clr_tbl);\t\t\t\tbreak;\t\t\tcase 16:\t\t\tcase 24:\t\t\t\tnbands = 3;\t\t\t\tdepth = info_hdr.iBitCount / nbands;\t\t\t\tphotometric = PHOTOMETRIC_RGB;\t\t\t\tbreak;\t\t\tcase 32:\t\t\t\tnbands = 3;\t\t\t\tdepth = 8;\t\t\t\tphotometric = PHOTOMETRIC_RGB;\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tbreak;                        }                                                \t\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\t\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, length);\t\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\t\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, nbands);\t\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, depth);\t\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\t\t\t     TIFFDefaultStripSize(out, rowsperstrip));\t\t\t\tif (red_tbl && green_tbl && blue_tbl) {\t\t\tTIFFSetField(out, TIFFTAG_COLORMAP,\t\t\t\t     red_tbl, green_tbl, blue_tbl);\t\t}\t\t\t\tif (compression == (uint16) -1)\t\t\tcompression = COMPRESSION_PACKBITS;\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\t\tswitch (compression) {\t\tcase COMPRESSION_JPEG:\t\t\tif (photometric == PHOTOMETRIC_RGB\t\t\t    && jpegcolormode == JPEGCOLORMODE_RGB)\t\t\t\tphotometric = PHOTOMETRIC_YCBCR;\t\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\t\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\t\t\tbreak;\t\tcase COMPRESSION_LZW:\t\tcase COMPRESSION_DEFLATE:\t\t\tif (predictor != 0)\t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\t\t\tbreak;\t\t}                                                \t\tif (info_hdr.iCompression == BMPC_RGB) {\t\t\tuint32 offset, size;\t\t\tchar *scanbuf;\t\t\t\t\t\tsize = width * info_hdr.iBitCount + 31;\t\t\tif (!width || !info_hdr.iBitCount\t\t\t    || (size - 31) / info_hdr.iBitCount != width ) {\t\t\t\tTIFFError(infilename,\t\t\t\t\t  \"Wrong image parameters; can't \"\t\t\t\t\t  \"allocate space for scanline buffer\");\t\t\t\tgoto bad3;\t\t\t}\t\t\tsize = (size & ~31) / 8;\t\t\tscanbuf = (char *) _TIFFmalloc(size);\t\t\tif (!scanbuf) {\t\t\t\tTIFFError(infilename,                                          \"Can't allocate space for scanline buffer\");\t\t\t\tgoto bad3;\t\t\t}\t\t\tfor (row = 0; row < length; row++) {\t\t\t\tif (info_hdr.iHeight > 0)\t\t\t\t\toffset = file_hdr.iOffBits+(length-row-1)*size;\t\t\t\telse\t\t\t\t\toffset = file_hdr.iOffBits + row * size;\t\t\t\tif (_TIFF_lseek_f(fd, offset, SEEK_SET) == (_TIFF_off_t)-1) {\t\t\t\t\tTIFFError(infilename,\t\t\t\t\t\t  \"scanline %lu: Seek error\",\t\t\t\t\t\t  (unsigned long) row);\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\tif (read(fd, scanbuf, size) != (long) size) {\t\t\t\t\tTIFFError(infilename,\t\t\t\t\t\t  \"scanline %lu: Read error\",\t\t\t\t\t\t  (unsigned long) row);\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\trearrangePixels(scanbuf, width, info_hdr.iBitCount);\t\t\t\tif (TIFFWriteScanline(out, scanbuf, row, 0)<0) {\t\t\t\t\tTIFFError(infilename,\t\t\t\t\t\t  \"scanline %lu: Write error\",\t\t\t\t\t\t  (unsigned long) row);\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t\t_TIFFfree(scanbuf);                                                                        \t\t} else if ( info_hdr.iCompression == BMPC_RLE8\t\t\t    || info_hdr.iCompression == BMPC_RLE4 ) {\t\t\tuint32\t\ti, j, k, runlength;\t\t\tuint32\t\tcompr_size, uncompr_size;\t\t\tunsigned char   *comprbuf;\t\t\tunsigned char   *uncomprbuf;\t\t\tcompr_size = file_hdr.iSize - file_hdr.iOffBits;\t\t\tuncompr_size = width * length;                                                if( uncompr_size / width != length ) {                                TIFFError(infilename,                                          \"Invalid dimensions of BMP file\" );                                close(fd);                                return -1;                        }                        if ( (compr_size == 0) ||                             (compr_size > ((uint32) ~0) >> 1) ||                             (uncompr_size == 0) ||                             (uncompr_size > ((uint32) ~0) >> 1) ) {                                TIFFError(infilename,                                          \"Invalid dimensions of BMP file\" );                                close(fd);                                return -1;                          }\t\t\tcomprbuf = (unsigned char *) _TIFFmalloc( compr_size );\t\t\tif (!comprbuf) {\t\t\t\tTIFFError(infilename,                                          \"Can't allocate space for compressed scanline buffer\");\t\t\t\tgoto bad3;\t\t\t}\t\t\tuncomprbuf = (unsigned char *)_TIFFmalloc(uncompr_size);\t\t\tif (!uncomprbuf) {\t\t\t\tTIFFError(infilename,                                          \"Can't allocate space for uncompressed scanline buffer\");\t\t\t\tgoto bad3;\t\t\t}\t\t\tif (_TIFF_lseek_f(fd, file_hdr.iOffBits, SEEK_SET) == (_TIFF_off_t)-1) {                                TIFFError(infilename, \"Failed to seek to offset\");                                goto bad3;                        }\t\t\tif ( read(fd, comprbuf, compr_size) != (long) compr_size ) {                                TIFFError(infilename, \"Failed to read from file (%s)\",                                          strerror(errno));                                goto bad;                        }\t\t\ti = 0;\t\t\tj = 0;\t\t\tif (info_hdr.iBitCount == 8) {\t\t                                while(j < uncompr_size && i < compr_size) {                                        if ( comprbuf[i] ) {                                                runlength = comprbuf[i++];                                                while( runlength > 0                                                       && j < uncompr_size                                                       && i < compr_size ) {                                                        uncomprbuf[j++] = comprbuf[i];                                                        runlength--;                                                }                                                i++;                                        } else {                                                i++;                                                if (comprbuf[i] == 0)                                                         i++;                                                else if (comprbuf[i] == 1)                                                         break;                                                else if (comprbuf[i] == 2) {                                                         i++;                                                        if (i < compr_size - 1) {                                                                j+=comprbuf[i]+comprbuf[i+1]*width;                                                                i += 2;                                                        }                                                        else                                                                break;                                                } else {                                                                    runlength = comprbuf[i++];                                                        for (k = 0; k < runlength && j < uncompr_size && i < compr_size; k++)                                                                uncomprbuf[j++] = comprbuf[i++];                                                        if ( k & 0x01 )                                                                i++;                                                }                                        }                                }\t\t\t}\t\t\telse {\t\t\t\t                                    while( j < uncompr_size && i < compr_size ) {                                        if ( comprbuf[i] ) {                                                runlength = comprbuf[i++];                                                while( runlength > 0 && j < uncompr_size && i < compr_size ) {                                                        if ( runlength & 0x01 )                                                                uncomprbuf[j++] = (comprbuf[i] & 0xF0) >> 4;                                                        else                                                                uncomprbuf[j++] = comprbuf[i] & 0x0F;                                                        runlength--;                                                }                                                i++;                                        } else {                                                i++;                                                if (comprbuf[i] == 0)                                                         i++;                                                else if (comprbuf[i] == 1)                                                         break;                                                else if (comprbuf[i] == 2) {                                                         i++;                                                        if (i < compr_size - 1) {                                                                j+=comprbuf[i]+comprbuf[i+1]*width;                                                                i += 2;                                                        }                                                        else                                                                break;                                                } else {                                                                    runlength = comprbuf[i++];                                                        for (k = 0; k < runlength && j < uncompr_size && i < compr_size; k++) {                                                                if (k & 0x01)                                                                        uncomprbuf[j++] = comprbuf[i++] & 0x0F;                                                                else                                                                        uncomprbuf[j++] = (comprbuf[i] & 0xF0) >> 4;                                                        }                                                        if (k & 0x01)                                                                i++;                                                }                                        }                                }\t\t\t}\t\t\t_TIFFfree(comprbuf);\t\t\tfor (row = 0; row < length; row++) {\t\t\t\tif (TIFFWriteScanline(out,                                                      uncomprbuf + (length - row - 1) * width,                                                      row, 0) < 0) {\t\t\t\t\tTIFFError(infilename,                                                  \"scanline %lu: Write error.\\n\",\t\t\t\t\t\t  (unsigned long) row);\t\t\t\t}\t\t\t}\t\t\t_TIFFfree(uncomprbuf);\t\t}\t\tTIFFWriteDirectory(out);\t\tif (blue_tbl) {                        _TIFFfree(blue_tbl);                        blue_tbl=NULL;\t\t}\t\tif (green_tbl) {                        _TIFFfree(green_tbl);                        green_tbl=NULL;\t\t}\t\tif (red_tbl) {                        _TIFFfree(red_tbl);                        red_tbl=NULL;\t\t}\t} bad3:\tif (blue_tbl)\t\t_TIFFfree(blue_tbl); bad2:\tif (green_tbl)\t\t_TIFFfree(green_tbl); bad1:\tif (red_tbl)\t\t_TIFFfree(red_tbl); bad:        close(fd);\tif (out)\t\tTIFFClose(out);        return 0;}",
        "label": 1,
        "cve": "cve-2015-8870"
    },
    {
        "code": "static int writeBufferToSeparateTiles (TIFF* out, uint8* buf, uint32 imagelength,\t\t\t\t       uint32 imagewidth, tsample_t spp,                                        struct dump_opts * dump)  {  tdata_t obuf = _TIFFmalloc(TIFFTileSize(out));  uint32 tl, tw;  uint32 row, col, nrow, ncol;  uint32 src_rowsize, col_offset;  uint16 bps;  tsample_t s;  uint8* bufp = (uint8*) buf;  if (obuf == NULL)    return 1;  TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);  TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);  TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);  if( imagewidth == 0 ||      (uint32)bps * (uint32)spp > TIFF_UINT32_MAX / imagewidth ||      bps * spp * imagewidth > TIFF_UINT32_MAX - 7 )  {      TIFFError(TIFFFileName(out),            \"Error, uint32 overflow when computing (imagewidth * bps * spp) + 7\");      _TIFFfree(obuf);      return 1;  }  src_rowsize = ((imagewidth * spp * bps) + 7U) / 8;  for (row = 0; row < imagelength; row += tl)    {    nrow = (row + tl > imagelength) ? imagelength - row : tl;    for (col = 0; col < imagewidth; col += tw)      {            if (col + tw > imagewidth)\tncol = imagewidth - col;      else        ncol = tw;      col_offset = (((col * bps * spp) + 7) / 8);      bufp = buf + (row * src_rowsize) + col_offset;      for (s = 0; s < spp; s++)        {\tif (extractContigSamplesToTileBuffer(obuf, bufp, nrow, ncol, imagewidth,\t\t\t\t\t     tw, s, 1, spp, bps, dump) > 0)          {\t  TIFFError(\"writeBufferToSeparateTiles\",                     \"Unable to extract data to tile for row %lu, col %lu sample %d\",                    (unsigned long) row, (unsigned long)col, (int)s);\t  _TIFFfree(obuf);\t  return 1;          }\tif (TIFFWriteTile(out, obuf, col, row, 0, s) < 0)          {\t   TIFFError(\"writeBufferToseparateTiles\",\t             \"Cannot write tile at %lu %lu sample %lu\",\t             (unsigned long) col, (unsigned long) row,\t             (unsigned long) s);\t   _TIFFfree(obuf);\t   return 1;\t  }\t}      }    }  _TIFFfree(obuf);  return 0;  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidsplitbox(Colorbox* ptr){\tuint32\t\thist2[B_LEN];\tint\t\tfirst=0, last=0;\tregister Colorbox\t*new;\tregister uint32\t*iptr, *histp;\tregister int\ti, j;\tregister int\tir,ig,ib;\tregister uint32 sum, sum1, sum2;\tenum { RED, GREEN, BLUE } axis;\t\ti = ptr->rmax - ptr->rmin;\tif (i >= ptr->gmax - ptr->gmin && i >= ptr->bmax - ptr->bmin)\t\taxis = RED;\telse if (ptr->gmax - ptr->gmin >= ptr->bmax - ptr->bmin)\t\taxis = GREEN;\telse\t\taxis = BLUE;\t\tswitch (axis) {\tcase RED:\t\thistp = &hist2[ptr->rmin];\t        for (ir = ptr->rmin; ir <= ptr->rmax; ++ir) {\t\t\t*histp = 0;\t\t\tfor (ig = ptr->gmin; ig <= ptr->gmax; ++ig) {\t\t\t\tiptr = &histogram[ir][ig][ptr->bmin];\t\t\t\tfor (ib = ptr->bmin; ib <= ptr->bmax; ++ib)\t\t\t\t\t*histp += *iptr++;\t\t\t}\t\t\thistp++;\t        }\t        first = ptr->rmin;\t\tlast = ptr->rmax;\t        break;\tcase GREEN:\t        histp = &hist2[ptr->gmin];\t        for (ig = ptr->gmin; ig <= ptr->gmax; ++ig) {\t\t\t*histp = 0;\t\t\tfor (ir = ptr->rmin; ir <= ptr->rmax; ++ir) {\t\t\t\tiptr = &histogram[ir][ig][ptr->bmin];\t\t\t\tfor (ib = ptr->bmin; ib <= ptr->bmax; ++ib)\t\t\t\t\t*histp += *iptr++;\t\t\t}\t\t\thistp++;\t        }\t        first = ptr->gmin;\t\tlast = ptr->gmax;\t        break;\tcase BLUE:\t        histp = &hist2[ptr->bmin];\t        for (ib = ptr->bmin; ib <= ptr->bmax; ++ib) {\t\t\t*histp = 0;\t\t\tfor (ir = ptr->rmin; ir <= ptr->rmax; ++ir) {\t\t\t\tiptr = &histogram[ir][ptr->gmin][ib];\t\t\t\tfor (ig = ptr->gmin; ig <= ptr->gmax; ++ig) {\t\t\t\t\t*histp += *iptr;\t\t\t\t\tiptr += B_LEN;\t\t\t\t}\t\t\t}\t\t\thistp++;\t        }\t        first = ptr->bmin;\t\tlast = ptr->bmax;\t        break;\t}\t\tsum2 = ptr->total / 2;\thistp = &hist2[first];\tsum = 0;\tfor (i = first; i <= last && (sum += *histp++) < sum2; ++i)\t\t;\tif (i == first)\t\ti++;\t\tnew = freeboxes;\tfreeboxes = new->next;\tif (freeboxes)\t\tfreeboxes->prev = NULL;\tif (usedboxes)\t\tusedboxes->prev = new;\tnew->next = usedboxes;\tusedboxes = new;\thistp = &hist2[first];\tfor (sum1 = 0, j = first; j < i; j++)\t\tsum1 += *histp++;\tfor (sum2 = 0, j = i; j <= last; j++)\t    sum2 += *histp++;\tnew->total = sum1;\tptr->total = sum2;\tnew->rmin = ptr->rmin;\tnew->rmax = ptr->rmax;\tnew->gmin = ptr->gmin;\tnew->gmax = ptr->gmax;\tnew->bmin = ptr->bmin;\tnew->bmax = ptr->bmax;\tswitch (axis) {\tcase RED:\t\tnew->rmax = i-1;\t        ptr->rmin = i;\t        break;\tcase GREEN:\t        new->gmax = i-1;\t        ptr->gmin = i;\t        break;\tcase BLUE:\t        new->bmax = i-1;\t        ptr->bmin = i;\t        break;\t}\tshrinkbox(new);\tshrinkbox(ptr);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidFillTable(TIFFFaxTabEnt *T, int Size, struct proto *P, int State){    int limit = 1 << Size;    while (P->val) {\tint width = P->val & 15;\tint param = P->val >> 4;\tint incr = 1 << width;\tint code;\tfor (code = P->code; code < limit; code += incr) {\t    TIFFFaxTabEnt *E = T+code;\t    E->State = State;\t    E->Width = width;\t    E->Param = param;\t}\tP++;    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int JBIGDecode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s){\tstruct jbg_dec_state decoder;\tint decodeStatus = 0;\tunsigned char* pImage = NULL;\t(void) size, (void) s;\tif (isFillOrder(tif, tif->tif_dir.td_fillorder))\t{\t\tTIFFReverseBits(tif->tif_rawdata, tif->tif_rawdatasize);\t}\tjbg_dec_init(&decoder);#if defined(HAVE_JBG_NEWLEN)\tjbg_newlen(tif->tif_rawdata, (size_t)tif->tif_rawdatasize);\t#endif \tdecodeStatus = jbg_dec_in(&decoder, (unsigned char*)tif->tif_rawdata,\t\t\t\t  (size_t)tif->tif_rawdatasize, NULL);\tif (JBG_EOK != decodeStatus)\t{\t\t\t\tTIFFErrorExt(tif->tif_clientdata,\t\t\t     \"JBIG\", \"Error (%d) decoding: %s\",\t\t\t     decodeStatus,#if defined(JBG_EN)\t\t\t     jbg_strerror(decodeStatus, JBG_EN)#else\t\t\t     jbg_strerror(decodeStatus)#endif\t\t\t     );\t\treturn 0;\t}\tpImage = jbg_dec_getimage(&decoder, 0);\t_TIFFmemcpy(buffer, pImage, jbg_dec_getsize(&decoder));\tjbg_dec_free(&decoder);\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFSetCompressionScheme(TIFF* tif, int scheme){\tconst TIFFCodec *c = TIFFFindCODEC((uint16) scheme);\t_TIFFSetDefaultCompressionState(tif);\t\treturn (c ? (*c->init)(tif, scheme) : 1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidOJPEGPostDecode(TIFF* tif, tidata_t buf, tsize_t cc){\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\t(void)buf;\t(void)cc;\tsp->write_curstrile++;\tif (sp->write_curstrile%tif->tif_dir.td_stripsperimage==0)\t{\t\tassert(sp->libjpeg_session_active!=0);\t\tOJPEGLibjpegSessionAbort(tif);\t\tsp->writeheader_done=0;\t}}",
        "label": 1,
        "cve": "cve-2010-2596"
    },
    {
        "code": "static intCheckDirCount(TIFF* tif, TIFFDirEntry* dir, uint32 count){\tif (count != dir->tdir_count) {\t\tTIFFWarning(tif->tif_name,\t\"incorrect count for field \\\"%s\\\" (%lu, expecting %lu); tag ignored\",\t\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name,\t\t    dir->tdir_count, count);\t\treturn (0);\t}\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidraster_keys(unsigned char key, int x, int y){        switch (key) {                case 'b':                                           photo = PHOTOMETRIC_MINISBLACK;                    initImage();                    break;                case 'l':                                           order = FILLORDER_LSB2MSB;                    initImage();                    break;                case 'm':                                           order = FILLORDER_MSB2LSB;                    initImage();                    break;                case 'w':                                           photo = PHOTOMETRIC_MINISWHITE;                    initImage();                    break;                case 'W':                                           owarning = TIFFSetWarningHandler(owarning);                    initImage();                    break;                case 'E':                                           oerror = TIFFSetErrorHandler(oerror);                    initImage();                    break;                case 'z':                                       case 'Z':                    order = order0;                    photo = photo0;                    if (owarning == NULL)                        owarning = TIFFSetWarningHandler(NULL);                    if (oerror == NULL)                        oerror = TIFFSetErrorHandler(NULL);                    initImage();                    break;                case 'q':                                       case '\\033':                    cleanup_and_exit();        }        glutPostRedisplay();}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFSwabArrayOfTriples(register uint8* tp, tmsize_t n){\tunsigned char* cp;\tunsigned char t;\t\twhile (n-- > 0) {\t\tcp = (unsigned char*) tp;\t\tt = cp[2]; cp[2] = cp[0]; cp[0] = t;\t\ttp += 3;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "staticvoid TIFF_DownSample( unsigned char *pabySrcTile,                      uint32 nBlockXSize, uint32 nBlockYSize,                      int nPixelSkewBits, int nBitsPerPixel,                      unsigned char * pabyOTile,                      uint32 nOBlockXSize, uint32 nOBlockYSize,                      uint32 nTXOff, uint32 nTYOff, int nOMult,                      int nSampleFormat, const char * pszResampling ){    uint32\ti, j;    int         k, nPixelBytes = (nBitsPerPixel) / 8;    int\t\tnPixelGroupBytes = (nBitsPerPixel+nPixelSkewBits)/8;    unsigned char *pabySrc, *pabyDst;    double      *padfSamples;    assert( nBitsPerPixel >= 8 );    padfSamples = (double *) malloc(sizeof(double) * nOMult * nOMult);    for( j = 0; j*nOMult < nBlockYSize; j++ )    {        if( j + nTYOff >= nOBlockYSize )            break;        pabyDst = pabyOTile + ((j+nTYOff)*nOBlockXSize + nTXOff)            * nPixelBytes * nPixelGroupBytes;        if( strncmp(pszResampling,\"nearest\",4) == 0            || strncmp(pszResampling,\"NEAR\",4) == 0 )        {            pabySrc = pabySrcTile + j*nOMult*nBlockXSize * nPixelGroupBytes;            for( i = 0; i*nOMult < nBlockXSize; i++ )            {                if( i + nTXOff >= nOBlockXSize )                    break;                                for( k = 0; k < nPixelBytes; k++ )                    pabyDst[k] = pabySrc[k];                pabyDst += nPixelBytes * nPixelGroupBytes;                pabySrc += nOMult * nPixelGroupBytes;            }        }        else if( strncmp(pszResampling,\"averag\",6) == 0                 || strncmp(pszResampling,\"AVERAG\",6) == 0 )        {            pabySrc = pabySrcTile + j*nOMult*nBlockXSize * nPixelGroupBytes;            for( i = 0; i*nOMult < nBlockXSize; i++ )            {                double   dfTotal;                uint32   nXSize, nYSize, iSample;                if( i + nTXOff >= nOBlockXSize )                    break;                nXSize = MIN((uint32)nOMult,nBlockXSize-i);                nYSize = MIN((uint32)nOMult,nBlockYSize-j);                TIFF_GetSourceSamples( padfSamples, pabySrc,                                       nPixelBytes, nSampleFormat,                                       nXSize, nYSize,                                       nPixelGroupBytes,                                       nPixelGroupBytes * nBlockXSize );                dfTotal = 0;                for( iSample = 0; iSample < nXSize*nYSize; iSample++ )                {                    dfTotal += padfSamples[iSample];                }                TIFF_SetSample( pabyDst, nPixelBytes, nSampleFormat,                                 dfTotal / (nXSize*nYSize) );                pabySrc += nOMult * nPixelGroupBytes;                pabyDst += nPixelBytes;            }        }    }    free( padfSamples );}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char* argv[]){\tuint16 bitspersample, shortv;\tuint32 imagewidth, imagelength;\tuint16 config = PLANARCONFIG_CONTIG;\tuint32 rowsperstrip = (uint32) -1;\tuint16 photometric = PHOTOMETRIC_RGB;\tuint16 *rmap, *gmap, *bmap;\tuint32 row;\tint cmap = -1;\tTIFF *in, *out;\tint c;\textern int optind;\textern char* optarg;\twhile ((c = getopt(argc, argv, \"C:c:p:r:\")) != -1)\t\tswitch (c) {\t\tcase 'C':\t\t\t\t\tcmap = atoi(optarg);\t\t\tbreak;\t\tcase 'c':\t\t\t\t\tif (!processCompressOptions(optarg))\t\t\t\tusage();\t\t\tbreak;\t\tcase 'p':\t\t\t\t\tif (streq(optarg, \"separate\"))\t\t\t\tconfig = PLANARCONFIG_SEPARATE;\t\t\telse if (streq(optarg, \"contig\"))\t\t\t\tconfig = PLANARCONFIG_CONTIG;\t\t\telse\t\t\t\tusage();\t\t\tbreak;\t\tcase 'r':\t\t\t\t\trowsperstrip = atoi(optarg);\t\t\tbreak;\t\tcase '?':\t\t\tusage();\t\t\t\t\t}\tif (argc - optind != 2)\t\tusage();\tin = TIFFOpen(argv[optind], \"r\");\tif (in == NULL)\t\treturn (-1);\tif (!TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &shortv) ||\t    shortv != PHOTOMETRIC_PALETTE) {\t\tfprintf(stderr, \"%s: Expecting a palette image.\\n\",\t\t    argv[optind]);\t\treturn (-1);\t}\tif (!TIFFGetField(in, TIFFTAG_COLORMAP, &rmap, &gmap, &bmap)) {\t\tfprintf(stderr,\t\t    \"%s: No colormap (not a valid palette image).\\n\",\t\t    argv[optind]);\t\treturn (-1);\t}\tbitspersample = 0;\tTIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\tif (bitspersample != 8) {\t\tfprintf(stderr, \"%s: Sorry, can only handle 8-bit images.\\n\",\t\t    argv[optind]);\t\treturn (-1);\t}\tout = TIFFOpen(argv[optind+1], \"w\");\tif (out == NULL)\t\treturn (-2);\tcpTags(in, out);\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &imagewidth);\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &imagelength);\tif (compression != (uint16)-1)\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\telse\t\tTIFFGetField(in, TIFFTAG_COMPRESSION, &compression);\tswitch (compression) {\tcase COMPRESSION_JPEG:\t\tif (jpegcolormode == JPEGCOLORMODE_RGB)\t\t\tphotometric = PHOTOMETRIC_YCBCR;\t\telse\t\t\tphotometric = PHOTOMETRIC_RGB;\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\t\tbreak;\tcase COMPRESSION_LZW:\tcase COMPRESSION_DEFLATE:\t\tif (predictor != 0)\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\t\tbreak;\t}\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3);\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\t    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip));\t(void) TIFFGetField(in, TIFFTAG_PLANARCONFIG, &shortv);\tif (cmap == -1)\t\tcmap = checkcmap(1<<bitspersample, rmap, gmap, bmap);\tif (cmap == 16) {\t\t\t\tint i;\t\tfor (i = (1<<bitspersample)-1; i >= 0; i--) {#define\tCVT(x)\t\t(((x) * 255) / ((1L<<16)-1))\t\t\trmap[i] = CVT(rmap[i]);\t\t\tgmap[i] = CVT(gmap[i]);\t\t\tbmap[i] = CVT(bmap[i]);\t\t}\t}\t{ unsigned char *ibuf, *obuf;\t  register unsigned char* pp;\t  register uint32 x;\t  ibuf = (unsigned char*)_TIFFmalloc(TIFFScanlineSize(in));\t  obuf = (unsigned char*)_TIFFmalloc(TIFFScanlineSize(out));\t  switch (config) {\t  case PLANARCONFIG_CONTIG:\t\tfor (row = 0; row < imagelength; row++) {\t\t\tif (!TIFFReadScanline(in, ibuf, row, 0))\t\t\t\tgoto done;\t\t\tpp = obuf;\t\t\tfor (x = 0; x < imagewidth; x++) {\t\t\t\t*pp++ = (unsigned char) rmap[ibuf[x]];\t\t\t\t*pp++ = (unsigned char) gmap[ibuf[x]];\t\t\t\t*pp++ = (unsigned char) bmap[ibuf[x]];\t\t\t}\t\t\tif (!TIFFWriteScanline(out, obuf, row, 0))\t\t\t\tgoto done;\t\t}\t\tbreak;\t  case PLANARCONFIG_SEPARATE:\t\tfor (row = 0; row < imagelength; row++) {\t\t\tif (!TIFFReadScanline(in, ibuf, row, 0))\t\t\t\tgoto done;\t\t\tfor (pp = obuf, x = 0; x < imagewidth; x++)\t\t\t\t*pp++ = (unsigned char) rmap[ibuf[x]];\t\t\tif (!TIFFWriteScanline(out, obuf, row, 0))\t\t\t\tgoto done;\t\t\tfor (pp = obuf, x = 0; x < imagewidth; x++)\t\t\t\t*pp++ = (unsigned char) gmap[ibuf[x]];\t\t\tif (!TIFFWriteScanline(out, obuf, row, 0))\t\t\t\tgoto done;\t\t\tfor (pp = obuf, x = 0; x < imagewidth; x++)\t\t\t\t*pp++ = (unsigned char) bmap[ibuf[x]];\t\t\tif (!TIFFWriteScanline(out, obuf, row, 0))\t\t\t\tgoto done;\t\t}\t\tbreak;\t  }\t  _TIFFfree(ibuf);\t  _TIFFfree(obuf);\t}done:\t(void) TIFFClose(in);\t(void) TIFFClose(out);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int_TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c){\tregister const BYTE *pb1 = (const BYTE *) p1;\tregister const BYTE *pb2 = (const BYTE *) p2;\tregister DWORD dwTmp = c;\tregister int iTmp;\tfor (iTmp = 0; dwTmp-- && !iTmp; iTmp = (int)*pb1++ - (int)*pb2++)\t\t;\treturn (iTmp);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFUnlinkDirectory(TIFF* tif, tdir_t dirn){\tstatic const char module[] = \"TIFFUnlinkDirectory\";\ttoff_t nextdir;\ttoff_t off;\ttdir_t n;\tif (tif->tif_mode == O_RDONLY) {\t\tTIFFErrorExt(tif->tif_clientdata, module,                             \"Can not unlink directory in read-only file\");\t\treturn (0);\t}\t\tnextdir = tif->tif_header.tiff_diroff;\toff = sizeof (uint16) + sizeof (uint16);\tfor (n = dirn-1; n > 0; n--) {\t\tif (nextdir == 0) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Directory %d does not exist\", dirn);\t\t\treturn (0);\t\t}\t\tif (!TIFFAdvanceDirectory(tif, &nextdir, &off))\t\t\treturn (0);\t}\t\tif (!TIFFAdvanceDirectory(tif, &nextdir, NULL))\t\treturn (0);\t\t(void) TIFFSeekFile(tif, off, SEEK_SET);\tif (tif->tif_flags & TIFF_SWAB)\t\tTIFFSwabLong(&nextdir);\tif (!WriteOK(tif, &nextdir, sizeof (uint32))) {\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Error writing directory link\");\t\treturn (0);\t}\t\t(*tif->tif_cleanup)(tif);\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {\t\t_TIFFfree(tif->tif_rawdata);\t\ttif->tif_rawdata = NULL;\t\ttif->tif_rawcc = 0;\t}\ttif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP|TIFF_POSTENCODE);\tTIFFFreeDirectory(tif);\tTIFFDefaultDirectory(tif);\ttif->tif_diroff = 0;\t\t\t\ttif->tif_nextdiroff = 0;\t\t\ttif->tif_curoff = 0;\ttif->tif_row = (uint32) -1;\ttif->tif_curstrip = (tstrip_t) -1;\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int dump_long (FILE *dumpfile, int format, char *dump_tag, uint32 data)  {  int j, k;  char  dump_array[40];  unsigned char bitset;  if (dumpfile == NULL)    {    TIFFError (\"\", \"Invalid FILE pointer for dump file\");    return (1);    }  if (format == DUMP_TEXT)    {    fprintf (dumpfile,\" %s  \", dump_tag);    for (j = 0, k = 31; k >= 0; j++, k--)      {      bitset = data & (((uint32)1 << k)) ? 1 : 0;      sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");      if ((k % 8) == 0)          sprintf(&dump_array[++j], \" \");      }    dump_array[35] = '\\0';    fprintf (dumpfile,\" %s\\n\", dump_array);    }  else    {    if ((fwrite (&data, 4, 1, dumpfile)) != 4)      {      TIFFError (\"\", \"Unable to write binary data to dump file\");      return (1);      }    }  return (0);  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "toff_tTIFFWritePrivateDataSubDirectory(TIFF* tif,\t\t\t\t uint32 pdir_fieldsset[], int pdir_fields_last,\t\t\t\t TIFFFieldInfo *field_info,\t\t\t\t int (*getFieldFn)(TIFF *tif, ttag_t tag, ...)){\tuint16 dircount;\tuint32 diroff, nextdiroff;\tttag_t tag;\tuint32 nfields;\ttsize_t dirsize;\tchar* data;\tTIFFDirEntry* dir;\tu_long b, *fields, fields_size;\ttoff_t directory_offset;\tTIFFFieldInfo* fip;\t\t\tTIFFFlushData(tif);\t\tnfields = 0;\tfor (b = 0; b <= pdir_fields_last; b++)\t\tif (FieldSet(pdir_fieldsset, b))\t\t\t\t\t\tnfields += 1;\tdirsize = nfields * sizeof (TIFFDirEntry);\tdata = (char*) _TIFFmalloc(dirsize);\tif (data == NULL) {\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t    \"Cannot write private subdirectory, out of space\");\t\treturn (0);\t}\t\tif (tif->tif_dataoff == 0)\t    tif->tif_dataoff =(TIFFSeekFile(tif, (toff_t) 0, SEEK_END)+1) &~ 1;\tdiroff = tif->tif_dataoff;\ttif->tif_dataoff = (toff_t)(\t    diroff + sizeof (uint16) + dirsize + sizeof (toff_t));\tif (tif->tif_dataoff & 1)\t\ttif->tif_dataoff++;\t(void) TIFFSeekFile(tif, tif->tif_dataoff, SEEK_SET);\t\tdir = (TIFFDirEntry*) data;\t\t\tfields_size = pdir_fields_last / (8*sizeof(uint32)) + 1;\tfields = _TIFFmalloc(fields_size*sizeof(uint32));\t_TIFFmemcpy(fields, pdir_fieldsset, fields_size * sizeof(uint32));\t\t\tfor (fip = field_info; fip->field_tag; fip++) {\t\t\t\tif (\t\t    !FieldSet(fields, fip->field_bit))\t\t\tcontinue;\t\tif (!TIFFWriteNormalSubTag(tif, dir, fip, getFieldFn))\t\t\tgoto bad;\t\tdir++;\t\tResetFieldBit(fields, fip->field_bit);\t}\t\tdirectory_offset = tif->tif_dataoff;\t\tdircount = (uint16) nfields;\t\tnextdiroff = 0;\tif (tif->tif_flags & TIFF_SWAB) {\t\t\t\tfor (dir = (TIFFDirEntry*) data; dircount; dir++, dircount--) {\t\t\tTIFFSwabArrayOfShort(&dir->tdir_tag, 2);\t\t\tTIFFSwabArrayOfLong(&dir->tdir_count, 2);\t\t}\t\tdircount = (uint16) nfields;\t\tTIFFSwabShort(&dircount);\t\tTIFFSwabLong(&nextdiroff);\t}\t(void) TIFFSeekFile(tif, tif->tif_dataoff, SEEK_SET);\tif (!WriteOK(tif, &dircount, sizeof (dircount))) {\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error writing private subdirectory count\");\t\tgoto bad;\t}\tif (!WriteOK(tif, data, dirsize)) {\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error writing private subdirectory contents\");\t\tgoto bad;\t}\tif (!WriteOK(tif, &nextdiroff, sizeof (nextdiroff))) {\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error writing private subdirectory link\");\t\tgoto bad;\t}\ttif->tif_dataoff += sizeof(dircount) + dirsize + sizeof(nextdiroff);\t_TIFFfree(data);\t_TIFFfree(fields);\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\t\t(*tif->tif_cleanup)(tif);\t\tTIFFDefaultDirectory(tif);\ttif->tif_curoff = 0;\ttif->tif_row = (uint32) -1;\ttif->tif_curstrip = (tstrip_t) -1;\treturn (directory_offset);bad:\t_TIFFfree(data);\t_TIFFfree(fields);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFSetDefaultCompressionState(TIFF* tif){\ttif->tif_decodestatus = TRUE;\ttif->tif_setupdecode = _TIFFtrue;\ttif->tif_predecode = _TIFFNoPreCode;\ttif->tif_decoderow = _TIFFNoRowDecode;\ttif->tif_decodestrip = _TIFFNoStripDecode;\ttif->tif_decodetile = _TIFFNoTileDecode;\ttif->tif_encodestatus = TRUE;\ttif->tif_setupencode = _TIFFtrue;\ttif->tif_preencode = _TIFFNoPreCode;\ttif->tif_postencode = _TIFFtrue;\ttif->tif_encoderow = _TIFFNoRowEncode;\ttif->tif_encodestrip = _TIFFNoStripEncode;\ttif->tif_encodetile = _TIFFNoTileEncode;\ttif->tif_close = _TIFFvoid;\ttif->tif_seek = _TIFFNoSeek;\ttif->tif_cleanup = _TIFFvoid;\ttif->tif_defstripsize = _TIFFDefaultStripSize;\ttif->tif_deftilesize = _TIFFDefaultTileSize;\ttif->tif_flags &= ~(TIFF_NOBITREV|TIFF_NOREADRAW);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intOJPEGReadHeaderInfoSecTablesQTable(TIFF* tif){\tstatic const char module[]=\"OJPEGReadHeaderInfoSecTablesQTable\";\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\tuint8 m;\tuint8 n;\tuint32 oa;\tuint8* ob;\tuint32 p;\tif (sp->qtable_offset[0]==0)\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Missing JPEG tables\");\t\treturn(0);\t}\tsp->in_buffer_file_pos_log=0;\tfor (m=0; m<sp->samples_per_pixel; m++)\t{\t\tif ((sp->qtable_offset[m]!=0) && ((m==0) || (sp->qtable_offset[m]!=sp->qtable_offset[m-1])))\t\t{\t\t\tfor (n=0; n<m-1; n++)\t\t\t{\t\t\t\tif (sp->qtable_offset[m]==sp->qtable_offset[n])\t\t\t\t{\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JpegQTables tag value\");\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\toa=sizeof(uint32)+69;\t\t\tob=_TIFFmalloc(oa);\t\t\tif (ob==0)\t\t\t{\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\t\t\t\treturn(0);\t\t\t}\t\t\t*(uint32*)ob=oa;\t\t\tob[sizeof(uint32)]=255;\t\t\tob[sizeof(uint32)+1]=JPEG_MARKER_DQT;\t\t\tob[sizeof(uint32)+2]=0;\t\t\tob[sizeof(uint32)+3]=67;\t\t\tob[sizeof(uint32)+4]=m;\t\t\tTIFFSeekFile(tif,sp->qtable_offset[m],SEEK_SET); \t\t\tp=(uint32)TIFFReadFile(tif,&ob[sizeof(uint32)+5],64);\t\t\tif (p!=64)\t\t\t\treturn(0);\t\t\tsp->qtable[m]=ob;\t\t\tsp->sof_tq[m]=m;\t\t}\t\telse\t\t\tsp->sof_tq[m]=sp->sof_tq[m-1];\t}\treturn(1);}",
        "label": 1,
        "cve": "cve-2017-9404"
    },
    {
        "code": "static voidcompresssep(unsigned char* out,\t    unsigned char* r, unsigned char* g, unsigned char* b, uint32 n){\tregister uint32 red = RED, green = GREEN, blue = BLUE;\twhile (n-- > 0)\t\t*out++ = (unsigned char)\t\t\t((red*(*r++) + green*(*g++) + blue*(*b++)) >> 8);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*TIFFOpen(const char* name, const char* mode){\tstatic const char module[] = \"TIFFOpen\";\tint m;\tlong fd;\tm = _TIFFgetMode(mode, module);\tif (m == -1)\t\treturn ((TIFF*)0);\tif (m & O_TRUNC) {\t\tfd = Fcreate(name, 0);\t} else {\t\tfd = Fopen(name, m & O_ACCMODE);\t\tif (fd == AEFILNF && m & O_CREAT)\t\t\tfd = Fcreate(name, 0);\t}\tif (fd < 0)\t\terrno = (int)fd;\tif (fd < 0) {\t\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\t\treturn ((TIFF*)0);\t}\treturn (TIFFFdOpen(fd, name, mode));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static off_tReadDirectory(int fd, unsigned ix, off_t off){\tregister TIFFDirEntry *dp;\tregister unsigned int n;\tTIFFDirEntry *dir = 0;\tuint16 dircount;\tint space;\tuint32 nextdiroff = 0;\tif (off == 0)\t\t\t \t\tgoto done;\tif (lseek(fd, (off_t) off, 0) != off) {\t\tFatal(\"Seek error accessing TIFF directory\");\t\tgoto done;\t}\tif (read(fd, (char*) &dircount, sizeof (uint16)) != sizeof (uint16)) {\t\tReadError(\"directory count\");\t\tgoto done;\t}\tif (swabflag)\t\tTIFFSwabShort(&dircount);\tdir = (TIFFDirEntry *)_TIFFmalloc(dircount * sizeof (TIFFDirEntry));\tif (dir == NULL) {\t\tFatal(\"No space for TIFF directory\");\t\tgoto done;\t}\tn = read(fd, (char*) dir, dircount*sizeof (*dp));\tif (n != dircount*sizeof (*dp)) {\t\tn /= sizeof (*dp);\t\tError(\t    \"Could only read %u of %u entries in directory at offset %#lx\",\t\t    n, dircount, (unsigned long) off);\t\tdircount = n;\t}\tif (read(fd, (char*) &nextdiroff, sizeof (uint32)) != sizeof (uint32))\t\tnextdiroff = 0;\tif (swabflag)\t\tTIFFSwabLong(&nextdiroff);\tprintf(\"Directory %u: offset %lu (%#lx) next %lu (%#lx)\\n\", ix,\t    (unsigned long)off, (unsigned long)off,\t    (unsigned long)nextdiroff, (unsigned long)nextdiroff);\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\t\tif (swabflag) {\t\t\tTIFFSwabArrayOfShort(&dp->tdir_tag, 2);\t\t\tTIFFSwabArrayOfLong(&dp->tdir_count, 2);\t\t}\t\tPrintTag(stdout, dp->tdir_tag);\t\tputchar(' ');\t\tPrintType(stdout, dp->tdir_type);\t\tputchar(' ');\t\tprintf(\"%lu<\", (unsigned long) dp->tdir_count);\t\tif (dp->tdir_type >= NWIDTHS) {\t\t\tprintf(\">\\n\");\t\t\tcontinue;\t\t}\t\tspace = dp->tdir_count * datawidth[dp->tdir_type];\t\tif (space <= 0) {\t\t\tprintf(\">\\n\");\t\t\tError(\"Invalid count for tag %u\", dp->tdir_tag);\t\t\tcontinue;                }\t\tif (space <= 4) {\t\t\tswitch (dp->tdir_type) {\t\t\tcase TIFF_FLOAT:\t\t\tcase TIFF_UNDEFINED:\t\t\tcase TIFF_ASCII: {\t\t\t\tunsigned char data[4];\t\t\t\t_TIFFmemcpy(data, &dp->tdir_offset, 4);\t\t\t\tif (swabflag)\t\t\t\t\tTIFFSwabLong((uint32*) data);\t\t\t\tPrintData(stdout,\t\t\t\t    dp->tdir_type, dp->tdir_count, data);\t\t\t\tbreak;\t\t\t}\t\t\tcase TIFF_BYTE:\t\t\t\tPrintByte(stdout, bytefmt, dp);\t\t\t\tbreak;\t\t\tcase TIFF_SBYTE:\t\t\t\tPrintByte(stdout, sbytefmt, dp);\t\t\t\tbreak;\t\t\tcase TIFF_SHORT:\t\t\t\tPrintShort(stdout, shortfmt, dp);\t\t\t\tbreak;\t\t\tcase TIFF_SSHORT:\t\t\t\tPrintShort(stdout, sshortfmt, dp);\t\t\t\tbreak;\t\t\tcase TIFF_LONG:\t\t\t\tPrintLong(stdout, longfmt, dp);\t\t\t\tbreak;\t\t\tcase TIFF_SLONG:\t\t\t\tPrintLong(stdout, slongfmt, dp);\t\t\t\tbreak;\t\t\tcase TIFF_IFD:\t\t\t\tPrintLong(stdout, ifdfmt, dp);\t\t\t\tbreak;\t\t\t}\t\t} else {\t\t\tunsigned char *data = (unsigned char *)_TIFFmalloc(space);\t\t\tif (data) {\t\t\t\tif (TIFFFetchData(fd, dp, data)) {\t\t\t\t\tif (dp->tdir_count > maxitems) {\t\t\t\t\t\tPrintData(stdout, dp->tdir_type,\t\t\t\t\t\t    maxitems, data);\t\t\t\t\t\tprintf(\" ...\");\t\t\t\t\t} else\t\t\t\t\t\tPrintData(stdout, dp->tdir_type,\t\t\t\t\t\t    dp->tdir_count, data);                                }\t\t\t\t_TIFFfree(data);\t\t\t} else\t\t\t\tError(\"No space for data for tag %u\",\t\t\t\t    dp->tdir_tag);\t\t}\t\tprintf(\">\\n\");\t}done:\tif (dir)\t\t_TIFFfree((char *)dir);\treturn (nextdiroff);}",
        "label": 1,
        "cve": "cve-2010-4665"
    },
    {
        "code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value){\tenum TIFFReadDirEntryErr err;\tuint32 count;\tvoid* origdata;\tuint64* data;\tswitch (direntry->tdir_type)\t{\t\tcase TIFF_BYTE:\t\tcase TIFF_SBYTE:\t\tcase TIFF_SHORT:\t\tcase TIFF_SSHORT:\t\tcase TIFF_LONG:\t\tcase TIFF_SLONG:\t\tcase TIFF_LONG8:\t\tcase TIFF_SLONG8:\t\t\tbreak;\t\tdefault:\t\t\treturn(TIFFReadDirEntryErrType);\t}\terr=TIFFReadDirEntryArray(tif,direntry,&count,8,&origdata);\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\t{\t\t*value=0;\t\treturn(err);\t}\tswitch (direntry->tdir_type)\t{\t\tcase TIFF_LONG8:\t\t\t*value=(uint64*)origdata;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabArrayOfLong8(*value,count);\t\t\treturn(TIFFReadDirEntryErrOk);\t\tcase TIFF_SLONG8:\t\t\t{\t\t\t\tint64* m;\t\t\t\tuint32 n;\t\t\t\tm=(int64*)origdata;\t\t\t\tfor (n=0; n<count; n++)\t\t\t\t{\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\t\t\tTIFFSwabLong8((uint64*)m);\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Slong8(*m);\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\t_TIFFfree(origdata);\t\t\t\t\t\treturn(err);\t\t\t\t\t}\t\t\t\t\tm++;\t\t\t\t}\t\t\t\t*value=(uint64*)origdata;\t\t\t\treturn(TIFFReadDirEntryErrOk);\t\t\t}\t}\tdata=(uint64*)_TIFFmalloc(count*8);\tif (data==0)\t{\t\t_TIFFfree(origdata);\t\treturn(TIFFReadDirEntryErrAlloc);\t}\tswitch (direntry->tdir_type)\t{\t\tcase TIFF_BYTE:\t\t\t{\t\t\t\tuint8* ma;\t\t\t\tuint64* mb;\t\t\t\tuint32 n;\t\t\t\tma=(uint8*)origdata;\t\t\t\tmb=data;\t\t\t\tfor (n=0; n<count; n++)\t\t\t\t\t*mb++=(uint64)(*ma++);\t\t\t}\t\t\tbreak;\t\tcase TIFF_SBYTE:\t\t\t{\t\t\t\tint8* ma;\t\t\t\tuint64* mb;\t\t\t\tuint32 n;\t\t\t\tma=(int8*)origdata;\t\t\t\tmb=data;\t\t\t\tfor (n=0; n<count; n++)\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Sbyte(*ma);\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\t\t\t\t\t\tbreak;\t\t\t\t\t*mb++=(uint64)(*ma++);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SHORT:\t\t\t{\t\t\t\tuint16* ma;\t\t\t\tuint64* mb;\t\t\t\tuint32 n;\t\t\t\tma=(uint16*)origdata;\t\t\t\tmb=data;\t\t\t\tfor (n=0; n<count; n++)\t\t\t\t{\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\t\t\tTIFFSwabShort(ma);\t\t\t\t\t*mb++=(uint64)(*ma++);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SSHORT:\t\t\t{\t\t\t\tint16* ma;\t\t\t\tuint64* mb;\t\t\t\tuint32 n;\t\t\t\tma=(int16*)origdata;\t\t\t\tmb=data;\t\t\t\tfor (n=0; n<count; n++)\t\t\t\t{\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Sshort(*ma);\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\t\t\t\t\t\tbreak;\t\t\t\t\t*mb++=(uint64)(*ma++);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_LONG:\t\t\t{\t\t\t\tuint32* ma;\t\t\t\tuint64* mb;\t\t\t\tuint32 n;\t\t\t\tma=(uint32*)origdata;\t\t\t\tmb=data;\t\t\t\tfor (n=0; n<count; n++)\t\t\t\t{\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\t\t\tTIFFSwabLong(ma);\t\t\t\t\t*mb++=(uint64)(*ma++);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SLONG:\t\t\t{\t\t\t\tint32* ma;\t\t\t\tuint64* mb;\t\t\t\tuint32 n;\t\t\t\tma=(int32*)origdata;\t\t\t\tmb=data;\t\t\t\tfor (n=0; n<count; n++)\t\t\t\t{\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Slong(*ma);\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\t\t\t\t\t\tbreak;\t\t\t\t\t*mb++=(uint64)(*ma++);\t\t\t\t}\t\t\t}\t\t\tbreak;\t}\t_TIFFfree(origdata);\tif (err!=TIFFReadDirEntryErrOk)\t{\t\t_TIFFfree(data);\t\treturn(err);\t}\t*value=data;\treturn(TIFFReadDirEntryErrOk);}",
        "label": 1,
        "cve": "cve-2017-9403"
    },
    {
        "code": "static intmirrorImage(uint16 spp, uint16 bps, uint16 mirror, uint32 width, uint32 length, unsigned char *ibuff)  {  int      shift_width;  uint32   bytes_per_pixel, bytes_per_sample;  uint32   row, rowsize, row_offset;  unsigned char *line_buff = NULL;  unsigned char *src;  unsigned char *dst;  src = ibuff;  rowsize = ((width * bps * spp) + 7) / 8;  switch (mirror)    {    case MIRROR_BOTH:    case MIRROR_VERT:              line_buff = (unsigned char *)_TIFFmalloc(rowsize);             if (line_buff == NULL)               {\t       TIFFError (\"mirrorImage\", \"Unable to allocate mirror line buffer of %1u bytes\", rowsize);               return (-1);               }             dst = ibuff + (rowsize * (length - 1));             for (row = 0; row < length / 2; row++)               {\t      _TIFFmemcpy(line_buff, src, rowsize);\t      _TIFFmemcpy(src, dst,  rowsize);\t      _TIFFmemcpy(dst, line_buff, rowsize);               src += (rowsize);               dst -= (rowsize);                                                }             if (line_buff)               _TIFFfree(line_buff);             if (mirror == MIRROR_VERT)               break;    case MIRROR_HORIZ :              if ((bps % 8) == 0)                 {                 for (row = 0; row < length; row++)                  {\t\t  row_offset = row * rowsize;                  src = ibuff + row_offset;                  dst = ibuff + row_offset + rowsize;                  if (reverseSamplesBytes(spp, bps, width, src, dst))                    {\t\t    return (-1);                    }\t\t  }\t\t}\t      else                {                 if (!(line_buff = (unsigned char *)_TIFFmalloc(rowsize + 1)))                  {                  TIFFError(\"mirrorImage\", \"Unable to allocate mirror line buffer\");                  return (-1);                  }                bytes_per_sample = (bps + 7) / 8;                bytes_per_pixel  = ((bps * spp) + 7) / 8;                if (bytes_per_pixel < (bytes_per_sample + 1))                  shift_width = bytes_per_pixel;                else                  shift_width = bytes_per_sample + 1;                for (row = 0; row < length; row++)                  {\t\t  row_offset = row * rowsize;                  src = ibuff + row_offset;                  _TIFFmemset (line_buff, '\\0', rowsize);                  switch (shift_width)                    {                    case 1: if (reverseSamples16bits(spp, bps, width, src, line_buff))                              {\t\t              _TIFFfree(line_buff);                              return (-1);                              }                             _TIFFmemcpy (src, line_buff, rowsize);                             break;                    case 2: if (reverseSamples24bits(spp, bps, width, src, line_buff))                              {\t\t              _TIFFfree(line_buff);                              return (-1);                              }                             _TIFFmemcpy (src, line_buff, rowsize);                             break;                    case 3:                     case 4:                     case 5: if (reverseSamples32bits(spp, bps, width, src, line_buff))                              {\t\t              _TIFFfree(line_buff);                              return (-1);                              }                             _TIFFmemcpy (src, line_buff, rowsize);                             break;                    default: TIFFError(\"mirrorImage\",\"Unsupported bit depth %d\", bps);\t\t             _TIFFfree(line_buff);                             return (-1);                          }\t\t  }                if (line_buff)                  _TIFFfree(line_buff);\t\t}             break;    default: TIFFError (\"mirrorImage\", \"Invalid mirror axis %d\", mirror);             return (-1);             break;    }  return (0);  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intFax3Decode1D(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s){\tDECLARE_STATE(tif, sp, \"Fax3Decode1D\");        int line = 0;\t(void) s;\tCACHE_STATE(tif, sp);\tthisrun = sp->curruns;\twhile ((long)occ > 0) {\t\ta0 = 0;\t\tRunLength = 0;\t\tpa = thisrun;#ifdef FAX3_DEBUG\t\tprintf(\"\\nBitAcc=%08X, BitsAvail = %d\\n\", BitAcc, BitsAvail);\t\tprintf(\"-------------------- %d\\n\", tif->tif_row);\t\tfflush(stdout);#endif\t\tSYNC_EOL(EOF1D);\t\tEXPAND1D(EOF1Da);\t\t(*sp->fill)(buf, thisrun, pa, lastx);\t\tbuf += sp->b.rowbytes;\t\tocc -= sp->b.rowbytes;                line++;\t\tcontinue;\tEOF1D:\t\t\t\t\t\tCLEANUP_RUNS();\tEOF1Da:\t\t\t\t\t\t(*sp->fill)(buf, thisrun, pa, lastx);\t\tUNCACHE_STATE(tif, sp);\t\treturn (-1);\t}\tUNCACHE_STATE(tif, sp);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int tokenizer(unsigned inflag,char *token,int tokmax,char *line,              char *white,char *brkchar,char *quote,char eschar,char *brkused,              int *next,char *quoted){  int qp;  char c,nc;  *brkused=0;\t\t  *quoted=0;\t\t  if(!line[*next])\t    return 1;  _p_state=IN_WHITE;     _p_curquote=0;\t     _p_flag=inflag;\t     for(_p_tokpos=0;(c=line[*next]);++(*next))\t    {      if((qp=sindex(c,brkchar))>=0)          {          switch(_p_state)            {\t    case IN_WHITE:\t\t\t    case IN_TOKEN:\t\t\t    case IN_OZONE:\t\t\t      ++(*next);\t      *brkused=brkchar[qp];\t      goto byebye;\t    case IN_QUOTE:\t\t \t      chstore(token,tokmax,c);\t      break;            }        }      else if((qp=sindex(c,quote))>=0)          {          switch(_p_state)            {\t    case IN_WHITE:\t \t      _p_state=IN_QUOTE; \t      _p_curquote=quote[qp]; \t      *quoted=1;\t\t      break;\t    case IN_QUOTE:\t      if(quote[qp]==_p_curquote)                 {                  _p_state=IN_OZONE;                  _p_curquote=0;                }\t      else\t        chstore(token,tokmax,c); \t      break;\t    case IN_TOKEN:\t    case IN_OZONE:\t      *brkused=c; \t      goto byebye;            }        }      else if((qp=sindex(c,white))>=0)         {          switch(_p_state)            {\t    case IN_WHITE:\t    case IN_OZONE:\t      break;\t\t\t    case IN_TOKEN:\t      _p_state=IN_OZONE;\t      break;\t    case IN_QUOTE:\t      chstore(token,tokmax,c); \t      break;            }        }      else if(c==eschar)          {          nc=line[(*next)+1];          if(nc==0) \t\t            {              *brkused=0;              chstore(token,tokmax,c);              ++(*next);              goto byebye;            }          switch(_p_state)            {\t    case IN_WHITE:\t      --(*next);\t      _p_state=IN_TOKEN;\t      break;\t    case IN_TOKEN:\t    case IN_QUOTE:\t      ++(*next);\t      chstore(token,tokmax,nc);\t      break;\t    case IN_OZONE:\t      goto byebye;            }        }      else\t        {          switch(_p_state)            {\t    case IN_WHITE:\t      _p_state=IN_TOKEN; \t    case IN_TOKEN:\t\t \t    case IN_QUOTE:\t\t \t      chstore(token,tokmax,c);\t      break;\t    case IN_OZONE:\t      goto byebye;            }        }    }\t\t byebye:  token[_p_tokpos]=0;\t  return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int extractContigSamplesBytes (uint8 *in, uint8 *out, uint32 cols,                            tsample_t sample, uint16 spp, uint16 bps,                            tsample_t count, uint32 start, uint32 end)  {  int i, bytes_per_sample, sindex;  uint32 col, dst_rowsize, bit_offset;  uint32 src_byte ;  uint8 *src = in;  uint8 *dst = out;  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"extractContigSamplesBytes\",\"Invalid input or output buffer\");    return (1);    }  if ((start > end) || (start > cols))    {    TIFFError (\"extractContigSamplesBytes\",                \"Invalid start column value %d ignored\", start);    start = 0;    }  if ((end == 0) || (end > cols))    {    TIFFError (\"extractContigSamplesBytes\",                \"Invalid end column value %d ignored\", end);    end = cols;    }  dst_rowsize = (bps * (end - start) * count) / 8;  bytes_per_sample = (bps + 7) / 8;     if (count == spp)    {    src = in + (start * spp * bytes_per_sample);    _TIFFmemcpy (dst, src, dst_rowsize);    }  else    {    for (col = start; col < end; col++)      {      for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)        {        bit_offset = col * bps * spp;        if (sindex == 0)          {          src_byte = bit_offset / 8;                    }        else          {          src_byte = (bit_offset + (sindex * bps)) / 8;                    }        src = in + src_byte;        for (i = 0; i < bytes_per_sample; i++)            *dst++ = *src++;        }      }    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tsize_t t2p_write_pdf_page(uint32 object, T2P* t2p, TIFF* output){\tunsigned int i=0;\ttsize_t written=0;\tchar buffer[16];\tint buflen=0;\t\twritten += t2pWriteFile(output, (tdata_t) \"<<\\n/Type /Page \\n/Parent \", 24);\tbuflen=sprintf(buffer, \"%lu\", (unsigned long)t2p->pdf_pages);\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \\n\", 6);\twritten += t2pWriteFile(output, (tdata_t) \"/MediaBox [\", 11); \tbuflen=sprintf(buffer, \"%.4f\",t2p->pdf_mediabox.x1);\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\twritten += t2pWriteFile(output, (tdata_t) \" \", 1); \tbuflen=sprintf(buffer, \"%.4f\",t2p->pdf_mediabox.y1);\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\twritten += t2pWriteFile(output, (tdata_t) \" \", 1); \tbuflen=sprintf(buffer, \"%.4f\",t2p->pdf_mediabox.x2);\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\twritten += t2pWriteFile(output, (tdata_t) \" \", 1); \tbuflen=sprintf(buffer, \"%.4f\",t2p->pdf_mediabox.y2);\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\twritten += t2pWriteFile(output, (tdata_t) \"] \\n\", 3); \twritten += t2pWriteFile(output, (tdata_t) \"/Contents \", 10);\tbuflen=sprintf(buffer, \"%lu\", (unsigned long)(object + 1));\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \\n\", 6);\twritten += t2pWriteFile(output, (tdata_t) \"/Resources << \\n\", 15);\tif( t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount != 0 ){\t\twritten += t2pWriteFile(output, (tdata_t) \"/XObject <<\\n\", 12);\t\tfor(i=0;i<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;i++){\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Im\", 3);\t\t\tbuflen = sprintf(buffer, \"%u\", t2p->pdf_page+1);\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\t\t\twritten += t2pWriteFile(output, (tdata_t) \"_\", 1);\t\t\tbuflen = sprintf(buffer, \"%u\", i+1);\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\t\t\twritten += t2pWriteFile(output, (tdata_t) \" \", 1);\t\t\tbuflen = sprintf(\t\t\t\tbuffer, \t\t\t\t\"%lu\", \t\t\t\t(unsigned long)(object+3+(2*i)+t2p->tiff_pages[t2p->pdf_page].page_extra)); \t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\t\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \", 5);\t\t\tif(i%4==3){\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\t\t\t}\t\t}\t\twritten += t2pWriteFile(output, (tdata_t) \">>\\n\", 3);\t} else {\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/XObject <<\\n\", 12);\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Im\", 3);\t\t\tbuflen = sprintf(buffer, \"%u\", t2p->pdf_page+1);\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\t\t\twritten += t2pWriteFile(output, (tdata_t) \" \", 1);\t\t\tbuflen = sprintf(\t\t\t\tbuffer, \t\t\t\t\"%lu\", \t\t\t\t(unsigned long)(object+3+(2*i)+t2p->tiff_pages[t2p->pdf_page].page_extra)); \t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\t\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \", 5);\t\twritten += t2pWriteFile(output, (tdata_t) \">>\\n\", 3);\t}\tif(t2p->tiff_transferfunctioncount != 0) {\t\twritten += t2pWriteFile(output, (tdata_t) \"/ExtGState <<\", 13);\t\tt2pWriteFile(output, (tdata_t) \"/GS1 \", 5);\t\tbuflen = sprintf(\t\t\tbuffer, \t\t\t\"%lu\", \t\t\t(unsigned long)(object + 3)); \t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \", 5);\t\twritten += t2pWriteFile(output, (tdata_t) \">> \\n\", 4);\t}\twritten += t2pWriteFile(output, (tdata_t) \"/ProcSet [ \", 11);\tif(t2p->pdf_colorspace == T2P_CS_BILEVEL \t\t|| t2p->pdf_colorspace == T2P_CS_GRAY\t\t){\t\twritten += t2pWriteFile(output, (tdata_t) \"/ImageB \", 8);\t} else {\t\twritten += t2pWriteFile(output, (tdata_t) \"/ImageC \", 8);\t\tif(t2p->pdf_colorspace & T2P_CS_PALETTE){\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/ImageI \", 8);\t\t}\t}\twritten += t2pWriteFile(output, (tdata_t) \"]\\n>>\\n>>\\n\", 8);\treturn(written);}",
        "label": 1,
        "cve": "cve-2013-1961"
    },
    {
        "code": "static voidsvGrey(TIFF* tif, uint32* ss, int xsize, int ysize){\tregister int x, y;\tunsigned char *buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\tfor (y = 0; y <= ysize; y++) {\t\tfor (x = 0; x <= xsize; x++) {\t\t\tunsigned char *cp = (unsigned char *)&ss[x];\t\t\tbuf[x] = (RED*cp[3] + GREEN*cp[2] + BLUE*cp[1]) >> 8;\t\t}\t\tif (TIFFWriteScanline(tif, buf, (uint32) y, 0) < 0)\t\t\tbreak;\t\tss += xsize+1;\t}\t_TIFFfree(buf);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "main(){\tunsigned char runs[2][256];\tmemset(runs[0], 0, 256*sizeof (char));\tmemset(runs[1], 0, 256*sizeof (char));\t{ register int run, runlen, i;\t  runlen = 1;\t  for (run = 0x80; run != 0xff; run = (run>>1)|0x80) {\t\tfor (i = run-1; i >= 0; i--) {\t\t\truns[1][run|i] = runlen;\t\t\truns[0][(~(run|i)) & 0xff] = runlen;\t\t}\t\trunlen++;\t  }\t  runs[1][0xff] = runs[0][0] = 8;\t}\tdumparray(\"bruns\", runs[0]);\tdumparray(\"wruns\", runs[1]);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize){\t(void) fd; (void) pbase; (void) psize;\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidinitImageData (struct image_data *image)  {  image->xres = 0.0;  image->yres = 0.0;  image->width = 0;  image->length = 0;  image->res_unit = RESUNIT_NONE;  image->bps = 0;  image->spp = 0;  image->planar = 0;  image->photometric = 0;  image->orientation = 0;  image->compression = COMPRESSION_NONE;  image->adjustments = 0;  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_XTIFFVSetField(TIFF* tif, ttag_t tag, va_list ap){\txtiff *xt = XTIFFDIR(tif);\tXTIFFDirectory* xd = &xt->xtif_dir;\tint status = 1;\tuint32 v32=0;\tint i=0, v=0;\tva_list ap1 = ap;\t\tswitch (tag) {\t\t\tcase TIFFTAG_EXAMPLE_MULTI:\t\t\t\txd->xd_num_multi = (uint16) va_arg(ap, int);\t\t_TIFFsetDoubleArray(&xd->xd_example_multi, va_arg(ap, double*),\t\t\t(long) xd->xd_num_multi);\t\tbreak;\tcase TIFFTAG_EXAMPLE_SINGLE:\t\txd->xd_example_single = va_arg(ap, uint32);\t\tbreak;\tcase TIFFTAG_EXAMPLE_ASCII:\t\t_TIFFsetString(&xd->xd_example_ascii, va_arg(ap, char*));\t\tbreak;\tdefault:\t\t\t\treturn (PARENT(xt,vsetfield))(tif,tag,ap);\t\tbreak;\t}\tif (status) {\t\t\t\tif (!(xt->xtif_flags & XTIFFP_PRINT))\t\t{\t        \tPARENT(xt,printdir) =  TIFFMEMBER(tif,printdir);      \t\t  \tTIFFMEMBER(tif,printdir) = _XTIFFPrintDirectory;\t\t\txt->xtif_flags |= XTIFFP_PRINT;\t\t}\t\tTIFFSetFieldBit(tif, _TIFFFieldWithTag(tif, tag)->field_bit);\t\ttif->tif_flags |= TIFF_DIRTYDIRECT;\t}\tva_end(ap);\treturn (status);badvalue:\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"%d: Bad value for \\\"%s\\\"\", v,\t    _TIFFFieldWithTag(tif, tag)->field_name);\tva_end(ap);\treturn (0);badvalue32:\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"%ld: Bad value for \\\"%s\\\"\", v32,\t    _TIFFFieldWithTag(tif, tag)->field_name);\tva_end(ap);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static introtateImage(uint16 rotation, struct image_data *image, uint32 *img_width,             uint32 *img_length, unsigned char **ibuff_ptr)  {  int      shift_width;  uint32   bytes_per_pixel, bytes_per_sample;  uint32   row, rowsize, src_offset, dst_offset;  uint32   i, col, width, length;  uint32   colsize, buffsize, col_offset, pix_offset;  unsigned char *ibuff;  unsigned char *src;  unsigned char *dst;  uint16   spp, bps;  float    res_temp;  unsigned char *rbuff = NULL;  width  = *img_width;  length = *img_length;  spp = image->spp;  bps = image->bps;  rowsize = ((bps * spp * width) + 7) / 8;  colsize = ((bps * spp * length) + 7) / 8;  if ((colsize * width) > (rowsize * length))    buffsize = (colsize + 1) * width;  else    buffsize = (rowsize + 1) * length;  bytes_per_sample = (bps + 7) / 8;  bytes_per_pixel  = ((bps * spp) + 7) / 8;  if (bytes_per_pixel < (bytes_per_sample + 1))    shift_width = bytes_per_pixel;  else    shift_width = bytes_per_sample + 1;  switch (rotation)    {    case 0:    case 360: return (0);    case 90:    case 180:    case 270: break;    default:  TIFFError(\"rotateImage\", \"Invalid rotation angle %d\", rotation);              return (-1);    }  if (!(rbuff = (unsigned char *)_TIFFmalloc(buffsize)))    {    TIFFError(\"rotateImage\", \"Unable to allocate rotation buffer of %1u bytes\", buffsize);    return (-1);    }  _TIFFmemset(rbuff, '\\0', buffsize);  ibuff = *ibuff_ptr;  switch (rotation)    {    case 180: if ((bps % 8) == 0)                 {                 src = ibuff;                pix_offset = (spp * bps) / 8;                for (row = 0; row < length; row++)                   {\t\t   dst_offset = (length - row - 1) * rowsize;                   for (col = 0; col < width; col++)                     { \t\t     col_offset = (width - col - 1) * pix_offset;                     dst = rbuff + dst_offset + col_offset;\t\t     for (i = 0; i  < bytes_per_pixel; i++)\t\t       *dst++ = *src++;                     }                   }                }\t      else                {                  for (row = 0; row < length; row++)                  {\t\t  src_offset = row * rowsize;\t\t  dst_offset = (length - row - 1) * rowsize;\t\t  src = ibuff + src_offset;                  dst = rbuff + dst_offset;                  switch (shift_width)                    {                    case 1: if (bps == 1)\t\t\t      {                              if (reverseSamples8bits(spp, bps, width, src, dst))                                {\t\t                _TIFFfree(rbuff);                                return (-1);                                }                              break;                              }                            if (reverseSamples16bits(spp, bps, width, src, dst))                              {\t\t              _TIFFfree(rbuff);                              return (-1);                              }                             break;                    case 2: if (reverseSamples24bits(spp, bps, width, src, dst))                              {\t\t              _TIFFfree(rbuff);                              return (-1);                              }                             break;                    case 3:                     case 4:                     case 5: if (reverseSamples32bits(spp, bps, width, src, dst))                              {\t\t              _TIFFfree(rbuff);                              return (-1);                              }                             break;                    default: TIFFError(\"rotateImage\",\"Unsupported bit depth %d\", bps);\t\t             _TIFFfree(rbuff);                             return (-1);                          }\t\t  }\t\t}              _TIFFfree(ibuff);              *(ibuff_ptr) = rbuff;              break;    case 90:  if ((bps % 8) == 0)                 {                for (col = 0; col < width; col++)                  {\t\t  src_offset = ((length - 1) * rowsize) + (col * bytes_per_pixel);                  dst_offset = col * colsize;\t\t  src = ibuff + src_offset;\t\t  dst = rbuff + dst_offset;                  for (row = length; row > 0; row--)                    {                    for (i = 0; i < bytes_per_pixel; i++)                      *dst++ = *(src + i);\t\t    src -= rowsize;                    }\t\t  }\t\t}              else                {                  for (col = 0; col < width; col++)                  {\t\t  src_offset = (length - 1) * rowsize;                  dst_offset = col * colsize;\t\t  src = ibuff + src_offset;\t\t  dst = rbuff + dst_offset;                  switch (shift_width)                    {                    case 1: if (bps == 1)\t\t\t      {                              if (rotateContigSamples8bits(rotation, spp, bps, width, \t\t\t\t   \t                 length, col, src, dst))                                {\t\t                _TIFFfree(rbuff);                                return (-1);                                }                              break;                              }                            if (rotateContigSamples16bits(rotation, spp, bps, width, \t\t\t\t   \t                 length, col, src, dst))                              {\t                      _TIFFfree(rbuff);                              return (-1);\t\t              }\t\t            break;                    case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, \t\t\t\t\t                  length, col, src, dst))                              {\t\t              _TIFFfree(rbuff);                              return (-1);                              }                             break;                    case 3:                     case 4:                     case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, \t\t\t\t\t                  length, col, src, dst))                              {\t\t              _TIFFfree(rbuff);                              return (-1);                              }                             break;                    default: TIFFError(\"rotateImage\",\"Unsupported bit depth %d\", bps);\t\t             _TIFFfree(rbuff);                             return (-1);      \t\t    }\t\t  }\t\t}              _TIFFfree(ibuff);              *(ibuff_ptr) = rbuff;              *img_width = length;              *img_length = width;              image->width = length;              image->length = width;              res_temp = image->xres;              image->xres = image->yres;              image->yres = res_temp;\t      break;    case 270: if ((bps % 8) == 0)                 {                for (col = 0; col < width; col++)                  {\t\t  src_offset = col * bytes_per_pixel;                  dst_offset = (width - col - 1) * colsize;\t\t  src = ibuff + src_offset;\t\t  dst = rbuff + dst_offset;                  for (row = length; row > 0; row--)                    {                    for (i = 0; i < bytes_per_pixel; i++)                      *dst++ = *(src + i);\t\t    src += rowsize;                    }\t\t  }\t\t}              else                {                  for (col = 0; col < width; col++)                  {\t\t  src_offset = 0;                  dst_offset = (width - col - 1) * colsize;\t\t  src = ibuff + src_offset;\t\t  dst = rbuff + dst_offset;                  switch (shift_width)                    {                    case 1: if (bps == 1)\t\t\t      {                              if (rotateContigSamples8bits(rotation, spp, bps, width, \t\t\t\t   \t                 length, col, src, dst))                                {\t\t                _TIFFfree(rbuff);                                return (-1);                                }                              break;                              }                            if (rotateContigSamples16bits(rotation, spp, bps, width, \t\t\t\t   \t                 length, col, src, dst))                              {\t                      _TIFFfree(rbuff);                              return (-1);\t\t              }\t\t            break;                    case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, \t\t\t\t\t                  length, col, src, dst))                              {\t\t              _TIFFfree(rbuff);                              return (-1);                              }                             break;                    case 3:                     case 4:                     case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, \t\t\t\t\t                  length, col, src, dst))                              {\t\t              _TIFFfree(rbuff);                              return (-1);                              }                             break;                    default: TIFFError(\"rotateImage\",\"Unsupported bit depth %d\", bps);\t\t             _TIFFfree(rbuff);                             return (-1);      \t\t    }\t\t  }\t\t}              _TIFFfree(ibuff);              *(ibuff_ptr) = rbuff;              *img_width = length;              *img_length = width;              image->width = length;              image->length = width;              res_temp = image->xres;              image->xres = image->yres;              image->yres = res_temp;              break;    default:              break;    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char **argv){\tTIFF\t\t*tif;\tunsigned int\ti;\tunsigned char\tbuf[3] = { 0, 127, 255 };        (void) argc;        (void) argv;\t\ttif = TIFFOpen(filename, \"w\");\tif (!tif) {\t\tfprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename);\t\treturn 1;\t}\tif (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) {\t\tfprintf (stderr, \"Can't set ImageWidth tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) {\t\tfprintf (stderr, \"Can't set ImageLength tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8)) {\t\tfprintf (stderr, \"Can't set BitsPerSample tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3)) {\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip)) {\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) {\t\tfprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)) {\t\tfprintf (stderr, \"Can't set PhotometricInterpretation tag.\\n\");\t\tgoto failure;\t}\tfor (i = 0; i < NTAGS; i++) {\t\tif (!TIFFSetField(tif, long_tags[i].tag,\t\t\t\t  long_tags[i].value)) {\t\t\tfprintf(stderr, \"Can't set tag %d.\\n\",\t\t\t\t(int)long_tags[i].tag);\t\t\tgoto failure;\t\t}\t}\t\tif (TIFFWriteScanline(tif, buf, 0, 0) == -1) {\t\tfprintf (stderr, \"Can't write image data.\\n\");\t\tgoto failure;\t}\tTIFFClose(tif);\t\ttif = TIFFOpen(filename, \"r\");\tif (!tif) {\t\tfprintf (stderr, \"Can't open test TIFF file %s.\\n\", filename);\t\treturn 1;\t}\tif (CheckLongField(tif, TIFFTAG_IMAGEWIDTH, width) < 0)\t\tgoto failure;\tif (CheckLongField(tif, TIFFTAG_IMAGELENGTH, length) < 0)\t\tgoto failure;\tif (CheckLongField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip) < 0)\t\tgoto failure;\tfor (i = 0; i < NTAGS; i++) {\t\tif (CheckLongField(tif, long_tags[i].tag,\t\t\t\t   long_tags[i].value) < 0)\t\t\tgoto failure;\t}\tTIFFClose(tif);\t\tunlink(filename);\treturn 0;failure:\t\tTIFFClose(tif);\tunlink(filename);\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "DECLAREContigCallbackFunc(TestContigCallback){    printf(\"Contig Callback called with x = %d, y = %d, w = %d, h = %d, fromskew = %d\\n\",\t   x, y, w, h, fromskew);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void*_TIFFrealloc(tdata_t p, tsize_t s){\treturn (realloc(p, (size_t) s));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char **argv){\tuint32\t\trowsperstrip;\tuint16\t\tcompression;\tuint16\t\tspp, bps, photometric, sampleformat, planarconfig;        (void) argc;        (void) argv;\t\trowsperstrip = 1;\tcompression = COMPRESSION_NONE;\tspp = 1;\tbps = 8;        photometric = PHOTOMETRIC_MINISBLACK;\tsampleformat = SAMPLEFORMAT_UINT;\tplanarconfig = PLANARCONFIG_CONTIG;\tif (create_image_striped(filename, XSIZE * YSIZE, 1, rowsperstrip,\t\t\t\t  compression, spp, bps, photometric,\t\t\t\t  sampleformat, planarconfig,\t\t\t\t  (const tdata_t) byte_array1, byte_array1_size) < 0) {\t\tfprintf (stderr, \"Can't create TIFF file %s.\\n\", filename);\t\tgoto failure;\t}\tif (read_image_striped(filename, XSIZE * YSIZE, 1, rowsperstrip,\t\t\t\tcompression, spp, bps, photometric,\t\t\t\tsampleformat, planarconfig,\t\t\t\t(const tdata_t) byte_array1, byte_array1_size) < 0) {\t\tfprintf (stderr, \"Can't read TIFF file %s.\\n\", filename);\t\tgoto failure;\t}\tunlink(filename);\tif (create_image_striped(filename, 1, XSIZE * YSIZE, rowsperstrip,\t\t\t\t  compression, spp, bps, photometric,\t\t\t\t  sampleformat, planarconfig,\t\t\t\t  (const tdata_t) byte_array1, byte_array1_size) < 0) {\t\tfprintf (stderr, \"Can't create TIFF file %s.\\n\", filename);\t\tgoto failure;\t}\tif (read_image_striped(filename, 1, XSIZE * YSIZE, rowsperstrip,\t\t\t\tcompression, spp, bps, photometric,\t\t\t\tsampleformat, planarconfig,\t\t\t\t(const tdata_t) byte_array1, byte_array1_size) < 0) {\t\tfprintf (stderr, \"Can't read TIFF file %s.\\n\", filename);\t\tgoto failure;\t}\tunlink(filename);\t\trowsperstrip = 1;\tspp = 1;\tbps = 8;        photometric = PHOTOMETRIC_MINISBLACK;\tsampleformat = SAMPLEFORMAT_UINT;\tplanarconfig = PLANARCONFIG_CONTIG;\tif (create_image_striped(filename, XSIZE, YSIZE, rowsperstrip,\t\t\t\t  compression, spp, bps, photometric,\t\t\t\t  sampleformat, planarconfig,\t\t\t\t  (const tdata_t) byte_array1, byte_array1_size) < 0) {\t\tfprintf (stderr, \"Can't create TIFF file %s.\\n\", filename);\t\tgoto failure;\t}\tif (read_image_striped(filename, XSIZE, YSIZE, rowsperstrip,\t\t\t\tcompression, spp, bps, photometric,\t\t\t\tsampleformat, planarconfig,\t\t\t\t(const tdata_t) byte_array1, byte_array1_size) < 0) {\t\tfprintf (stderr, \"Can't read TIFF file %s.\\n\", filename);\t\tgoto failure;\t}\tunlink(filename);\trowsperstrip = YSIZE;\tif (create_image_striped(filename, XSIZE, YSIZE, rowsperstrip,\t\t\t\t  compression, spp, bps, photometric,\t\t\t\t  sampleformat, planarconfig,\t\t\t\t  (const tdata_t) byte_array1, byte_array1_size) < 0) {\t\tfprintf (stderr, \"Can't create TIFF file %s.\\n\", filename);\t\tgoto failure;\t}\tif (read_image_striped(filename, XSIZE, YSIZE, rowsperstrip,\t\t\t\tcompression, spp, bps, photometric,\t\t\t\tsampleformat, planarconfig,\t\t\t\t(const tdata_t) byte_array1, byte_array1_size) < 0) {\t\tfprintf (stderr, \"Can't read TIFF file %s.\\n\", filename);\t\tgoto failure;\t}\tunlink(filename);\treturn 0;failure:\tunlink(filename);\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intprocessCompressOptions(char* opt){\tif (streq(opt, \"none\"))\t\tcompression = COMPRESSION_NONE;\telse if (streq(opt, \"packbits\"))\t\tcompression = COMPRESSION_PACKBITS;\telse if (strneq(opt, \"jpeg\", 4)) {\t\tchar* cp = strchr(opt, ':');                compression = COMPRESSION_JPEG;                while (cp)                {                    if (isdigit((int)cp[1]))\t\t\tquality = atoi(cp+1);                    else if (cp[1] == 'r' )\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;                    else                        usage();                    cp = strchr(cp+1,':');                }\t} else if (strneq(opt, \"g3\", 2)) {\t\tprocessG3Options(opt);\t\tcompression = COMPRESSION_CCITTFAX3;\t} else if (streq(opt, \"g4\")) {\t\tcompression = COMPRESSION_CCITTFAX4;\t} else if (strneq(opt, \"lzw\", 3)) {\t\tchar* cp = strchr(opt, ':');\t\tif (cp)\t\t\tpredictor = atoi(cp+1);\t\tcompression = COMPRESSION_LZW;\t} else if (strneq(opt, \"zip\", 3)) {\t\tchar* cp = strchr(opt, ':');\t\tif (cp)\t\t\tpredictor = atoi(cp+1);\t\tcompression = COMPRESSION_DEFLATE;\t} else\t\treturn (0);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "staticvoid _XTIFFInitialize(void){\tstatic first_time=1;\tif (! first_time) return; \tfirst_time = 0;\t\t_ParentExtender = TIFFSetTagExtender(_XTIFFDefaultDirectory);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidUsage(){    fprintf(stderr, \"Usage xtiff: [options] tiff-file\\n\");    fprintf(stderr, \"\\tstandard Xt options\\n\");    fprintf(stderr, \"\\t[-help]\\n\");    fprintf(stderr, \"\\t[-gamma gamma]\\n\");    fprintf(stderr, \"\\t[-usePixmap (True | False)]\\n\");    fprintf(stderr, \"\\t[-viewportWidth pixels]\\n\");    fprintf(stderr, \"\\t[-viewportHeight pixels]\\n\");    fprintf(stderr, \"\\t[-translate pixels]\\n\");    fprintf(stderr, \"\\t[-verbose (True | False)]\\n\");    exit(0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidhorizontalAccumulate8abgr(uint16 *wp, int n, int stride, unsigned char *op,\tunsigned char *ToLinear8){    register unsigned int  cr, cg, cb, ca, mask;    register unsigned char  t0, t1, t2, t3;    if (n >= stride) {\tmask = CODE_MASK;\tif (stride == 3) {\t    op[0] = 0;\t    t1 = ToLinear8[cb = (wp[2] & mask)];\t    t2 = ToLinear8[cg = (wp[1] & mask)];\t    t3 = ToLinear8[cr = (wp[0] & mask)];\t    op[1] = t1;\t    op[2] = t2;\t    op[3] = t3;\t    n -= 3;\t    while (n > 0) {\t\tn -= 3;\t\twp += 3;\t\top += 4;\t\top[0] = 0;\t\tt1 = ToLinear8[(cb += wp[2]) & mask];\t\tt2 = ToLinear8[(cg += wp[1]) & mask];\t\tt3 = ToLinear8[(cr += wp[0]) & mask];\t\top[1] = t1;\t\top[2] = t2;\t\top[3] = t3;\t    }\t} else if (stride == 4) {\t    t0 = ToLinear8[ca = (wp[3] & mask)];\t    t1 = ToLinear8[cb = (wp[2] & mask)];\t    t2 = ToLinear8[cg = (wp[1] & mask)];\t    t3 = ToLinear8[cr = (wp[0] & mask)];\t    op[0] = t0;\t    op[1] = t1;\t    op[2] = t2;\t    op[3] = t3;\t    n -= 4;\t    while (n > 0) {\t\tn -= 4;\t\twp += 4;\t\top += 4;\t\tt0 = ToLinear8[(ca += wp[3]) & mask];\t\tt1 = ToLinear8[(cb += wp[2]) & mask];\t\tt2 = ToLinear8[(cg += wp[1]) & mask];\t\tt3 = ToLinear8[(cr += wp[0]) & mask];\t\top[0] = t0;\t\top[1] = t1;\t\top[2] = t2;\t\top[3] = t3;\t    }\t} else {\t    REPEAT(stride, *op = ToLinear8[*wp&mask]; wp++; op++)\t    n -= stride;\t    while (n > 0) {\t\tREPEAT(stride,\t\t    wp[stride] += *wp; *op = ToLinear8[*wp&mask]; wp++; op++)\t\tn -= stride;\t    }\t}    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intextractContigSamples16bits (uint8 *in, uint8 *out, uint32 cols,                             tsample_t sample, uint16 spp, uint16 bps,                             tsample_t count, uint32 start, uint32 end)  {  int    ready_bits = 0, sindex = 0;  uint32 col, src_byte, src_bit, bit_offset;  uint16 maskbits = 0, matchbits = 0;  uint16 buff1 = 0, buff2 = 0;  uint8  bytebuff = 0;  uint8 *src = in;  uint8 *dst = out;  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"extractContigSamples16bits\",\"Invalid input or output buffer\");    return (1);    }  if ((start > end) || (start > cols))    {    TIFFError (\"extractContigSamples16bits\",                \"Invalid start column value %d ignored\", start);    start = 0;    }  if ((end == 0) || (end > cols))    {    TIFFError (\"extractContigSamples16bits\",                \"Invalid end column value %d ignored\", end);    end = cols;    }  ready_bits = 0;  maskbits = (uint16)-1 >> (16 - bps);  for (col = start; col < end; col++)    {        bit_offset = col * bps * spp;    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)      {      if (sindex == 0)        {        src_byte = bit_offset / 8;        src_bit  = bit_offset % 8;        }      else        {        src_byte = (bit_offset + (sindex * bps)) / 8;        src_bit  = (bit_offset + (sindex * bps)) % 8;        }      src = in + src_byte;      matchbits = maskbits << (16 - src_bit - bps);       if (little_endian)        buff1 = (src[0] << 8) | src[1];      else        buff1 = (src[1] << 8) | src[0];      buff1 = (buff1 & matchbits) << (src_bit);      if (ready_bits < 8)         {         bytebuff = 0;        buff2 = (buff2 | (buff1 >> ready_bits));        }      else         {        bytebuff = (buff2 >> 8);        *dst++ = bytebuff;        ready_bits -= 8;                buff2 = ((buff2 << 8) | (buff1 >> ready_bits));        }      ready_bits += bps;      }    }    while (ready_bits > 0)    {    bytebuff = (buff2 >> 8);    *dst++ = bytebuff;    ready_bits -= 8;    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*TIFFFdOpen(int fd, const char* name, const char* mode){\tTIFF* tif;\ttif = TIFFClientOpen(name, mode, (thandle_t) fd,\t    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,\t    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);\tif (tif)\t\ttif->tif_fd = fd;\treturn (tif);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "    { setByteArray((void**) wpp, (void*) wp, n, sizeof (uint16)); }void _TIFFsetLongArray(uint32** lpp, uint32* lp, uint32 n)    { setByteArray((void**) lpp, (void*) lp, n, sizeof (uint32)); }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidGetVisual(){    XColor *colors = NULL;    unsigned long *pixels = NULL;    unsigned long i;    switch (tfImageDepth) {        case 32:    case 24:        if (SearchVisualList(24, DirectColor, &xVisual) == False) {            fprintf(stderr, \"xtiff: 24-bit DirectColor visual not available\\n\");            exit(0);        }        colors = (XColor *) malloc(3 * colormapSize * sizeof(XColor));        MCHECK(colors);        for (i = 0; i < colormapSize; i++) {            colors[i].pixel = (i << 16) + (i << 8) + i;            colors[i].red = redMap[i];            colors[i].green = greenMap[i];            colors[i].blue = blueMap[i];            colors[i].flags = DoRed | DoGreen | DoBlue;        }        xColormap = XCreateColormap(xDisplay, RootWindow(xDisplay, xScreen),            xVisual, AllocAll);        XStoreColors(xDisplay, xColormap, colors, colormapSize);        break;    case 8:    case 4:    case 2:                switch (tfPhotometricInterpretation) {        case PHOTOMETRIC_MINISWHITE:        case PHOTOMETRIC_MINISBLACK:            if (SearchVisualList((int) tfImageDepth, GrayScale, &xVisual) == True)                break;        case PHOTOMETRIC_PALETTE:            if (SearchVisualList((int) tfImageDepth, PseudoColor, &xVisual) == True)                break;        default:            fprintf(stderr, \"xtiff: Unsupported TIFF/X configuration\\n\");            exit(0);        }        colors = (XColor *) malloc(colormapSize * sizeof(XColor));        MCHECK(colors);        for (i = 0; i < colormapSize; i++) {            colors[i].pixel = i;            colors[i].red = redMap[i];            colors[i].green = greenMap[i];            colors[i].blue = blueMap[i];            colors[i].flags = DoRed | DoGreen | DoBlue;        }                if (tfImageDepth == 8)            xColormap = XCreateColormap(xDisplay, RootWindow(xDisplay, xScreen),                xVisual, AllocAll);        else {            xColormap = XCreateColormap(xDisplay, RootWindow(xDisplay, xScreen),                xVisual, AllocNone);            pixels = (unsigned long *)                malloc(colormapSize * sizeof(unsigned long));            MCHECK(pixels);            (void) XAllocColorCells(xDisplay, xColormap, True,                NULL, 0, pixels, colormapSize);            basePixel = (unsigned char) pixels[0];            free(pixels);        }        XStoreColors(xDisplay, xColormap, colors, colormapSize);        break;    case 1:        xImageDepth = 1;        xVisual = DefaultVisual(xDisplay, xScreen);        xColormap = DefaultColormap(xDisplay, xScreen);        break;    default:        fprintf(stderr, \"xtiff: unsupported image depth %d\\n\", tfImageDepth);        exit(0);    }    if (appData.verbose == True)\tfprintf(stderr, \"%s: Using %d-bit %s visual.\\n\",\t    fileName, xImageDepth, classNames[xVisual->class]);    if (colors != NULL)        free(colors);    if (grayMap != NULL)        free(grayMap);    if (redMap != NULL)        free(redMap);    if (greenMap != NULL)        free(greenMap);    if (blueMap != NULL)        free(blueMap);    colors = NULL; grayMap = redMap = greenMap = blueMap = NULL;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFFax3fillruns(unsigned char* buf, uint32* runs, uint32* erun, uint32 lastx){\tstatic const unsigned char _fillmasks[] =\t    { 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff };\tunsigned char* cp;\tuint32 x, bx, run;\tint32 n, nw;\tlong* lp;\tif ((erun-runs)&1)\t    *erun++ = 0;\tx = 0;\tfor (; runs < erun; runs += 2) {\t    run = runs[0];\t    if (x+run > lastx || run > lastx )\t\trun = runs[0] = (uint32) (lastx - x);\t    if (run) {\t\tcp = buf + (x>>3);\t\tbx = x&7;\t\tif (run > 8-bx) {\t\t    if (bx) {\t\t\t\t\t\t*cp++ &= 0xff << (8-bx);\t\t\trun -= 8-bx;\t\t    }\t\t    if( (n = run >> 3) != 0 ) {\t\t\t\tif ((n/sizeof (long)) > 1) {\t\t\t    \t\t\t    for (; n && !isAligned(cp, long); n--)\t\t\t\t    *cp++ = 0x00;\t\t\t    lp = (long*) cp;\t\t\t    nw = (int32)(n / sizeof (long));\t\t\t    n -= nw * sizeof (long);\t\t\t    do {\t\t\t\t    *lp++ = 0L;\t\t\t    } while (--nw);\t\t\t    cp = (unsigned char*) lp;\t\t\t}\t\t\tZERO(n, cp);\t\t\trun &= 7;\t\t    }\t\t    if (run)\t\t\tcp[0] &= 0xff >> run;\t\t} else\t\t    cp[0] &= ~(_fillmasks[run]>>bx);\t\tx += runs[0];\t    }\t    run = runs[1];\t    if (x+run > lastx || run > lastx )\t\trun = runs[1] = lastx - x;\t    if (run) {\t\tcp = buf + (x>>3);\t\tbx = x&7;\t\tif (run > 8-bx) {\t\t    if (bx) {\t\t\t\t\t\t*cp++ |= 0xff >> bx;\t\t\trun -= 8-bx;\t\t    }\t\t    if( (n = run>>3) != 0 ) {\t\t\t\tif ((n/sizeof (long)) > 1) {\t\t\t    \t\t\t    for (; n && !isAligned(cp, long); n--)\t\t\t\t*cp++ = 0xff;\t\t\t    lp = (long*) cp;\t\t\t    nw = (int32)(n / sizeof (long));\t\t\t    n -= nw * sizeof (long);\t\t\t    do {\t\t\t\t*lp++ = -1L;\t\t\t    } while (--nw);\t\t\t    cp = (unsigned char*) lp;\t\t\t}\t\t\tFILL(n, cp);\t\t\trun &= 7;\t\t    }                    \t\t    if (run)\t\t\tcp[0] = (unsigned char)((cp[0] | (0xff00 >> run))&0xff);\t\t} else\t\t    cp[0] |= _fillmasks[run]>>bx;\t\tx += runs[1];\t    }\t}\tassert(x == lastx);}",
        "label": 1,
        "cve": "cve-2016-10271"
    },
    {
        "code": "static int JBIGSetupDecode(TIFF* tif){\tif (TIFFNumberOfStrips(tif) != 1)\t{\t\tTIFFErrorExt(tif->tif_clientdata, \"JBIG\", \"Multistrip images not supported in decoder\");\t\treturn 0;\t}\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char** argv){    extern int optind;    extern char* optarg;    uint16 *pages = NULL, npages = 0, pageNumber;    int c, dowarnings = 0;\t\t    TIFF* tif;    while ((c = getopt(argc, argv, \"l:p:x:y:W:H:wS\")) != -1)\tswitch (c) {\tcase 'H':\t\t\t    pageHeight = (float)atof(optarg);\t    break;\tcase 'S':\t\t\t    scaleToPage = 1;\t    break;\tcase 'W':\t\t\t    pageWidth = (float)atof(optarg);\t    break;\tcase 'p':\t\t\t    pageNumber = (uint16)atoi(optarg);\t    if (pages)\t\tpages = (uint16*) realloc(pages, (npages+1)*sizeof(uint16));\t    else\t\tpages = (uint16*) malloc(sizeof(uint16));\t    pages[npages++] = pageNumber;\t    break;\tcase 'w':\t    dowarnings = 1;\t    break;\tcase 'x':\t    defxres = (float)atof(optarg);\t    break;\tcase 'y':\t    defyres = (float)atof(optarg);\t    break;\tcase 'l':\t    maxline = atoi(optarg);\t    break;\tcase '?':\t    usage(-1);\t}    if (npages > 0)\tqsort(pages, npages, sizeof(uint16), pcompar);    if (!dowarnings)\tTIFFSetWarningHandler(0);    if (optind < argc) {\tdo {\t    tif = TIFFOpen(argv[optind], \"r\");\t    if (tif) {\t\tfax2ps(tif, npages, pages, argv[optind]);\t\tTIFFClose(tif);\t    } else\t\tfprintf(stderr, \"%s: Can not open, or not a TIFF file.\\n\",\t\t    argv[optind]);\t} while (++optind < argc);    } else {\tint n;\tFILE* fd;\tchar buf[16*1024];\tfd = tmpfile();\tif (fd == NULL) {\t    fprintf(stderr, \"Could not obtain temporary file.\\n\");\t    exit(-2);\t}#if defined(HAVE_SETMODE) && defined(O_BINARY)\tsetmode(fileno(stdin), O_BINARY);#endif\twhile ((n = read(fileno(stdin), buf, sizeof (buf))) > 0)\t    write(fileno(fd), buf, n);\tlseek(fileno(fd), 0, SEEK_SET);#if defined(_WIN32) && defined(USE_WIN32_FILEIO)\ttif = TIFFFdOpen(_get_osfhandle(fileno(fd)), \"temp\", \"r\");#else\ttif = TIFFFdOpen(fileno(fd), \"temp\", \"r\");#endif\tif (tif) {\t    fax2ps(tif, npages, pages, \"<stdin>\");\t    TIFFClose(tif);\t} else\t    fprintf(stderr, \"Can not open, or not a TIFF file.\\n\");\tfclose(fd);    }    printf(\"%%%%Trailer\\n\");    printf(\"%%%%Pages: %u\\n\", totalPages);    printf(\"%%%%EOF\\n\");    return (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int dump_wide (FILE *dumpfile, int format, char *dump_tag, uint64 data)  {  int j, k;  char  dump_array[80];  unsigned char bitset;  if (dumpfile == NULL)    {    TIFFError (\"\", \"Invalid FILE pointer for dump file\");    return (1);    }  if (format == DUMP_TEXT)    {    fprintf (dumpfile,\" %s  \", dump_tag);    for (j = 0, k = 63; k >= 0; j++, k--)      {      bitset = data & (((uint64)1 << k)) ? 1 : 0;      sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");      if ((k % 8) == 0)          sprintf(&dump_array[++j], \" \");      }    dump_array[71] = '\\0';    fprintf (dumpfile,\" %s\\n\", dump_array);    }  else    {    if ((fwrite (&data, 8, 1, dumpfile)) != 8)      {      TIFFError (\"\", \"Unable to write binary data to dump file\");      return (1);      }    }  return (0);  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intprocessCompressOptions(char* opt){\tif (streq(opt, \"none\"))\t\tcompression = COMPRESSION_NONE;\telse if (streq(opt, \"packbits\"))\t\tcompression = COMPRESSION_PACKBITS;\telse if (strneq(opt, \"jpeg\", 4)) {\t\tchar* cp = strchr(opt, ':');                compression = COMPRESSION_JPEG;                while( cp )                {                    if (isdigit((int)cp[1]))\t\t\tquality = atoi(cp+1);                    else if (cp[1] == 'r' )\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;                    else                        usage();                    cp = strchr(cp+1,':');                }\t} else if (strneq(opt, \"lzw\", 3)) {\t\tchar* cp = strchr(opt, ':');\t\tif (cp)\t\t\tpredictor = atoi(cp+1);\t\tcompression = COMPRESSION_LZW;\t} else if (strneq(opt, \"zip\", 3)) {\t\tchar* cp = strchr(opt, ':');\t\tif (cp)\t\t\tpredictor = atoi(cp+1);\t\tcompression = COMPRESSION_DEFLATE;\t} else\t\treturn (0);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static toff_t_tiffSizeProc(thandle_t fd){\tlong pos, eof;\tpos = Fseek(0, (int) fd, SEEK_CUR);\teof = Fseek(0, (int) fd, SEEK_END);\tFseek(pos, (int) fd, SEEK_SET);\treturn eof;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcompresscontig(unsigned char* out, unsigned char* rgb, uint32 n){\tregister int v, red = RED, green = GREEN, blue = BLUE;\twhile (n-- > 0) {\t\tv = red*(*rgb++);\t\tv += green*(*rgb++);\t\tv += blue*(*rgb++);\t\t*out++ = v>>8;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidappleErrorHandler(const char* module, const char* fmt, va_list ap){\tif (module != NULL)\t\tfprintf(stderr, \"%s: \", module);\tvfprintf(stderr, fmt, ap);\tfprintf(stderr, \".\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidChopUpSingleUncompressedStrip(TIFF* tif){\tregister TIFFDirectory *td = &tif->tif_dir;\tuint32 bytecount = td->td_stripbytecount[0];\tuint32 offset = td->td_stripoffset[0];\ttsize_t rowbytes = TIFFVTileSize(tif, 1), stripbytes;\ttstrip_t strip, nstrips, rowsperstrip;\tuint32* newcounts;\tuint32* newoffsets;\t\tif (rowbytes > 8192) {\t\tstripbytes = rowbytes;\t\trowsperstrip = 1;\t} else {\t\trowsperstrip = 8192 / rowbytes;\t\tstripbytes = rowbytes * rowsperstrip;\t}\t\tif (rowsperstrip >= td->td_rowsperstrip)\t\treturn;\tnstrips = (tstrip_t) TIFFhowmany(bytecount, stripbytes);\tnewcounts = (uint32*) CheckMalloc(tif, nstrips * sizeof (uint32),\t\t\t\t\"for chopped \\\"StripByteCounts\\\" array\");\tnewoffsets = (uint32*) CheckMalloc(tif, nstrips * sizeof (uint32),\t\t\t\t\"for chopped \\\"StripOffsets\\\" array\");\tif (newcounts == NULL || newoffsets == NULL) {\t        \t\tif (newcounts != NULL)\t\t\t_TIFFfree(newcounts);\t\tif (newoffsets != NULL)\t\t\t_TIFFfree(newoffsets);\t\treturn;\t}\t\tfor (strip = 0; strip < nstrips; strip++) {\t\tif (stripbytes > bytecount)\t\t\tstripbytes = bytecount;\t\tnewcounts[strip] = stripbytes;\t\tnewoffsets[strip] = offset;\t\toffset += stripbytes;\t\tbytecount -= stripbytes;\t}\t\ttd->td_stripsperimage = td->td_nstrips = nstrips;\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\t_TIFFfree(td->td_stripbytecount);\t_TIFFfree(td->td_stripoffset);\ttd->td_stripbytecount = newcounts;\ttd->td_stripoffset = newoffsets;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tsize_t_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size){\tDWORD dwSizeRead;\tif (!ReadFile(fd, buf, size, &dwSizeRead, NULL))\t\treturn(0);\treturn ((tsize_t) dwSizeRead);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf){        uint8* bufp = buf;        int32  bytes_read = 0;        uint16 strip, nstrips   = TIFFNumberOfStrips(in);        uint32 stripsize = TIFFStripSize(in);        uint32 rows = 0;        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);        tsize_t scanline_size = TIFFScanlineSize(in);        if (scanline_size == 0) {                TIFFError(\"\", \"TIFF scanline size is zero!\");                    return 0;        }        for (strip = 0; strip < nstrips; strip++) {                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);                rows = bytes_read / scanline_size;                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",                                  (int)strip + 1, (unsigned long) bytes_read,                                  (unsigned long)stripsize);                if (bytes_read < 0 && !ignore) {                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",                                  (unsigned long) strip, (unsigned long)rows);                        return 0;                }                bufp += bytes_read;        }        return 1;}",
        "label": 1,
        "cve": "cve-2016-9538"
    },
    {
        "code": "void t2p_read_tiff_size(T2P* t2p, TIFF* input){\tuint64* sbc=NULL;#if defined(JPEG_SUPPORT) || defined (OJPEG_SUPPORT)\tunsigned char* jpt=NULL;\ttstrip_t i=0;\ttstrip_t stripcount=0;#endif        uint64 k = 0;\tif(t2p->pdf_transcode == T2P_TRANSCODE_RAW){#ifdef CCITT_SUPPORT\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4 ){\t\t\tTIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);            if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {                TIFFError(TIFF2PDF_MODULE, \"Integer overflow\");                t2p->t2p_error = T2P_ERR_ERROR;            }\t\t\tt2p->tiff_datasize=(tmsize_t)sbc[0];\t\t\treturn;\t\t}#endif#ifdef ZIP_SUPPORT\t\tif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\t\t\tTIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);            if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {                TIFFError(TIFF2PDF_MODULE, \"Integer overflow\");                t2p->t2p_error = T2P_ERR_ERROR;            }\t\t\tt2p->tiff_datasize=(tmsize_t)sbc[0];\t\t\treturn;\t\t}#endif#ifdef OJPEG_SUPPORT\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG){\t\t\tif(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS\",\t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn;\t\t\t}\t\t\tstripcount=TIFFNumberOfStrips(input);\t\t\tfor(i=0;i<stripcount;i++){\t\t\t\tk = checkAdd64(k, sbc[i], t2p);\t\t\t}\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGIFOFFSET, &(t2p->tiff_dataoffset))){\t\t\t\tif(t2p->tiff_dataoffset != 0){\t\t\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGIFBYTECOUNT, &(t2p->tiff_datasize))!=0){\t\t\t\t\t\tif((uint64)t2p->tiff_datasize < k) {\t\t\t\t\t\t\tTIFFWarning(TIFF2PDF_MODULE, \t\t\t\t\t\t\t\t\"Input file %s has short JPEG interchange file byte count\", \t\t\t\t\t\t\t\tTIFFFileName(input));\t\t\t\t\t\t\tt2p->pdf_ojpegiflength=t2p->tiff_datasize;\t\t\t\t\t\t\tk = checkAdd64(k, t2p->tiff_datasize, t2p);\t\t\t\t\t\t\tk = checkAdd64(k, 6, t2p);\t\t\t\t\t\t\tk = checkAdd64(k, stripcount, t2p);\t\t\t\t\t\t\tk = checkAdd64(k, stripcount, t2p);\t\t\t\t\t\t\tt2p->tiff_datasize = (tsize_t) k;\t\t\t\t\t\t\tif ((uint64) t2p->tiff_datasize != k) {\t\t\t\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\t\t\t\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\t\t\t\t}\t\t\t\t\t\t\treturn;\t\t\t\t\t\t}\t\t\t\t\t\treturn;\t\t\t\t\t}else {\t\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\t\t\"Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT\",\t\t\t\t\t\t\tTIFFFileName(input));\t\t\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\t\t\t\treturn;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tk = checkAdd64(k, stripcount, t2p);\t\t\tk = checkAdd64(k, stripcount, t2p);\t\t\tk = checkAdd64(k, 2048, t2p);\t\t\tt2p->tiff_datasize = (tsize_t) k;\t\t\tif ((uint64) t2p->tiff_datasize != k) {\t\t\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t}\t\t\treturn;\t\t}#endif#ifdef JPEG_SUPPORT\t\tif(t2p->tiff_compression == COMPRESSION_JPEG) {\t\t\tuint32 count = 0;\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0 ){\t\t\t\tif(count > 4){\t\t\t\t\tk += count;\t\t\t\t\tk -= 2; \t\t\t\t}\t\t\t} else {\t\t\t\tk = 2; \t\t\t}\t\t\tstripcount=TIFFNumberOfStrips(input);\t\t\tif(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS\",\t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn;\t\t\t}\t\t\tfor(i=0;i<stripcount;i++){\t\t\t\tk = checkAdd64(k, sbc[i], t2p);\t\t\t\tk -=2; \t\t\t\tk +=2; \t\t\t}\t\t\tk = checkAdd64(k, 2, t2p); \t\t\tk = checkAdd64(k, 6, t2p); \t\t\tt2p->tiff_datasize = (tsize_t) k;\t\t\tif ((uint64) t2p->tiff_datasize != k) {\t\t\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t}\t\t\treturn;\t\t}#endif\t\t(void) 0;\t}\tk = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);\tif(t2p->tiff_planar==PLANARCONFIG_SEPARATE){\t\tk = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);\t}\tif (k == 0) {\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t}\tt2p->tiff_datasize = (tsize_t) k;\tif ((uint64) t2p->tiff_datasize != k) {\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\t\tt2p->t2p_error = T2P_ERR_ERROR;\t}\treturn;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "    { setByteArray((void**) lpp, (void*) lp, n, sizeof (uint32)); }void _TIFFsetFloatArray(float** fpp, float* fp, uint32 n)    { setByteArray((void**) fpp, (void*) fp, n, sizeof (float)); }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int_TIFFmemcmp(const tdata_t d, const tdata_t s, tsize_t c){\tchar* dd = (char*) d;\tchar* ss = (char*) s;\ttsize_t chunks, chunkd, chunk;\tint result;\twhile (c > 0) {\t\tchunks = 0x10000 - ((uint32) ss & 0xffff);\t\t\tchunkd = 0x10000 - ((uint32) dd & 0xffff);\t\t\tchunk = c;\t\t\t\t\t\t\tif (chunk > chunks)\t\t\t\t\t\t\tchunk = chunks;\t\t\t\t\t\tif (chunk > chunkd)\t\t\tchunk = chunkd;\t\tif (chunk > 0xff00)\t\t\tchunk = 0xff00;\t\tresult = memcmp(dd, ss, chunk);\t\tif (result != 0)\t\t\treturn (result);\t\tdd = (char*) (chunk + (char huge*) dd);\t\tss = (char*) (chunk + (char huge*) ss);\t\tc -= chunk;\t}\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intgetCropOffsets(struct image_data *image, struct crop_mask *crop, struct dump_opts *dump)  {  struct offset offsets;  int    i;  int32  test;  uint32 seg, total, need_buff = 0;  uint32 buffsize;  uint32 zwidth, zlength;  memset(&offsets, '\\0', sizeof(struct offset));  crop->bufftotal = 0;  crop->combined_width  = (uint32)0;  crop->combined_length = (uint32)0;  crop->selections = 0;    if ((crop->crop_mode & CROP_MARGINS) ||      (crop->crop_mode & CROP_REGIONS) ||      (crop->crop_mode & CROP_LENGTH)  ||       (crop->crop_mode & CROP_WIDTH))    {    if (computeInputPixelOffsets(crop, image, &offsets))      {      TIFFError (\"getCropOffsets\", \"Unable to compute crop margins\");      return (-1);      }    need_buff = TRUE;    crop->selections = crop->regions;        if (crop->crop_mode & CROP_REGIONS)      return (0);    }  else    {     offsets.tmargin = 0;    offsets.lmargin = 0;    offsets.bmargin = 0;    offsets.rmargin = 0;    offsets.crop_width = image->width;    offsets.crop_length = image->length;    offsets.startx = 0;    offsets.endx = image->width - 1;    offsets.starty = 0;    offsets.endy = image->length - 1;    need_buff = FALSE;    }  if (dump->outfile != NULL)    {    dump_info (dump->outfile, dump->format, \"\", \"Margins: Top: %d  Left: %d  Bottom: %d  Right: %d\",            offsets.tmargin, offsets.lmargin, offsets.bmargin, offsets.rmargin);     dump_info (dump->outfile, dump->format, \"\", \"Crop region within margins: Adjusted Width:  %6d  Length: %6d\",            offsets.crop_width, offsets.crop_length);    }  if (!(crop->crop_mode & CROP_ZONES))     {    if (need_buff == FALSE)        {      crop->selections = 0;      crop->combined_width  = image->width;      crop->combined_length = image->length;      return (0);      }    else       {            crop->selections = 1;      crop->zones = 1;      crop->zonelist[0].total = 1;      crop->zonelist[0].position = 1;      }    }       else    crop->selections = crop->zones;  for (i = 0; i < crop->zones; i++)    {    seg = crop->zonelist[i].position;    total = crop->zonelist[i].total;    switch (crop->edge_ref)       {      case EDGE_LEFT:            zlength = offsets.crop_length;\t   crop->regionlist[i].y1 = offsets.starty;           crop->regionlist[i].y2 = offsets.endy;           crop->regionlist[i].x1 = offsets.startx +                                   (uint32)(offsets.crop_width * 1.0 * (seg - 1) / total);           test = (int32)offsets.startx +                   (int32)(offsets.crop_width * 1.0 * seg / total);           if (test < 1 )             crop->regionlist[i].x2 = 0;           else\t     {\t     if (test > (int32)(image->width - 1))               crop->regionlist[i].x2 = image->width - 1;             else\t       crop->regionlist[i].x2 = test - 1;             }           zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1  + 1;\t              crop->combined_length = (uint32)zlength;           if (crop->exp_mode == COMPOSITE_IMAGES)             crop->combined_width += (uint32)zwidth;           else             crop->combined_width = (uint32)zwidth;           break;      case EDGE_BOTTOM:            zwidth = offsets.crop_width;\t   crop->regionlist[i].x1 = offsets.startx;           crop->regionlist[i].x2 = offsets.endx;           test = offsets.endy - (uint32)(offsets.crop_length * 1.0 * seg / total);           if (test < 1 )\t     crop->regionlist[i].y1 = 0;           else\t     crop->regionlist[i].y1 = test + 1;           test = offsets.endy - (offsets.crop_length * 1.0 * (seg - 1) / total);           if (test < 1 )             crop->regionlist[i].y2 = 0;           else\t     {             if (test > (int32)(image->length - 1))               crop->regionlist[i].y2 = image->length - 1;             else                crop->regionlist[i].y2 = test;\t     }           zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;\t              if (crop->exp_mode == COMPOSITE_IMAGES)             crop->combined_length += (uint32)zlength;           else             crop->combined_length = (uint32)zlength;           crop->combined_width = (uint32)zwidth;           break;      case EDGE_RIGHT:            zlength = offsets.crop_length;\t   crop->regionlist[i].y1 = offsets.starty;           crop->regionlist[i].y2 = offsets.endy;           crop->regionlist[i].x1 = offsets.startx +                                  (uint32)(offsets.crop_width  * (total - seg) * 1.0 / total);           test = offsets.startx + \t          (offsets.crop_width * (total - seg + 1) * 1.0 / total);           if (test < 1 )             crop->regionlist[i].x2 = 0;           else\t     {\t     if (test > (int32)(image->width - 1))               crop->regionlist[i].x2 = image->width - 1;             else               crop->regionlist[i].x2 = test - 1;             }           zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1  + 1;\t              crop->combined_length = (uint32)zlength;           if (crop->exp_mode == COMPOSITE_IMAGES)             crop->combined_width += (uint32)zwidth;           else             crop->combined_width = (uint32)zwidth;           break;      case EDGE_TOP:       default:           zwidth = offsets.crop_width;\t   crop->regionlist[i].x1 = offsets.startx;           crop->regionlist[i].x2 = offsets.endx;           crop->regionlist[i].y1 = offsets.starty + (uint32)(offsets.crop_length * 1.0 * (seg - 1) / total);           test = offsets.starty + (uint32)(offsets.crop_length * 1.0 * seg / total);           if (test < 1 )             crop->regionlist[i].y2 = 0;           else\t     {\t     if (test > (int32)(image->length - 1))\t       crop->regionlist[i].y2 = image->length - 1;             else\t       crop->regionlist[i].y2 = test - 1;\t     }           zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;\t              if (crop->exp_mode == COMPOSITE_IMAGES)             crop->combined_length += (uint32)zlength;           else             crop->combined_length = (uint32)zlength;           crop->combined_width = (uint32)zwidth;           break;      }     buffsize = (uint32)          ((((zwidth * image->bps * image->spp) + 7 ) / 8) * (zlength + 1));    crop->regionlist[i].width = (uint32) zwidth;    crop->regionlist[i].length = (uint32) zlength;    crop->regionlist[i].buffsize = buffsize;    crop->bufftotal += buffsize;  if (dump->outfile != NULL)    dump_info (dump->outfile, dump->format, \"\",  \"Zone %d, width: %4d, length: %4d, x1: %4d  x2: %4d  y1: %4d  y2: %4d\",                    i + 1, (uint32)zwidth, (uint32)zlength,\t\t    crop->regionlist[i].x1, crop->regionlist[i].x2,                     crop->regionlist[i].y1, crop->regionlist[i].y2);    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFmemcpy(tdata_t d, const tdata_t s, tsize_t c){\tmemcpy(d, s, (size_t) c);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidShowRawWords(uint16* pp, uint32 n){\tuint32 i;\tfor (i = 0; i < n; i++) {\t\tprintf(\" %04x\", *pp++);\t\tif (((i+1) % 15) == 0)\t\t\tprintf(\"\\n \");\t}\tputchar('\\n');}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFReadSeparateStripData(TIFF* tif){\tunsigned char *buf;\ttsize_t scanline = TIFFScanlineSize(tif);\tbuf = (unsigned char *)_TIFFmalloc(TIFFStripSize(tif));\tif (buf) {\t\tuint32 row, h;\t\tuint32 rowsperstrip = (uint32)-1;\t\ttsample_t s, samplesperpixel;\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\t\tfor (row = 0; row < h; row += rowsperstrip) {\t\t\tfor (s = 0; s < samplesperpixel; s++) {\t\t\t\tuint32 nrow = (row+rowsperstrip > h ?\t\t\t\t    h-row : rowsperstrip);\t\t\t\ttstrip_t strip = TIFFComputeStrip(tif, row, s);\t\t\t\tif (TIFFReadEncodedStrip(tif, strip, buf, nrow*scanline) < 0) {\t\t\t\t\tif (stoponerr)\t\t\t\t\t\tbreak;\t\t\t\t} else if (showdata)\t\t\t\t\tShowStrip(strip, buf, nrow, scanline);\t\t\t}\t\t}\t\t_TIFFfree(buf);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFDefaultRefBlackWhite(TIFFDirectory* td){\tint i;\tif (!(td->td_refblackwhite = (float *)_TIFFmalloc(6*sizeof (float))))\t\treturn 0;        if (td->td_photometric == PHOTOMETRIC_YCBCR) {\t\t\t\ttd->td_refblackwhite[0] = 0.0F;\t\ttd->td_refblackwhite[1] = td->td_refblackwhite[3] =\t\t\ttd->td_refblackwhite[5] = 255.0F;\t\ttd->td_refblackwhite[2] = td->td_refblackwhite[4] = 128.0F;\t} else {\t\t\t\tfor (i = 0; i < 3; i++) {\t\t    td->td_refblackwhite[2*i+0] = 0;\t\t    td->td_refblackwhite[2*i+1] =\t\t\t    (float)((1L<<td->td_bitspersample)-1L);\t\t}\t}\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intread_image_striped(const char *name, uint32 width, uint32 length,\t\t    uint32 rowsperstrip, uint16 compression,\t\t    uint16 spp, uint16 bps, uint16 photometric,\t\t    uint16 sampleformat, uint16 planarconfig,\t\t    const tdata_t array, const tsize_t size){\tTIFF\t\t*tif;\tuint16\t\tvalue_u16;\tuint32\t\tvalue_u32;\t\ttif = TIFFOpen(name, \"r\");\tif (!tif)\t\tgoto openfailure;\tif (TIFFIsTiled(tif)) {\t\tfprintf (stderr, \"Can't read image %s, it is tiled.\\n\",\t\t\t name);\t\tgoto failure;\t}\tif (!TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &value_u32)\t    || value_u32 != width) {\t\tfprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_IMAGEWIDTH);\t\tgoto failure;\t}\tif (!TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &value_u32)\t    || value_u32 != length) {\t\tfprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_IMAGELENGTH);\t\tgoto failure;\t}\tif (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &value_u16)\t    || value_u16 != bps) {\t\tfprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_BITSPERSAMPLE);\t\tgoto failure;\t}\tif (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &value_u16)\t    || value_u16 != photometric) {\t\tfprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_PHOTOMETRIC);\t\tgoto failure;\t}\tif (!TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &value_u16)\t    || value_u16 != spp) {\t\tfprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_SAMPLESPERPIXEL);\t\tgoto failure;\t}\tif (!TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &value_u32)\t    || value_u32 != rowsperstrip) {\t\tfprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_ROWSPERSTRIP);\t\tgoto failure;\t}\tif (!TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &value_u16)\t    || value_u16 != planarconfig) {\t\tfprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_PLANARCONFIG);\t\tgoto failure;\t}\tif (read_strips(tif, array, size) < 0) {\t\tfprintf (stderr, \"Can't read image data.\\n\");\t\tgoto failure;\t}\tTIFFClose(tif);\treturn 0;failure:\tTIFFClose(tif);openfailure:\tfprintf (stderr, \"Can't read test TIFF file %s:\\n\"\"    ImageWidth=%ld, ImageLength=%ld, RowsPerStrip=%ld, Compression=%d,\\n\"\"    BitsPerSample=%d, SamplesPerPixel=%d, SampleFormat=%d,\\n\"\"    PlanarConfiguration=%d, PhotometricInterpretation=%d.\\n\",\t\t name, (long) width, (long) length, (long) rowsperstrip,                 compression, bps, spp, sampleformat, planarconfig,\t\t photometric);\treturn -1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char **argv){    XSetWindowAttributes window_attributes;    Widget widget_list[3];    Arg args[5];    setbuf(stdout, NULL); setbuf(stderr, NULL);    shellWidget = XtInitialize(argv[0], \"XTiff\", shellOptions,        XtNumber(shellOptions), &argc, argv);    XSetErrorHandler(XTiffErrorHandler);    XtGetApplicationResources(shellWidget, &appData,        (XtResourceList) clientResources, (Cardinal) XtNumber(clientResources),        (ArgList) NULL, (Cardinal) 0);    if ((argc <= 1) || (argc > 2) || appData.help)        Usage();    if (appData.verbose == False) {        TIFFSetErrorHandler(0);        TIFFSetWarningHandler(0);    }    fileName = argv[1];    xDisplay = XtDisplay(shellWidget);    xScreen = DefaultScreen(xDisplay);    OpenTIFFFile();    GetTIFFHeader();    SimpleGammaCorrection();    GetVisual();    GetTIFFImage();        XtSetArg(args[0], XtNvisual, xVisual);    XtSetArg(args[1], XtNcolormap, xColormap);    XtSetArg(args[2], XtNdepth,        xImageDepth == 1 ? DefaultDepth(xDisplay, xScreen) : xImageDepth);    XtSetArg(args[3], XtNiconPixmap,        XCreateBitmapFromData(xDisplay, RootWindow(xDisplay, xScreen),            xtifficon_bits, xtifficon_width, xtifficon_height));    XtSetArg(args[4], XtNallowShellResize, True);    XtSetValues(shellWidget, args, 5);        formWidget = XtCreateManagedWidget(\"form\", formWidgetClass,        shellWidget, formArgs, XtNumber(formArgs));        widget_list[0] = listWidget = XtCreateWidget(\"list\",            listWidgetClass, formWidget, listArgs, XtNumber(listArgs));        widget_list[1] = labelWidget = XtCreateWidget(\"label\",            labelWidgetClass, formWidget, labelArgs, XtNumber(labelArgs));        widget_list[2] = imageWidget = XtCreateWidget(\"image\",            widgetClass, formWidget, imageArgs, XtNumber(imageArgs));    XtManageChildren(widget_list, XtNumber(widget_list));        if (tfImageWidth >= appData.viewportWidth) {        XtSetArg(args[0], XtNwidth, appData.viewportWidth);        XtSetValues(shellWidget, args, 1);    }    if (tfImageHeight >= appData.viewportHeight) {        XtSetArg(args[0], XtNheight, appData.viewportHeight);        XtSetValues(shellWidget, args, 1);    }    XtSetArg(args[0], XtNwidth, tfImageWidth);    XtSetArg(args[1], XtNheight, tfImageHeight);    XtSetValues(imageWidget, args, 2);        XtSetArg(args[0], XtNfromVert, listWidget);    XtSetValues(imageWidget, args, 1);    XtSetArg(args[0], XtNfromHoriz, listWidget);    XtSetValues(labelWidget, args, 1);    SetNameLabel();    XtAddCallback(listWidget, XtNcallback, (XtCallbackProc) SelectProc,        (XtPointer) NULL);    XtAddActions(actionsTable, XtNumber(actionsTable));    XtSetArg(args[0], XtNtranslations,        XtParseTranslationTable(translationsTable));    XtSetValues(formWidget, &args[0], 1);    XtSetValues(imageWidget, &args[0], 1);        XtAddEventHandler(imageWidget, ExposureMask | ButtonPressMask        | ButtonReleaseMask | Button1MotionMask | KeyPressMask,        False, EventProc, NULL);    XtRealizeWidget(shellWidget);    window_attributes.cursor = XCreateFontCursor(xDisplay, XC_fleur);    XChangeWindowAttributes(xDisplay, XtWindow(imageWidget),        CWCursor, &window_attributes);    CreateXImage();    XtMainLoop();    return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int_TIFFNoStripDecode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s){\t(void) pp; (void) cc; (void) s;\treturn (TIFFNoDecode(tif, \"strip\"));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tdata_t_TIFFmalloc(tsize_t s){\treturn (NewPtr((size_t) s));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFReadRawData(TIFF* tif, int bitrev){\ttstrip_t nstrips = TIFFNumberOfStrips(tif);\tconst char* what = TIFFIsTiled(tif) ? \"Tile\" : \"Strip\";\tuint64* stripbc;\tTIFFGetField(tif, TIFFTAG_STRIPBYTECOUNTS, &stripbc);\tif (nstrips > 0) {\t\tuint32 bufsize = (uint32) stripbc[0];\t\ttdata_t buf = _TIFFmalloc(bufsize);\t\ttstrip_t s;\t\tfor (s = 0; s < nstrips; s++) {\t\t\tif (stripbc[s] > bufsize) {\t\t\t\tbuf = _TIFFrealloc(buf, (tmsize_t)stripbc[s]);\t\t\t\tbufsize = (uint32) stripbc[s];\t\t\t}\t\t\tif (buf == NULL) {\t\t\t\tfprintf(stderr,\t\t\t\t   \"Cannot allocate buffer to read strip %lu\\n\",\t\t\t\t    (unsigned long) s);\t\t\t\tbreak;\t\t\t}\t\t\tif (TIFFReadRawStrip(tif, s, buf, (tmsize_t) stripbc[s]) < 0) {\t\t\t\tfprintf(stderr, \"Error reading strip %lu\\n\",\t\t\t\t    (unsigned long) s);\t\t\t\tif (stoponerr)\t\t\t\t\tbreak;\t\t\t} else if (showdata) {\t\t\t\tif (bitrev) {\t\t\t\t\tTIFFReverseBits(buf, (tmsize_t)stripbc[s]);\t\t\t\t\tprintf(\"%s %lu: (bit reversed)\\n \",\t\t\t\t\t    what, (unsigned long) s);\t\t\t\t} else\t\t\t\t\tprintf(\"%s %lu:\\n \", what,\t\t\t\t\t    (unsigned long) s);\t\t\t\tif (showwords)\t\t\t\t\tShowRawWords((uint16*) buf, (uint32) stripbc[s]>>1);\t\t\t\telse\t\t\t\t\tShowRawBytes((unsigned char*) buf, (uint32) stripbc[s]);\t\t\t}\t\t}\t\tif (buf != NULL)\t\t\t_TIFFfree(buf);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void t2p_validate(T2P* t2p){#ifdef JPEG_SUPPORT\tif(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){\t\tif(t2p->pdf_defaultcompressionquality>100 ||\t\t\tt2p->pdf_defaultcompressionquality<1){\t\t\tt2p->pdf_defaultcompressionquality=0;\t\t}\t}#endif#ifdef ZIP_SUPPORT\tif(t2p->pdf_defaultcompression==T2P_COMPRESS_ZIP){ \t\tuint16 m=t2p->pdf_defaultcompressionquality%100; \t\tif(t2p->pdf_defaultcompressionquality/100 > 9 || \t\t\t(m>1 && m<10) || m>15){ \t\t\tt2p->pdf_defaultcompressionquality=0;\t\t}\t\tif(t2p->pdf_defaultcompressionquality%100 !=0){ \t\t\tt2p->pdf_defaultcompressionquality/=100; \t\t\tt2p->pdf_defaultcompressionquality*=100;\t\t\tTIFFError(\t\t\t\tTIFF2PDF_MODULE, \t\t\t\t\"PNG Group predictor differencing not implemented, assuming compression quality %u\", \t\t\t\tt2p->pdf_defaultcompressionquality);\t\t}\t\tt2p->pdf_defaultcompressionquality%=100;\t\tif(t2p->pdf_minorversion<2){t2p->pdf_minorversion=2;}\t}#endif\t(void)0;\treturn;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFImageIterBegin(TIFFImageIter* img, TIFF* tif, int stop, char emsg[1024]){    uint16* sampleinfo;    uint16 extrasamples;    uint16 planarconfig;    int colorchannels;    img->tif = tif;    img->stoponerr = stop;    TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &img->bitspersample);    img->alpha = 0;    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\t&extrasamples, &sampleinfo);    if (extrasamples == 1)\tswitch (sampleinfo[0]) {\tcase EXTRASAMPLE_ASSOCALPHA:\t\tcase EXTRASAMPLE_UNASSALPHA:\t\t    img->alpha = sampleinfo[0];\t    break;\t}    colorchannels = img->samplesperpixel - extrasamples;    TIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarconfig);    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &img->photometric)) {\tswitch (colorchannels) {\tcase 1:\t    if (isCCITTCompression(tif))\t\timg->photometric = PHOTOMETRIC_MINISWHITE;\t    else\t\timg->photometric = PHOTOMETRIC_MINISBLACK;\t    break;\tcase 3:\t    img->photometric = PHOTOMETRIC_RGB;\t    break;\tdefault:\t    sprintf(emsg, \"Missing needed %s tag\", photoTag);\t    return (0);\t}    }    switch (img->photometric) {    case PHOTOMETRIC_PALETTE:\tif (!TIFFGetField(tif, TIFFTAG_COLORMAP,\t    &img->redcmap, &img->greencmap, &img->bluecmap)) {\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Missing required \\\"Colormap\\\" tag\");\t    return (0);\t}\t    case PHOTOMETRIC_MINISWHITE:    case PHOTOMETRIC_MINISBLACK:\tbreak;    case PHOTOMETRIC_YCBCR:\tif (planarconfig != PLANARCONFIG_CONTIG) {\t    sprintf(emsg, \"Sorry, can not handle YCbCr images with %s=%d\",\t\t\"Planarconfiguration\", planarconfig);\t    return (0);\t}\t\t{ uint16 compress;\t  TIFFGetField(tif, TIFFTAG_COMPRESSION, &compress);\t  if (compress == COMPRESSION_JPEG && planarconfig == PLANARCONFIG_CONTIG) {\t    \t    \t    TIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\t    img->photometric = PHOTOMETRIC_RGB;\t  }\t}\tbreak;    case PHOTOMETRIC_RGB: \tif (colorchannels < 3) {\t    sprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",\t\t\"Color channels\", colorchannels);\t    return (0);\t}\tbreak;    case PHOTOMETRIC_SEPARATED: {\tuint16 inkset;\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);\tif (inkset != INKSET_CMYK) {\t    sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",\t\t\"InkSet\", inkset);\t    return (0);\t}\tif (img->samplesperpixel != 4) {\t    sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",\t\t\"Samples/pixel\", img->samplesperpixel);\t    return (0);\t}\tbreak;    }    default:\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",\t    photoTag, img->photometric);\treturn (0);    }    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &img->width);    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &img->height);    TIFFGetFieldDefaulted(tif, TIFFTAG_ORIENTATION, &img->orientation);    switch (img->orientation) {    case ORIENTATION_BOTRIGHT:    case ORIENTATION_RIGHTBOT:\t    case ORIENTATION_LEFTBOT:\t\tTIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\timg->orientation = ORIENTATION_BOTLEFT;\t    case ORIENTATION_BOTLEFT:\tbreak;    case ORIENTATION_TOPRIGHT:    case ORIENTATION_RIGHTTOP:\t    case ORIENTATION_LEFTTOP:\t    default:\tTIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\timg->orientation = ORIENTATION_TOPLEFT;\t    case ORIENTATION_TOPLEFT:\tbreak;    }    img->isContig =\t!(planarconfig == PLANARCONFIG_SEPARATE && colorchannels > 1);    if (img->isContig) {\timg->get = TIFFIsTiled(tif) ? gtTileContig : gtStripContig;    } else {\timg->get = TIFFIsTiled(tif) ? gtTileSeparate : gtStripSeparate;    }    return (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcvt_by_tile( TIFF *in, TIFF *out ){    uint32* raster;\t\t\t    uint32  width, height;\t\t    uint32  tile_width, tile_height;    uint32  row, col;    uint32  *wrk_line;    int\t    ok = 1;    TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width);    TIFFGetField(in, TIFFTAG_IMAGELENGTH, &height);    if( !TIFFGetField(in, TIFFTAG_TILEWIDTH, &tile_width)        || !TIFFGetField(in, TIFFTAG_TILELENGTH, &tile_height) ) {        TIFFError(TIFFFileName(in), \"Source image not tiled\");        return (0);    }        TIFFSetField(out, TIFFTAG_TILEWIDTH, tile_width );    TIFFSetField(out, TIFFTAG_TILELENGTH, tile_height );        raster = (uint32*)_TIFFmalloc(tile_width * tile_height * sizeof (uint32));    if (raster == 0) {        TIFFError(TIFFFileName(in), \"No space for raster buffer\");        return (0);    }        wrk_line = (uint32*)_TIFFmalloc(tile_width * sizeof (uint32));    if (!wrk_line) {        TIFFError(TIFFFileName(in), \"No space for raster scanline buffer\");        ok = 0;    }            for( row = 0; ok && row < height; row += tile_height )    {        for( col = 0; ok && col < width; col += tile_width )        {            uint32 i_row;                        if (!TIFFReadRGBATile(in, col, row, raster)) {                ok = 0;                break;            }\t    #if HOST_BIGENDIAN\t    TIFFSwabArrayOfLong(raster, tile_width * tile_height);#endif                        for( i_row = 0; i_row < tile_height / 2; i_row++ )            {                uint32\t*top_line, *bottom_line;                top_line = raster + tile_width * i_row;                bottom_line = raster + tile_width * (tile_height-i_row-1);                _TIFFmemcpy(wrk_line, top_line, 4*tile_width);                _TIFFmemcpy(top_line, bottom_line, 4*tile_width);                _TIFFmemcpy(bottom_line, wrk_line, 4*tile_width);            }                        if( TIFFWriteEncodedTile( out,                                      TIFFComputeTile( out, col, row, 0, 0),                                      raster,                                      4 * tile_width * tile_height ) == -1 )            {                ok = 0;                break;            }        }    }    _TIFFfree( raster );    _TIFFfree( wrk_line );    return ok;}",
        "label": 1,
        "cve": "cve-2016-3945-2"
    },
    {
        "code": "TIFF*TIFFFdOpen(int fd, const char* name, const char* mode){\tTIFF* tif;\ttif = TIFFClientOpen(name, mode,\t    (thandle_t) fd,\t    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,\t    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);\tif (tif)\t\ttif->tif_fd = fd;\treturn (tif);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static toff_t_tiffSeekProc(thandle_t fd, toff_t off, int whence){\treturn (lseek((int) fd, (off_t) off, whence));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidquant_fsdither(TIFF* in, TIFF* out){\tunsigned char *outline, *inputline, *inptr;\tshort *thisline, *nextline;\tregister unsigned char\t*outptr;\tregister short *thisptr, *nextptr;\tregister uint32 i, j;\tuint32 imax, jmax;\tint lastline, lastpixel;\timax = imagelength - 1;\tjmax = imagewidth - 1;\tinputline = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\tthisline = (short *)_TIFFmalloc(imagewidth * 3 * sizeof (short));\tnextline = (short *)_TIFFmalloc(imagewidth * 3 * sizeof (short));\toutline = (unsigned char *) _TIFFmalloc(TIFFScanlineSize(out));\tGetInputLine(in, 0, goto bad);\t\t\tfor (i = 1; i <= imagelength; ++i) {\t\tSWAP(short *, thisline, nextline);\t\tlastline = (i >= imax);\t\tif (i <= imax)\t\t\tGetInputLine(in, i, break);\t\tthisptr = thisline;\t\tnextptr = nextline;\t\toutptr = outline;\t\tfor (j = 0; j < imagewidth; ++j) {\t\t\tint red, green, blue;\t\t\tregister int oval, r2, g2, b2;\t\t\tlastpixel = (j == jmax);\t\t\tGetComponent(*thisptr++, r2, red);\t\t\tGetComponent(*thisptr++, g2, green);\t\t\tGetComponent(*thisptr++, b2, blue);\t\t\toval = histogram[r2][g2][b2];\t\t\tif (oval == -1) {\t\t\t\tint ci;\t\t\t\tregister int cj, tmp, d2, dist;\t\t\t\tregister C_cell\t*cell;\t\t\t\tcell = *(ColorCells +\t\t\t\t    (((r2>>(B_DEPTH-C_DEPTH)) << C_DEPTH*2) +\t\t\t\t    ((g2>>(B_DEPTH-C_DEPTH)) << C_DEPTH ) +\t\t\t\t    (b2>>(B_DEPTH-C_DEPTH))));\t\t\t\tif (cell == NULL)\t\t\t\t\tcell = create_colorcell(red,\t\t\t\t\t    green, blue);\t\t\t\tdist = 9999999;\t\t\t\tfor (ci = 0; ci < cell->num_ents && dist > cell->entries[ci][1]; ++ci) {\t\t\t\t\tcj = cell->entries[ci][0];\t\t\t\t\td2 = (rm[cj] >> COLOR_SHIFT) - r2;\t\t\t\t\td2 *= d2;\t\t\t\t\ttmp = (gm[cj] >> COLOR_SHIFT) - g2;\t\t\t\t\td2 += tmp*tmp;\t\t\t\t\ttmp = (bm[cj] >> COLOR_SHIFT) - b2;\t\t\t\t\td2 += tmp*tmp;\t\t\t\t\tif (d2 < dist) {\t\t\t\t\t\tdist = d2;\t\t\t\t\t\toval = cj;\t\t\t\t\t}\t\t\t\t}\t\t\t\thistogram[r2][g2][b2] = oval;\t\t\t}\t\t\t*outptr++ = oval;\t\t\tred -= rm[oval];\t\t\tgreen -= gm[oval];\t\t\tblue -= bm[oval];\t\t\tif (!lastpixel) {\t\t\t\tthisptr[0] += blue * 7 / 16;\t\t\t\tthisptr[1] += green * 7 / 16;\t\t\t\tthisptr[2] += red * 7 / 16;\t\t\t}\t\t\tif (!lastline) {\t\t\t\tif (j != 0) {\t\t\t\t\tnextptr[-3] += blue * 3 / 16;\t\t\t\t\tnextptr[-2] += green * 3 / 16;\t\t\t\t\tnextptr[-1] += red * 3 / 16;\t\t\t\t}\t\t\t\tnextptr[0] += blue * 5 / 16;\t\t\t\tnextptr[1] += green * 5 / 16;\t\t\t\tnextptr[2] += red * 5 / 16;\t\t\t\tif (!lastpixel) {\t\t\t\t\tnextptr[3] += blue / 16;\t\t\t\t        nextptr[4] += green / 16;\t\t\t\t        nextptr[5] += red / 16;\t\t\t\t}\t\t\t\tnextptr += 3;\t\t\t}\t\t}\t\tif (TIFFWriteScanline(out, outline, i-1, 0) < 0)\t\t\tbreak;\t}bad:\t_TIFFfree(inputline);\t_TIFFfree(thisline);\t_TIFFfree(nextline);\t_TIFFfree(outline);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static uint64ReadDirectory(int fd, unsigned int ix, uint64 off){\tuint16 dircount;\tuint32 direntrysize;\tvoid* dirmem = NULL;\tuint64 nextdiroff = 0;\tuint32 n;\tuint8* dp;\tif (off == 0)\t\t\t\t\tgoto done;\tif (_TIFF_lseek_f(fd, (_TIFF_off_t)off, SEEK_SET) != (_TIFF_off_t)off) {\t\tFatal(\"Seek error accessing TIFF directory\");\t\tgoto done;\t}\tif (!bigtiff) {\t\tif (read(fd, (char*) &dircount, sizeof (uint16)) != sizeof (uint16)) {\t\t\tReadError(\"directory count\");\t\t\tgoto done;\t\t}\t\tif (swabflag)\t\t\tTIFFSwabShort(&dircount);\t\tdirentrysize = 12;\t} else {\t\tuint64 dircount64 = 0;\t\tif (read(fd, (char*) &dircount64, sizeof (uint64)) != sizeof (uint64)) {\t\t\tReadError(\"directory count\");\t\t\tgoto done;\t\t}\t\tif (swabflag)\t\t\tTIFFSwabLong8(&dircount64);\t\tif (dircount64>0xFFFF) {\t\t\tError(\"Sanity check on directory count failed\");\t\t\tgoto done;\t\t}\t\tdircount = (uint16)dircount64;\t\tdirentrysize = 20;\t}\tdirmem = _TIFFmalloc(TIFFSafeMultiply(tmsize_t,dircount,direntrysize));\tif (dirmem == NULL) {\t\tFatal(\"No space for TIFF directory\");\t\tgoto done;\t}\tn = read(fd, (char*) dirmem, dircount*direntrysize);\tif (n != dircount*direntrysize) {\t\tn /= direntrysize;\t\tError(#if defined(__WIN32__) && defined(_MSC_VER)\t    \"Could only read %lu of %u entries in directory at offset %#I64x\",\t\t      (unsigned long)n, dircount, (unsigned __int64) off);#else\t    \"Could only read %lu of %u entries in directory at offset %#llx\",\t\t      (unsigned long)n, dircount, (unsigned long long) off);#endif\t\tdircount = n;\t\tnextdiroff = 0;\t} else {\t\tif (!bigtiff) {\t\t\tuint32 nextdiroff32;\t\t\tif (read(fd, (char*) &nextdiroff32, sizeof (uint32)) != sizeof (uint32))\t\t\t\tnextdiroff32 = 0;\t\t\tif (swabflag)\t\t\t\tTIFFSwabLong(&nextdiroff32);\t\t\tnextdiroff = nextdiroff32;\t\t} else {\t\t\tif (read(fd, (char*) &nextdiroff, sizeof (uint64)) != sizeof (uint64))\t\t\t\tnextdiroff = 0;\t\t\tif (swabflag)\t\t\t\tTIFFSwabLong8(&nextdiroff);\t\t}\t}#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\tprintf(\"Directory %u: offset %I64u (%#I64x) next %I64u (%#I64x)\\n\", ix,\t    (unsigned __int64)off, (unsigned __int64)off,\t    (unsigned __int64)nextdiroff, (unsigned __int64)nextdiroff);#else\tprintf(\"Directory %u: offset %llu (%#llx) next %llu (%#llx)\\n\", ix,\t    (unsigned long long)off, (unsigned long long)off,\t    (unsigned long long)nextdiroff, (unsigned long long)nextdiroff);#endif\tfor (dp = (uint8*)dirmem, n = dircount; n > 0; n--) {\t\tuint16 tag;\t\tuint16 type;\t\tuint16 typewidth;\t\tuint64 count;\t\tuint64 datasize;\t\tint datafits;\t\tvoid* datamem;\t\tuint64 dataoffset;\t\tint datatruncated;                int datasizeoverflow;\t\ttag = *(uint16*)dp;\t\tif (swabflag)\t\t\tTIFFSwabShort(&tag);\t\tdp += sizeof(uint16);\t\ttype = *(uint16*)dp;\t\tdp += sizeof(uint16);\t\tif (swabflag)\t\t\tTIFFSwabShort(&type);\t\tPrintTag(stdout, tag);\t\tputchar(' ');\t\tPrintType(stdout, type);\t\tputchar(' ');\t\tif (!bigtiff)\t\t{\t\t\tuint32 count32;\t\t\tcount32 = *(uint32*)dp;\t\t\tif (swabflag)\t\t\t\tTIFFSwabLong(&count32);\t\t\tdp += sizeof(uint32);\t\t\tcount = count32;\t\t}\t\telse\t\t{\t\t\tmemcpy(&count, dp, sizeof(uint64));\t\t\tif (swabflag)\t\t\t\tTIFFSwabLong8(&count);\t\t\tdp += sizeof(uint64);\t\t}#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\tprintf(\"%I64u<\", (unsigned __int64)count);#else\t\tprintf(\"%llu<\", (unsigned long long)count);#endif\t\tif (type >= NWIDTHS)\t\t\ttypewidth = 0;\t\telse\t\t\ttypewidth = datawidth[type];\t\tdatasize = TIFFSafeMultiply(tmsize_t,count,typewidth);                datasizeoverflow = (typewidth > 0 && datasize / typewidth != count);\t\tdatafits = 1;\t\tdatamem = dp;\t\tdataoffset = 0;\t\tdatatruncated = 0;\t\tif (!bigtiff)\t\t{\t\t\tif (datasizeoverflow || datasize>4)\t\t\t{\t\t\t\tuint32 dataoffset32;\t\t\t\tdatafits = 0;\t\t\t\tdatamem = NULL;\t\t\t\tdataoffset32 = *(uint32*)dp;\t\t\t\tif (swabflag)\t\t\t\t\tTIFFSwabLong(&dataoffset32);\t\t\t\tdataoffset = dataoffset32;\t\t\t}\t\t\tdp += sizeof(uint32);\t\t}\t\telse\t\t{\t\t\tif (datasizeoverflow || datasize>8)\t\t\t{\t\t\t\tdatafits = 0;\t\t\t\tdatamem = NULL;\t\t\t\tdataoffset = *(uint64*)dp;\t\t\t\tif (swabflag)\t\t\t\t\tTIFFSwabLong8(&dataoffset);\t\t\t}\t\t\tdp += sizeof(uint64);\t\t}\t\tif (datasizeoverflow || datasize>0x10000)\t\t{\t\t\tdatatruncated = 1;\t\t\tcount = 0x10000/typewidth;\t\t\tdatasize = TIFFSafeMultiply(tmsize_t,count,typewidth);\t\t}\t\tif (count>maxitems)\t\t{\t\t\tdatatruncated = 1;\t\t\tcount = maxitems;                        datasize = TIFFSafeMultiply(tmsize_t,count,typewidth);\t\t}\t\tif (!datafits)\t\t{\t\t\tdatamem = _TIFFmalloc(datasize);\t\t\tif (datamem) {\t\t\t\tif (_TIFF_lseek_f(fd, (_TIFF_off_t)dataoffset, 0) !=\t\t\t\t    (_TIFF_off_t)dataoffset)\t\t\t\t{\t\t\t\t\tError(\t\t\t\t\"Seek error accessing tag %u value\", tag);\t\t\t\t\t_TIFFfree(datamem);\t\t\t\t\tdatamem = NULL;\t\t\t\t}\t\t\t\telse if (read(fd, datamem, (size_t)datasize) != (TIFF_SSIZE_T)datasize)\t\t\t\t{\t\t\t\t\tError(\t\t\t\t\"Read error accessing tag %u value\", tag);\t\t\t\t\t_TIFFfree(datamem);\t\t\t\t\tdatamem = NULL;\t\t\t\t}\t\t\t} else\t\t\t\tError(\"No space for data for tag %u\",tag);\t\t}\t\tif (datamem)\t\t{\t\t\tif (swabflag)\t\t\t{\t\t\t\tswitch (type)\t\t\t\t{\t\t\t\t\tcase TIFF_BYTE:\t\t\t\t\tcase TIFF_ASCII:\t\t\t\t\tcase TIFF_SBYTE:\t\t\t\t\tcase TIFF_UNDEFINED:\t\t\t\t\t\tbreak;\t\t\t\t\tcase TIFF_SHORT:\t\t\t\t\tcase TIFF_SSHORT:\t\t\t\t\t\tTIFFSwabArrayOfShort((uint16*)datamem,(tmsize_t)count);\t\t\t\t\t\tbreak;\t\t\t\t\tcase TIFF_LONG:\t\t\t\t\tcase TIFF_SLONG:\t\t\t\t\tcase TIFF_FLOAT:\t\t\t\t\tcase TIFF_IFD:\t\t\t\t\t\tTIFFSwabArrayOfLong((uint32*)datamem,(tmsize_t)count);\t\t\t\t\t\tbreak;\t\t\t\t\tcase TIFF_RATIONAL:\t\t\t\t\tcase TIFF_SRATIONAL:\t\t\t\t\t\tTIFFSwabArrayOfLong((uint32*)datamem,(tmsize_t)count*2);\t\t\t\t\t\tbreak;\t\t\t\t\tcase TIFF_DOUBLE:\t\t\t\t\tcase TIFF_LONG8:\t\t\t\t\tcase TIFF_SLONG8:\t\t\t\t\tcase TIFF_IFD8:\t\t\t\t\t\tTIFFSwabArrayOfLong8((uint64*)datamem,(tmsize_t)count);\t\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t\tPrintData(stdout,type,(uint32)count,datamem);\t\t\tif (datatruncated)\t\t\t\tprintf(\" ...\");\t\t\tif (!datafits)                                {                                        _TIFFfree(datamem);                                        datamem = NULL;                                }\t\t}\t\tprintf(\">\\n\");\t}done:\tif (dirmem)\t\t_TIFFfree((char *)dirmem);\treturn (nextdiroff);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidsetupLumaTables(void){    lumaRed = setupLuma(LumaRed);    lumaGreen = setupLuma(LumaGreen);    lumaBlue = setupLuma(LumaBlue);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidUsage(){    fprintf(stderr, \"Usage: %s -gamma gamma tiff-image\\n\", programName);    exit(0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidFax3PrematureEOF(const char* module, TIFF* tif, uint32 line, uint32 a0){\tTIFFWarningExt(tif->tif_clientdata, module, \"%s: Premature EOF at line %lu of %s %lu (x %lu)\",\t    tif->tif_name,\t    (unsigned long) line, isTiled(tif) ? \"tile\" : \"strip\",        (unsigned long) (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),        (unsigned long) a0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPixarLogPreEncode(TIFF* tif, uint16 s){\tstatic const char module[] = \"PixarLogPreEncode\";\tPixarLogState *sp = EncoderState(tif);\t(void) s;\tassert(sp != NULL);\tsp->stream.next_out = tif->tif_rawdata;\tassert(sizeof(sp->stream.avail_out)==4);  \tsp->stream.avail_out = (uInt)tif->tif_rawdatasize;\tif ((tmsize_t)sp->stream.avail_out != tif->tif_rawdatasize)\t{\t\tTIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\");\t\treturn (0);\t}\treturn (deflateReset(&sp->stream) == Z_OK);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*TIFFFdOpen(int fd, const char* name, const char* mode){\tTIFF* tif;\ttif = TIFFClientOpen(name, mode,\t\t(thandle_t) fd,\t\t_tiffReadProc, _tiffWriteProc,\t\t_tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\t\t_tiffMapProc, _tiffUnmapProc);\tif (tif)\t{\t\ttif->tif_fd = fd;\t}\treturn (tif);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int mfs_read (int fd, void *clnt_buf, int size){    int ret;    if (fds[fd] == -1 || buf_mode[fd] != 'r')    {                ret = -1;        errno = EBADF;    }    else if (buf_off[fd] + size > buf_size[fd])    {        ret = 0;            }    else    {        memcpy (clnt_buf, (void *) (buf[fd] + buf_off[fd]), size);        buf_off[fd] = buf_off[fd] + size;        ret = size;    }    return (ret);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFFCodec*TIFFGetConfiguredCODECs(){\tint\t\ti = 1;        codec_t\t\t*cd;        const TIFFCodec\t*c;\tTIFFCodec\t*codecs = NULL, *new_codecs;        for (cd = registeredCODECS; cd; cd = cd->next) {                new_codecs = (TIFFCodec *)\t\t\t_TIFFrealloc(codecs, i * sizeof(TIFFCodec));\t\tif (!new_codecs) {\t\t\t_TIFFfree (codecs);\t\t\treturn NULL;\t\t}\t\tcodecs = new_codecs;\t\t_TIFFmemcpy(codecs + i - 1, cd, sizeof(TIFFCodec));\t\ti++;\t}        for (c = _TIFFBuiltinCODECS; c->name; c++) {                if (TIFFIsCODECConfigured(c->scheme)) {                        new_codecs = (TIFFCodec *)\t\t\t\t_TIFFrealloc(codecs, i * sizeof(TIFFCodec));\t\t\tif (!new_codecs) {\t\t\t\t_TIFFfree (codecs);\t\t\t\treturn NULL;\t\t\t}\t\t\tcodecs = new_codecs;\t\t\t_TIFFmemcpy(codecs + i - 1, (const tdata_t)c, sizeof(TIFFCodec));\t\t\ti++;\t\t}\t}\tnew_codecs = (TIFFCodec *) _TIFFrealloc(codecs, i * sizeof(TIFFCodec));\tif (!new_codecs) {\t\t_TIFFfree (codecs);\t\treturn NULL;\t}\tcodecs = new_codecs;\t_TIFFmemset(codecs + i - 1, 0, sizeof(TIFFCodec));        return codecs;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intgtTileSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h){\tTIFF* tif = img->tif;\ttileSeparateRoutine put = img->put.separate;\tuint32 col, row, y, rowstoread;\tuint32 pos;\tuint32 tw, th;\tunsigned char* buf;\tunsigned char* p0;\tunsigned char* p1;\tunsigned char* p2;\tunsigned char* pa;\ttsize_t tilesize;\tint32 fromskew, toskew;\tint alpha = img->alpha;\tuint32 nrow;\tint ret = 1, flip;\ttilesize = TIFFTileSize(tif);\tbuf = (unsigned char*) _TIFFmalloc((alpha?4:3)*tilesize);\tif (buf == 0) {\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for tile buffer\");\t\treturn (0);\t}\t_TIFFmemset(buf, 0, (alpha?4:3)*tilesize);\tp0 = buf;\tp1 = p0 + tilesize;\tp2 = p1 + tilesize;\tpa = (alpha?(p2+tilesize):NULL);\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\tflip = setorientation(img);\tif (flip & FLIP_VERTICALLY) {\t\ty = h - 1;\t\ttoskew = -(int32)(tw + w);\t}\telse {\t\ty = 0;\t\ttoskew = -(int32)(tw - w);\t}\tfor (row = 0; row < h; row += nrow)\t{\t\trowstoread = th - (row + img->row_offset) % th;\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\t\tfor (col = 0; col < w; col += tw)\t\t{\t\t\tif (TIFFReadTile(tif, p0, col+img->col_offset,\t\t\t    row+img->row_offset,0,0) < 0 && img->stoponerr)\t\t\t{\t\t\t\tret = 0;\t\t\t\tbreak;\t\t\t}\t\t\tif (TIFFReadTile(tif, p1, col+img->col_offset,\t\t\t    row+img->row_offset,0,1) < 0 && img->stoponerr)\t\t\t{\t\t\t\tret = 0;\t\t\t\tbreak;\t\t\t}\t\t\tif (TIFFReadTile(tif, p2, col+img->col_offset,\t\t\t    row+img->row_offset,0,2) < 0 && img->stoponerr)\t\t\t{\t\t\t\tret = 0;\t\t\t\tbreak;\t\t\t}\t\t\tif (alpha)\t\t\t{\t\t\t\tif (TIFFReadTile(tif,pa,col+img->col_offset,\t\t\t\t    row+img->row_offset,0,3) < 0 && img->stoponerr)\t\t\t\t{\t\t\t\t\tret = 0;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t\tpos = ((row+img->row_offset) % th) * TIFFTileRowSize(tif);\t\t\tif (col + tw > w)\t\t\t{\t\t\t\t\t\t\t\tuint32 npix = w - col;\t\t\t\tfromskew = tw - npix;\t\t\t\t(*put)(img, raster+y*w+col, col, y,\t\t\t\t    npix, nrow, fromskew, toskew + fromskew,\t\t\t\t    p0 + pos, p1 + pos, p2 + pos, (alpha?(pa+pos):NULL));\t\t\t} else {\t\t\t\t(*put)(img, raster+y*w+col, col, y,\t\t\t\t    tw, nrow, 0, toskew, p0 + pos, p1 + pos, p2 + pos, (alpha?(pa+pos):NULL));\t\t\t}\t\t}\t\ty += (flip & FLIP_VERTICALLY ?-(int32) nrow : (int32) nrow);\t}\tif (flip & FLIP_HORIZONTALLY) {\t\tuint32 line;\t\tfor (line = 0; line < h; line++) {\t\t\tuint32 *left = raster + (line * w);\t\t\tuint32 *right = left + w - 1;\t\t\twhile ( left < right ) {\t\t\t\tuint32 temp = *left;\t\t\t\t*left = *right;\t\t\t\t*right = temp;\t\t\t\tleft++, right--;\t\t\t}\t\t}\t}\t_TIFFfree(buf);\treturn (ret);}",
        "label": 1,
        "cve": "cve-2012-1173_1"
    },
    {
        "code": "static void dump_info(FILE *dumpfile, int format, char *prefix, char *msg, ...)  {  if (format == DUMP_TEXT)    {    va_list ap;    va_start(ap, msg);    fprintf(dumpfile, \"%s \", prefix);    vfprintf(dumpfile, msg, ap);    fprintf(dumpfile, \"\\n\");    va_end(ap);    }  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteLongArray(TIFF* tif,    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, uint32* v){\tdir->tdir_tag = tag;\tdir->tdir_type = (short) type;\tdir->tdir_count = n;\tif (n == 1) {\t\tdir->tdir_offset = v[0];\t\treturn (1);\t} else\t\treturn (TIFFWriteData(tif, dir, (char*) v));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intswabHorAcc16(TIFF* tif, uint8* cp0, tmsize_t cc){\tuint16* wp = (uint16*) cp0;\ttmsize_t wc = cc / 2;        TIFFSwabArrayOfShort(wp, wc);        return horAcc16(tif, cp0, cc);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(void)  {  int i;  fprintf(stderr, \"\\n%s\\n\", TIFFGetVersion());  for (i = 0; usage_info[i] != NULL; i++)    fprintf(stderr, \"%s\\n\", usage_info[i]);  exit(-1);  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intextractContigSamples8bits (uint8 *in, uint8 *out, uint32 cols,                           tsample_t sample, uint16 spp, uint16 bps,                            tsample_t count, uint32 start, uint32 end)  {  int    ready_bits = 0, sindex = 0;  uint32 col, src_byte, src_bit, bit_offset;  uint8  maskbits = 0, matchbits = 0;  uint8  buff1 = 0, buff2 = 0;  uint8 *src = in;  uint8 *dst = out;  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"extractContigSamples8bits\",\"Invalid input or output buffer\");    return (1);    }  if ((start > end) || (start > cols))    {    TIFFError (\"extractContigSamples8bits\",                \"Invalid start column value %d ignored\", start);    start = 0;    }  if ((end == 0) || (end > cols))    {    TIFFError (\"extractContigSamples8bits\",                \"Invalid end column value %d ignored\", end);    end = cols;    }  ready_bits = 0;  maskbits =  (uint8)-1 >> ( 8 - bps);  buff1 = buff2 = 0;  for (col = start; col < end; col++)    {        bit_offset = col * bps * spp;    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)      {      if (sindex == 0)        {        src_byte = bit_offset / 8;        src_bit  = bit_offset % 8;        }      else        {        src_byte = (bit_offset + (sindex * bps)) / 8;        src_bit  = (bit_offset + (sindex * bps)) % 8;        }      src = in + src_byte;      matchbits = maskbits << (8 - src_bit - bps);       buff1 = ((*src) & matchbits) << (src_bit);            if (ready_bits >= 8)        {        *dst++ = buff2;        buff2 = buff1;        ready_bits -= 8;        }      else        buff2 = (buff2 | (buff1 >> ready_bits));      ready_bits += bps;      }    }  while (ready_bits > 0)    {    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));    *dst++ = buff1;    ready_bits -= 8;    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int t2p_mapproc(thandle_t handle, void **data, toff_t *offset) { \t(void) handle, (void) data, (void) offset;\treturn -1; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_notConfigured(TIFF* tif){\tconst TIFFCodec* c = TIFFFindCODEC(tif->tif_dir.td_compression);        char compression_code[20];        sprintf(compression_code, \"%d\",tif->tif_dir.td_compression );\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,                     \"%s compression support is not configured\",                      c ? c->name : compression_code );\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "float_TIFFUInt64ToFloat(uint64 ui64){\t_Int64 i;\ti.value = ui64;\tif (i.part.high >= 0) {\t\treturn (float)i.value;\t} else {\t\tlong double df;\t\tdf = (long double)i.value;\t\tdf += 18446744073709551616.0; \t\treturn (float)df;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static toff_t_tiffSeekProc(thandle_t fd, toff_t off, int whence){\treturn (_llseek(fd, (off_t) off, whence));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static char *CheckMalloc(TIFF* tif, tsize_t n, const char* what){\tchar *cp = (char*)_TIFFmalloc(n);\tif (cp == NULL)\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"No space %s\", what);\treturn (cp);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFCvtNativeToIEEEDouble(TIFF* tif, u_int n, double* f){\tdouble_t* fp = (double_t*) f;\twhile (n-- > 0) {\t\tNATIVE2IEEEDOUBLE(fp);\t\tfp++;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidsetByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size){\tif (*vpp)\t\t_TIFFfree(*vpp), *vpp = 0;\tif (vp) {\t\ttmsize_t bytes = (tmsize_t)(nmemb * elem_size);\t\tif (elem_size && bytes / elem_size == nmemb)\t\t\t*vpp = (void*) _TIFFmalloc(bytes);\t\tif (*vpp)\t\t\t_TIFFmemcpy(*vpp, vp, bytes);\t}}",
        "label": 1,
        "cve": "cve-2016-5322"
    },
    {
        "code": "static intLZWDecode(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s){\tstatic const char module[] = \"LZWDecode\";\tLZWCodecState *sp = DecoderState(tif);\tchar *op = (char*) op0;\tlong occ = (long) occ0;\tchar *tp;\tunsigned char *bp;\thcode_t code;\tint len;\tlong nbits, nextbits, nbitsmask;        unsigned long nextdata;\tcode_t *codep, *free_entp, *maxcodep, *oldcodep;\t(void) s;\tassert(sp != NULL);        assert(sp->dec_codetab != NULL);\t \tif ((tmsize_t) occ != occ0)\t        return (0);\t \tif (sp->dec_restart) {\t\tlong residue;\t\tcodep = sp->dec_codep;\t\tresidue = codep->length - sp->dec_restart;\t\tif (residue > occ) {\t\t\t \t\t\tsp->dec_restart += occ;\t\t\tdo {\t\t\t\tcodep = codep->next;\t\t\t} while (--residue > occ && codep);\t\t\tif (codep) {\t\t\t\ttp = op + occ;\t\t\t\tdo {\t\t\t\t\t*--tp = codep->value;\t\t\t\t\tcodep = codep->next;\t\t\t\t} while (--occ && codep);\t\t\t}\t\t\treturn (1);\t\t}\t\t \t\top += residue;\t\tocc -= residue;\t\ttp = op;\t\tdo {\t\t\tint t;\t\t\t--tp;\t\t\tt = codep->value;\t\t\tcodep = codep->next;\t\t\t*tp = (char)t;\t\t} while (--residue && codep);\t\tsp->dec_restart = 0;\t}\tbp = (unsigned char *)tif->tif_rawcp;#ifdef LZW_CHECKEOS\tsp->dec_bitsleft = (((uint64)tif->tif_rawcc) << 3);#endif\tnbits = sp->lzw_nbits;\tnextdata = sp->lzw_nextdata;\tnextbits = sp->lzw_nextbits;\tnbitsmask = sp->dec_nbitsmask;\toldcodep = sp->dec_oldcodep;\tfree_entp = sp->dec_free_entp;\tmaxcodep = sp->dec_maxcodep;\twhile (occ > 0) {\t\tNextCode(tif, sp, bp, code, GetNextCode);\t\tif (code == CODE_EOI)\t\t\tbreak;\t\tif (code == CODE_CLEAR) {\t\t\tdo {\t\t\t\tfree_entp = sp->dec_codetab + CODE_FIRST;\t\t\t\t_TIFFmemset(free_entp, 0,\t\t\t\t\t    (CSIZE - CODE_FIRST) * sizeof (code_t));\t\t\t\tnbits = BITS_MIN;\t\t\t\tnbitsmask = MAXCODE(BITS_MIN);\t\t\t\tmaxcodep = sp->dec_codetab + nbitsmask-1;\t\t\t\tNextCode(tif, sp, bp, code, GetNextCode);\t\t\t} while (code == CODE_CLEAR);\t \t\t\tif (code == CODE_EOI)\t\t\t\tbreak;\t\t\tif (code > CODE_CLEAR) {\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\t\t\"LZWDecode: Corrupted LZW table at scanline %d\",\t\t\t\t\t     tif->tif_row);\t\t\t\treturn (0);\t\t\t}\t\t\t*op++ = (char)code;\t\t\tocc--;\t\t\toldcodep = sp->dec_codetab + code;\t\t\tcontinue;\t\t}\t\tcodep = sp->dec_codetab + code;\t\t \t\tif (free_entp < &sp->dec_codetab[0] ||\t\t    free_entp >= &sp->dec_codetab[CSIZE]) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"Corrupted LZW table at scanline %d\",\t\t\t    tif->tif_row);\t\t\treturn (0);\t\t}\t\tfree_entp->next = oldcodep;\t\tif (free_entp->next < &sp->dec_codetab[0] ||\t\t    free_entp->next >= &sp->dec_codetab[CSIZE]) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"Corrupted LZW table at scanline %d\",\t\t\t    tif->tif_row);\t\t\treturn (0);\t\t}\t\tfree_entp->firstchar = free_entp->next->firstchar;\t\tfree_entp->length = free_entp->next->length+1;\t\tfree_entp->value = (codep < free_entp) ?\t\t    codep->firstchar : free_entp->firstchar;\t\tif (++free_entp > maxcodep) {\t\t\tif (++nbits > BITS_MAX)\t\t \t\t\t\tnbits = BITS_MAX;\t\t\tnbitsmask = MAXCODE(nbits);\t\t\tmaxcodep = sp->dec_codetab + nbitsmask-1;\t\t}\t\toldcodep = codep;\t\tif (code >= 256) {\t\t\t \t\t\tif(codep->length == 0) {\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t    \"Wrong length of decoded string: \"\t\t\t\t    \"data probably corrupted at scanline %d\",\t\t\t\t    tif->tif_row);\t\t\t\treturn (0);\t\t\t}\t\t\tif (codep->length > occ) {\t\t\t\t \t\t\t\tsp->dec_codep = codep;\t\t\t\tdo {\t\t\t\t\tcodep = codep->next;\t\t\t\t} while (codep && codep->length > occ);\t\t\t\tif (codep) {\t\t\t\t\tsp->dec_restart = (long)occ;\t\t\t\t\ttp = op + occ;\t\t\t\t\tdo  {\t\t\t\t\t\t*--tp = codep->value;\t\t\t\t\t\tcodep = codep->next;\t\t\t\t\t}  while (--occ && codep);\t\t\t\t\tif (codep)\t\t\t\t\t\tcodeLoop(tif, module);\t\t\t\t}\t\t\t\tbreak;\t\t\t}\t\t\tlen = codep->length;\t\t\ttp = op + len;\t\t\tdo {\t\t\t\tint t;\t\t\t\t--tp;\t\t\t\tt = codep->value;\t\t\t\tcodep = codep->next;\t\t\t\t*tp = (char)t;\t\t\t} while (codep && tp > op);\t\t\tif (codep) {\t\t\t    codeLoop(tif, module);\t\t\t    break;\t\t\t}\t\t\tassert(occ >= len);\t\t\top += len;\t\t\tocc -= len;\t\t} else {\t\t\t*op++ = (char)code;\t\t\tocc--;\t\t}\t}\ttif->tif_rawcc -= (tmsize_t)( (uint8*) bp - tif->tif_rawcp );\ttif->tif_rawcp = (uint8*) bp;\tsp->lzw_nbits = (unsigned short) nbits;\tsp->lzw_nextdata = nextdata;\tsp->lzw_nextbits = nextbits;\tsp->dec_nbitsmask = nbitsmask;\tsp->dec_oldcodep = oldcodep;\tsp->dec_free_entp = free_entp;\tsp->dec_maxcodep = maxcodep;\tif (occ > 0) {#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\"Not enough data at scanline %d (short %I64d bytes)\",\t\t\t     tif->tif_row, (unsigned __int64) occ);#else\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\"Not enough data at scanline %d (short %llu bytes)\",\t\t\t     tif->tif_row, (unsigned long long) occ);#endif\t\treturn (0);\t}\treturn (1);}",
        "label": 1,
        "cve": "CVE-2018-18661"
    },
    {
        "code": "static tsize_tTIFFFetchData(TIFF* tif, TIFFDirEntry* dir, char* cp){\tint w = TIFFDataWidth((TIFFDataType) dir->tdir_type);\ttsize_t cc = dir->tdir_count * w;\tif (!isMapped(tif)) {\t\tif (!SeekOK(tif, dir->tdir_offset))\t\t\tgoto bad;\t\tif (!ReadOK(tif, cp, cc))\t\t\tgoto bad;\t} else {\t\tif (dir->tdir_offset + cc > tif->tif_size)\t\t\tgoto bad;\t\t_TIFFmemcpy(cp, tif->tif_base + dir->tdir_offset, cc);\t}\tif (tif->tif_flags & TIFF_SWAB) {\t\tswitch (dir->tdir_type) {\t\tcase TIFF_SHORT:\t\tcase TIFF_SSHORT:\t\t\tTIFFSwabArrayOfShort((uint16*) cp, dir->tdir_count);\t\t\tbreak;\t\tcase TIFF_LONG:\t\tcase TIFF_SLONG:\t\tcase TIFF_FLOAT:\t\t\tTIFFSwabArrayOfLong((uint32*) cp, dir->tdir_count);\t\t\tbreak;\t\tcase TIFF_RATIONAL:\t\tcase TIFF_SRATIONAL:\t\t\tTIFFSwabArrayOfLong((uint32*) cp, 2*dir->tdir_count);\t\t\tbreak;\t\tcase TIFF_DOUBLE:\t\t\tTIFFSwabArrayOfDouble((double*) cp, dir->tdir_count);\t\t\tbreak;\t\t}\t}\treturn (cc);bad:\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error fetching data for field \\\"%s\\\"\",\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\treturn ((tsize_t) 0);}",
        "label": 1,
        "cve": "cve-2006-2025"
    },
    {
        "code": "void_TIFFmemset(tdata_t p, int v, tsize_t c){\tchar* pp = (char*) p;\twhile (c > 0) {\t\ttsize_t chunk = 0x10000 - ((uint32) pp & 0xffff);\t\tif (chunk > 0xff00)\t\t\t\t\t\t\tchunk = 0xff00;\t\tif (chunk > c)\t\t\t\t\t\t\t\tchunk = c;\t\tmemset(pp, v, chunk);\t\tpp = (char*) (chunk + (char huge*) pp);\t\tc -= chunk;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static inttiffcmp(TIFF* tif1, TIFF* tif2){\tuint16 config1, config2;\ttsize_t size1;\tuint32 row;\ttsample_t s;\tunsigned char *buf1, *buf2;\tif (!CheckShortTag(tif1, tif2, TIFFTAG_BITSPERSAMPLE, \"BitsPerSample\"))\t\treturn (0);\tif (!CheckShortTag(tif1, tif2, TIFFTAG_SAMPLESPERPIXEL, \"SamplesPerPixel\"))\t\treturn (0);\tif (!CheckLongTag(tif1, tif2, TIFFTAG_IMAGEWIDTH, \"ImageWidth\"))\t\treturn (0);\tif (!cmptags(tif1, tif2))\t\treturn (1);\t(void) TIFFGetField(tif1, TIFFTAG_BITSPERSAMPLE, &bitspersample);\t(void) TIFFGetField(tif1, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\t(void) TIFFGetField(tif1, TIFFTAG_SAMPLEFORMAT, &sampleformat);\t(void) TIFFGetField(tif1, TIFFTAG_IMAGEWIDTH, &imagewidth);\t(void) TIFFGetField(tif1, TIFFTAG_IMAGELENGTH, &imagelength);\t(void) TIFFGetField(tif1, TIFFTAG_PLANARCONFIG, &config1);\t(void) TIFFGetField(tif2, TIFFTAG_PLANARCONFIG, &config2);\tbuf1 = (unsigned char *)_TIFFmalloc(size1 = TIFFScanlineSize(tif1));\tbuf2 = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif2));\tif (buf1 == NULL || buf2 == NULL) {\t\tfprintf(stderr, \"No space for scanline buffers\\n\");\t\texit(-1);\t}\tif (config1 != config2 && bitspersample != 8 && samplesperpixel > 1) {\t\tfprintf(stderr,\"Can't handle different planar configuration w/ different bits/sample\\n\");\t\tgoto bad;\t}#define\tpack(a,b)\t((a)<<8)|(b)\tswitch (pack(config1, config2)) {\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG):\t\tfor (row = 0; row < imagelength; row++) {\t\t\tif (TIFFReadScanline(tif2, buf2, row, 0) < 0)\t\t\t\tcheckEOF(tif2, row, -1)\t\t\tfor (s = 0; s < samplesperpixel; s++) {\t\t\t\tif (TIFFReadScanline(tif1, buf1, row, s) < 0)\t\t\t\t\tcheckEOF(tif1, row, s)\t\t\t\tif (SeparateCompare(1, s, row, buf2, buf1) < 0)\t\t\t\t\tgoto bad1;\t\t\t}\t\t}\t\tbreak;\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE):\t\tfor (row = 0; row < imagelength; row++) {\t\t\tif (TIFFReadScanline(tif1, buf1, row, 0) < 0)\t\t\t\tcheckEOF(tif1, row, -1)\t\t\tfor (s = 0; s < samplesperpixel; s++) {\t\t\t\tif (TIFFReadScanline(tif2, buf2, row, s) < 0)\t\t\t\t\tcheckEOF(tif2, row, s)\t\t\t\tif (SeparateCompare(0, s, row, buf1, buf2) < 0)\t\t\t\t\tgoto bad1;\t\t\t}\t\t}\t\tbreak;\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE):\t\tfor (s = 0; s < samplesperpixel; s++)\t\t\tfor (row = 0; row < imagelength; row++) {\t\t\t\tif (TIFFReadScanline(tif1, buf1, row, s) < 0)\t\t\t\t\tcheckEOF(tif1, row, s)\t\t\t\tif (TIFFReadScanline(tif2, buf2, row, s) < 0)\t\t\t\t\tcheckEOF(tif2, row, s)\t\t\t\tif (ContigCompare(s, row, buf1, buf2, size1) < 0)\t\t\t\t\tgoto bad1;\t\t\t}\t\tbreak;\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG):\t\tfor (row = 0; row < imagelength; row++) {\t\t\tif (TIFFReadScanline(tif1, buf1, row, 0) < 0)\t\t\t\tcheckEOF(tif1, row, -1)\t\t\tif (TIFFReadScanline(tif2, buf2, row, 0) < 0)\t\t\t\tcheckEOF(tif2, row, -1)\t\t\tif (ContigCompare(-1, row, buf1, buf2, size1) < 0)\t\t\t\tgoto bad1;\t\t}\t\tbreak;\t}\tif (buf1) _TIFFfree(buf1);\tif (buf2) _TIFFfree(buf2);\treturn (1);bad:\tif (stopondiff)\t\texit(1);bad1:\tif (buf1) _TIFFfree(buf1);\tif (buf2) _TIFFfree(buf2);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intZIPEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s){\tstatic const char module[] = \"ZIPEncode\";\tZIPState *sp = EncoderState(tif);\tassert(sp != NULL);\tassert(sp->state == ZSTATE_INIT_ENCODE);\t(void) s;\tsp->stream.next_in = bp;\tassert(sizeof(sp->stream.avail_in)==4);  \tsp->stream.avail_in = (uInt) cc;\tif ((tmsize_t)sp->stream.avail_in != cc)\t{\t\tTIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\");\t\treturn (0);\t}\tdo {\t\tif (deflate(&sp->stream, Z_NO_FLUSH) != Z_OK) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \t\t\t\t     \"Encoder error: %s\",\t\t\t\t     SAFE_MSG(sp));\t\t\treturn (0);\t\t}\t\tif (sp->stream.avail_out == 0) {\t\t\ttif->tif_rawcc = tif->tif_rawdatasize;\t\t\tTIFFFlushData1(tif);\t\t\tsp->stream.next_out = tif->tif_rawdata;\t\t\tsp->stream.avail_out = (uInt) tif->tif_rawdatasize;  \t\t}\t} while (sp->stream.avail_in > 0);\treturn (1);}",
        "label": 1,
        "cve": "cve-2016-3620"
    },
    {
        "code": "static void_TIFFprintAsciiBounded(FILE* fd, const char* cp, size_t max_chars){\tfor (; max_chars > 0 && *cp != '\\0'; cp++, max_chars--) {\t\tconst char* tp;\t\tif (isprint((int)*cp)) {\t\t\tfputc(*cp, fd);\t\t\tcontinue;\t\t}\t\tfor (tp = \"\\tt\\bb\\rr\\nn\\vv\"; *tp; tp++)\t\t\tif (*tp++ == *cp)\t\t\t\tbreak;\t\tif (*tp)\t\t\tfprintf(fd, \"\\\\%c\", *tp);\t\telse\t\t\tfprintf(fd, \"\\\\%03o\", *cp & 0xff);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int_TIFFNoPreCode(TIFF* tif, tsample_t s){\t(void) tif; (void) s;\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tsize_t_tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size){\treturn (write((int) fd, buf, size));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcreateImageSection(uint32 sectsize, unsigned char **sect_buff_ptr)  {  unsigned  char *sect_buff = NULL;  unsigned  char *new_buff  = NULL;  static    uint32  prev_sectsize = 0;  sect_buff = *sect_buff_ptr;  if (!sect_buff)    {    sect_buff = (unsigned char *)_TIFFmalloc(sectsize);    *sect_buff_ptr = sect_buff;    _TIFFmemset(sect_buff, 0, sectsize);    }  else    {    if (prev_sectsize < sectsize)      {      new_buff = _TIFFrealloc(sect_buff, sectsize);      if (!new_buff)        {\tfree (sect_buff);        sect_buff = (unsigned char *)_TIFFmalloc(sectsize);        }      else        sect_buff = new_buff;      _TIFFmemset(sect_buff, 0, sectsize);      }    }  if (!sect_buff)    {    TIFFError(\"createImageSection\", \"Unable to allocate/reallocate section buffer\");    return (-1);    }  prev_sectsize = sectsize;  *sect_buff_ptr = sect_buff;  return (0);  }  ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tsize_t_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size){\tlong r;\tr = Fread((int) fd, size, buf);\tif (r < 0) {\t\terrno = (int)-r;\t\tr = -1;\t}\treturn r;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidFatal(const char* fmt, ...){\tva_list ap;\tva_start(ap, fmt);\tvError(stderr, fmt, ap);\tva_end(ap);\texit(-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap){\tTIFFDirectory *td = &tif->tif_dir;\tif (TIFFVGetField(tif, tag, ap))\t\treturn (1);\tswitch (tag) {\tcase TIFFTAG_SUBFILETYPE:\t\t*va_arg(ap, uint32 *) = td->td_subfiletype;\t\treturn (1);\tcase TIFFTAG_BITSPERSAMPLE:\t\t*va_arg(ap, uint16 *) = td->td_bitspersample;\t\treturn (1);\tcase TIFFTAG_THRESHHOLDING:\t\t*va_arg(ap, uint16 *) = td->td_threshholding;\t\treturn (1);\tcase TIFFTAG_FILLORDER:\t\t*va_arg(ap, uint16 *) = td->td_fillorder;\t\treturn (1);\tcase TIFFTAG_ORIENTATION:\t\t*va_arg(ap, uint16 *) = td->td_orientation;\t\treturn (1);\tcase TIFFTAG_SAMPLESPERPIXEL:\t\t*va_arg(ap, uint16 *) = td->td_samplesperpixel;\t\treturn (1);\tcase TIFFTAG_ROWSPERSTRIP:\t\t*va_arg(ap, uint32 *) = td->td_rowsperstrip;\t\treturn (1);\tcase TIFFTAG_MINSAMPLEVALUE:\t\t*va_arg(ap, uint16 *) = td->td_minsamplevalue;\t\treturn (1);\tcase TIFFTAG_MAXSAMPLEVALUE:\t\t*va_arg(ap, uint16 *) = td->td_maxsamplevalue;\t\treturn (1);\tcase TIFFTAG_PLANARCONFIG:\t\t*va_arg(ap, uint16 *) = td->td_planarconfig;\t\treturn (1);\tcase TIFFTAG_RESOLUTIONUNIT:\t\t*va_arg(ap, uint16 *) = td->td_resolutionunit;\t\treturn (1);\tcase TIFFTAG_PREDICTOR:                {\t\t\tTIFFPredictorState* sp = (TIFFPredictorState*) tif->tif_data;\t\t\t*va_arg(ap, uint16*) = (uint16) sp->predictor;\t\t\treturn 1;                }\tcase TIFFTAG_DOTRANGE:\t\t*va_arg(ap, uint16 *) = 0;\t\t*va_arg(ap, uint16 *) = (1<<td->td_bitspersample)-1;\t\treturn (1);\tcase TIFFTAG_INKSET:\t\t*va_arg(ap, uint16 *) = INKSET_CMYK;\t\treturn 1;\tcase TIFFTAG_NUMBEROFINKS:\t\t*va_arg(ap, uint16 *) = 4;\t\treturn (1);\tcase TIFFTAG_EXTRASAMPLES:\t\t*va_arg(ap, uint16 *) = td->td_extrasamples;\t\t*va_arg(ap, uint16 **) = td->td_sampleinfo;\t\treturn (1);\tcase TIFFTAG_MATTEING:\t\t*va_arg(ap, uint16 *) =\t\t    (td->td_extrasamples == 1 &&\t\t     td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\t\treturn (1);\tcase TIFFTAG_TILEDEPTH:\t\t*va_arg(ap, uint32 *) = td->td_tiledepth;\t\treturn (1);\tcase TIFFTAG_DATATYPE:\t\t*va_arg(ap, uint16 *) = td->td_sampleformat-1;\t\treturn (1);\tcase TIFFTAG_SAMPLEFORMAT:\t\t*va_arg(ap, uint16 *) = td->td_sampleformat;                return(1);\tcase TIFFTAG_IMAGEDEPTH:\t\t*va_arg(ap, uint32 *) = td->td_imagedepth;\t\treturn (1);\tcase TIFFTAG_YCBCRCOEFFICIENTS:\t\t{\t\t\t\t\t\tstatic float ycbcrcoeffs[] = { 0.299f, 0.587f, 0.114f };\t\t\t*va_arg(ap, float **) = ycbcrcoeffs;\t\t\treturn 1;\t\t}\tcase TIFFTAG_YCBCRSUBSAMPLING:\t\t*va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[0];\t\t*va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[1];\t\treturn (1);\tcase TIFFTAG_YCBCRPOSITIONING:\t\t*va_arg(ap, uint16 *) = td->td_ycbcrpositioning;\t\treturn (1);\tcase TIFFTAG_WHITEPOINT:\t\t{\t\t\tstatic float whitepoint[2];\t\t\t\t\t\twhitepoint[0] =\tD50_X0 / (D50_X0 + D50_Y0 + D50_Z0);\t\t\twhitepoint[1] =\tD50_Y0 / (D50_X0 + D50_Y0 + D50_Z0);\t\t\t*va_arg(ap, float **) = whitepoint;\t\t\treturn 1;\t\t}\tcase TIFFTAG_TRANSFERFUNCTION:\t\tif (!td->td_transferfunction[0] &&\t\t    !TIFFDefaultTransferFunction(td)) {\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"No space for \\\"TransferFunction\\\" tag\");\t\t\treturn (0);\t\t}\t\t*va_arg(ap, uint16 **) = td->td_transferfunction[0];\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\t\t\t*va_arg(ap, uint16 **) = td->td_transferfunction[1];\t\t\t*va_arg(ap, uint16 **) = td->td_transferfunction[2];\t\t}\t\treturn (1);\tcase TIFFTAG_REFERENCEBLACKWHITE:\t\tif (!td->td_refblackwhite && !TIFFDefaultRefBlackWhite(td))\t\t\treturn (0);\t\t*va_arg(ap, float **) = td->td_refblackwhite;\t\treturn (1);\t}\treturn 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intprevImage(void){        if (fileindex > 0)                fileindex--;        else if (tif)                return fileindex;        if (tif)                TIFFClose(tif);        tif = TIFFOpen(filelist[fileindex], \"r\");        if (tif == NULL)                return -1;        return fileindex;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcpContigBufToSeparateBuf(uint8* out, uint8* in,    uint32 rows, uint32 cols, int outskew, int inskew, tsample_t spp,    int bytes_per_sample ){\twhile (rows-- > 0) {\t\tuint32 j = cols;\t\twhile (j-- > 0)\t\t{\t\t\tint n = bytes_per_sample;\t\t\twhile( n-- ) {\t\t\t\t*out++ = *in++;\t\t\t}\t\t\tin += (spp-1) * bytes_per_sample;\t\t}\t\tout += outskew;\t\tin += inskew;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFReassignTagToIgnore (enum TIFFIgnoreSense task, int TIFFtagID){    static int TIFFignoretags [FIELD_LAST];    static int tagcount = 0 ;    int\t\ti;\t\t\t\t\t    int\t\tj;\t\t\t\t\t    switch (task)    {      case TIS_STORE:        if ( tagcount < (FIELD_LAST - 1) )        {            for ( j = 0 ; j < tagcount ; ++j )            {\t\t\t\t\t                if ( TIFFignoretags [j] == TIFFtagID )                    return (TRUE) ;            }            TIFFignoretags [tagcount++] = TIFFtagID ;            return (TRUE) ;        }        break ;      case TIS_EXTRACT:        for ( i = 0 ; i < tagcount ; ++i )        {            if ( TIFFignoretags [i] == TIFFtagID )                return (TRUE) ;        }        break;      case TIS_EMPTY:        tagcount = 0 ;\t\t\t        return (TRUE) ;      default:        break;    }    return (FALSE);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidvError(FILE* fd, const char* fmt, va_list ap){\tfprintf(fd, \"%s: \", curfile);\tvfprintf(fd, fmt, ap);\tfprintf(fd, \".\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFInitCCITTFax3(TIFF* tif, int scheme){\t(void) scheme;\tif (InitCCITTFax3(tif)) {\t\t_TIFFMergeFieldInfo(tif, fax3FieldInfo, N(fax3FieldInfo));\t\t\t\treturn TIFFSetField(tif, TIFFTAG_FAXMODE, FAXMODE_CLASSF);\t} else\t\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPackBitsEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s){\tunsigned char* bp = (unsigned char*) buf;\tuint8* op;\tuint8* ep;\tuint8* lastliteral;\tlong n, slop;\tint b;\tenum { BASE, LITERAL, RUN, LITERAL_RUN } state;\t(void) s;\top = tif->tif_rawcp;\tep = tif->tif_rawdata + tif->tif_rawdatasize;\tstate = BASE;\tlastliteral = 0;\twhile (cc > 0) {\t\t\t\tb = *bp++, cc--, n = 1;\t\tfor (; cc > 0 && b == *bp; cc--, bp++)\t\t\tn++;\tagain:\t\tif (op + 2 >= ep) {\t\t\t\t\t\t\t\tif (state == LITERAL || state == LITERAL_RUN) {\t\t\t\tslop = (long)(op - lastliteral);\t\t\t\ttif->tif_rawcc += (tmsize_t)(lastliteral - tif->tif_rawcp);\t\t\t\tif (!TIFFFlushData1(tif))\t\t\t\t\treturn (-1);\t\t\t\top = tif->tif_rawcp;\t\t\t\twhile (slop-- > 0)\t\t\t\t\t*op++ = *lastliteral++;\t\t\t\tlastliteral = tif->tif_rawcp;\t\t\t} else {\t\t\t\ttif->tif_rawcc += (tmsize_t)(op - tif->tif_rawcp);\t\t\t\tif (!TIFFFlushData1(tif))\t\t\t\t\treturn (-1);\t\t\t\top = tif->tif_rawcp;\t\t\t}\t\t}\t\tswitch (state) {\t\tcase BASE:\t\t\t\t\tif (n > 1) {\t\t\t\tstate = RUN;\t\t\t\tif (n > 128) {\t\t\t\t\t*op++ = (uint8) -127;\t\t\t\t\t*op++ = (uint8) b;\t\t\t\t\tn -= 128;\t\t\t\t\tgoto again;\t\t\t\t}\t\t\t\t*op++ = (uint8)(-(n-1));\t\t\t\t*op++ = (uint8) b;\t\t\t} else {\t\t\t\tlastliteral = op;\t\t\t\t*op++ = 0;\t\t\t\t*op++ = (uint8) b;\t\t\t\tstate = LITERAL;\t\t\t}\t\t\tbreak;\t\tcase LITERAL:\t\t\t\t\tif (n > 1) {\t\t\t\tstate = LITERAL_RUN;\t\t\t\tif (n > 128) {\t\t\t\t\t*op++ = (uint8) -127;\t\t\t\t\t*op++ = (uint8) b;\t\t\t\t\tn -= 128;\t\t\t\t\tgoto again;\t\t\t\t}\t\t\t\t*op++ = (uint8)(-(n-1));\t\t\t\t\t*op++ = (uint8) b;\t\t\t} else {\t\t\t\t\t\t\tif (++(*lastliteral) == 127)\t\t\t\t\tstate = BASE;\t\t\t\t*op++ = (uint8) b;\t\t\t}\t\t\tbreak;\t\tcase RUN:\t\t\t\t\tif (n > 1) {\t\t\t\tif (n > 128) {\t\t\t\t\t*op++ = (uint8) -127;\t\t\t\t\t*op++ = (uint8) b;\t\t\t\t\tn -= 128;\t\t\t\t\tgoto again;\t\t\t\t}\t\t\t\t*op++ = (uint8)(-(n-1));\t\t\t\t*op++ = (uint8) b;\t\t\t} else {\t\t\t\tlastliteral = op;\t\t\t\t*op++ = 0;\t\t\t\t*op++ = (uint8) b;\t\t\t\tstate = LITERAL;\t\t\t}\t\t\tbreak;\t\tcase LITERAL_RUN:\t\t\t\t\t\t\tif (n == 1 && op[-2] == (uint8) -1 &&\t\t\t    *lastliteral < 126) {\t\t\t\tstate = (((*lastliteral) += 2) == 127 ?\t\t\t\t    BASE : LITERAL);\t\t\t\top[-2] = op[-1];\t\t\t\t} else\t\t\t\tstate = RUN;\t\t\tgoto again;\t\t}\t}\ttif->tif_rawcc += (tmsize_t)(op - tif->tif_rawcp);\ttif->tif_rawcp = op;\treturn (1);}",
        "label": 1,
        "cve": "cve-2016-5319"
    },
    {
        "code": "static intTIFFLinkDirectory(TIFF* tif){\tstatic const char module[] = \"TIFFLinkDirectory\";\tuint32 nextdir;\tuint32 diroff;\ttif->tif_diroff = (TIFFSeekFile(tif, (toff_t) 0, SEEK_END)+1) &~ 1;\tdiroff = (uint32) tif->tif_diroff;\tif (tif->tif_flags & TIFF_SWAB)\t\tTIFFSwabLong(&diroff);\tif (tif->tif_flags & TIFF_INSUBIFD) {\t\t(void) TIFFSeekFile(tif, tif->tif_subifdoff, SEEK_SET);\t\tif (!WriteOK(tif, &diroff, sizeof (diroff))) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"%s: Error writing SubIFD directory link\",\t\t\t    tif->tif_name);\t\t\treturn (0);\t\t}\t\t\t\tif (--tif->tif_nsubifd)\t\t\ttif->tif_subifdoff += sizeof (diroff);\t\telse\t\t\ttif->tif_flags &= ~TIFF_INSUBIFD;\t\treturn (1);\t}\tif (tif->tif_header.tiff_diroff == 0) {\t\t\t\ttif->tif_header.tiff_diroff = (uint32) tif->tif_diroff;#define\tHDROFF(f)\t((toff_t) &(((TIFFHeader*) 0)->f))\t\t(void) TIFFSeekFile(tif, HDROFF(tiff_diroff), SEEK_SET);\t\tif (!WriteOK(tif, &diroff, sizeof (diroff))) {\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error writing TIFF header\");\t\t\treturn (0);\t\t}\t\treturn (1);\t}\t\tnextdir = tif->tif_header.tiff_diroff;\tdo {\t\tuint16 dircount;\t\tif (!SeekOK(tif, nextdir) ||\t\t    !ReadOK(tif, &dircount, sizeof (dircount))) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Error fetching directory count\");\t\t\treturn (0);\t\t}\t\tif (tif->tif_flags & TIFF_SWAB)\t\t\tTIFFSwabShort(&dircount);\t\t(void) TIFFSeekFile(tif,\t\t    dircount * sizeof (TIFFDirEntry), SEEK_CUR);\t\tif (!ReadOK(tif, &nextdir, sizeof (nextdir))) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Error fetching directory link\");\t\t\treturn (0);\t\t}\t\tif (tif->tif_flags & TIFF_SWAB)\t\t\tTIFFSwabLong(&nextdir);\t} while (nextdir != 0);\t(void) TIFFSeekFile(tif, -(toff_t) sizeof (nextdir), SEEK_CUR);\tif (!WriteOK(tif, &diroff, sizeof (diroff))) {\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Error writing directory link\");\t\treturn (0);\t}\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tsize_t t2p_sample_lab_signed_to_unsigned(tdata_t buffer, uint32 samplecount){\tuint32 i=0;\tfor(i=0;i<samplecount;i++){\t\tif( (((unsigned char*)buffer)[(i*3)+1] & 0x80) !=0){\t\t\t((unsigned char*)buffer)[(i*3)+1] =\t\t\t\t(unsigned char)(0x80 + ((char*)buffer)[(i*3)+1]);\t\t} else {\t\t\t((unsigned char*)buffer)[(i*3)+1] |= 0x80;\t\t}\t\tif( (((unsigned char*)buffer)[(i*3)+2] & 0x80) !=0){\t\t\t((unsigned char*)buffer)[(i*3)+2] =\t\t\t\t(unsigned char)(0x80 + ((char*)buffer)[(i*3)+2]);\t\t} else {\t\t\t((unsigned char*)buffer)[(i*3)+2] |= 0x80;\t\t}\t}\treturn(samplecount*3);}",
        "label": 1,
        "cve": "CVE-2014-8129"
    },
    {
        "code": "static voidFax3Close(TIFF* tif){\tif ((Fax3State(tif)->mode & FAXMODE_NORTC) == 0) {\t\tFax3CodecState* sp = EncoderState(tif);\t\tunsigned int code = EOL;\t\tunsigned int length = 12;\t\tint i;\t\tif (is2DEncoding(sp))\t\t\tcode = (code<<1) | (sp->tag == G3_1D), length++;\t\tfor (i = 0; i < 6; i++)\t\t\tFax3PutBits(tif, code, length);\t\tFax3FlushBits(tif, sp);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intextractContigSamplesShifted24bits (uint8 *in, uint8 *out, uint32 cols, \t                           tsample_t sample, uint16 spp, uint16 bps,                                    tsample_t count, uint32 start, uint32 end,\t                           int shift)  {  int    ready_bits = 0, sindex = 0;  uint32 col, src_byte, src_bit, bit_offset;  uint32 maskbits = 0, matchbits = 0;  uint32 buff1 = 0, buff2 = 0;  uint8  bytebuff1 = 0, bytebuff2 = 0;  uint8 *src = in;  uint8 *dst = out;  if ((in == NULL) || (out == NULL))    {    TIFFError(\"extractContigSamplesShifted24bits\",\"Invalid input or output buffer\");    return (1);    }  if ((start > end) || (start > cols))    {    TIFFError (\"extractContigSamplesShifted24bits\",                \"Invalid start column value %d ignored\", start);    start = 0;    }  if ((end == 0) || (end > cols))    {    TIFFError (\"extractContigSamplesShifted24bits\",                \"Invalid end column value %d ignored\", end);    end = cols;    }  ready_bits = shift;  maskbits =  (uint32)-1 >> ( 32 - bps);  for (col = start; col < end; col++)    {        bit_offset = col * bps * spp;    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)      {      if (sindex == 0)        {        src_byte = bit_offset / 8;        src_bit  = bit_offset % 8;        }      else        {        src_byte = (bit_offset + (sindex * bps)) / 8;        src_bit  = (bit_offset + (sindex * bps)) % 8;        }      src = in + src_byte;      matchbits = maskbits << (32 - src_bit - bps);       if (little_endian)\tbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];      else\tbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];      if ((col == start) && (sindex == sample))        buff2 = buff1 & ((uint32)-1) << (16 - shift);      buff1 = (buff1 & matchbits) << (src_bit);      if (ready_bits < 16)          {        bytebuff1 = bytebuff2 = 0;        buff2 = (buff2 | (buff1 >> ready_bits));        }      else         {        bytebuff1 = (buff2 >> 24);        *dst++ = bytebuff1;        bytebuff2 = (buff2 >> 16);        *dst++ = bytebuff2;        ready_bits -= 16;                buff2 = ((buff2 << 16) | (buff1 >> ready_bits));        }      ready_bits += bps;      }    }    while (ready_bits > 0)    {    bytebuff1 = (buff2 >> 24);    *dst++ = bytebuff1;    buff2 = (buff2 << 8);    bytebuff2 = bytebuff1;    ready_bits -= 8;    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcodeLoop(TIFF* tif, const char* module){\tTIFFErrorExt(tif->tif_clientdata, module,\t    \"Bogus encoding, loop in the code table; scanline %d\",\t    tif->tif_row);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value){\tint typesize;\tuint32 datasize;\tvoid* data;\ttypesize=TIFFDataWidth(direntry->tdir_type);\tif ((direntry->tdir_count==0)||(typesize==0))\t{\t\t*value=0;\t\treturn(TIFFReadDirEntryErrOk);\t}        (void) desttypesize;        \tif ((uint64)(2147483647/typesize)<direntry->tdir_count)\t\treturn(TIFFReadDirEntryErrSizesan);\tif ((uint64)(2147483647/desttypesize)<direntry->tdir_count)\t\treturn(TIFFReadDirEntryErrSizesan);\t*count=(uint32)direntry->tdir_count;\tdatasize=(*count)*typesize;\tassert((tmsize_t)datasize>0);\tdata=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\tif (data==0)\t\treturn(TIFFReadDirEntryErrAlloc);\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t{\t\tif (datasize<=4)\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\t\telse\t\t{\t\t\tenum TIFFReadDirEntryErr err;\t\t\tuint32 offset = direntry->tdir_offset.toff_long;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabLong(&offset);\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\t\t\tif (err!=TIFFReadDirEntryErrOk)\t\t\t{\t\t\t\t_TIFFfree(data);\t\t\t\treturn(err);\t\t\t}\t\t}\t}\telse\t{\t\tif (datasize<=8)\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\t\telse\t\t{\t\t\tenum TIFFReadDirEntryErr err;\t\t\tuint64 offset = direntry->tdir_offset.toff_long8;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabLong8(&offset);\t\t\terr=TIFFReadDirEntryData(tif,offset,(tmsize_t)datasize,data);\t\t\tif (err!=TIFFReadDirEntryErrOk)\t\t\t{\t\t\t\t_TIFFfree(data);\t\t\t\treturn(err);\t\t\t}\t\t}\t}\t*value=data;\treturn(TIFFReadDirEntryErrOk);}",
        "label": 1,
        "cve": "cve-2017-12944"
    },
    {
        "code": "static inttagCompare(const void* a, const void* b){\tconst TIFFField* ta = *(const TIFFField**) a;\tconst TIFFField* tb = *(const TIFFField**) b;\t\tif (ta->field_tag != tb->field_tag)\t\treturn (int)ta->field_tag - (int)tb->field_tag;\telse\t\treturn (ta->field_type == TIFF_ANY) ?\t\t\t0 : ((int)tb->field_type - (int)ta->field_type);}",
        "label": 1,
        "cve": "cve-2016-3634"
    },
    {
        "code": "HDIB CreateDIB(DWORD dwWidth, DWORD dwHeight, WORD wBitCount){   BITMAPINFOHEADER bi;            LPBITMAPINFOHEADER lpbi;        DWORD dwLen;                    HDIB hDIB;   DWORD dwBytesPerLine;              if (wBitCount <= 1)      wBitCount = 1;   else if (wBitCount <= 4)      wBitCount = 4;   else if (wBitCount <= 8)      wBitCount = 8;   else if (wBitCount <= 24)      wBitCount = 24;   else      wBitCount = 4;        bi.biSize = sizeof(BITMAPINFOHEADER);   bi.biWidth = dwWidth;            bi.biHeight = dwHeight;          bi.biPlanes = 1;                 bi.biBitCount = wBitCount;       bi.biCompression = BI_RGB;       bi.biSizeImage = (dwWidth*dwHeight*wBitCount)/8; mean \"default\"   bi.biXPelsPerMeter = 2834;    bi.biYPelsPerMeter = 2834;    bi.biClrUsed = 0;   bi.biClrImportant = 0;            dwBytesPerLine =   (((wBitCount * dwWidth) + 31) / 32 * 4);   dwLen = bi.biSize + PaletteSize((LPSTR)&bi) + (dwBytesPerLine * dwHeight);      hDIB = GlobalAlloc(GHND, dwLen);      if (!hDIB)   {      return NULL;   }      lpbi = (VOID FAR *)GlobalLock(hDIB);         *lpbi = bi;         GlobalUnlock(hDIB);      return hDIB;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchDoubleArray(TIFF* tif, TIFFDirEntry* dir, double* v){\tif (TIFFFetchData(tif, dir, (char*) v)) {\t\tTIFFCvtIEEEDoubleToNative(tif, dir->tdir_count, v);\t\treturn (1);\t} else\t\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tdata_t_TIFFmalloc(tsize_t s){\treturn (malloc((size_t) s));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int formatIPTC(FILE *ifile, FILE *ofile){  unsigned int    foundiptc,    tagsfound;  char    *readable,    *str;  long    tagindx,    taglen;  int    i,    tagcount = sizeof(tags) / sizeof(tag_spec);  int    c,    dataset,    recnum;  foundiptc = 0;   tagsfound = 0;   c = getc(ifile);  while (c != EOF)    {      if (c == 0x1c)        foundiptc = 1;      else        {          if (foundiptc)            {              return -1;            }          else            {              c = getc(ifile);              continue;            }        }            dataset = getc(ifile);      if ((char) dataset == EOF)        return -1;      recnum = getc(ifile);      if ((char) recnum == EOF)        return -1;            for (i=0; i< tagcount; i++)        {          if (tags[i].id == recnum)            break;        }      if (i < tagcount)        readable = tags[i].name;      else        readable = \"\";            c = getc(ifile);      if (c == EOF)        return 0;      if (c & (unsigned char) 0x80)        {          unsigned char            buffer[4];          for (i=0; i<4; i++)            {              c = getc(ifile);              if (c == EOF)                return -1;              buffer[i] = c;            }          taglen = (((long) buffer[ 0 ]) << 24) |            (((long) buffer[ 1 ]) << 16) |             (((long) buffer[ 2 ]) <<  8) |            (((long) buffer[ 3 ]));        }      else        {          int            x = c;          taglen = x << 8;          x = getc(ifile);          if (x == EOF)            return -1;          taglen |= (long) x;        }            if ((taglen <= 0) || (taglen > 1048576))        {          printf(\"Inappropriate IPTC tag length %ld\\n\",taglen);          return -1;        }            str = (char *) malloc((unsigned int) (taglen+1));      if (str == (char *) NULL)        {          printf(\"Memory allocation failed\");          return 0;        }      for (tagindx=0; tagindx<taglen; tagindx++)        {          c = getc(ifile);          if (c == EOF)            {              free(str);              return -1;            }          str[tagindx] = c;        }      str[ taglen ] = 0;            if (strlen(readable) > 0)        fprintf(ofile, \"%d#%d#%s=\",(unsigned int)dataset, (unsigned int) recnum, readable);      else        fprintf(ofile, \"%d#%d=\",(unsigned int)dataset, (unsigned int) recnum);      formatString( ofile, str, taglen );      free(str);      tagsfound++;      c = getc(ifile);    }  return tagsfound;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "DECLAREContigPutFunc(putagreytile){    int samplesperpixel = img->samplesperpixel;    uint32** BWmap = img->BWmap;    (void) y;    while (h-- > 0) {\tfor (x = w; x-- > 0;)        {            *cp++ = BWmap[*pp][0] & (*(pp+1) << 24 | ~A1);            pp += samplesperpixel;        }\tcp += toskew;\tpp += fromskew;    }}",
        "label": 1,
        "cve": "cve-2017-7592"
    },
    {
        "code": "static void initDumpOptions(struct dump_opts *dump)  {  dump->debug  = 0;  dump->format = DUMP_NONE;  dump->level  = 1;  sprintf (dump->mode, \"w\");  memset (dump->infilename, '\\0', PATH_MAX + 1);  memset (dump->outfilename, '\\0',PATH_MAX + 1);  dump->infile = NULL;  dump->outfile = NULL;  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void _TIFFsetByteArray(void** vpp, void* vp, uint32 n)    { setByteArray(vpp, vp, n, 1); }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidFax3Unexpected(const char* module, TIFF* tif, uint32 line, uint32 a0){\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Bad code word at line %lu of %s %lu (x %lu)\",\t\ttif->tif_name, (unsigned long) line, isTiled(tif) ? \"tile\" : \"strip\",\t   (unsigned long) (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),\t   (unsigned long) a0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFFCodec*TIFFRegisterCODEC(uint16 scheme, const char* name, TIFFInitMethod init){\tcodec_t* cd = (codec_t*)\t    _TIFFmalloc(sizeof (codec_t) + sizeof (TIFFCodec) + strlen(name)+1);\tif (cd != NULL) {\t\tcd->info = (TIFFCodec*) ((tidata_t) cd + sizeof (codec_t));\t\tcd->info->name = (char*)\t\t    ((tidata_t) cd->info + sizeof (TIFFCodec));\t\tstrcpy(cd->info->name, name);\t\tcd->info->scheme = scheme;\t\tcd->info->init = init;\t\tcd->next = registeredCODECS;\t\tregisteredCODECS = cd;\t} else {\t\tTIFFErrorExt(0, \"TIFFRegisterCODEC\",\t\t    \"No space to register compression scheme %s\", name);\t\treturn NULL;\t}\treturn (cd->info);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap){\tTIFFDirectory* td = &tif->tif_dir;\tint ret_val = 1;\tuint32 standard_tag = tag;\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\tif( fip == NULL ) \t    return 0;\t\t\tif (fip->field_bit == FIELD_CUSTOM) {\t\tstandard_tag = 0;\t}\tswitch (standard_tag) {\t\tcase TIFFTAG_SUBFILETYPE:\t\t\t*va_arg(ap, uint32*) = td->td_subfiletype;\t\t\tbreak;\t\tcase TIFFTAG_IMAGEWIDTH:\t\t\t*va_arg(ap, uint32*) = td->td_imagewidth;\t\t\tbreak;\t\tcase TIFFTAG_IMAGELENGTH:\t\t\t*va_arg(ap, uint32*) = td->td_imagelength;\t\t\tbreak;\t\tcase TIFFTAG_BITSPERSAMPLE:\t\t\t*va_arg(ap, uint16*) = td->td_bitspersample;\t\t\tbreak;\t\tcase TIFFTAG_COMPRESSION:\t\t\t*va_arg(ap, uint16*) = td->td_compression;\t\t\tbreak;\t\tcase TIFFTAG_PHOTOMETRIC:\t\t\t*va_arg(ap, uint16*) = td->td_photometric;\t\t\tbreak;\t\tcase TIFFTAG_THRESHHOLDING:\t\t\t*va_arg(ap, uint16*) = td->td_threshholding;\t\t\tbreak;\t\tcase TIFFTAG_FILLORDER:\t\t\t*va_arg(ap, uint16*) = td->td_fillorder;\t\t\tbreak;\t\tcase TIFFTAG_ORIENTATION:\t\t\t*va_arg(ap, uint16*) = td->td_orientation;\t\t\tbreak;\t\tcase TIFFTAG_SAMPLESPERPIXEL:\t\t\t*va_arg(ap, uint16*) = td->td_samplesperpixel;\t\t\tbreak;\t\tcase TIFFTAG_ROWSPERSTRIP:\t\t\t*va_arg(ap, uint32*) = td->td_rowsperstrip;\t\t\tbreak;\t\tcase TIFFTAG_MINSAMPLEVALUE:\t\t\t*va_arg(ap, uint16*) = td->td_minsamplevalue;\t\t\tbreak;\t\tcase TIFFTAG_MAXSAMPLEVALUE:\t\t\t*va_arg(ap, uint16*) = td->td_maxsamplevalue;\t\t\tbreak;\t\tcase TIFFTAG_SMINSAMPLEVALUE:\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\t\t\t\t*va_arg(ap, double**) = td->td_sminsamplevalue;\t\t\telse\t\t\t{\t\t\t\t\t\t\t\tuint16 i;\t\t\t\tdouble v = td->td_sminsamplevalue[0];\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\t\t\t\t\tif( td->td_sminsamplevalue[i] < v )\t\t\t\t\t\tv = td->td_sminsamplevalue[i];\t\t\t\t*va_arg(ap, double*) = v;\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\t\t\t\t*va_arg(ap, double**) = td->td_smaxsamplevalue;\t\t\telse\t\t\t{\t\t\t\t\t\t\t\tuint16 i;\t\t\t\tdouble v = td->td_smaxsamplevalue[0];\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\t\t\t\t\tif( td->td_smaxsamplevalue[i] > v )\t\t\t\t\t\tv = td->td_smaxsamplevalue[i];\t\t\t\t*va_arg(ap, double*) = v;\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_XRESOLUTION:\t\t\t*va_arg(ap, float*) = td->td_xresolution;\t\t\tbreak;\t\tcase TIFFTAG_YRESOLUTION:\t\t\t*va_arg(ap, float*) = td->td_yresolution;\t\t\tbreak;\t\tcase TIFFTAG_PLANARCONFIG:\t\t\t*va_arg(ap, uint16*) = td->td_planarconfig;\t\t\tbreak;\t\tcase TIFFTAG_XPOSITION:\t\t\t*va_arg(ap, float*) = td->td_xposition;\t\t\tbreak;\t\tcase TIFFTAG_YPOSITION:\t\t\t*va_arg(ap, float*) = td->td_yposition;\t\t\tbreak;\t\tcase TIFFTAG_RESOLUTIONUNIT:\t\t\t*va_arg(ap, uint16*) = td->td_resolutionunit;\t\t\tbreak;\t\tcase TIFFTAG_PAGENUMBER:\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[0];\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[1];\t\t\tbreak;\t\tcase TIFFTAG_HALFTONEHINTS:\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[0];\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[1];\t\t\tbreak;\t\tcase TIFFTAG_COLORMAP:\t\t\t*va_arg(ap, uint16**) = td->td_colormap[0];\t\t\t*va_arg(ap, uint16**) = td->td_colormap[1];\t\t\t*va_arg(ap, uint16**) = td->td_colormap[2];\t\t\tbreak;\t\tcase TIFFTAG_STRIPOFFSETS:\t\tcase TIFFTAG_TILEOFFSETS:\t\t\t_TIFFFillStriles( tif );\t\t\t*va_arg(ap, uint64**) = td->td_stripoffset;\t\t\tbreak;\t\tcase TIFFTAG_STRIPBYTECOUNTS:\t\tcase TIFFTAG_TILEBYTECOUNTS:\t\t\t_TIFFFillStriles( tif );\t\t\t*va_arg(ap, uint64**) = td->td_stripbytecount;\t\t\tbreak;\t\tcase TIFFTAG_MATTEING:\t\t\t*va_arg(ap, uint16*) =\t\t\t    (td->td_extrasamples == 1 &&\t\t\t    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\t\t\tbreak;\t\tcase TIFFTAG_EXTRASAMPLES:\t\t\t*va_arg(ap, uint16*) = td->td_extrasamples;\t\t\t*va_arg(ap, uint16**) = td->td_sampleinfo;\t\t\tbreak;\t\tcase TIFFTAG_TILEWIDTH:\t\t\t*va_arg(ap, uint32*) = td->td_tilewidth;\t\t\tbreak;\t\tcase TIFFTAG_TILELENGTH:\t\t\t*va_arg(ap, uint32*) = td->td_tilelength;\t\t\tbreak;\t\tcase TIFFTAG_TILEDEPTH:\t\t\t*va_arg(ap, uint32*) = td->td_tiledepth;\t\t\tbreak;\t\tcase TIFFTAG_DATATYPE:\t\t\tswitch (td->td_sampleformat) {\t\t\t\tcase SAMPLEFORMAT_UINT:\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_UINT;\t\t\t\t\tbreak;\t\t\t\tcase SAMPLEFORMAT_INT:\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_INT;\t\t\t\t\tbreak;\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_IEEEFP;\t\t\t\t\tbreak;\t\t\t\tcase SAMPLEFORMAT_VOID:\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_VOID;\t\t\t\t\tbreak;\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_SAMPLEFORMAT:\t\t\t*va_arg(ap, uint16*) = td->td_sampleformat;\t\t\tbreak;\t\tcase TIFFTAG_IMAGEDEPTH:\t\t\t*va_arg(ap, uint32*) = td->td_imagedepth;\t\t\tbreak;\t\tcase TIFFTAG_SUBIFD:\t\t\t*va_arg(ap, uint16*) = td->td_nsubifd;\t\t\t*va_arg(ap, uint64**) = td->td_subifd;\t\t\tbreak;\t\tcase TIFFTAG_YCBCRPOSITIONING:\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrpositioning;\t\t\tbreak;\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];\t\t\tbreak;\t\tcase TIFFTAG_TRANSFERFUNCTION:\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[0];\t\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[1];\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[2];\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\t\t\t*va_arg(ap, float**) = td->td_refblackwhite;\t\t\tbreak;\t\tcase TIFFTAG_INKNAMES:\t\t\t*va_arg(ap, char**) = td->td_inknames;\t\t\tbreak;\t\tdefault:\t\t\t{\t\t\t\tint i;\t\t\t\t\t\t\t\tif( fip->field_bit != FIELD_CUSTOM )\t\t\t\t{\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFVGetField\",\t\t\t\t\t    \"%s: Invalid %stag \\\"%s\\\" \"\t\t\t\t\t    \"(not supported by codec)\",\t\t\t\t\t    tif->tif_name,\t\t\t\t\t    isPseudoTag(tag) ? \"pseudo-\" : \"\",\t\t\t\t\t    fip->field_name);\t\t\t\t\tret_val = 0;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\t\t\t\t\tret_val = 0;\t\t\t\tfor (i = 0; i < td->td_customValueCount; i++) {\t\t\t\t\tTIFFTagValue *tv = td->td_customValues + i;\t\t\t\t\tif (tv->info->field_tag != tag)\t\t\t\t\t\tcontinue;\t\t\t\t\tif (fip->field_passcount) {\t\t\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2)\t\t\t\t\t\t\t*va_arg(ap, uint32*) = (uint32)tv->count;\t\t\t\t\t\telse  \t\t\t\t\t\t\t*va_arg(ap, uint16*) = (uint16)tv->count;\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\t\t\t\t\t\tret_val = 1;\t\t\t\t\t} else if (fip->field_tag == TIFFTAG_DOTRANGE\t\t\t\t\t\t   && strcmp(fip->field_name,\"DotRange\") == 0) {\t\t\t\t\t\t\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];\t\t\t\t\t\tret_val = 1;\t\t\t\t\t} else {\t\t\t\t\t\tif (fip->field_type == TIFF_ASCII\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2\t\t\t\t\t\t    || fip->field_readcount == TIFF_SPP\t\t\t\t\t\t    || tv->count > 1) {\t\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t} else {\t\t\t\t\t\t\tchar *val = (char *)tv->value;\t\t\t\t\t\t\tassert( tv->count == 1 );\t\t\t\t\t\t\tswitch (fip->field_type) {\t\t\t\t\t\t\tcase TIFF_BYTE:\t\t\t\t\t\t\tcase TIFF_UNDEFINED:\t\t\t\t\t\t\t\t*va_arg(ap, uint8*) =\t\t\t\t\t\t\t\t\t*(uint8 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SBYTE:\t\t\t\t\t\t\t\t*va_arg(ap, int8*) =\t\t\t\t\t\t\t\t\t*(int8 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SHORT:\t\t\t\t\t\t\t\t*va_arg(ap, uint16*) =\t\t\t\t\t\t\t\t\t*(uint16 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SSHORT:\t\t\t\t\t\t\t\t*va_arg(ap, int16*) =\t\t\t\t\t\t\t\t\t*(int16 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_LONG:\t\t\t\t\t\t\tcase TIFF_IFD:\t\t\t\t\t\t\t\t*va_arg(ap, uint32*) =\t\t\t\t\t\t\t\t\t*(uint32 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SLONG:\t\t\t\t\t\t\t\t*va_arg(ap, int32*) =\t\t\t\t\t\t\t\t\t*(int32 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_LONG8:\t\t\t\t\t\t\tcase TIFF_IFD8:\t\t\t\t\t\t\t\t*va_arg(ap, uint64*) =\t\t\t\t\t\t\t\t\t*(uint64 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SLONG8:\t\t\t\t\t\t\t\t*va_arg(ap, int64*) =\t\t\t\t\t\t\t\t\t*(int64 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_RATIONAL:\t\t\t\t\t\t\tcase TIFF_SRATIONAL:\t\t\t\t\t\t\tcase TIFF_FLOAT:\t\t\t\t\t\t\t\t*va_arg(ap, float*) =\t\t\t\t\t\t\t\t\t*(float *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_DOUBLE:\t\t\t\t\t\t\t\t*va_arg(ap, double*) =\t\t\t\t\t\t\t\t\t*(double *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tdefault:\t\t\t\t\t\t\t\tret_val = 0;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t}\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t}\treturn(ret_val);}",
        "label": 1,
        "cve": "cve-2015-7554"
    },
    {
        "code": "intreadextension(void){    int count;    char buf[255];    int status = 1;    (void) getc(infile);    while ((count = getc(infile)) && count <= 255)        if (fread(buf, 1, count, infile) != (size_t) count) {            fprintf(stderr, \"short read from file %s (%s)\\n\",                    filename, strerror(errno));            status = 0;            break;        }    return status;}",
        "label": 1,
        "cve": "cve-2016-3186"
    },
    {
        "code": "static intcomputeInputPixelOffsets(struct crop_mask *crop, struct image_data *image,                         struct offset *off)  {  double scale;  float xres, yres;    uint32 tmargin, bmargin, lmargin, rmargin;  uint32 startx, endx;     uint32 starty, endy;     uint32 width, length, crop_width, crop_length;   uint32 i, max_width, max_length, zwidth, zlength, buffsize;  uint32 x1, x2, y1, y2;  if (image->res_unit != RESUNIT_INCH && image->res_unit != RESUNIT_CENTIMETER)    {    xres = 1.0;    yres = 1.0;    }  else    {    if (((image->xres == 0) || (image->yres == 0)) &&          (crop->res_unit != RESUNIT_NONE) &&\t((crop->crop_mode & CROP_REGIONS) || (crop->crop_mode & CROP_MARGINS) || \t (crop->crop_mode & CROP_LENGTH)  || (crop->crop_mode & CROP_WIDTH)))      {      TIFFError(\"computeInputPixelOffsets\", \"Cannot compute margins or fixed size sections without image resolution\");      TIFFError(\"computeInputPixelOffsets\", \"Specify units in pixels and try again\");      return (-1);      }    xres = image->xres;    yres = image->yres;    }    scale = 1.0;  switch (crop->res_unit) {    case RESUNIT_CENTIMETER:         if (image->res_unit == RESUNIT_INCH)\t   scale = 1.0/2.54;\t break;    case RESUNIT_INCH:\t if (image->res_unit == RESUNIT_CENTIMETER)\t     scale = 2.54;\t break;    case RESUNIT_NONE:     default:    break;    }  if (crop->crop_mode & CROP_REGIONS)    {    max_width = max_length = 0;    for (i = 0; i < crop->regions; i++)      {      if ((crop->res_unit == RESUNIT_INCH) || (crop->res_unit == RESUNIT_CENTIMETER))        {\tx1 = (uint32) (crop->corners[i].X1 * scale * xres);\tx2 = (uint32) (crop->corners[i].X2 * scale * xres);\ty1 = (uint32) (crop->corners[i].Y1 * scale * yres);\ty2 = (uint32) (crop->corners[i].Y2 * scale * yres);        }      else        {\tx1 = (uint32) (crop->corners[i].X1);\tx2 = (uint32) (crop->corners[i].X2);\ty1 = (uint32) (crop->corners[i].Y1);\ty2 = (uint32) (crop->corners[i].Y2);       \t}      if (x1 < 1)        crop->regionlist[i].x1 = 0;      else        crop->regionlist[i].x1 = (uint32) (x1 - 1);      if (x2 > image->width - 1)        crop->regionlist[i].x2 = image->width - 1;      else        crop->regionlist[i].x2 = (uint32) (x2 - 1);      zwidth  = crop->regionlist[i].x2 - crop->regionlist[i].x1 + 1;       if (y1 < 1)        crop->regionlist[i].y1 = 0;      else        crop->regionlist[i].y1 = (uint32) (y1 - 1);      if (y2 > image->length - 1)        crop->regionlist[i].y2 = image->length - 1;      else        crop->regionlist[i].y2 = (uint32) (y2 - 1);      zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;       if (zwidth > max_width)        max_width = zwidth;      if (zlength > max_length)        max_length = zlength;      buffsize = (uint32)          (((zwidth * image->bps * image->spp + 7 ) / 8) * (zlength + 1));      crop->regionlist[i].buffsize = buffsize;      crop->bufftotal += buffsize;      if (crop->img_mode == COMPOSITE_IMAGES)        {        switch (crop->edge_ref)          {          case EDGE_LEFT:          case EDGE_RIGHT:               crop->combined_length = zlength;               crop->combined_width += zwidth;               break;          case EDGE_BOTTOM:          case EDGE_TOP:            default:               crop->combined_width = zwidth;               crop->combined_length += zlength;\t       break;          }\t}      }    return (0);    }    if (crop->crop_mode & CROP_MARGINS)    {    if (crop->res_unit != RESUNIT_INCH && crop->res_unit != RESUNIT_CENTIMETER)      {       tmargin = (uint32)(crop->margins[0]);      lmargin = (uint32)(crop->margins[1]);      bmargin = (uint32)(crop->margins[2]);      rmargin = (uint32)(crop->margins[3]);      }    else      {       tmargin = (uint32)(crop->margins[0] * scale * yres);      lmargin = (uint32)(crop->margins[1] * scale * xres);      bmargin = (uint32)(crop->margins[2] * scale * yres);      rmargin = (uint32)(crop->margins[3] * scale * xres);      }    if ((lmargin + rmargin) > image->width)      {      TIFFError(\"computeInputPixelOffsets\", \"Combined left and right margins exceed image width\");      lmargin = (uint32) 0;      rmargin = (uint32) 0;      return (-1);      }    if ((tmargin + bmargin) > image->length)      {      TIFFError(\"computeInputPixelOffsets\", \"Combined top and bottom margins exceed image length\");       tmargin = (uint32) 0;       bmargin = (uint32) 0;      return (-1);      }    }  else    {     tmargin = (uint32) 0;    lmargin = (uint32) 0;    bmargin = (uint32) 0;    rmargin = (uint32) 0;    }    if (crop->res_unit != RESUNIT_INCH && crop->res_unit != RESUNIT_CENTIMETER)    {    if (crop->crop_mode & CROP_WIDTH)      width = (uint32)crop->width;    else      width = image->width - lmargin - rmargin;    if (crop->crop_mode & CROP_LENGTH)      length  = (uint32)crop->length;    else      length = image->length - tmargin - bmargin;    }  else    {    if (crop->crop_mode & CROP_WIDTH)      width = (uint32)(crop->width * scale * image->xres);    else      width = image->width - lmargin - rmargin;    if (crop->crop_mode & CROP_LENGTH)      length  = (uint32)(crop->length * scale * image->yres);    else      length = image->length - tmargin - bmargin;    }  off->tmargin = tmargin;  off->bmargin = bmargin;  off->lmargin = lmargin;  off->rmargin = rmargin;    switch (crop->edge_ref) {    case EDGE_BOTTOM:         startx = lmargin;         if ((startx + width) >= (image->width - rmargin))           endx = image->width - rmargin - 1;         else           endx = startx + width - 1;         endy = image->length - bmargin - 1;         if ((endy - length) <= tmargin)           starty = tmargin;         else           starty = endy - length + 1;         break;    case EDGE_RIGHT:         endx = image->width - rmargin - 1;         if ((endx - width) <= lmargin)           startx = lmargin;         else           startx = endx - width + 1;         starty = tmargin;         if ((starty + length) >= (image->length - bmargin))           endy = image->length - bmargin - 1;         else           endy = starty + length - 1;         break;    case EDGE_TOP:      case EDGE_LEFT:    default:         startx = lmargin;         if ((startx + width) >= (image->width - rmargin))           endx = image->width - rmargin - 1;         else           endx = startx + width - 1;         starty = tmargin;         if ((starty + length) >= (image->length - bmargin))           endy = image->length - bmargin - 1;         else           endy = starty + length - 1;         break;    }  off->startx = startx;  off->starty = starty;  off->endx   = endx;  off->endy   = endy;  crop_width  = endx - startx + 1;  crop_length = endy - starty + 1;  if (crop_width <= 0)    {    TIFFError(\"computeInputPixelOffsets\",                \"Invalid left/right margins and /or image crop width requested\");    return (-1);    }  if (crop_width > image->width)    crop_width = image->width;  if (crop_length <= 0)    {    TIFFError(\"computeInputPixelOffsets\",               \"Invalid top/bottom margins and /or image crop length requested\");    return (-1);    }  if (crop_length > image->length)    crop_length = image->length;  off->crop_width = crop_width;  off->crop_length = crop_length;  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tsize_tTIFFVStripSize(TIFF* tif, uint32 nrows){\tTIFFDirectory *td = &tif->tif_dir;\tif (nrows == (uint32) -1)\t\tnrows = td->td_imagelength;\tif (td->td_planarconfig == PLANARCONFIG_CONTIG &&\t    td->td_photometric == PHOTOMETRIC_YCBCR &&\t    !isUpSampled(tif)) {\t\t\t\tuint16 ycbcrsubsampling[2];\t\ttsize_t w, scanline, samplingarea;\t\tTIFFGetField( tif, TIFFTAG_YCBCRSUBSAMPLING,\t\t\t      ycbcrsubsampling + 0,\t\t\t      ycbcrsubsampling + 1 );\t\tsamplingarea = ycbcrsubsampling[0]*ycbcrsubsampling[1];\t\tif (samplingarea == 0) {\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\t\t     \"Invalid YCbCr subsampling\");\t\t\treturn 0;\t\t}\t\tw = TIFFroundup(td->td_imagewidth, ycbcrsubsampling[0]);\t\tscanline = TIFFhowmany8(multiply(tif, w, td->td_bitspersample,\t\t\t\t\t\t \"TIFFVStripSize\"));\t\tnrows = TIFFroundup(nrows, ycbcrsubsampling[1]);\t\t\t\tscanline = multiply(tif, nrows, scanline, \"TIFFVStripSize\");\t\treturn ((tsize_t)\t\t    summarize(tif, scanline,\t\t\t      multiply(tif, 2, scanline / samplingarea,\t\t\t\t       \"TIFFVStripSize\"), \"TIFFVStripSize\"));\t} else\t\treturn ((tsize_t) multiply(tif, nrows, TIFFScanlineSize(tif),\t\t\t\t\t   \"TIFFVStripSize\"));}",
        "label": 1,
        "cve": "cve-2010-2597"
    },
    {
        "code": "static intOJPEGDecodeRaw(TIFF* tif, tidata_t buf, tsize_t cc){\tstatic const char module[]=\"OJPEGDecodeRaw\";\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\tuint8* m;\tuint32 n;\tuint8* oy;\tuint8* ocb;\tuint8* ocr;\tuint8* p;\tuint32 q;\tuint8* r;\tuint8 sx,sy;\tif (cc%sp->bytes_per_line!=0)\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Fractional scanline not read\");\t\treturn(0);\t}\tassert(cc>0);\tm=buf;\tn=cc;\tdo\t{\t\tif (sp->subsampling_convert_state==0)\t\t{\t\t\tif (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)\t\t\t\treturn(0);\t\t}\t\toy=sp->subsampling_convert_ybuf+sp->subsampling_convert_state*sp->subsampling_ver*sp->subsampling_convert_ylinelen;\t\tocb=sp->subsampling_convert_cbbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen;\t\tocr=sp->subsampling_convert_crbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen;\t\tp=m;\t\tfor (q=0; q<sp->subsampling_convert_clinelenout; q++)\t\t{\t\t\tr=oy;\t\t\tfor (sy=0; sy<sp->subsampling_ver; sy++)\t\t\t{\t\t\t\tfor (sx=0; sx<sp->subsampling_hor; sx++)\t\t\t\t\t*p++=*r++;\t\t\t\tr+=sp->subsampling_convert_ylinelen-sp->subsampling_hor;\t\t\t}\t\t\toy+=sp->subsampling_hor;\t\t\t*p++=*ocb++;\t\t\t*p++=*ocr++;\t\t}\t\tsp->subsampling_convert_state++;\t\tif (sp->subsampling_convert_state==sp->subsampling_convert_clines)\t\t\tsp->subsampling_convert_state=0;\t\tm+=sp->bytes_per_line;\t\tn-=sp->bytes_per_line;\t} while(n>0);\treturn(1);}",
        "label": 1,
        "cve": "cve-2009-5022"
    },
    {
        "code": "static voidatariWarningHandler(const char* module, const char* fmt, va_list ap){\tif (module != NULL)\t\tfprintf(stderr, \"%s: \", module);\tfprintf(stderr, \"Warning, \");\tvfprintf(stderr, fmt, ap);\tfprintf(stderr, \".\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchShortPair(TIFF* tif, TIFFDirEntry* dir){\tswitch (dir->tdir_type) {\t\tcase TIFF_BYTE:\t\tcase TIFF_SBYTE:\t\t\t{\t\t\tuint8 v[4];\t\t\treturn TIFFFetchByteArray(tif, dir, v)\t\t\t\t&& TIFFSetField(tif, dir->tdir_tag, v[0], v[1]);\t\t\t}\t\tcase TIFF_SHORT:\t\tcase TIFF_SSHORT:\t\t\t{\t\t\tuint16 v[4];\t\t\treturn TIFFFetchShortArray(tif, dir, v)\t\t\t\t&& TIFFSetField(tif, dir->tdir_tag, v[0], v[1]);\t\t\t}\t\tdefault:\t\t\treturn 0;\t}}",
        "label": 1,
        "cve": "cve-2006-0405"
    },
    {
        "code": "void *lfind(const void *key, const void *base, size_t *nmemb, size_t size,      int(*compar)(const void *, const void *)){\tchar *element, *end;\tend = (char *)base + *nmemb * size;\tfor (element = (char *)base; element < end; element += size)\t\tif (!compar(element, key))\t\t\t\t\treturn element;\treturn NULL;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "extern int close(int fd){\treturn ((int) xosfind_close((os_f) fd));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidFax3Extension(const char* module, TIFF* tif, uint32 line, uint32 a0){\tTIFFErrorExt(tif->tif_clientdata, module,\t    \"%s: Uncompressed data (not supported) at line %lu of %s %lu (x %lu)\",\t    tif->tif_name, (unsigned long) line, isTiled(tif) ? \"tile\" : \"strip\",       (unsigned long) (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),       (unsigned long) a0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intLZWDecodeCompat(TIFF* tif, tidata_t op0, tsize_t occ0, tsample_t s){\tLZWCodecState *sp = DecoderState(tif);\tchar *op = (char*) op0;\tlong occ = (long) occ0;\tchar *tp;\tunsigned char *bp;\tint code, nbits;\tlong nextbits, nextdata, nbitsmask;\tcode_t *codep, *free_entp, *maxcodep, *oldcodep;\t(void) s;\tassert(sp != NULL);\t\tif (sp->dec_restart) {\t\tlong residue;\t\tcodep = sp->dec_codep;\t\tresidue = codep->length - sp->dec_restart;\t\tif (residue > occ) {\t\t\t\t\t\tsp->dec_restart += occ;\t\t\tdo {\t\t\t\tcodep = codep->next;\t\t\t} while (--residue > occ);\t\t\ttp = op + occ;\t\t\tdo {\t\t\t\t*--tp = codep->value;\t\t\t\tcodep = codep->next;\t\t\t} while (--occ);\t\t\treturn (1);\t\t}\t\t\t\top += residue, occ -= residue;\t\ttp = op;\t\tdo {\t\t\t*--tp = codep->value;\t\t\tcodep = codep->next;\t\t} while (--residue);\t\tsp->dec_restart = 0;\t}\tbp = (unsigned char *)tif->tif_rawcp;\tnbits = sp->lzw_nbits;\tnextdata = sp->lzw_nextdata;\tnextbits = sp->lzw_nextbits;\tnbitsmask = sp->dec_nbitsmask;\toldcodep = sp->dec_oldcodep;\tfree_entp = sp->dec_free_entp;\tmaxcodep = sp->dec_maxcodep;\twhile (occ > 0) {\t\tNextCode(tif, sp, bp, code, GetNextCodeCompat);\t\tif (code == CODE_EOI)\t\t\tbreak;\t\tif (code == CODE_CLEAR) {\t\t\tfree_entp = sp->dec_codetab + CODE_FIRST;\t\t\tnbits = BITS_MIN;\t\t\tnbitsmask = MAXCODE(BITS_MIN);\t\t\tmaxcodep = sp->dec_codetab + nbitsmask;\t\t\tNextCode(tif, sp, bp, code, GetNextCodeCompat);\t\t\tif (code == CODE_EOI)\t\t\t\tbreak;\t\t\t*op++ = code, occ--;\t\t\toldcodep = sp->dec_codetab + code;\t\t\tcontinue;\t\t}\t\tcodep = sp->dec_codetab + code;\t\t\t\tif (free_entp < &sp->dec_codetab[0] ||\t\t\tfree_entp >= &sp->dec_codetab[CSIZE]) {\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\t\"LZWDecodeCompat: Corrupted LZW table at scanline %d\",\t\t\ttif->tif_row);\t\t\treturn (0);\t\t}\t\tfree_entp->next = oldcodep;\t\tif (free_entp->next < &sp->dec_codetab[0] ||\t\t\tfree_entp->next >= &sp->dec_codetab[CSIZE]) {\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\t\"LZWDecodeCompat: Corrupted LZW table at scanline %d\",\t\t\ttif->tif_row);\t\t\treturn (0);\t\t}\t\tfree_entp->firstchar = free_entp->next->firstchar;\t\tfree_entp->length = free_entp->next->length+1;\t\tfree_entp->value = (codep < free_entp) ?\t\t    codep->firstchar : free_entp->firstchar;\t\tif (++free_entp > maxcodep) {\t\t\tif (++nbits > BITS_MAX)\t\t\t\t\t\tnbits = BITS_MAX;\t\t\tnbitsmask = MAXCODE(nbits);\t\t\tmaxcodep = sp->dec_codetab + nbitsmask;\t\t}\t\toldcodep = codep;\t\tif (code >= 256) {\t\t\t\t\t\tif(codep->length == 0) {\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t    \t\t    \"LZWDecodeCompat: Wrong length of decoded \"\t\t\t    \"string: data probably corrupted at scanline %d\",\t\t\t    tif->tif_row);\t\t\t\t    return (0);\t\t\t}\t\t\tif (codep->length > occ) {\t\t\t\t\t\t\t\tsp->dec_codep = codep;\t\t\t\tdo {\t\t\t\t\tcodep = codep->next;\t\t\t\t} while (codep->length > occ);\t\t\t\tsp->dec_restart = occ;\t\t\t\ttp = op + occ;\t\t\t\tdo  {\t\t\t\t\t*--tp = codep->value;\t\t\t\t\tcodep = codep->next;\t\t\t\t}  while (--occ);\t\t\t\tbreak;\t\t\t}\t\t\top += codep->length, occ -= codep->length;\t\t\ttp = op;\t\t\tdo {\t\t\t\t*--tp = codep->value;\t\t\t} while( (codep = codep->next) != NULL);\t\t} else\t\t\t*op++ = code, occ--;\t}\ttif->tif_rawcp = (tidata_t) bp;\tsp->lzw_nbits = nbits;\tsp->lzw_nextdata = nextdata;\tsp->lzw_nextbits = nextbits;\tsp->dec_nbitsmask = nbitsmask;\tsp->dec_oldcodep = oldcodep;\tsp->dec_free_entp = free_entp;\tsp->dec_maxcodep = maxcodep;\tif (occ > 0) {\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t    \"LZWDecodeCompat: Not enough data at scanline %d (short %d bytes)\",\t\t    tif->tif_row, occ);\t\treturn (0);\t}\treturn (1);}",
        "label": 1,
        "cve": "cve-2009-2285"
    },
    {
        "code": "intTIFFDefaultDirectory(TIFF* tif){\tregister TIFFDirectory* td = &tif->tif_dir;\tsize_t tiffFieldInfoCount;\tconst TIFFFieldInfo *tiffFieldInfo =\t\t_TIFFGetFieldInfo(&tiffFieldInfoCount);\t_TIFFSetupFieldInfo(tif, tiffFieldInfo, tiffFieldInfoCount);\t_TIFFmemset(td, 0, sizeof (*td));\ttd->td_fillorder = FILLORDER_MSB2LSB;\ttd->td_bitspersample = 1;\ttd->td_threshholding = THRESHHOLD_BILEVEL;\ttd->td_orientation = ORIENTATION_TOPLEFT;\ttd->td_samplesperpixel = 1;\ttd->td_rowsperstrip = (uint32) -1;\ttd->td_tilewidth = 0;\ttd->td_tilelength = 0;\ttd->td_tiledepth = 1;\ttd->td_stripbytecountsorted = 1; \ttd->td_resolutionunit = RESUNIT_INCH;\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\ttd->td_imagedepth = 1;\ttd->td_ycbcrsubsampling[0] = 2;\ttd->td_ycbcrsubsampling[1] = 2;\ttd->td_ycbcrpositioning = YCBCRPOSITION_CENTERED;\ttif->tif_postdecode = _TIFFNoPostDecode;        tif->tif_foundfield = NULL;\ttif->tif_tagmethods.vsetfield = _TIFFVSetField;\ttif->tif_tagmethods.vgetfield = _TIFFVGetField;\ttif->tif_tagmethods.printdir = NULL;\t\tif (_TIFFextender)\t\t(*_TIFFextender)(tif);\t(void) TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\t\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;                tif->tif_flags &= ~TIFF_ISTILED;\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intFax3PreEncode(TIFF* tif, tsample_t s){\tFax3CodecState* sp = EncoderState(tif);\t(void) s;\tassert(sp != NULL);\tsp->bit = 8;\tsp->data = 0;\tsp->tag = G3_1D;\t\tif (sp->refline)\t\t_TIFFmemset(sp->refline, 0x00, sp->b.rowbytes);\tif (is2DEncoding(sp)) {\t\tfloat res = tif->tif_dir.td_yresolution;\t\t\t\tif (tif->tif_dir.td_resolutionunit == RESUNIT_CENTIMETER)\t\t\tres *= 2.54f;\t\t\t\tsp->maxk = (res > 150 ? 4 : 2);\t\tsp->k = sp->maxk-1;\t} else\t\tsp->k = sp->maxk = 0;\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tsize_t_tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size){\treturn (FSWrite((short) fd, (long*) &size, (char*) buf) == noErr ?\t    size : (tsize_t) -1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "const TIFFCodec*TIFFFindCODEC(uint16 scheme){\tconst TIFFCodec* c;\tcodec_t* cd;\tfor (cd = registeredCODECS; cd; cd = cd->next)\t\tif (cd->info->scheme == scheme)\t\t\treturn ((const TIFFCodec*) cd->info);\tfor (c = _TIFFBuiltinCODECS; c->name; c++)\t\tif (c->scheme == scheme)\t\t\treturn (c);\treturn ((const TIFFCodec*) 0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static toff_t_tiffSizeProc(thandle_t fd){\tstruct stat sb;\treturn (fstat((int) fd, &sb) < 0 ? 0 : sb.st_size);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intgtTileSeparate(TIFFImageIter* img, void *udata, uint32 w, uint32 h){    TIFF* tif = img->tif;    ImageIterTileSeparateRoutine callback = img->callback.separate;    uint16 orientation;    uint32 col, row;    uint32 tw, th;    u_char* buf;    u_char* r;    u_char* g;    u_char* b;    u_char* a;    tsize_t tilesize;    int32 fromskew;    int alpha = img->alpha;    uint32 nrow;    tilesize = TIFFTileSize(tif);    buf = (u_char*) _TIFFmalloc(4*tilesize);    if (buf == 0) {\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for tile buffer\");\treturn (0);    }    r = buf;    g = r + tilesize;    b = g + tilesize;    a = b + tilesize;    if (!alpha)\tmemset(a, 0xff, tilesize);    TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);    TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);    orientation = img->orientation;    for (row = 0; row < h; row += th) {\tnrow = (row + th > h ? h - row : th);\tfor (col = 0; col < w; col += tw) {\t    if (TIFFReadTile(tif, r, col, row,0,0) < 0 && img->stoponerr)\t\tbreak;\t    if (TIFFReadTile(tif, g, col, row,0,1) < 0 && img->stoponerr)\t\tbreak;\t    if (TIFFReadTile(tif, b, col, row,0,2) < 0 && img->stoponerr)\t\tbreak;\t    if (alpha && TIFFReadTile(tif,a,col,row,0,3) < 0 && img->stoponerr)\t\tbreak;\t    if (col + tw > w) {\t\t\t\tuint32 npix = w - col;\t\tfromskew = tw - npix;\t\t(*callback)(img, udata, col, row, npix, nrow, fromskew, r, g, b, a);\t    } else {\t\t(*callback)(img, udata, col, row, tw, nrow, 0, r, g, b, a);\t    }\t}    }    _TIFFfree(buf);    return (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intreverseSamples24bits (uint16 spp, uint16 bps, uint32 width,                       uint8 *ibuff, uint8 *obuff)  {  int      ready_bits = 0;  uint32   col;  uint32   src_byte = 0, high_bit = 0;  uint32   bit_offset = 0;  uint32   match_bits = 0, mask_bits = 0;  uint32   buff1 = 0, buff2 = 0;  uint8    bytebuff1 = 0, bytebuff2 = 0;  unsigned char *src;  unsigned char *dst;  tsample_t sample;  if ((ibuff == NULL) || (obuff == NULL))    {    TIFFError(\"reverseSamples24bits\",\"Invalid image or work buffer\");    return (1);    }  ready_bits = 0;  mask_bits =  (uint32)-1 >> (32 - bps);  dst = obuff;  for (col = width; col > 0; col--)    {        bit_offset = (col - 1) * bps * spp;    for (sample = 0; sample < spp; sample++)      {      if (sample == 0)        {        src_byte = bit_offset / 8;        high_bit  = bit_offset % 8;        }      else        {        src_byte = (bit_offset + (sample * bps)) / 8;        high_bit  = (bit_offset + (sample * bps)) % 8;        }      src = ibuff + src_byte;      match_bits = mask_bits << (32 - high_bit - bps);       if (little_endian)\tbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];      else\tbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];      buff1 = (buff1 & match_bits) << (high_bit);      if (ready_bits < 16)        {         bytebuff1 = bytebuff2 = 0;        buff2 = (buff2 | (buff1 >> ready_bits));        }      else         {        bytebuff1 = (buff2 >> 24);        *dst++ = bytebuff1;        bytebuff2 = (buff2 >> 16);        *dst++ = bytebuff2;        ready_bits -= 16;                buff2 = ((buff2 << 16) | (buff1 >> ready_bits));        }      ready_bits += bps;      }    }   while (ready_bits > 0)    {    bytebuff1 = (buff2 >> 24);    *dst++ = bytebuff1;    buff2 = (buff2 << 8);    bytebuff2 = bytebuff1;    ready_bits -= 8;    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intFax3Encode1DRow(TIFF* tif, unsigned char* bp, uint32 bits){\tFax3CodecState* sp = EncoderState(tif);\tint32 span;        uint32 bs = 0;\tfor (;;) {\t\tspan = find0span(bp, bs, bits);\t\t\t\tputspan(tif, span, TIFFFaxWhiteCodes);\t\tbs += span;\t\tif (bs >= bits)\t\t\tbreak;\t\tspan = find1span(bp, bs, bits);\t\t\t\tputspan(tif, span, TIFFFaxBlackCodes);\t\tbs += span;\t\tif (bs >= bits)\t\t\tbreak;\t}\tif (sp->b.mode & (FAXMODE_BYTEALIGN|FAXMODE_WORDALIGN)) {\t\tif (sp->bit != 8)\t\t\t\t\t\tFax3FlushBits(tif, sp);\t\tif ((sp->b.mode&FAXMODE_WORDALIGN) &&\t\t    !isAligned(tif->tif_rawcp, uint16))\t\t\tFax3FlushBits(tif, sp);\t}\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidfax2ps(TIFF* tif, uint16 npages, uint16* pages, char* filename){    if (npages > 0) {\tuint16 pn, ptotal;\tint i;\tif (!GetPageNumber(tif))\t    fprintf(stderr, \"%s: No page numbers, counting directories.\\n\",\t\tfilename);\tfor (i = 0; i < npages; i++) {\t    if (findPage(tif, pages[i]))\t\tprintTIF(tif, pages[i]);\t    else\t\tfprintf(stderr, \"%s: No page number %d\\n\", filename, pages[i]);\t}    } else {\tuint16 pageNumber = 0;\tdo\t    printTIF(tif, pageNumber++);\twhile (TIFFReadDirectory(tif));    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intprocessCompressOptions(char* opt){\tif (streq(opt, \"none\"))\t\tcompression = COMPRESSION_NONE;\telse if (streq(opt, \"packbits\"))\t\tcompression = COMPRESSION_PACKBITS;\telse if (strneq(opt, \"g3\", 2)) {\t\tprocessG3Options(opt);\t\tcompression = COMPRESSION_CCITTFAX3;\t} else if (streq(opt, \"g4\"))\t\tcompression = COMPRESSION_CCITTFAX4;\telse if (strneq(opt, \"lzw\", 3)) {\t\tchar* cp = strchr(opt, ':');\t\tif (cp)\t\t\tpredictor = atoi(cp+1);\t\tcompression = COMPRESSION_LZW;\t} else if (strneq(opt, \"zip\", 3)) {\t\tchar* cp = strchr(opt, ':');\t\tif (cp)\t\t\tpredictor = atoi(cp+1);\t\tcompression = COMPRESSION_DEFLATE;\t} else\t\treturn (0);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int convertHTMLcodes(char *s, int len){  if (len <=0 || s==(char*)NULL || *s=='\\0')    return 0;  if (s[1] == '#')    {      int val, o;      if (sscanf(s,\"&#%d;\",&val) == 1)        {          o = 3;          while (s[o] != ';')            {              o++;              if (o > 5)                break;            }          if (o < 5)            strcpy(s+1, s+1+o);          *s = val;          return o;        }    }  else    {      int        i,        codes = sizeof(html_codes) / sizeof(html_code);      for (i=0; i < codes; i++)        {          if (html_codes[i].len <= len)            if (STRNICMP(s, html_codes[i].code, html_codes[i].len) == 0)              {                strcpy(s+1, s+html_codes[i].len);                *s = html_codes[i].val;                return html_codes[i].len-1;              }        }    }  return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidacornErrorHandler(const char* module, const char* fmt, va_list ap){\tif (module != NULL)\t{\t\tfprintf(stderr, \"%s: \", module);\t}\tvfprintf(stderr, fmt, ap);\tfprintf(stderr, \".\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size){\tUnmapViewOfFile(base);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize){\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intLZWDecode(TIFF* tif, tidata_t op0, tsize_t occ0, tsample_t s){\tLZWCodecState *sp = DecoderState(tif);\tchar *op = (char*) op0;\tlong occ = (long) occ0;\tchar *tp;\tunsigned char *bp;\thcode_t code;\tint len;\tlong nbits, nextbits, nextdata, nbitsmask;\tcode_t *codep, *free_entp, *maxcodep, *oldcodep;\t(void) s;\tassert(sp != NULL);\t\tif (sp->dec_restart) {\t\tlong residue;\t\tcodep = sp->dec_codep;\t\tresidue = codep->length - sp->dec_restart;\t\tif (residue > occ) {\t\t\t\t\t\tsp->dec_restart += occ;\t\t\tdo {\t\t\t\tcodep = codep->next;\t\t\t} while (--residue > occ && codep);\t\t\tif (codep) {\t\t\t\ttp = op + occ;\t\t\t\tdo {\t\t\t\t\t*--tp = codep->value;\t\t\t\t\tcodep = codep->next;\t\t\t\t} while (--occ && codep);\t\t\t}\t\t\treturn (1);\t\t}\t\t\t\top += residue, occ -= residue;\t\ttp = op;\t\tdo {\t\t\tint t;\t\t\t--tp;\t\t\tt = codep->value;\t\t\tcodep = codep->next;\t\t\t*tp = t;\t\t} while (--residue && codep);\t\tsp->dec_restart = 0;\t}\tbp = (unsigned char *)tif->tif_rawcp;\tnbits = sp->lzw_nbits;\tnextdata = sp->lzw_nextdata;\tnextbits = sp->lzw_nextbits;\tnbitsmask = sp->dec_nbitsmask;\toldcodep = sp->dec_oldcodep;\tfree_entp = sp->dec_free_entp;\tmaxcodep = sp->dec_maxcodep;\twhile (occ > 0) {\t\tNextCode(tif, sp, bp, code, GetNextCode);\t\tif (code == CODE_EOI)\t\t\tbreak;\t\tif (code == CODE_CLEAR) {\t\t\tfree_entp = sp->dec_codetab + CODE_FIRST;\t\t\tnbits = BITS_MIN;\t\t\tnbitsmask = MAXCODE(BITS_MIN);\t\t\tmaxcodep = sp->dec_codetab + nbitsmask-1;\t\t\tNextCode(tif, sp, bp, code, GetNextCode);\t\t\tif (code == CODE_EOI)\t\t\t\tbreak;\t\t\t*op++ = (char)code, occ--;\t\t\toldcodep = sp->dec_codetab + code;\t\t\tcontinue;\t\t}\t\tcodep = sp->dec_codetab + code;\t\t\t\tif (free_entp < &sp->dec_codetab[0] ||\t\t\tfree_entp >= &sp->dec_codetab[CSIZE]) {\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\t\"LZWDecode: Corrupted LZW table at scanline %d\",\t\t\ttif->tif_row);\t\t\treturn (0);\t\t}\t\tfree_entp->next = oldcodep;\t\tif (free_entp->next < &sp->dec_codetab[0] ||\t\t\tfree_entp->next >= &sp->dec_codetab[CSIZE]) {\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\t\"LZWDecode: Corrupted LZW table at scanline %d\",\t\t\ttif->tif_row);\t\t\treturn (0);\t\t}\t\tfree_entp->firstchar = free_entp->next->firstchar;\t\tfree_entp->length = free_entp->next->length+1;\t\tfree_entp->value = (codep < free_entp) ?\t\t    codep->firstchar : free_entp->firstchar;\t\tif (++free_entp > maxcodep) {\t\t\tif (++nbits > BITS_MAX)\t\t\t\t\t\tnbits = BITS_MAX;\t\t\tnbitsmask = MAXCODE(nbits);\t\t\tmaxcodep = sp->dec_codetab + nbitsmask-1;\t\t}\t\toldcodep = codep;\t\tif (code >= 256) {\t\t\t\t\t\tif(codep->length == 0) {\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t    \t\t    \"LZWDecode: Wrong length of decoded string: \"\t\t\t    \"data probably corrupted at scanline %d\",\t\t\t    tif->tif_row);\t\t\t\t    return (0);\t\t\t}\t\t\tif (codep->length > occ) {\t\t\t\t\t\t\t\tsp->dec_codep = codep;\t\t\t\tdo {\t\t\t\t\tcodep = codep->next;\t\t\t\t} while (codep && codep->length > occ);\t\t\t\tif (codep) {\t\t\t\t\tsp->dec_restart = occ;\t\t\t\t\ttp = op + occ;\t\t\t\t\tdo  {\t\t\t\t\t\t*--tp = codep->value;\t\t\t\t\t\tcodep = codep->next;\t\t\t\t\t}  while (--occ && codep);\t\t\t\t\tif (codep)\t\t\t\t\t\tcodeLoop(tif);\t\t\t\t}\t\t\t\tbreak;\t\t\t}\t\t\tlen = codep->length;\t\t\ttp = op + len;\t\t\tdo {\t\t\t\tint t;\t\t\t\t--tp;\t\t\t\tt = codep->value;\t\t\t\tcodep = codep->next;\t\t\t\t*tp = t;\t\t\t} while (codep && tp > op);\t\t\tif (codep) {\t\t\t    codeLoop(tif);\t\t\t    break;\t\t\t}\t\t\top += len, occ -= len;\t\t} else\t\t\t*op++ = (char)code, occ--;\t}\ttif->tif_rawcp = (tidata_t) bp;\tsp->lzw_nbits = (unsigned short) nbits;\tsp->lzw_nextdata = nextdata;\tsp->lzw_nextbits = nextbits;\tsp->dec_nbitsmask = nbitsmask;\tsp->dec_oldcodep = oldcodep;\tsp->dec_free_entp = free_entp;\tsp->dec_maxcodep = maxcodep;\tif (occ > 0) {\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\"LZWDecode: Not enough data at scanline %d (short %d bytes)\",\t\t    tif->tif_row, occ);\t\treturn (0);\t}\treturn (1);}",
        "label": 1,
        "cve": "cve-2008-2327"
    },
    {
        "code": "static voidtiffsv(char* name, int x1, int x2, int y1, int y2){\tTIFF *tif;\tint xsize, ysize;\tint xorg, yorg;\tuint32 *scrbuf;\txorg = MIN(x1,x2);\tyorg = MIN(y1,y2);\tif (xorg<0)\t\txorg = 0;\tif (yorg<0)\t\tyorg = 0;\txsize = ABS(x2-x1);\tysize = ABS(y2-y1);\tif (xorg+xsize > xmaxscreen)\t\txsize = xmaxscreen-xorg;\tif (yorg+ysize > ymaxscreen)\t\tysize = ymaxscreen-yorg;\ttif = TIFFOpen(name, \"w\");\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, (uint32) (xsize+1));\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, (uint32) (ysize+1));\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL,\t    photometric == PHOTOMETRIC_RGB ? 3 : 1);\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, config);\tTIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\tswitch (compression) {\tcase COMPRESSION_JPEG:\t\tif (photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB)\t\t\tphotometric = PHOTOMETRIC_YCBCR;\t\tTIFFSetField(tif, TIFFTAG_JPEGQUALITY, quality);\t\tTIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\t\tbreak;\tcase COMPRESSION_LZW:\t\tif (predictor != 0)\t\t\tTIFFSetField(tif, TIFFTAG_PREDICTOR, predictor);\t\tbreak;\t}\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric);\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\trowsperstrip = TIFFDefaultStripSize(tif, rowsperstrip);\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\tscrbuf = (uint32 *)_TIFFmalloc((xsize+1)*(ysize+1)*sizeof (uint32));\treaddisplay(xorg, yorg, xorg+xsize, yorg+ysize, scrbuf, RD_FREEZE);\tif (photometric == PHOTOMETRIC_RGB) {\t\tif (config == PLANARCONFIG_SEPARATE)\t\t\tsvRGBSeparate(tif, scrbuf, xsize, ysize);\t\telse\t\t\tsvRGBContig(tif, scrbuf, xsize, ysize);\t} else\t\tsvGrey(tif, scrbuf, xsize, ysize);\t(void) TIFFClose(tif);\t_TIFFfree((char *)scrbuf);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,\t\t\t\t       uint32 imagewidth, tsample_t spp,                                        struct dump_opts* dump)  {  uint16 bps;  uint32 tl, tw;  uint32 row, col, nrow, ncol;  uint32 src_rowsize, col_offset;  uint32 tile_rowsize  = TIFFTileRowSize(out);  uint8* bufp = (uint8*) buf;  tsize_t tile_buffsize = 0;  tsize_t tilesize = TIFFTileSize(out);  unsigned char *tilebuf = NULL;  if( !TIFFGetField(out, TIFFTAG_TILELENGTH, &tl) ||      !TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw) ||      !TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps) )      return 1;  if (tilesize == 0 || tile_rowsize == 0 || tl == 0 || tw == 0)  {    TIFFError(\"writeBufferToContigTiles\", \"Tile size, tile row size, tile width, or tile length is zero\");    exit(-1);  }  tile_buffsize = tilesize;  if (tilesize < (tsize_t)(tl * tile_rowsize))    {#ifdef DEBUG2    TIFFError(\"writeBufferToContigTiles\",\t      \"Tilesize %lu is too small, using alternate calculation %u\",              tilesize, tl * tile_rowsize);#endif    tile_buffsize = tl * tile_rowsize;    if (tl != tile_buffsize / tile_rowsize)    {\tTIFFError(\"writeBufferToContigTiles\", \"Integer overflow when calculating buffer size\");\texit(-1);    }    }  if( imagewidth == 0 ||      (uint32)bps * (uint32)spp > TIFF_UINT32_MAX / imagewidth ||      bps * spp * imagewidth > TIFF_UINT32_MAX - 7U )  {      TIFFError(TIFFFileName(out),            \"Error, uint32 overflow when computing (imagewidth * bps * spp) + 7\");      return 1;  }  src_rowsize = ((imagewidth * spp * bps) + 7U) / 8;  tilebuf = _TIFFmalloc(tile_buffsize);  if (tilebuf == 0)    return 1;  for (row = 0; row < imagelength; row += tl)    {    nrow = (row + tl > imagelength) ? imagelength - row : tl;    for (col = 0; col < imagewidth; col += tw)      {            if (col + tw > imagewidth)\tncol = imagewidth - col;      else        ncol = tw;      col_offset = (((col * bps * spp) + 7) / 8);      bufp = buf + (row * src_rowsize) + col_offset;      if (extractContigSamplesToTileBuffer(tilebuf, bufp, nrow, ncol, imagewidth,\t\t\t\t\t   tw, 0, spp, spp, bps, dump) > 0)        {\tTIFFError(\"writeBufferToContigTiles\",                   \"Unable to extract data to tile for row %lu, col %lu\",                  (unsigned long) row, (unsigned long)col);\t_TIFFfree(tilebuf);\treturn 1;        }      if (TIFFWriteTile(out, tilebuf, col, row, 0, 0) < 0)        {\tTIFFError(\"writeBufferToContigTiles\",\t          \"Cannot write tile at %lu %lu\",\t          (unsigned long) col, (unsigned long) row);\t _TIFFfree(tilebuf);\treturn 1;\t}      }    }  _TIFFfree(tilebuf);  return 0;  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFFErrorHandlerTIFFSetErrorHandler(TIFFErrorHandler handler){\tTIFFErrorHandler prev = _TIFFerrorHandler;\t_TIFFerrorHandler = handler;\treturn (prev);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size){}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPixarLogEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s){\tstatic const char module[] = \"PixarLogEncode\";\tTIFFDirectory *td = &tif->tif_dir;\tPixarLogState *sp = EncoderState(tif);\ttmsize_t i;\ttmsize_t n;\tint llen;\tunsigned short * up;\t(void) s;\tswitch (sp->user_datafmt) {\tcase PIXARLOGDATAFMT_FLOAT:\t\tn = cc / sizeof(float);\t\t\t\tbreak;\tcase PIXARLOGDATAFMT_16BIT:\tcase PIXARLOGDATAFMT_12BITPICIO:\tcase PIXARLOGDATAFMT_11BITLOG:\t\tn = cc / sizeof(uint16);\t\t\tbreak;\tcase PIXARLOGDATAFMT_8BIT:\tcase PIXARLOGDATAFMT_8BITABGR:\t\tn = cc;\t\tbreak;\tdefault:\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\"%d bit input not supported in PixarLog\",\t\t\ttd->td_bitspersample);\t\treturn 0;\t}\tllen = sp->stride * td->td_imagewidth;        if( n > (tmsize_t)(td->td_rowsperstrip * llen) )    {        TIFFErrorExt(tif->tif_clientdata, module,                     \"Too many input bytes provided\");        return 0;    }\tfor (i = 0, up = sp->tbuf; i < n; i += llen, up += llen) {\t\tswitch (sp->user_datafmt)  {\t\tcase PIXARLOGDATAFMT_FLOAT:\t\t\thorizontalDifferenceF((float *)bp, llen, \t\t\t\tsp->stride, up, sp->FromLT2);\t\t\tbp += llen * sizeof(float);\t\t\tbreak;\t\tcase PIXARLOGDATAFMT_16BIT:\t\t\thorizontalDifference16((uint16 *)bp, llen, \t\t\t\tsp->stride, up, sp->From14);\t\t\tbp += llen * sizeof(uint16);\t\t\tbreak;\t\tcase PIXARLOGDATAFMT_8BIT:\t\t\thorizontalDifference8((unsigned char *)bp, llen, \t\t\t\tsp->stride, up, sp->From8);\t\t\tbp += llen * sizeof(unsigned char);\t\t\tbreak;\t\tdefault:\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t\"%d bit input not supported in PixarLog\",\t\t\t\ttd->td_bitspersample);\t\t\treturn 0;\t\t}\t}\tsp->stream.next_in = (unsigned char *) sp->tbuf;\tassert(sizeof(sp->stream.avail_in)==4);  \tsp->stream.avail_in = (uInt) (n * sizeof(uint16));\tif ((sp->stream.avail_in / sizeof(uint16)) != (uInt) n)\t{\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t     \"ZLib cannot deal with buffers this size\");\t\treturn (0);\t}\tdo {\t\tif (deflate(&sp->stream, Z_NO_FLUSH) != Z_OK) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Encoder error: %s\",\t\t\t    sp->stream.msg ? sp->stream.msg : \"(null)\");\t\t\treturn (0);\t\t}\t\tif (sp->stream.avail_out == 0) {\t\t\ttif->tif_rawcc = tif->tif_rawdatasize;\t\t\tTIFFFlushData1(tif);\t\t\tsp->stream.next_out = tif->tif_rawdata;\t\t\tsp->stream.avail_out = (uInt) tif->tif_rawdatasize;  \t\t}\t} while (sp->stream.avail_in > 0);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void                Usage();int main(int argc, char **argv){    int             bits_per_pixel = 8, cmsize, i, j, k,                    cmap_index, chunk_size = 32, nchunks = 16;    unsigned char * scan_line;    uint16          *red, *green, *blue;    TIFF *          tif;    programName = argv[0];    if (argc != 4)        Usage();    if (!strcmp(argv[1], \"-depth\"))         bits_per_pixel = atoi(argv[2]);    else         Usage();    switch (bits_per_pixel) {        case 8:            nchunks = 16;            chunk_size = 32;            break;        case 4:            nchunks = 4;            chunk_size = 128;            break;        case 2:            nchunks = 2;            chunk_size = 256;            break;\tcase 1:\t    nchunks = 2;\t    chunk_size = 256;\t    break;        default:            Usage();    }    if (bits_per_pixel != 1) {\tcmsize = nchunks * nchunks;    } else {\tcmsize = 2;    }    red = (uint16 *) malloc(cmsize * sizeof(uint16));    green = (uint16 *) malloc(cmsize * sizeof(uint16));    blue = (uint16 *) malloc(cmsize * sizeof(uint16));    switch (bits_per_pixel) {    case 8:        for (i = 0; i < cmsize; i++) {            if (i < 32)                red[i] = 0;            else if (i < 64)                red[i] = SCALE(36);            else if (i < 96)                red[i] = SCALE(73);            else if (i < 128)                red[i] = SCALE(109);            else if (i < 160)                red[i] = SCALE(146);            else if (i < 192)                red[i] = SCALE(182);            else if (i < 224)                red[i] = SCALE(219);            else if (i < 256)                red[i] = SCALE(255);            if ((i % 32) < 4)                green[i] = 0;            else if (i < 8)                green[i] = SCALE(36);            else if ((i % 32) < 12)                green[i] = SCALE(73);            else if ((i % 32) < 16)                green[i] = SCALE(109);            else if ((i % 32) < 20)                green[i] = SCALE(146);            else if ((i % 32) < 24)                green[i] = SCALE(182);            else if ((i % 32) < 28)                green[i] = SCALE(219);            else if ((i % 32) < 32)                green[i] = SCALE(255);            if ((i % 4) == 0)                blue[i] = SCALE(0);            else if ((i % 4) == 1)                blue[i] = SCALE(85);            else if ((i % 4) == 2)                blue[i] = SCALE(170);            else if ((i % 4) == 3)                blue[i] = SCALE(255);        }        break;    case 4:        red[0] = SCALE(255);        green[0] = 0;        blue[0] = 0;        red[1] = 0;        green[1] = SCALE(255);        blue[1] = 0;        red[2] = 0;        green[2] = 0;        blue[2] = SCALE(255);        red[3] = SCALE(255);        green[3] = SCALE(255);        blue[3] = SCALE(255);        red[4] = 0;        green[4] = SCALE(255);        blue[4] = SCALE(255);        red[5] = SCALE(255);        green[5] = 0;        blue[5] = SCALE(255);        red[6] = SCALE(255);        green[6] = SCALE(255);        blue[6] = 0;        red[7] = 0;        green[7] = 0;        blue[7] = 0;        red[8] = SCALE(176);        green[8] = SCALE(224);        blue[8] = SCALE(230);        red[9] = SCALE(100);        green[9] = SCALE(149);        blue[9] = SCALE(237);        red[10] = SCALE(46);        green[10] = SCALE(139);        blue[10] = SCALE(87);        red[11] = SCALE(160);        green[11] = SCALE(82);        blue[11] = SCALE(45);        red[12] = SCALE(238);        green[12] = SCALE(130);        blue[12] = SCALE(238);        red[13] = SCALE(176);        green[13] = SCALE(48);        blue[13] = SCALE(96);        red[14] = SCALE(50);        green[14] = SCALE(205);        blue[14] = SCALE(50);        red[15] = SCALE(240);        green[15] = SCALE(152);        blue[15] = SCALE(35);        break;    case 2:        red[0] = SCALE(255);        green[0] = 0;        blue[0] = 0;        red[1] = 0;        green[1] = SCALE(255);        blue[1] = 0;        red[2] = 0;        green[2] = 0;        blue[2] = SCALE(255);        red[3] = SCALE(255);        green[3] = SCALE(255);        blue[3] = SCALE(255);        break;    case 1:        red[0] = 0;        green[0] = 0;        blue[0] = 0;        red[1] = SCALE(255);        green[1] = SCALE(255);        blue[1] = SCALE(255);        break;    }    if ((tif = TIFFOpen(argv[3], \"w\")) == NULL) {        fprintf(stderr, \"can't open %s as a TIFF file\\n\", argv[3]);\t\tfree(red);free(green);free(blue);        return 0;    }    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, WIDTH);    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, HEIGHT);    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bits_per_pixel);    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE);    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);    TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_NONE);    TIFFSetField(tif, TIFFTAG_COLORMAP, red, green, blue);    scan_line = (unsigned char *) malloc(WIDTH / (8 / bits_per_pixel));    for (i = 0; i < HEIGHT; i++) {        for (j = 0, k = 0; j < WIDTH;) {            cmap_index = (j / chunk_size) + ((i / chunk_size) * nchunks);            switch (bits_per_pixel) {            case 8:                scan_line[k++] = cmap_index;                j++;                break;            case 4:                scan_line[k++] = (cmap_index << 4) + cmap_index;                j += 2;                break;            case 2:                scan_line[k++] = (cmap_index << 6) + (cmap_index << 4)                    + (cmap_index << 2) + cmap_index;                j += 4;                break;\t    case 1:\t\tscan_line[k++] =\t\t\t((j / chunk_size) == (i / chunk_size)) ? 0x00 : 0xff;\t\tj += 8;\t\tbreak;            }        }        TIFFWriteScanline(tif, scan_line, i, 0);    }    free(scan_line);    TIFFClose(tif);    return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFfree(tdata_t p){\tfree(p);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchFloatArray(TIFF* tif, TIFFDirEntry* dir, float* v){\tif (dir->tdir_count == 1) {\t\tv[0] = *(float*) &dir->tdir_offset;\t\tTIFFCvtIEEEFloatToNative(tif, dir->tdir_count, v);\t\treturn (1);\t} else\tif (TIFFFetchData(tif, dir, (char*) v)) {\t\tTIFFCvtIEEEFloatToNative(tif, dir->tdir_count, v);\t\treturn (1);\t} else\t\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcpSeparateBufToContigBuf(uint8* out, uint8* in,    uint32 rows, uint32 cols, int outskew, int inskew, tsample_t spp,    int bytes_per_sample){\twhile (rows-- > 0) {\t\tuint32 j = cols;\t\twhile (j-- > 0) {\t\t\tint n = bytes_per_sample;\t\t\twhile( n-- ) {\t\t\t\t*out++ = *in++;\t\t\t}\t\t\tout += (spp-1)*bytes_per_sample;\t\t}\t\tout += outskew;\t\tin += inskew;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFmemset(tdata_t p, int v, tsize_t c){\tmemset(p, v, (size_t) c);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "    { setByteArray((void**) fpp, (void*) fp, n, sizeof (float)); }void _TIFFsetDoubleArray(double** dpp, double* dp, uint32 n)    { setByteArray((void**) dpp, (void*) dp, n, sizeof (double)); }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcombineSeparateTileSamples16bits (uint8 *in[], uint8 *out, uint32 cols,                                  uint32 rows, uint32 imagewidth,                                   uint32 tw, uint16 spp, uint16 bps,  \t                          FILE *dumpfile, int format, int level)  {  int    ready_bits = 0;  uint32 src_rowsize, dst_rowsize;   uint32 bit_offset, src_offset;  uint32 row, col, src_byte = 0, src_bit = 0;  uint16 maskbits = 0, matchbits = 0;  uint16 buff1 = 0, buff2 = 0;  uint8  bytebuff = 0;  tsample_t s;  unsigned char *src = in[0];  unsigned char *dst = out;  char           action[8];  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"combineSeparateTileSamples16bits\",\"Invalid input or output buffer\");    return (1);    }  src_rowsize = ((bps * tw) + 7) / 8;  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;  maskbits = (uint16)-1 >> (16 - bps);  for (row = 0; row < rows; row++)    {    ready_bits = 0;    buff1 = buff2 = 0;    dst = out + (row * dst_rowsize);    src_offset = row * src_rowsize;    for (col = 0; col < cols; col++)      {            bit_offset = col * bps;      src_byte = bit_offset / 8;      src_bit  = bit_offset % 8;      matchbits = maskbits << (16 - src_bit - bps);       for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)        {\tsrc = in[s] + src_offset + src_byte;        if (little_endian)          buff1 = (src[0] << 8) | src[1];        else          buff1 = (src[1] << 8) | src[0];\tbuff1 = (buff1 & matchbits) << (src_bit);\t\tif (ready_bits >= 8)\t  {\t    bytebuff = (buff2 >> 8);\t    *dst++ = bytebuff;\t    ready_bits -= 8;\t    \t    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\t    strcpy (action, \"Flush\");\t  }\telse\t  { \t    bytebuff = 0;\t    buff2 = (buff2 | (buff1 >> ready_bits));\t    strcpy (action, \"Update\");\t  }\tready_bits += bps;\tif ((dumpfile != NULL) && (level == 3))\t  {\t  dump_info (dumpfile, format, \"\",\t\t       \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\t  dump_short (dumpfile, format, \"Match bits\", matchbits);\t  dump_data  (dumpfile, format, \"Src   bits\", src, 2);\t  dump_short (dumpfile, format, \"Buff1 bits\", buff1);\t  dump_short (dumpfile, format, \"Buff2 bits\", buff2);\t  dump_byte  (dumpfile, format, \"Write byte\", bytebuff);\t  dump_info  (dumpfile, format, \"\",\"Ready bits:  %d, %s\", ready_bits, action); \t  }\t}      }        if (ready_bits > 0)      {      bytebuff = (buff2 >> 8);      *dst++ = bytebuff;      if ((dumpfile != NULL) && (level == 3))\t{\tdump_info (dumpfile, format, \"\",\t\t       \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\t\t       row + 1, col + 1, src_byte, src_bit, dst - out);\tdump_byte (dumpfile, format, \"Final bits\", bytebuff);\t}      }    if ((dumpfile != NULL) && (level == 2))      {      dump_info (dumpfile, format, \"combineSeparateTileSamples16bits\",\"Output data\");      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));      }    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "extern int write(int fd, const char *buf, int nbytes){\t\treturn (nbytes - osgbpb_write((os_f) fd, (const byte*) buf, nbytes));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char* argv[]){    FILE* fd;    char* outputfile;    int c;#if !HAVE_DECL_OPTARG    extern int optind;    extern char* optarg;#endif    while ((c = getopt(argc, argv, \"c:s:bp\")) != -1)\tswitch (c) {\tcase 'c':\t    const_class = optarg;\t    break;\tcase 's':\t    storage_class = optarg;\t    break;\tcase 'p':\t    packoutput = 0;\t    break;\tcase 'b':\t    prebrace = \"{\";\t    postbrace = \"}\";\t    break;\tcase '?':\t    fprintf(stderr,\t\t\"usage: %s [-c const] [-s storage] [-p] [-b] file\\n\",\t\targv[0]);\t    return (-1);\t}    outputfile = optind < argc ? argv[optind] : \"g3states.h\";    fd = fopen(outputfile, \"w\");    if (fd == NULL) {\tfprintf(stderr, \"%s: %s: Cannot create output file.\\n\",\t    argv[0], outputfile);\treturn (-2);    }    FillTable(MainTable, 7, Pass, S_Pass);    FillTable(MainTable, 7, Horiz, S_Horiz);    FillTable(MainTable, 7, V0, S_V0);    FillTable(MainTable, 7, VR, S_VR);    FillTable(MainTable, 7, VL, S_VL);    FillTable(MainTable, 7, Ext, S_Ext);    FillTable(MainTable, 7, EOLV, S_EOL);    FillTable(WhiteTable, 12, MakeUpW, S_MakeUpW);    FillTable(WhiteTable, 12, MakeUp, S_MakeUp);    FillTable(WhiteTable, 12, TermW, S_TermW);    FillTable(WhiteTable, 12, EOLH, S_EOL);    FillTable(BlackTable, 13, MakeUpB, S_MakeUpB);    FillTable(BlackTable, 13, MakeUp, S_MakeUp);    FillTable(BlackTable, 13, TermB, S_TermB);    FillTable(BlackTable, 13, EOLH, S_EOL);    fprintf(fd, \"/* WARNING, this file was automatically generated by the\\n\");    fprintf(fd, \"    mkg3states program */\\n\");    fprintf(fd, \"#include \\\"tiff.h\\\"\\n\");    fprintf(fd, \"#include \\\"tif_fax3.h\\\"\\n\");    WriteTable(fd, MainTable, 128, \"TIFFFaxMainTable\");    WriteTable(fd, WhiteTable, 4096, \"TIFFFaxWhiteTable\");    WriteTable(fd, BlackTable, 8192, \"TIFFFaxBlackTable\");    fclose(fd);    return (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFCvtIEEEFloatToNative(TIFF* tif, u_int n, float* f){\tfloat_t* fp = (float_t*) f;\twhile (n-- > 0) {\t\tIEEEFLOAT2NATIVE(fp);\t\tfp++;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidacornWarningHandler(const char* module, const char* fmt, va_list ap){\tif (module != NULL)\t{\t\tfprintf(stderr, \"%s: \", module);\t}\tfprintf(stderr, \"Warning, \");\tvfprintf(stderr, fmt, ap);\tfprintf(stderr, \".\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tsize_t t2p_write_pdf(T2P* t2p, TIFF* input, TIFF* output){\ttsize_t written=0;\tttile_t i2=0;\ttsize_t streamlen=0;\tuint16 i=0;\tt2p_read_tiff_init(t2p, input);\tif(t2p->t2p_error!=T2P_ERR_OK){return(0);}\tt2p->pdf_xrefoffsets= (uint32*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_xrefcount,sizeof(uint32)) );\tif(t2p->pdf_xrefoffsets==NULL){\t\tTIFFError(\t\t\tTIFF2PDF_MODULE, \t\t\t\"Can't allocate %u bytes of memory for t2p_write_pdf\", \t\t\t(unsigned int) (t2p->pdf_xrefcount * sizeof(uint32)) );\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn(written);\t}\tt2p->pdf_xrefcount=0;\tt2p->pdf_catalog=1;\tt2p->pdf_info=2;\tt2p->pdf_pages=3;\twritten += t2p_write_pdf_header(t2p, output);\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\tt2p->pdf_catalog=t2p->pdf_xrefcount;\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\twritten += t2p_write_pdf_catalog(t2p, output);\twritten += t2p_write_pdf_obj_end(output);\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\tt2p->pdf_info=t2p->pdf_xrefcount;\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\twritten += t2p_write_pdf_info(t2p, input, output);\twritten += t2p_write_pdf_obj_end(output);\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\tt2p->pdf_pages=t2p->pdf_xrefcount;\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\twritten += t2p_write_pdf_pages(t2p, output);\twritten += t2p_write_pdf_obj_end(output);\tfor(t2p->pdf_page=0;t2p->pdf_page<t2p->tiff_pagecount;t2p->pdf_page++){\t\tt2p_read_tiff_data(t2p, input);\t\tif(t2p->t2p_error!=T2P_ERR_OK){return(0);}\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\twritten += t2p_write_pdf_page(t2p->pdf_xrefcount, t2p, output);\t\twritten += t2p_write_pdf_obj_end(output);\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\twritten += t2p_write_pdf_stream_dict_start(output);\t\twritten += t2p_write_pdf_stream_dict(0, t2p->pdf_xrefcount+1, output);\t\twritten += t2p_write_pdf_stream_dict_end(output);\t\twritten += t2p_write_pdf_stream_start(output);\t\tstreamlen=written;\t\twritten += t2p_write_pdf_page_content_stream(t2p, output);\t\tstreamlen=written-streamlen;\t\twritten += t2p_write_pdf_stream_end(output);\t\twritten += t2p_write_pdf_obj_end(output);\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\twritten += t2p_write_pdf_stream_length(streamlen, output);\t\twritten += t2p_write_pdf_obj_end(output);\t\tif(t2p->tiff_transferfunctioncount != 0){\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\t\twritten += t2p_write_pdf_transfer(t2p, output);\t\t\twritten += t2p_write_pdf_obj_end(output);\t\t\tfor(i=0; i < t2p->tiff_transferfunctioncount; i++){\t\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\t\t\t\twritten += t2p_write_pdf_transfer_dict(t2p, output, i);\t\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\t\t\t\twritten += t2p_write_pdf_stream_start(output);\t\t\t\t   \t\t\t\twritten += t2p_write_pdf_transfer_stream(t2p, output, i);\t\t\t\t   \t\t\t\twritten += t2p_write_pdf_stream_end(output);\t\t\t\twritten += t2p_write_pdf_obj_end(output);\t\t\t}\t\t}\t\tif( (t2p->pdf_colorspace & T2P_CS_PALETTE) != 0){\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\t\tt2p->pdf_palettecs=t2p->pdf_xrefcount;\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\t\t\twritten += t2p_write_pdf_stream_dict(t2p->pdf_palettesize, 0, output);\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\t\t\twritten += t2p_write_pdf_stream_start(output);\t\t\t   \t\t\twritten += t2p_write_pdf_xobject_palettecs_stream(t2p, output);\t\t\t   \t\t\twritten += t2p_write_pdf_stream_end(output);\t\t\twritten += t2p_write_pdf_obj_end(output);\t\t}\t\tif( (t2p->pdf_colorspace & T2P_CS_ICCBASED) != 0){\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\t\tt2p->pdf_icccs=t2p->pdf_xrefcount;\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\t\t\twritten += t2p_write_pdf_xobject_icccs_dict(t2p, output);\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\t\t\twritten += t2p_write_pdf_stream_start(output);\t\t\t   \t\t\twritten += t2p_write_pdf_xobject_icccs_stream(t2p, output);\t\t\t   \t\t\twritten += t2p_write_pdf_stream_end(output);\t\t\twritten += t2p_write_pdf_obj_end(output);\t\t}\t\tif(t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount !=0){\t\t\tfor(i2=0;i2<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;i2++){\t\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\t\t\t\twritten += t2p_write_pdf_xobject_stream_dict(\t\t\t\t\ti2+1, \t\t\t\t\tt2p, \t\t\t\t\toutput);\t\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\t\t\t\twritten += t2p_write_pdf_stream_start(output);\t\t\t\tstreamlen=written;\t\t\t\tt2p_read_tiff_size_tile(t2p, input, i2);\t\t\t\twritten += t2p_readwrite_pdf_image_tile(t2p, input, output, i2);\t\t\t\tt2p_write_advance_directory(t2p, output);\t\t\t\tif(t2p->t2p_error!=T2P_ERR_OK){return(0);}\t\t\t\tstreamlen=written-streamlen;\t\t\t\twritten += t2p_write_pdf_stream_end(output);\t\t\t\twritten += t2p_write_pdf_obj_end(output);\t\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\t\t\twritten += t2p_write_pdf_stream_length(streamlen, output);\t\t\t\twritten += t2p_write_pdf_obj_end(output);\t\t\t}\t\t} else {\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\t\t\twritten += t2p_write_pdf_xobject_stream_dict(\t\t\t\t0, \t\t\t\tt2p, \t\t\t\toutput);\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\t\t\twritten += t2p_write_pdf_stream_start(output);\t\t\tstreamlen=written;\t\t\tt2p_read_tiff_size(t2p, input);\t\t\twritten += t2p_readwrite_pdf_image(t2p, input, output);\t\t\tt2p_write_advance_directory(t2p, output);\t\t\tif(t2p->t2p_error!=T2P_ERR_OK){return(0);}\t\t\tstreamlen=written-streamlen;\t\t\twritten += t2p_write_pdf_stream_end(output);\t\t\twritten += t2p_write_pdf_obj_end(output);\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\t\twritten += t2p_write_pdf_stream_length(streamlen, output);\t\t\twritten += t2p_write_pdf_obj_end(output);\t\t}\t}\tt2p->pdf_startxref = written;\twritten += t2p_write_pdf_xreftable(t2p, output);\twritten += t2p_write_pdf_trailer(t2p, output);\tt2p_disable(output);\treturn(written);}",
        "label": 1,
        "cve": "CVE-2018-17795"
    },
    {
        "code": "static toff_t_tiffSizeProc(thandle_t fd){\t_TIFF_stat_s sb;\treturn (toff_t) (_TIFF_fstat_f((int) fd, &sb) < 0 ? 0 : sb.st_size);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteShortTable(TIFF* tif,    ttag_t tag, TIFFDirEntry* dir, uint32 n, uint16** table){\tuint32 i, off;\tdir->tdir_tag = tag;\tdir->tdir_type = (short) TIFF_SHORT;\t\tdir->tdir_count = (uint32) (1L<<tif->tif_dir.td_bitspersample);\toff = tif->tif_dataoff;\tfor (i = 0; i < n; i++)\t\tif (!TIFFWriteData(tif, dir, (char *)table[i]))\t\t\treturn (0);\tdir->tdir_count *= n;\tdir->tdir_offset = off;\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidsvRGBSeparate(TIFF* tif, uint32* ss, int xsize, int ysize){\ttsize_t stripsize = TIFFStripSize(tif);\tunsigned char *rbuf = (unsigned char *)_TIFFmalloc(3*stripsize);\tunsigned char *gbuf = rbuf + stripsize;\tunsigned char *bbuf = gbuf + stripsize;\tregister int y;\tfor (y = 0; y <= ysize; y += rowsperstrip) {\t\tunsigned char *rp, *gp, *bp;\t\tregister int x;\t\tregister uint32 n;\t\tn = rowsperstrip;\t\tif (n > ysize-y+1)\t\t\tn = ysize-y+1;\t\trp = rbuf; gp = gbuf; bp = bbuf;\t\tdo {\t\t\tfor (x = 0; x <= xsize; x++) {\t\t\t\tuint32 v = ss[x];\t\t\t\trp[x] = v;\t\t\t\tgp[x] = v >> 8;\t\t\t\tbp[x] = v >> 16;\t\t\t}\t\t\trp += xsize+1, gp += xsize+1, bp += xsize+1;\t\t\tss += xsize+1;\t\t} while (--n);\t\tif (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,0),\t\t    rbuf, stripsize) < 0)\t\t\tbreak;\t\tif (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,1),\t\t    gbuf, stripsize) < 0)\t\t\tbreak;\t\tif (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,2),\t\t    bbuf, stripsize) < 0)\t\t\tbreak;\t}\t_TIFFfree(rbuf);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidPredictorPrintDir(TIFF* tif, FILE* fd, long flags){\tTIFFPredictorState* sp = PredictorState(tif);\t(void) flags;\tif (TIFFFieldSet(tif,FIELD_PREDICTOR)) {\t\tfprintf(fd, \"  Predictor: \");\t\tswitch (sp->predictor) {\t\t\tcase 1: fprintf(fd, \"none \"); break;\t\t\tcase 2: fprintf(fd, \"horizontal differencing \"); break;\t\t\tcase 3: fprintf(fd, \"floating point predictor \"); break;\t\t}\t\tfprintf(fd, \"%d (0x%x)\\n\", sp->predictor, sp->predictor);\t}\tif (sp->printdir)\t\t(*sp->printdir)(tif, fd, flags);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff){\tstatic const char module[] = \"TIFFWriteDirectorySec\";\tuint32 ndir;\tTIFFDirEntry* dir;\tuint32 dirsize;\tvoid* dirmem;\tuint32 m;\tif (tif->tif_mode == O_RDONLY)\t\treturn (1);        _TIFFFillStriles( tif );        \t \tif (imagedone)\t{\t\tif (tif->tif_flags & TIFF_POSTENCODE)\t\t{\t\t\ttif->tif_flags &= ~TIFF_POSTENCODE;\t\t\tif (!(*tif->tif_postencode)(tif))\t\t\t{\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\t\t\t\t    \"Error post-encoding before directory write\");\t\t\t\treturn (0);\t\t\t}\t\t}\t\t(*tif->tif_close)(tif);        \t\t \t\tif (tif->tif_rawcc > 0 \t\t    && (tif->tif_flags & TIFF_BEENWRITING) != 0 )\t\t{\t\t    if( !TIFFFlushData1(tif) )                    {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"Error flushing data before directory write\");\t\t\treturn (0);                    }\t\t}\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata)\t\t{\t\t\t_TIFFfree(tif->tif_rawdata);\t\t\ttif->tif_rawdata = NULL;\t\t\ttif->tif_rawcc = 0;\t\t\ttif->tif_rawdatasize = 0;                        tif->tif_rawdataoff = 0;                        tif->tif_rawdataloaded = 0;\t\t}\t\ttif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP);\t}\tdir=NULL;\tdirmem=NULL;\tdirsize=0;\twhile (1)\t{\t\tndir=0;\t\tif (isimage)\t\t{\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGEWIDTH,tif->tif_dir.td_imagewidth))\t\t\t\t\tgoto bad;\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGELENGTH,tif->tif_dir.td_imagelength))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILEWIDTH,tif->tif_dir.td_tilewidth))\t\t\t\t\tgoto bad;\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILELENGTH,tif->tif_dir.td_tilelength))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XRESOLUTION,tif->tif_dir.td_xresolution))\t\t\t\t\tgoto bad;\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YRESOLUTION,tif->tif_dir.td_yresolution))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_POSITION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XPOSITION,tif->tif_dir.td_xposition))\t\t\t\t\tgoto bad;\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YPOSITION,tif->tif_dir.td_yposition))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SUBFILETYPE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_SUBFILETYPE,tif->tif_dir.td_subfiletype))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_BITSPERSAMPLE,tif->tif_dir.td_bitspersample))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_COMPRESSION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_COMPRESSION,tif->tif_dir.td_compression))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PHOTOMETRIC,tif->tif_dir.td_photometric))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_THRESHHOLDING,tif->tif_dir.td_threshholding))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_FILLORDER))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_FILLORDER,tif->tif_dir.td_fillorder))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_ORIENTATION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_ORIENTATION,tif->tif_dir.td_orientation))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_SAMPLESPERPIXEL,tif->tif_dir.td_samplesperpixel))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_ROWSPERSTRIP,tif->tif_dir.td_rowsperstrip))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MINSAMPLEVALUE,tif->tif_dir.td_minsamplevalue))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MAXSAMPLEVALUE,tif->tif_dir.td_maxsamplevalue))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_PLANARCONFIG))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PLANARCONFIG,tif->tif_dir.td_planarconfig))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_RESOLUTIONUNIT,tif->tif_dir.td_resolutionunit))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_PAGENUMBER))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_PAGENUMBER,2,&tif->tif_dir.td_pagenumber[0]))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPBYTECOUNTS))\t\t\t{\t\t\t\tif (!isTiled(tif))\t\t\t\t{\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\t\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\t\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPOFFSETS))\t\t\t{\t\t\t\tif (!isTiled(tif))\t\t\t\t{                                         if (tif->tif_dir.td_stripoffset != NULL &&                        !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))                        goto bad;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\t\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_COLORMAP))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_EXTRASAMPLES))\t\t\t{\t\t\t\tif (tif->tif_dir.td_extrasamples)\t\t\t\t{\t\t\t\t\tuint16 na;\t\t\t\t\tuint16* nb;\t\t\t\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb);\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb))\t\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDEPTH))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_TILEDEPTH,tif->tif_dir.td_tiledepth))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_HALFTONEHINTS,2,&tif->tif_dir.td_halftonehints[0]))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_YCBCRSUBSAMPLING,2,&tif->tif_dir.td_ycbcrsubsampling[0]))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_YCBCRPOSITIONING,tif->tif_dir.td_ycbcrpositioning))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_REFBLACKWHITE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,TIFFTAG_REFERENCEBLACKWHITE,6,tif->tif_dir.td_refblackwhite))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagTransferfunction(tif,&ndir,dir))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_INKNAMES))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir))\t\t\t\t\tgoto bad;\t\t\t}\t\t\t{\t\t\t\tuint32 n;\t\t\t\tfor (n=0; n<tif->tif_nfields; n++) {\t\t\t\t\tconst TIFFField* o;\t\t\t\t\to = tif->tif_fields[n];\t\t\t\t\tif ((o->field_bit>=FIELD_CODEC)&&(TIFFFieldSet(tif,o->field_bit)))\t\t\t\t\t{\t\t\t\t\t\tswitch (o->get_field_type)\t\t\t\t\t\t{\t\t\t\t\t\t\tcase TIFF_SETGET_ASCII:\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tuint32 pa;\t\t\t\t\t\t\t\t\tchar* pb;\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_ASCII);\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE);\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pb);\t\t\t\t\t\t\t\t\tpa=(uint32)(strlen(pb));\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\t\t\t\t\t\t\t\t\t\tgoto bad;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SETGET_UINT16:\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tuint16 p;\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_SHORT);\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p))\t\t\t\t\t\t\t\t\t\tgoto bad;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SETGET_UINT32:\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tuint32 p;\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_LONG);\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p))\t\t\t\t\t\t\t\t\t\tgoto bad;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SETGET_C32_UINT8:\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tuint32 pa;\t\t\t\t\t\t\t\t\tvoid* pb;\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_UNDEFINED);\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE2);\t\t\t\t\t\t\t\t\tassert(o->field_passcount==1);\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pa,&pb);\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\t\t\t\t\t\t\t\t\t\tgoto bad;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tdefault:\t\t\t\t\t\t\t\tassert(0);    \t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\tfor (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++)\t\t{                        uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag;                        uint32 count = tif->tif_dir.td_customValues[m].count;\t\t\tswitch (tif->tif_dir.td_customValues[m].info->field_type)\t\t\t{\t\t\t\tcase TIFF_ASCII:\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_UNDEFINED:\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_BYTE:\t\t\t\t\tif (!TIFFWriteDirectoryTagByteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SBYTE:\t\t\t\t\tif (!TIFFWriteDirectoryTagSbyteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SHORT:\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SSHORT:\t\t\t\t\tif (!TIFFWriteDirectoryTagSshortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_LONG:\t\t\t\t\tif (!TIFFWriteDirectoryTagLongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SLONG:\t\t\t\t\tif (!TIFFWriteDirectoryTagSlongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_LONG8:\t\t\t\t\tif (!TIFFWriteDirectoryTagLong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SLONG8:\t\t\t\t\tif (!TIFFWriteDirectoryTagSlong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_RATIONAL:\t\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SRATIONAL:\t\t\t\t\tif (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_FLOAT:\t\t\t\t\tif (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_DOUBLE:\t\t\t\t\tif (!TIFFWriteDirectoryTagDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_IFD:\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_IFD8:\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdIfd8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tdefault:\t\t\t\t\tassert(0);    \t\t\t\t\tbreak;\t\t\t}\t\t}\t\tif (dir!=NULL)\t\t\tbreak;\t\tdir=_TIFFmalloc(ndir*sizeof(TIFFDirEntry));\t\tif (dir==NULL)\t\t{\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\t\t\tgoto bad;\t\t}\t\tif (isimage)\t\t{\t\t\tif ((tif->tif_diroff==0)&&(!TIFFLinkDirectory(tif)))\t\t\t\tgoto bad;\t\t}\t\telse\t\t\ttif->tif_diroff=(TIFFSeekFile(tif,0,SEEK_END)+1)&(~((toff_t)1));\t\tif (pdiroff!=NULL)\t\t\t*pdiroff=tif->tif_diroff;\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t\t\tdirsize=2+ndir*12+4;\t\telse\t\t\tdirsize=8+ndir*20+8;\t\ttif->tif_dataoff=tif->tif_diroff+dirsize;\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t\t\ttif->tif_dataoff=(uint32)tif->tif_dataoff;\t\tif ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize))\t\t{\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\");\t\t\tgoto bad;\t\t}\t\tif (tif->tif_dataoff&1)\t\t\ttif->tif_dataoff++;\t\tif (isimage)\t\t\ttif->tif_curdir++;\t}\tif (isimage)\t{\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0))\t\t{\t\t\tuint32 na;\t\t\tTIFFDirEntry* nb;\t\t\tfor (na=0, nb=dir; ; na++, nb++)\t\t\t{\t\t\t\tif( na == ndir )                                {                                    TIFFErrorExt(tif->tif_clientdata,module,                                                 \"Cannot find SubIFD tag\");                                    goto bad;                                }\t\t\t\tif (nb->tdir_tag==TIFFTAG_SUBIFD)\t\t\t\t\tbreak;\t\t\t}\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+2+na*12+8;\t\t\telse\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+8+na*20+12;\t\t}\t}\tdirmem=_TIFFmalloc(dirsize);\tif (dirmem==NULL)\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\t\tgoto bad;\t}\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t{\t\tuint8* n;\t\tuint32 nTmp;\t\tTIFFDirEntry* o;\t\tn=dirmem;\t\t*(uint16*)n=(uint16)ndir;\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabShort((uint16*)n);\t\tn+=2;\t\to=dir;\t\tfor (m=0; m<ndir; m++)\t\t{\t\t\t*(uint16*)n=o->tdir_tag;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabShort((uint16*)n);\t\t\tn+=2;\t\t\t*(uint16*)n=o->tdir_type;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabShort((uint16*)n);\t\t\tn+=2;\t\t\tnTmp = (uint32)o->tdir_count;\t\t\t_TIFFmemcpy(n,&nTmp,4);\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabLong((uint32*)n);\t\t\tn+=4;\t\t\t \t\t\t \t\t\t_TIFFmemcpy(n,&o->tdir_offset,4);\t\t\tn+=4;\t\t\to++;\t\t}\t\tnTmp = (uint32)tif->tif_nextdiroff;\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabLong(&nTmp);\t\t_TIFFmemcpy(n,&nTmp,4);\t}\telse\t{\t\tuint8* n;\t\tTIFFDirEntry* o;\t\tn=dirmem;\t\t*(uint64*)n=ndir;\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabLong8((uint64*)n);\t\tn+=8;\t\to=dir;\t\tfor (m=0; m<ndir; m++)\t\t{\t\t\t*(uint16*)n=o->tdir_tag;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabShort((uint16*)n);\t\t\tn+=2;\t\t\t*(uint16*)n=o->tdir_type;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabShort((uint16*)n);\t\t\tn+=2;\t\t\t_TIFFmemcpy(n,&o->tdir_count,8);\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabLong8((uint64*)n);\t\t\tn+=8;\t\t\t_TIFFmemcpy(n,&o->tdir_offset,8);\t\t\tn+=8;\t\t\to++;\t\t}\t\t_TIFFmemcpy(n,&tif->tif_nextdiroff,8);\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabLong8((uint64*)n);\t}\t_TIFFfree(dir);\tdir=NULL;\tif (!SeekOK(tif,tif->tif_diroff))\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\t\tgoto bad;\t}\tif (!WriteOK(tif,dirmem,(tmsize_t)dirsize))\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\t\tgoto bad;\t}\t_TIFFfree(dirmem);\tif (imagedone)\t{\t\tTIFFFreeDirectory(tif);\t\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\t\ttif->tif_flags &= ~TIFF_DIRTYSTRIP;\t\t(*tif->tif_cleanup)(tif);\t\t \t\tTIFFCreateDirectory(tif);\t}\treturn(1);bad:\tif (dir!=NULL)\t\t_TIFFfree(dir);\tif (dirmem!=NULL)\t\t_TIFFfree(dirmem);\treturn(0);}",
        "label": 1,
        "cve": "CVE-2018-19210"
    },
    {
        "code": "static inthorAcc16(TIFF* tif, uint8* cp0, tmsize_t cc){\ttmsize_t stride = PredictorState(tif)->stride;\tuint16* wp = (uint16*) cp0;\ttmsize_t wc = cc / 2;    if((cc%(2*stride))!=0)    {        TIFFErrorExt(tif->tif_clientdata, \"horAcc16\",                     \"%s\", \"cc%(2*stride))!=0\");        return 0;    }\tif (wc > stride) {\t\twc -= stride;\t\tdo {\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++)\t\t\twc -= stride;\t\t} while (wc > 0);\t}\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFCreateDirectory(TIFF* tif){    TIFFDefaultDirectory(tif);    tif->tif_diroff = 0;    tif->tif_nextdiroff = 0;    tif->tif_curoff = 0;    tif->tif_row = (uint32) -1;    tif->tif_curstrip = (tstrip_t) -1;    return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFmemcpy(tdata_t d, const tdata_t s, tsize_t c){\tmemcpy(d, s, (size_t) c);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void*_TIFFmalloc(tsize_t s){\treturn (malloc((size_t) s));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFReadRawData(TIFF* tif, int bitrev){\ttstrip_t nstrips = TIFFNumberOfStrips(tif);\tconst char* what = TIFFIsTiled(tif) ? \"Tile\" : \"Strip\";\tuint64* stripbc;\tTIFFGetField(tif, TIFFTAG_STRIPBYTECOUNTS, &stripbc);\tif (nstrips > 0) {\t\tuint32 bufsize = stripbc[0];\t\ttdata_t buf = _TIFFmalloc(bufsize);\t\ttstrip_t s;\t\tfor (s = 0; s < nstrips; s++) {\t\t\tif (stripbc[s] > bufsize) {\t\t\t\tbuf = _TIFFrealloc(buf, stripbc[s]);\t\t\t\tbufsize = stripbc[s];\t\t\t}\t\t\tif (buf == NULL) {\t\t\t\tfprintf(stderr,\t\t\t\t   \"Cannot allocate buffer to read strip %lu\\n\",\t\t\t\t    (unsigned long) s);\t\t\t\tbreak;\t\t\t}\t\t\tif (TIFFReadRawStrip(tif, s, buf, stripbc[s]) < 0) {\t\t\t\tfprintf(stderr, \"Error reading strip %lu\\n\",\t\t\t\t    (unsigned long) s);\t\t\t\tif (stoponerr)\t\t\t\t\tbreak;\t\t\t} else if (showdata) {\t\t\t\tif (bitrev) {\t\t\t\t\tTIFFReverseBits(buf, stripbc[s]);\t\t\t\t\tprintf(\"%s %lu: (bit reversed)\\n \",\t\t\t\t\t    what, (unsigned long) s);\t\t\t\t} else\t\t\t\t\tprintf(\"%s %lu:\\n \", what,\t\t\t\t\t    (unsigned long) s);\t\t\t\tif (showwords)\t\t\t\t\tShowRawWords((uint16*) buf, stripbc[s]>>1);\t\t\t\telse\t\t\t\t\tShowRawBytes((unsigned char*) buf, stripbc[s]);\t\t\t}\t\t}\t\tif (buf != NULL)\t\t\t_TIFFfree(buf);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidprintruns(unsigned char* buf, uint32* runs, uint32* erun, uint32 lastx){    static struct {\tchar white, black;\tunsigned short width;    } WBarr[] = {\t{ 'd', 'n', 512 }, { 'e', 'o', 256 }, { 'f', 'p', 128 },\t{ 'g', 'q',  64 }, { 'h', 'r',  32 }, { 'i', 's',  16 },\t{ 'j', 't',   8 }, { 'k', 'u',   4 }, { 'l', 'v',   2 },\t{ 'm', 'w',   1 }    };    static char* svalue =\t\" !\\\"#$&'*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abc\";    int colormode = 1;\t\t    uint32 runlength = 0;    int n = maxline;    uint32 x = 0;    int l;    (void) buf;    printf(\"%d m(\", row++);    while (runs < erun) {\tif (runlength <= 0) {\t    colormode ^= 1;\t    runlength = *runs++;\t    if (x+runlength > lastx)\t\trunlength = runs[-1] = lastx-x;\t    x += runlength;\t    if (!colormode && runs == erun)\t\t\tbreak;\t\t\t}\t\tl = 0;\twhile (runlength > 6) {\t\t    if (runlength >= WBarr[l].width) {\t\tif (n == 0) {\t\t    putchar('\\n');\t\t    n = maxline;\t\t}\t\tputchar(colormode ? WBarr[l].black : WBarr[l].white), n--;\t\trunlength -= WBarr[l].width;\t    } else\t\tl++;\t}\twhile (runlength > 0 && runlength <= 6) {\t    uint32 bitsleft = 6;\t    int t = 0;\t    while (bitsleft) {\t\tif (runlength <= bitsleft) {\t\t    if (colormode)\t\t\tt |= ((1 << runlength)-1) << (bitsleft-runlength);\t\t    bitsleft -= runlength;\t\t    runlength = 0;\t\t    if (bitsleft) {\t\t\tif (runs >= erun)\t\t\t    break;\t\t\tcolormode ^= 1;\t\t\trunlength = *runs++;\t\t\tif (x+runlength > lastx)\t\t\t    runlength = runs[-1] = lastx-x;\t\t\tx += runlength;\t\t    }\t\t} else {\t\t\t\t    if (colormode)\t\t\tt |= ((1 << bitsleft)-1);\t\t    runlength -= bitsleft;\t\t    bitsleft = 0;\t\t}\t    }\t    if (n == 0) {\t\tputchar('\\n');\t\tn = maxline;\t    }\t    putchar(svalue[t]), n--;\t}    }    printf(\")s\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intCheckLongField(TIFF *tif, const ttag_t field, const uint32 value){\tuint32 tmp = 123;\tif (!TIFFGetField(tif, field, &tmp)) {\t\tfprintf (stderr, \"Problem fetching tag %lu.\\n\",\t\t\t (unsigned long) field);\t\treturn -1;\t}\tif (tmp != value) {\t\tfprintf (stderr, \"Wrong LONG value fetched for tag %lu.\\n\",\t\t\t (unsigned long) field);\t\treturn -1;\t}\treturn 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*TIFFOpen(const char* name, const char* mode){\tstatic const char module[] = \"TIFFOpen\";\tStr255 pname;\tFInfo finfo;\tshort fref;\tOSErr err;\tFSSpec\tfSpec;\tstrcpy((char*) pname, name);\tourc2pstr((char*) pname);\terr = FSMakeFSSpec( 0, 0, pname, &fSpec );\tswitch (_TIFFgetMode(mode, module)) {\tdefault:\t\treturn ((TIFF*) 0);\tcase O_RDWR | O_CREAT | O_TRUNC:\t\tif (FSpGetFInfo(&fSpec, &finfo) == noErr)\t\t\tFSpDelete(&fSpec);\t\t\tcase O_RDWR | O_CREAT:\t\tif ((err = FSpGetFInfo(&fSpec, &finfo)) == fnfErr) {\t\t\tif (FSpCreate(&fSpec, '    ', 'TIFF', smSystemScript) != noErr)\t\t\t\tgoto badCreate;\t\t\tif (FSpOpenDF(&fSpec, fsRdWrPerm, &fref) != noErr)\t\t\t\tgoto badOpen;\t\t} else if (err == noErr) {\t\t\tif (FSpOpenDF(&fSpec, fsRdWrPerm, &fref) != noErr)\t\t\t\tgoto badOpen;\t\t} else\t\t\tgoto badOpen;\t\tbreak;\tcase O_RDONLY:\t\tif (FSpOpenDF(&fSpec, fsRdPerm, &fref) != noErr)\t\t\tgoto badOpen;\t\tbreak;\tcase O_RDWR:\t\tif (FSpOpenDF(&fSpec, fsRdWrPerm, &fref) != noErr)\t\t\tgoto badOpen;\t\tbreak;\t}\treturn (TIFFFdOpen((int) fref, name, mode));badCreate:\tTIFFErrorExt(0, module, \"%s: Cannot create\", name);\treturn ((TIFF*) 0);badOpen:\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\treturn ((TIFF*) 0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidXTIFFClose(TIFF *tif){\txtiff *xt = XTIFFDIR(tif);\t\tTIFFClose(tif);\t\t_XTIFFFreeDirectory(xt);\t_TIFFfree(xt);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intextractContigSamples24bits (uint8 *in, uint8 *out, uint32 cols, \t                    tsample_t sample, uint16 spp, uint16 bps,                             tsample_t count, uint32 start, uint32 end)  {  int    ready_bits = 0, sindex = 0;  uint32 col, src_byte, src_bit, bit_offset;  uint32 maskbits = 0, matchbits = 0;  uint32 buff1 = 0, buff2 = 0;  uint8  bytebuff1 = 0, bytebuff2 = 0;  uint8 *src = in;  uint8 *dst = out;  if ((in == NULL) || (out == NULL))    {    TIFFError(\"extractContigSamples24bits\",\"Invalid input or output buffer\");    return (1);    }  if ((start > end) || (start > cols))    {    TIFFError (\"extractContigSamples24bits\",                \"Invalid start column value %d ignored\", start);    start = 0;    }  if ((end == 0) || (end > cols))    {    TIFFError (\"extractContigSamples24bits\",                \"Invalid end column value %d ignored\", end);    end = cols;    }  ready_bits = 0;  maskbits =  (uint32)-1 >> ( 32 - bps);  for (col = start; col < end; col++)    {        bit_offset = col * bps * spp;    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)      {      if (sindex == 0)        {        src_byte = bit_offset / 8;        src_bit  = bit_offset % 8;        }      else        {        src_byte = (bit_offset + (sindex * bps)) / 8;        src_bit  = (bit_offset + (sindex * bps)) % 8;        }      src = in + src_byte;      matchbits = maskbits << (32 - src_bit - bps);       if (little_endian)\tbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];      else\tbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];      buff1 = (buff1 & matchbits) << (src_bit);      if (ready_bits < 16)         {        bytebuff1 = bytebuff2 = 0;        buff2 = (buff2 | (buff1 >> ready_bits));        }      else         {        bytebuff1 = (buff2 >> 24);        *dst++ = bytebuff1;        bytebuff2 = (buff2 >> 16);        *dst++ = bytebuff2;        ready_bits -= 16;                buff2 = ((buff2 << 16) | (buff1 >> ready_bits));        }      ready_bits += bps;      }    }    while (ready_bits > 0)    {    bytebuff1 = (buff2 >> 24);    *dst++ = bytebuff1;    buff2 = (buff2 << 8);    bytebuff2 = bytebuff1;    ready_bits -= 8;    }   return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int JBIGEncode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s){\tTIFFDirectory* dir = &tif->tif_dir;\tstruct jbg_enc_state encoder;\t(void) size, (void) s;\tjbg_enc_init(&encoder,\t\t     dir->td_imagewidth,\t\t     dir->td_imagelength,\t\t     1,\t\t     &buffer,\t\t     JBIGOutputBie,\t\t     tif);\t\tjbg_enc_out(&encoder);\tjbg_enc_free(&encoder);\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFNoDecode(TIFF* tif, const char* method){\tconst TIFFCodec* c = TIFFFindCODEC(tif->tif_dir.td_compression);\tif (c)\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\t     \"%s %s decoding is not implemented\",\t\t\t     c->name, method);\telse\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\t     \"Compression scheme %u %s decoding is not implemented\",\t\t\t     tif->tif_dir.td_compression, method);\treturn (-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(void){\tchar buf[BUFSIZ];\tint i;\tsetbuf(stderr, buf);        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\tfor (i = 0; stuff[i] != NULL; i++)\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\texit(-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidtiffinfo(TIFF* tif, uint16 order, long flags, int is_image){\tTIFFPrintDirectory(tif, stdout, flags);\tif (!readdata || !is_image)\t\treturn;\tif (rawdata) {\t\tif (order) {\t\t\tuint16 o;\t\t\tTIFFGetFieldDefaulted(tif,\t\t\t    TIFFTAG_FILLORDER, &o);\t\t\tTIFFReadRawData(tif, o != order);\t\t} else\t\t\tTIFFReadRawData(tif, 0);\t} else {\t\tif (order)\t\t\tTIFFSetField(tif, TIFFTAG_FILLORDER, order);\t\tTIFFReadData(tif);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void JBIGOutputBie(unsigned char* buffer, size_t len, void* userData){\tTIFF* tif = (TIFF*)userData;\tif (isFillOrder(tif, tif->tif_dir.td_fillorder))\t{\t\tTIFFReverseBits(buffer, (tmsize_t)len);\t}\tJBIGCopyEncodedData(tif, buffer, len, 0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFprintAscii(FILE* fd, const char* cp){\t_TIFFprintAsciiBounded( fd, cp, strlen(cp));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tmsize_t t2pReadFile(TIFF *tif, tdata_t data, tmsize_t size){\tthandle_t client = TIFFClientdata(tif);\tTIFFReadWriteProc proc = TIFFGetReadProc(tif);\tif (proc)\t\treturn proc(client, data, size);\treturn -1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*TIFFOpen(const char* name, const char* mode){\tstatic const char module[] = \"TIFFOpen\";\tthandle_t fd;\tint m;\tDWORD dwMode;\tTIFF* tif;\tm = _TIFFgetMode(mode, module);\tswitch(m)\t{\tcase O_RDONLY:\t\tdwMode = OPEN_EXISTING;\t\tbreak;\tcase O_RDWR:\t\tdwMode = OPEN_ALWAYS;\t\tbreak;\tcase O_RDWR|O_CREAT:\t\tdwMode = OPEN_ALWAYS;\t\tbreak;\tcase O_RDWR|O_TRUNC:\t\tdwMode = CREATE_ALWAYS;\t\tbreak;\tcase O_RDWR|O_CREAT|O_TRUNC:\t\tdwMode = CREATE_ALWAYS;\t\tbreak;\tdefault:\t\treturn ((TIFF*)0);\t}\tfd = (thandle_t)CreateFileA(name,\t\t(m == O_RDONLY)?GENERIC_READ:(GENERIC_READ | GENERIC_WRITE),\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, dwMode,\t\t(m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL,\t\tNULL);\tif (fd == INVALID_HANDLE_VALUE) {\t\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\t\treturn ((TIFF *)0);\t}\ttif = TIFFFdOpen((int)fd, name, mode);\tif(!tif)\t\tCloseHandle(fd);\treturn tif;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tsize_t t2p_readwrite_pdf_image(T2P* t2p, TIFF* input, TIFF* output){\ttsize_t written=0;\tunsigned char* buffer=NULL;\tunsigned char* samplebuffer=NULL;\ttsize_t bufferoffset=0;\ttsize_t samplebufferoffset=0;\ttsize_t read=0;\ttstrip_t i=0;\ttstrip_t j=0;\ttstrip_t stripcount=0;\ttsize_t stripsize=0;\ttsize_t sepstripcount=0;\ttsize_t sepstripsize=0;#ifdef OJPEG_SUPPORT\ttoff_t inputoffset=0;\tuint16 h_samp=1;\tuint16 v_samp=1;\tuint16 ri=1;\tuint32 rows=0;#endif#ifdef JPEG_SUPPORT\tunsigned char* jpt;\tfloat* xfloatp;\tuint64* sbc;\tunsigned char* stripbuffer;\ttsize_t striplength=0;\tuint32 max_striplength=0;#endif\t\tif (t2p->t2p_error != T2P_ERR_OK)\t\treturn(0);\tif(t2p->pdf_transcode == T2P_TRANSCODE_RAW){#ifdef CCITT_SUPPORT\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\t\t\tbuffer = (unsigned char*)\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\t\t\tif (buffer == NULL) {\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tTIFFReadRawStrip(input, 0, (tdata_t) buffer,\t\t\t\t\t t2p->tiff_datasize);\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\t\t\t\t\t\t\t\t\t\tTIFFReverseBits(buffer,\t\t\t\t\t\t\tt2p->tiff_datasize);\t\t\t}\t\t\tt2pWriteFile(output, (tdata_t) buffer,\t\t\t\t      t2p->tiff_datasize);\t\t\t_TIFFfree(buffer);\t\t\treturn(t2p->tiff_datasize);\t\t}#endif#ifdef ZIP_SUPPORT\t\tif (t2p->pdf_compression == T2P_COMPRESS_ZIP) {\t\t\tbuffer = (unsigned char*)\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\t\t\tif(buffer == NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}                        memset(buffer, 0, t2p->tiff_datasize);\t\t\tTIFFReadRawStrip(input, 0, (tdata_t) buffer,\t\t\t\t\t t2p->tiff_datasize);\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB) {\t\t\t\t\tTIFFReverseBits(buffer,\t\t\t\t\t\t\tt2p->tiff_datasize);\t\t\t}\t\t\tt2pWriteFile(output, (tdata_t) buffer,\t\t\t\t      t2p->tiff_datasize);\t\t\t_TIFFfree(buffer);\t\t\treturn(t2p->tiff_datasize);\t\t}#endif#ifdef OJPEG_SUPPORT\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG) {\t\t\tif(t2p->tiff_dataoffset != 0) {\t\t\t\tbuffer = (unsigned char*)\t\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\t\t\t\tif(buffer == NULL) {\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \t\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\t\tTIFFFileName(input));\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\t\treturn(0);\t\t\t\t}                                memset(buffer, 0, t2p->tiff_datasize);\t\t\t\tif(t2p->pdf_ojpegiflength==0){\t\t\t\t\tinputoffset=t2pSeekFile(input, 0,\t\t\t\t\t\t\t\t SEEK_CUR);\t\t\t\t\tt2pSeekFile(input,\t\t\t\t\t\t     t2p->tiff_dataoffset,\t\t\t\t\t\t     SEEK_SET);\t\t\t\t\tt2pReadFile(input, (tdata_t) buffer,\t\t\t\t\t\t     t2p->tiff_datasize);\t\t\t\t\tt2pSeekFile(input, inputoffset,\t\t\t\t\t\t     SEEK_SET);\t\t\t\t\tt2pWriteFile(output, (tdata_t) buffer,\t\t\t\t\t\t      t2p->tiff_datasize);\t\t\t\t\t_TIFFfree(buffer);\t\t\t\t\treturn(t2p->tiff_datasize);\t\t\t\t} else {\t\t\t\t\tinputoffset=t2pSeekFile(input, 0,\t\t\t\t\t\t\t\t SEEK_CUR);\t\t\t\t\tt2pSeekFile(input,\t\t\t\t\t\t     t2p->tiff_dataoffset,\t\t\t\t\t\t     SEEK_SET);\t\t\t\t\tbufferoffset = t2pReadFile(input,\t\t\t\t\t\t(tdata_t) buffer,\t\t\t\t\t\tt2p->pdf_ojpegiflength);\t\t\t\t\tt2p->pdf_ojpegiflength = 0;\t\t\t\t\tt2pSeekFile(input, inputoffset,\t\t\t\t\t\t     SEEK_SET);\t\t\t\t\tTIFFGetField(input,\t\t\t\t\t\t     TIFFTAG_YCBCRSUBSAMPLING,\t\t\t\t\t\t     &h_samp, &v_samp);\t\t\t\t\tbuffer[bufferoffset++]= 0xff;\t\t\t\t\tbuffer[bufferoffset++]= 0xdd;\t\t\t\t\tbuffer[bufferoffset++]= 0x00;\t\t\t\t\tbuffer[bufferoffset++]= 0x04;\t\t\t\t\th_samp*=8;\t\t\t\t\tv_samp*=8;\t\t\t\t\tri=(t2p->tiff_width+h_samp-1) / h_samp;\t\t\t\t\tTIFFGetField(input,\t\t\t\t\t\t     TIFFTAG_ROWSPERSTRIP,\t\t\t\t\t\t     &rows);\t\t\t\t\tri*=(rows+v_samp-1)/v_samp;\t\t\t\t\tbuffer[bufferoffset++]= (ri>>8) & 0xff;\t\t\t\t\tbuffer[bufferoffset++]= ri & 0xff;\t\t\t\t\tstripcount=TIFFNumberOfStrips(input);\t\t\t\t\tfor(i=0;i<stripcount;i++){\t\t\t\t\t\tif(i != 0 ){ \t\t\t\t\t\t\tbuffer[bufferoffset++]=0xff;\t\t\t\t\t\t\tbuffer[bufferoffset++]=(0xd0 | ((i-1)%8));\t\t\t\t\t\t}\t\t\t\t\t\tbufferoffset+=TIFFReadRawStrip(input, \t\t\t\t\t\t\ti, \t\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \t\t\t\t\t\t\t-1);\t\t\t\t\t}\t\t\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\t\t\t\t\t_TIFFfree(buffer);\t\t\t\t\treturn(bufferoffset);\t\t\t\t}\t\t\t} else {\t\t\t\tif(! t2p->pdf_ojpegdata){\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\"No support for OJPEG image %s with bad tables\", \t\t\t\t\t\tTIFFFileName(input));\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t\tbuffer = (unsigned char*)\t\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\t\t\t\tif(buffer==NULL){\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \t\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\t\tTIFFFileName(input));\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\t\treturn(0);\t\t\t\t}                                memset(buffer, 0, t2p->tiff_datasize);\t\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\t\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\t\t\t\tstripcount=TIFFNumberOfStrips(input);\t\t\t\tfor(i=0;i<stripcount;i++){\t\t\t\t\tif(i != 0){\t\t\t\t\t\tbuffer[bufferoffset++]=0xff;\t\t\t\t\t\tbuffer[bufferoffset++]=(0xd0 | ((i-1)%8));\t\t\t\t\t}\t\t\t\t\tbufferoffset+=TIFFReadRawStrip(input, \t\t\t\t\t\ti, \t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \t\t\t\t\t\t-1);\t\t\t\t}\t\t\t\tif( ! ( (buffer[bufferoffset-1]==0xd9) && (buffer[bufferoffset-2]==0xff) ) ){\t\t\t\t\t\tbuffer[bufferoffset++]=0xff;\t\t\t\t\t\tbuffer[bufferoffset++]=0xd9;\t\t\t\t}\t\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\t\t\t\t_TIFFfree(buffer);\t\t\t\treturn(bufferoffset);\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\"No support for OJPEG image %s with no JPEG File Interchange offset\", \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\treturn(t2p->tiff_datasize);\t\t}#endif#ifdef JPEG_SUPPORT\t\tif(t2p->tiff_compression == COMPRESSION_JPEG) {\t\t\tuint32 count = 0;\t\t\tbuffer = (unsigned char*)\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\t\t\tif(buffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}                        memset(buffer, 0, t2p->tiff_datasize);\t\t\tif (TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\t\t\t\tif(count > 4) {\t\t\t\t\t_TIFFmemcpy(buffer, jpt, count);\t\t\t\t\tbufferoffset += count - 2;\t\t\t\t}\t\t\t}\t\t\tstripcount=TIFFNumberOfStrips(input);\t\t\tTIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);\t\t\tfor(i=0;i<stripcount;i++){\t\t\t\tif(sbc[i]>max_striplength) max_striplength=sbc[i];\t\t\t}\t\t\tstripbuffer = (unsigned char*)\t\t\t\t_TIFFmalloc(max_striplength);\t\t\tif(stripbuffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\"Can't allocate %u bytes of memory for t2p_readwrite_pdf_image, %s\", \t\t\t\t\tmax_striplength, \t\t\t\t\tTIFFFileName(input));\t\t\t\t_TIFFfree(buffer);\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tfor(i=0;i<stripcount;i++){\t\t\t\tstriplength=TIFFReadRawStrip(input, i, (tdata_t) stripbuffer, -1);\t\t\t\tif(!t2p_process_jpeg_strip(\t\t\t\t\tstripbuffer, \t\t\t\t\t&striplength, \t\t\t\t\tbuffer, \t\t\t\t\t&bufferoffset, \t\t\t\t\ti, \t\t\t\t\tt2p->tiff_length)){\t\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\"Can't process JPEG data in input file %s\", \t\t\t\t\t\t\tTIFFFileName(input));\t\t\t\t\t\t_TIFFfree(samplebuffer);\t\t\t\t\t\t_TIFFfree(buffer);\t\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbuffer[bufferoffset++]=0xff; \t\t\tbuffer[bufferoffset++]=0xd9;\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\t\t\t_TIFFfree(stripbuffer);\t\t\t_TIFFfree(buffer);\t\t\treturn(bufferoffset);\t\t}#endif\t\t(void)0;\t}\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\tif(buffer==NULL){\t\t\tTIFFError(TIFF2PDF_MODULE, \t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\tTIFFFileName(input));\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\treturn(0);\t\t}                memset(buffer, 0, t2p->tiff_datasize);\t\tstripsize=TIFFStripSize(input);\t\tstripcount=TIFFNumberOfStrips(input);\t\tfor(i=0;i<stripcount;i++){\t\t\tread = \t\t\t\tTIFFReadEncodedStrip(input, \t\t\t\ti, \t\t\t\t(tdata_t) &buffer[bufferoffset], \t\t\t\tstripsize);\t\t\tif(read==-1){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Error on decoding strip %u of %s\", \t\t\t\t\ti, \t\t\t\t\tTIFFFileName(input));\t\t\t\t_TIFFfree(buffer);\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tbufferoffset+=read;\t\t}\t} else {\t\tif(t2p->pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\t\t\t\t\tsepstripsize=TIFFStripSize(input);\t\t\tsepstripcount=TIFFNumberOfStrips(input);\t\t\t\t\tstripsize=sepstripsize*t2p->tiff_samplesperpixel;\t\t\tstripcount=sepstripcount/t2p->tiff_samplesperpixel;\t\t\t\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\t\tif(buffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}                        memset(buffer, 0, t2p->tiff_datasize);\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(stripsize);\t\t\tif(samplebuffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tfor(i=0;i<stripcount;i++){\t\t\t\tsamplebufferoffset=0;\t\t\t\tfor(j=0;j<t2p->tiff_samplesperpixel;j++){\t\t\t\t\tread = \t\t\t\t\t\tTIFFReadEncodedStrip(input, \t\t\t\t\t\t\ti + j*stripcount, \t\t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \t\t\t\t\t\t\tsepstripsize);\t\t\t\t\tif(read==-1){\t\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Error on decoding strip %u of %s\", \t\t\t\t\t\t\ti + j*stripcount, \t\t\t\t\t\t\tTIFFFileName(input));\t\t\t\t\t\t\t_TIFFfree(buffer);\t\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t\tsamplebufferoffset+=read;\t\t\t\t}\t\t\t\tt2p_sample_planar_separate_to_contig(\t\t\t\t\tt2p,\t\t\t\t\t&(buffer[bufferoffset]),\t\t\t\t\tsamplebuffer, \t\t\t\t\tsamplebufferoffset); \t\t\t\tbufferoffset+=samplebufferoffset;\t\t\t}\t\t\t_TIFFfree(samplebuffer);\t\t\tgoto dataready;\t\t}\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\tif(buffer==NULL){\t\t\tTIFFError(TIFF2PDF_MODULE, \t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\tTIFFFileName(input));\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\treturn(0);\t\t}                memset(buffer, 0, t2p->tiff_datasize);\t\tstripsize=TIFFStripSize(input);\t\tstripcount=TIFFNumberOfStrips(input);\t\tfor(i=0;i<stripcount;i++){\t\t\tread = \t\t\t\tTIFFReadEncodedStrip(input, \t\t\t\ti, \t\t\t\t(tdata_t) &buffer[bufferoffset], \t\t\t\tstripsize);\t\t\tif(read==-1){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Error on decoding strip %u of %s\", \t\t\t\t\ti, \t\t\t\t\tTIFFFileName(input));\t\t\t\t_TIFFfree(samplebuffer);\t\t\t\t_TIFFfree(buffer);\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tbufferoffset+=read;\t\t}\t\tif(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){\t\t\t\t\t\tsamplebuffer=(unsigned char*)_TIFFrealloc( \t\t\t\t(tdata_t) buffer, \t\t\t\tt2p->tiff_datasize * t2p->tiff_samplesperpixel);\t\t\tif(samplebuffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t  _TIFFfree(buffer);\t\t\t} else {\t\t\t\tbuffer=samplebuffer;\t\t\t\tt2p->tiff_datasize *= t2p->tiff_samplesperpixel;\t\t\t}\t\t\tt2p_sample_realize_palette(t2p, buffer);\t\t}\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\t\t\t\t(tdata_t)buffer, \t\t\t\tt2p->tiff_width*t2p->tiff_length);\t\t}\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\t\t\t\t(tdata_t)buffer, \t\t\t\tt2p->tiff_width*t2p->tiff_length);\t\t}\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\t\t\tsamplebuffer=(unsigned char*)_TIFFrealloc(\t\t\t\t(tdata_t)buffer, \t\t\t\tt2p->tiff_width*t2p->tiff_length*4);\t\t\tif(samplebuffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\t_TIFFfree(buffer);\t\t\t\treturn(0);\t\t\t} else {\t\t\t\tbuffer=samplebuffer;\t\t\t}\t\t\tif(!TIFFReadRGBAImageOriented(\t\t\t\tinput, \t\t\t\tt2p->tiff_width, \t\t\t\tt2p->tiff_length, \t\t\t\t(uint32*)buffer, \t\t\t\tORIENTATION_TOPLEFT,\t\t\t\t0)){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\"Can't use TIFFReadRGBAImageOriented to extract RGB image from %s\", \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tt2p->tiff_datasize=t2p_sample_abgr_to_rgb(\t\t\t\t(tdata_t) buffer, \t\t\t\tt2p->tiff_width*t2p->tiff_length);\t\t}\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\t\t\t\t(tdata_t)buffer, \t\t\t\tt2p->tiff_width*t2p->tiff_length);\t\t}\t}dataready:\tt2p_disable(output);\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\tTIFFSetField(output, TIFFTAG_IMAGEWIDTH, t2p->tiff_width);\tTIFFSetField(output, TIFFTAG_IMAGELENGTH, t2p->tiff_length);\tTIFFSetField(output, TIFFTAG_ROWSPERSTRIP, t2p->tiff_length);\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\tswitch(t2p->pdf_compression){\tcase T2P_COMPRESS_NONE:\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\t\tbreak;#ifdef CCITT_SUPPORT\tcase T2P_COMPRESS_G4:\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\t\tbreak;#endif#ifdef JPEG_SUPPORT\tcase T2P_COMPRESS_JPEG:\t\tif(t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\t\t\tuint16 hor = 0, ver = 0;\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver) !=0 ) {\t\t\t\tif(hor != 0 && ver != 0){\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\t\t\t\t}\t\t\t}\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\t\t\t}\t\t}\t\tif(TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG)==0){\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\"Unable to use JPEG compression for input %s and output %s\", \t\t\t\tTIFFFileName(input),\t\t\t\tTIFFFileName(output));\t\t\t_TIFFfree(buffer);\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\treturn(0);\t\t}\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0);\t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\t\t\t} else {\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\t\t\t}\t\t}\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\t\t\t(void)0;\t\t}\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\t\t\t(void)0;\t\t}\t\tif(t2p->pdf_defaultcompressionquality != 0){\t\t\tTIFFSetField(output, \t\t\t\tTIFFTAG_JPEGQUALITY, \t\t\t\tt2p->pdf_defaultcompressionquality);\t\t}\t\t\tbreak;#endif#ifdef ZIP_SUPPORT\tcase T2P_COMPRESS_ZIP:\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\t\t\tTIFFSetField(output, \t\t\t\tTIFFTAG_PREDICTOR, \t\t\t\tt2p->pdf_defaultcompressionquality % 100);\t\t}\t\tif(t2p->pdf_defaultcompressionquality/100 != 0){\t\t\tTIFFSetField(output, \t\t\t\tTIFFTAG_ZIPQUALITY, \t\t\t\t(t2p->pdf_defaultcompressionquality / 100));\t\t}\t\tbreak;#endif\tdefault:\t\tbreak;\t}\tt2p_enable(output);\tt2p->outputwritten = 0;#ifdef JPEG_SUPPORT\tif(t2p->pdf_compression == T2P_COMPRESS_JPEG\t   && t2p->tiff_photometric == PHOTOMETRIC_YCBCR){\t\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,\t\t\t\t\t\t     buffer,\t\t\t\t\t\t     stripsize * stripcount); \t} else#endif        {\t\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,\t\t\t\t\t\t     buffer,\t\t\t\t\t\t     t2p->tiff_datasize); \t}\tif (buffer != NULL) {\t\t_TIFFfree(buffer);\t\tbuffer=NULL;\t}\tif (bufferoffset == (tsize_t)-1) {\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t  \"Error writing encoded strip to output PDF %s\", \t\t\t  TIFFFileName(output));\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn(0);\t}\t\twritten = t2p->outputwritten;\treturn(written);}",
        "label": 1,
        "cve": "cve-2013-4232"
    },
    {
        "code": "intmain(int argc, char* argv[]){\tuint16 defconfig = (uint16) -1;\tuint16 deffillorder = 0;\tuint32 deftilewidth = (uint32) -1;\tuint32 deftilelength = (uint32) -1;\tuint32 defrowsperstrip = (uint32) 0;\tuint64 diroff = 0;\tTIFF* in;\tTIFF* out;\tchar mode[10];\tchar* mp = mode;\tint c;#if !HAVE_DECL_OPTARG\textern int optind;\textern char* optarg;#endif\t*mp++ = 'w';\t*mp = '\\0';\twhile ((c = getopt(argc, argv, \",:b:c:f:l:o:p:r:w:aistBLMC8x\")) != -1)\t\tswitch (c) {\t\tcase ',':\t\t\tif (optarg[0] != '=') usage();\t\t\tcomma = optarg[1];\t\t\tbreak;\t\tcase 'b':   \t\t\tif (bias) {\t\t\t\tfputs (\"Only 1 bias image may be specified\\n\", stderr);\t\t\t\texit (-2);\t\t\t}\t\t\t{\t\t\t\tuint16 samples = (uint16) -1;\t\t\t\tchar **biasFn = &optarg;\t\t\t\tbias = openSrcImage (biasFn);\t\t\t\tif (!bias) exit (-5);\t\t\t\tif (TIFFIsTiled (bias)) {\t\t\t\t\tfputs (\"Bias image must be organized in strips\\n\", stderr);\t\t\t\t\texit (-7);\t\t\t\t}\t\t\t\tTIFFGetField(bias, TIFFTAG_SAMPLESPERPIXEL, &samples);\t\t\t\tif (samples != 1) {\t\t\t\t\tfputs (\"Bias image must be monochrome\\n\", stderr);\t\t\t\t\texit (-7);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase 'a':   \t\t\tmode[0] = 'a';\t\t\tbreak;\t\tcase 'c':   \t\t\tif (!processCompressOptions(optarg))\t\t\t\tusage();\t\t\tbreak;\t\tcase 'f':   \t\t\tif (streq(optarg, \"lsb2msb\"))\t\t\t\tdeffillorder = FILLORDER_LSB2MSB;\t\t\telse if (streq(optarg, \"msb2lsb\"))\t\t\t\tdeffillorder = FILLORDER_MSB2LSB;\t\t\telse\t\t\t\tusage();\t\t\tbreak;\t\tcase 'i':   \t\t\tignore = TRUE;\t\t\tbreak;\t\tcase 'l':   \t\t\touttiled = TRUE;\t\t\tdeftilelength = atoi(optarg);\t\t\tbreak;\t\tcase 'o':   \t\t\tdiroff = strtoul(optarg, NULL, 0);\t\t\tbreak;\t\tcase 'p':   \t\t\tif (streq(optarg, \"separate\"))\t\t\t\tdefconfig = PLANARCONFIG_SEPARATE;\t\t\telse if (streq(optarg, \"contig\"))\t\t\t\tdefconfig = PLANARCONFIG_CONTIG;\t\t\telse\t\t\t\tusage();\t\t\tbreak;\t\tcase 'r':   \t\t\tdefrowsperstrip = atol(optarg);\t\t\tbreak;\t\tcase 's':   \t\t\touttiled = FALSE;\t\t\tbreak;\t\tcase 't':   \t\t\touttiled = TRUE;\t\t\tbreak;\t\tcase 'w':   \t\t\touttiled = TRUE;\t\t\tdeftilewidth = atoi(optarg);\t\t\tbreak;\t\tcase 'B':\t\t\t*mp++ = 'b'; *mp = '\\0';\t\t\tbreak;\t\tcase 'L':\t\t\t*mp++ = 'l'; *mp = '\\0';\t\t\tbreak;\t\tcase 'M':\t\t\t*mp++ = 'm'; *mp = '\\0';\t\t\tbreak;\t\tcase 'C':\t\t\t*mp++ = 'c'; *mp = '\\0';\t\t\tbreak;\t\tcase '8':\t\t\t*mp++ = '8'; *mp = '\\0';\t\t\tbreak;\t\tcase 'x':\t\t\tpageInSeq = 1;\t\t\tbreak;\t\tcase '?':\t\t\tusage();\t\t\t\t\t}\tif (argc - optind < 2)\t\tusage();\tout = TIFFOpen(argv[argc-1], mode);\tif (out == NULL)\t\treturn (-2);\tif ((argc - optind) == 2)\t\tpageNum = -1;\tfor (; optind < argc-1 ; optind++) {\t\tchar *imageCursor = argv[optind];\t\tin = openSrcImage (&imageCursor);\t\tif (in == NULL) {\t\t\t(void) TIFFClose(out);\t\t\treturn (-3);\t\t}\t\tif (diroff != 0 && !TIFFSetSubDirectory(in, diroff)) {\t\t\tTIFFError(TIFFFileName(in),\t\t\t    \"Error, setting subdirectory at \" TIFF_UINT64_FORMAT, diroff);\t\t\t(void) TIFFClose(in);\t\t\t(void) TIFFClose(out);\t\t\treturn (1);\t\t}\t\tfor (;;) {\t\t\tconfig = defconfig;\t\t\tcompression = defcompression;\t\t\tpredictor = defpredictor;                        preset = defpreset;\t\t\tfillorder = deffillorder;\t\t\trowsperstrip = defrowsperstrip;\t\t\ttilewidth = deftilewidth;\t\t\ttilelength = deftilelength;\t\t\tg3opts = defg3opts;\t\t\tif (!tiffcp(in, out) || !TIFFWriteDirectory(out)) {\t\t\t\t(void) TIFFClose(in);\t\t\t\t(void) TIFFClose(out);\t\t\t\treturn (1);\t\t\t}\t\t\tif (imageCursor) { \t\t\t\tif (!nextSrcImage(in, &imageCursor)) break;\t\t\t}else\t\t\t\tif (!TIFFReadDirectory(in)) break;\t\t}\t\t(void) TIFFClose(in);\t}\t(void) TIFFClose(out);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tsize_t_tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size){\treturn ((tsize_t) write((int) fd, buf, (size_t) size));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intinitImage(void){        uint32 w, h;        if (order)                TIFFSetField(tif, TIFFTAG_FILLORDER, order);        if (photo != (uint16) -1)                TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photo);        if (!TIFFRGBAImageBegin(&img, tif, stoponerr, title)) {                TIFFError(filelist[fileindex], \"%s\", title);                TIFFClose(tif);                tif = NULL;                return -1;        }                h = img.height;        w = img.width;        if (h > ymax) {                w = (int)(w * ((float)ymax / h));                h = ymax;        }        if (w > xmax) {                h = (int)(h * ((float)xmax / w));                w = xmax;        }\tif (w != width || h != height) {\t\tuint32 rastersize =\t\t\t_TIFFMultiply32(tif, img.width, img.height, \"allocating raster buffer\");\t\tif (raster != NULL)\t\t\t_TIFFfree(raster), raster = NULL;\t\traster = (uint32*) _TIFFCheckMalloc(tif, rastersize, sizeof (uint32),\t\t\t\t\t\t    \"allocating raster buffer\");\t\tif (raster == NULL) {\t\t\twidth = height = 0;\t\t\tTIFFError(filelist[fileindex], \"No space for raster buffer\");\t\t\tcleanup_and_exit();\t\t}\t\twidth = w;\t\theight = h;\t}\tTIFFRGBAImageGet(&img, raster, img.width, img.height);#if HOST_BIGENDIAN\tTIFFSwabArrayOfLong(raster,img.width*img.height);#endif\treturn 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static const TIFFField *GetField(TIFF *tiff, const char *tagname){    const TIFFField *fip;    if( atoi(tagname) > 0 )        fip = TIFFFieldWithTag(tiff, (ttag_t)atoi(tagname));    else        fip = TIFFFieldWithName(tiff, tagname);    if (!fip) {        fprintf( stderr, \"Field name \\\"%s\\\" is not recognised.\\n\", tagname );        return (TIFFField *)NULL;    }    return fip;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidPrintASCII(FILE* fd, uint32 cc, const unsigned char* cp){\tfor (; cc > 0; cc--, cp++) {\t\tconst char* tp;\t\tif (isprint(*cp)) {\t\t\tfputc(*cp, fd);\t\t\tcontinue;\t\t}\t\tfor (tp = \"\\tt\\bb\\rr\\nn\\vv\"; *tp; tp++)\t\t\tif (*tp++ == *cp)\t\t\t\tbreak;\t\tif (*tp)\t\t\tfprintf(fd, \"\\\\%c\", *tp);\t\telse if (*cp)\t\t\tfprintf(fd, \"\\\\%03o\", *cp);\t\telse\t\t\tfprintf(fd, \"\\\\0\");\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void_XTIFFDefaultDirectory(TIFF *tif){\txtiff *xt;\t\tif (!(tif->tif_flags & XTIFF_INITIALIZED))\t{\t\txt = _TIFFmalloc(sizeof(xtiff));\t\tif (!xt)\t\t{\t\t\t\t\t\treturn;\t\t}\t\t_TIFFmemset(xt,0,sizeof(xtiff));\t\t\t\tTIFFMEMBER(tif,clientdir) = (tidata_t)xt;\t\ttif->tif_flags |= XTIFF_INITIALIZED; \t}\t\t_XTIFFLocalDefaultDirectory(tif);\t\tif (_ParentExtender) \t\t(*_ParentExtender)(tif);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteDirectoryTagCheckedLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value){\tassert(count<0x20000000);\tassert(sizeof(uint64)==8);\tassert(tif->tif_flags&TIFF_BIGTIFF);\tif (tif->tif_flags&TIFF_SWAB)\t\tTIFFSwabArrayOfLong8(value,count);\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_LONG8,count,count*8,value));}",
        "label": 1,
        "cve": "cve-2017-10688"
    },
    {
        "code": "voidTIFFWarningExt(thandle_t fd, const char* module, const char* fmt, ...){\tva_list ap;\tva_start(ap, fmt);\tif (_TIFFwarningHandler)\t\t(*_TIFFwarningHandler)(module, fmt, ap);\tif (_TIFFwarningHandlerExt)\t\t(*_TIFFwarningHandlerExt)(fd, module, fmt, ap);\tva_end(ap);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intextractContigSamplesToBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,  \t                     tsample_t sample, uint16 spp, uint16 bps,                              struct dump_opts *dump)  {  int    shift_width, bytes_per_sample, bytes_per_pixel;  uint32 src_rowsize, src_offset, row, first_col = 0;  uint32 dst_rowsize, dst_offset;  tsample_t count = 1;  uint8 *src, *dst;  bytes_per_sample = (bps + 7) / 8;   bytes_per_pixel  = ((bps * spp) + 7) / 8;  if ((bps % 8) == 0)    shift_width = 0;  else    {    if (bytes_per_pixel < (bytes_per_sample + 1))      shift_width = bytes_per_pixel;    else      shift_width = bytes_per_sample + 1;    }  src_rowsize = ((bps * spp * cols) + 7) / 8;  dst_rowsize = ((bps * cols) + 7) / 8;  if ((dump->outfile != NULL) && (dump->level == 4))    {    dump_info  (dump->outfile, dump->format, \"extractContigSamplesToBuffer\",                 \"Sample %d, %d rows\", sample + 1, rows + 1);    }  for (row = 0; row < rows; row++)    {    src_offset = row * src_rowsize;    dst_offset = row * dst_rowsize;    src = in + src_offset;    dst = out + dst_offset;        switch (shift_width)      {        case 0: if (extractContigSamplesBytes (src, dst, cols, sample,                                             spp, bps,  count, first_col, cols))                  return (1); \t      break;      case 1: if (bps == 1)                {                if (extractContigSamples8bits (src, dst, cols, sample,                                               spp, bps, count, first_col, cols))\t          return (1);\t        break;\t\t}\t      else                 if (extractContigSamples16bits (src, dst, cols, sample,                                                 spp, bps, count, first_col, cols))\t         return (1);\t      break;      case 2: if (extractContigSamples24bits (src, dst, cols, sample,                                              spp, bps,  count, first_col, cols))\t         return (1);\t      break;      case 3:      case 4:       case 5: if (extractContigSamples32bits (src, dst, cols, sample,                                              spp, bps,  count, first_col, cols))\t         return (1);\t      break;      default: TIFFError (\"extractContigSamplesToBuffer\", \"Unsupported bit depth: %d\", bps);\t       return (1);      }    if ((dump->outfile != NULL) && (dump->level == 4))      dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst);    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFInitCCITTRLEW(TIFF* tif, int scheme){\t(void) scheme;\tif (InitCCITTFax3(tif)) {\t\t\t\ttif->tif_decoderow = Fax3DecodeRLE;\t\ttif->tif_decodestrip = Fax3DecodeRLE;\t\ttif->tif_decodetile = Fax3DecodeRLE;\t\t\t\treturn TIFFSetField(tif, TIFFTAG_FAXMODE,\t\t    FAXMODE_NORTC|FAXMODE_NOEOL|FAXMODE_WORDALIGN);\t} else\t\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tsize_t t2p_write_pdf(T2P* t2p, TIFF* input, TIFF* output){\ttsize_t written=0;\tttile_t i2=0;\ttsize_t streamlen=0;\tuint16 i=0;\tt2p_read_tiff_init(t2p, input);\tif(t2p->t2p_error!=T2P_ERR_OK){return(0);}\tt2p->pdf_xrefoffsets= (uint32*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_xrefcount,sizeof(uint32)) );\tif(t2p->pdf_xrefoffsets==NULL){\t\tTIFFError(\t\t\tTIFF2PDF_MODULE, \t\t\t\"Can't allocate %u bytes of memory for t2p_write_pdf\", \t\t\t(unsigned int) (t2p->pdf_xrefcount * sizeof(uint32)) );\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn(written);\t}\tt2p->pdf_xrefcount=0;\tt2p->pdf_catalog=1;\tt2p->pdf_info=2;\tt2p->pdf_pages=3;\twritten += t2p_write_pdf_header(t2p, output);\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\tt2p->pdf_catalog=t2p->pdf_xrefcount;\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\twritten += t2p_write_pdf_catalog(t2p, output);\twritten += t2p_write_pdf_obj_end(output);\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\tt2p->pdf_info=t2p->pdf_xrefcount;\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\twritten += t2p_write_pdf_info(t2p, input, output);\twritten += t2p_write_pdf_obj_end(output);\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\tt2p->pdf_pages=t2p->pdf_xrefcount;\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\twritten += t2p_write_pdf_pages(t2p, output);\twritten += t2p_write_pdf_obj_end(output);\tfor(t2p->pdf_page=0;t2p->pdf_page<t2p->tiff_pagecount;t2p->pdf_page++){\t\tt2p_read_tiff_data(t2p, input);\t\tif(t2p->t2p_error!=T2P_ERR_OK){return(0);}\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\twritten += t2p_write_pdf_page(t2p->pdf_xrefcount, t2p, output);\t\twritten += t2p_write_pdf_obj_end(output);\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\twritten += t2p_write_pdf_stream_dict_start(output);\t\twritten += t2p_write_pdf_stream_dict(0, t2p->pdf_xrefcount+1, output);\t\twritten += t2p_write_pdf_stream_dict_end(output);\t\twritten += t2p_write_pdf_stream_start(output);\t\tstreamlen=written;\t\twritten += t2p_write_pdf_page_content_stream(t2p, output);\t\tstreamlen=written-streamlen;\t\twritten += t2p_write_pdf_stream_end(output);\t\twritten += t2p_write_pdf_obj_end(output);\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\twritten += t2p_write_pdf_stream_length(streamlen, output);\t\twritten += t2p_write_pdf_obj_end(output);\t\tif(t2p->tiff_transferfunctioncount != 0){\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\t\twritten += t2p_write_pdf_transfer(t2p, output);\t\t\twritten += t2p_write_pdf_obj_end(output);\t\t\tfor(i=0; i < t2p->tiff_transferfunctioncount; i++){\t\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\t\t\t\twritten += t2p_write_pdf_transfer_dict(t2p, output, i);\t\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\t\t\t\twritten += t2p_write_pdf_stream_start(output);\t\t\t\t \t\t\t\twritten += t2p_write_pdf_transfer_stream(t2p, output, i);\t\t\t\t \t\t\t\twritten += t2p_write_pdf_stream_end(output);\t\t\t\twritten += t2p_write_pdf_obj_end(output);\t\t\t}\t\t}\t\tif( (t2p->pdf_colorspace & T2P_CS_PALETTE) != 0){\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\t\tt2p->pdf_palettecs=t2p->pdf_xrefcount;\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\t\t\twritten += t2p_write_pdf_stream_dict(t2p->pdf_palettesize, 0, output);\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\t\t\twritten += t2p_write_pdf_stream_start(output);\t\t\t \t\t\twritten += t2p_write_pdf_xobject_palettecs_stream(t2p, output);\t\t\t \t\t\twritten += t2p_write_pdf_stream_end(output);\t\t\twritten += t2p_write_pdf_obj_end(output);\t\t}\t\tif( (t2p->pdf_colorspace & T2P_CS_ICCBASED) != 0){\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\t\tt2p->pdf_icccs=t2p->pdf_xrefcount;\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\t\t\twritten += t2p_write_pdf_xobject_icccs_dict(t2p, output);\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\t\t\twritten += t2p_write_pdf_stream_start(output);\t\t\t \t\t\twritten += t2p_write_pdf_xobject_icccs_stream(t2p, output);\t\t\t \t\t\twritten += t2p_write_pdf_stream_end(output);\t\t\twritten += t2p_write_pdf_obj_end(output);\t\t}\t\tif(t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount !=0){\t\t\tfor(i2=0;i2<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;i2++){\t\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\t\t\t\twritten += t2p_write_pdf_xobject_stream_dict(\t\t\t\t\ti2+1, \t\t\t\t\tt2p, \t\t\t\t\toutput);\t\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\t\t\t\twritten += t2p_write_pdf_stream_start(output);\t\t\t\tstreamlen=written;\t\t\t\tt2p_read_tiff_size_tile(t2p, input, i2);\t\t\t\twritten += t2p_readwrite_pdf_image_tile(t2p, input, output, i2);\t\t\t\tt2p_write_advance_directory(t2p, output);\t\t\t\tif(t2p->t2p_error!=T2P_ERR_OK){return(0);}\t\t\t\tstreamlen=written-streamlen;\t\t\t\twritten += t2p_write_pdf_stream_end(output);\t\t\t\twritten += t2p_write_pdf_obj_end(output);\t\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\t\t\twritten += t2p_write_pdf_stream_length(streamlen, output);\t\t\t\twritten += t2p_write_pdf_obj_end(output);\t\t\t}\t\t} else {\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\t\t\twritten += t2p_write_pdf_xobject_stream_dict(\t\t\t\t0, \t\t\t\tt2p, \t\t\t\toutput);\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\t\t\twritten += t2p_write_pdf_stream_start(output);\t\t\tstreamlen=written;\t\t\tt2p_read_tiff_size(t2p, input);\t\t\twritten += t2p_readwrite_pdf_image(t2p, input, output);\t\t\tt2p_write_advance_directory(t2p, output);\t\t\tif(t2p->t2p_error!=T2P_ERR_OK){return(0);}\t\t\tstreamlen=written-streamlen;\t\t\twritten += t2p_write_pdf_stream_end(output);\t\t\twritten += t2p_write_pdf_obj_end(output);\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\t\t\twritten += t2p_write_pdf_stream_length(streamlen, output);\t\t\twritten += t2p_write_pdf_obj_end(output);\t\t}\t}\tt2p->pdf_startxref = written;\twritten += t2p_write_pdf_xreftable(t2p, output);\twritten += t2p_write_pdf_trailer(t2p, output);\tt2p_disable(output);\treturn(written);}",
        "label": 1,
        "cve": "cve-2017-9935"
    },
    {
        "code": "static voidputspan(TIFF* tif, int32 span, const tableentry* tab){\tFax3CodecState* sp = EncoderState(tif);\tunsigned int bit = sp->bit;\tint data = sp->data;\tunsigned int code, length;\twhile (span >= 2624) {\t\tconst tableentry* te = &tab[63 + (2560>>6)];\t\tcode = te->code, length = te->length;#ifdef FAX3_DEBUG\t\tDEBUG_PRINT(\"MakeUp\", te->runlen);#endif\t\t_PutBits(tif, code, length);\t\tspan -= te->runlen;\t}\tif (span >= 64) {\t\tconst tableentry* te = &tab[63 + (span>>6)];\t\tassert(te->runlen == 64*(span>>6));\t\tcode = te->code, length = te->length;#ifdef FAX3_DEBUG\t\tDEBUG_PRINT(\"MakeUp\", te->runlen);#endif\t\t_PutBits(tif, code, length);\t\tspan -= te->runlen;\t}\tcode = tab[span].code, length = tab[span].length;#ifdef FAX3_DEBUG\tDEBUG_PRINT(\"  Term\", tab[span].runlen);#endif\t_PutBits(tif, code, length);\tsp->data = data;\tsp->bit = bit;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFReadContigTileData(TIFF* tif){\tunsigned char *buf;\ttsize_t rowsize = TIFFTileRowSize(tif);\tbuf = (unsigned char *)_TIFFmalloc(TIFFTileSize(tif));\tif (buf) {\t\tuint32 tw, th, w, h;\t\tuint32 row, col;\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\t\tfor (row = 0; row < h; row += th) {\t\t\tfor (col = 0; col < w; col += tw) {\t\t\t\tif (TIFFReadTile(tif, buf, col, row, 0, 0) < 0) {\t\t\t\t\tif (stoponerr)\t\t\t\t\t\tbreak;\t\t\t\t} else if (showdata)\t\t\t\t\tShowTile(row, col, (tsample_t) -1, buf, th, rowsize);\t\t\t}\t\t}\t\t_TIFFfree(buf);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFSetSubDirectory(TIFF* tif, uint32 diroff){\ttif->tif_nextdiroff = diroff;\t\ttif->tif_dirnumber = 0;\treturn (TIFFReadDirectory(tif));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intprocessCompressOptions(char* opt){\tif (streq(opt, \"none\")) {\t\tdefcompression = COMPRESSION_NONE;\t} else if (streq(opt, \"packbits\")) {\t\tdefcompression = COMPRESSION_PACKBITS;\t} else if (strneq(opt, \"jpeg\", 4)) {\t\tchar* cp = strchr(opt, ':');\t\tdefcompression = COMPRESSION_JPEG;\t\twhile( cp )\t\t{\t\t\tif (isdigit((int)cp[1]))\t\t\t\tquality = atoi(cp+1);\t\t\telse if (cp[1] == 'r' )\t\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;\t\t\telse\t\t\t\tusage();\t\t\tcp = strchr(cp+1,':');\t\t}\t} else if (strneq(opt, \"g3\", 2)) {\t\tprocessG3Options(opt);\t\tdefcompression = COMPRESSION_CCITTFAX3;\t} else if (streq(opt, \"g4\")) {\t\tdefcompression = COMPRESSION_CCITTFAX4;\t} else if (strneq(opt, \"lzw\", 3)) {\t\tchar* cp = strchr(opt, ':');\t\tif (cp)\t\t\tdefpredictor = atoi(cp+1);\t\tdefcompression = COMPRESSION_LZW;\t} else if (strneq(opt, \"zip\", 3)) {\t\tprocessZIPOptions(opt);\t\tdefcompression = COMPRESSION_ADOBE_DEFLATE;\t} else if (strneq(opt, \"lzma\", 4)) {\t\tprocessZIPOptions(opt);\t\tdefcompression = COMPRESSION_LZMA;\t} else if (strneq(opt, \"jbig\", 4)) {\t\tdefcompression = COMPRESSION_JBIG;\t} else if (strneq(opt, \"sgilog\", 6)) {\t\tdefcompression = COMPRESSION_SGILOG;\t} else\t\treturn (0);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(void){\tchar buf[BUFSIZ];\tint i;\tsetbuf(stderr, buf);\tfor (i = 0; stuff[i] != NULL; i++)\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\texit(-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidFax3PutEOL(TIFF* tif){\tFax3CodecState* sp = EncoderState(tif);\tunsigned int bit = sp->bit;\tint data = sp->data;\tunsigned int code, length, tparm;\tif (sp->b.groupoptions & GROUP3OPT_FILLBITS) {\t\t\t\tint align = 8 - 4;\t\tif (align != sp->bit) {\t\t\tif (align > sp->bit)\t\t\t\talign = sp->bit + (8 - align);\t\t\telse\t\t\t\talign = sp->bit - align;\t\t\tcode = 0;\t\t\ttparm=align; \t\t\t_PutBits(tif, 0, tparm);\t\t}\t}\tcode = EOL, length = 12;\tif (is2DEncoding(sp))\t\tcode = (code<<1) | (sp->tag == G3_1D), length++;\t_PutBits(tif, code, length);\tsp->data = data;\tsp->bit = bit;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchRefBlackWhite(TIFF* tif, TIFFDirEntry* dir){\tstatic char mesg[] = \"for \\\"ReferenceBlackWhite\\\" array\";\tchar* cp;\tint ok;\tif (dir->tdir_type == TIFF_RATIONAL)\t\treturn (1);\t\tcp = CheckMalloc(tif, dir->tdir_count * sizeof (uint32), mesg);\tif (ok = (cp && TIFFFetchLongArray(tif, dir, (uint32*) cp))) {\t\tfloat* fp = (float*)\t\t    CheckMalloc(tif, dir->tdir_count * sizeof (float), mesg);\t\tif (ok = (fp != NULL)) {\t\t\tuint32 i;\t\t\tfor (i = 0; i < dir->tdir_count; i++)\t\t\t\tfp[i] = (float)((uint32*) cp)[i];\t\t\tok = TIFFSetField(tif, dir->tdir_tag, fp);\t\t\t_TIFFfree((char*) fp);\t\t}\t}\tif (cp)\t\t_TIFFfree(cp);\treturn (ok);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char* argv[]){        int c;        int dirnum = -1;        uint32 diroff = 0;        oerror = TIFFSetErrorHandler(NULL);        owarning = TIFFSetWarningHandler(NULL);        while ((c = getopt(argc, argv, \"d:o:p:eflmsvw?\")) != -1)            switch (c) {            case 'd':                dirnum = atoi(optarg);                break;            case 'e':                oerror = TIFFSetErrorHandler(oerror);                break;            case 'l':                order0 = FILLORDER_LSB2MSB;                break;            case 'm':                order0 = FILLORDER_MSB2LSB;                break;            case 'o':                diroff = strtoul(optarg, NULL, 0);                break;            case 'p':                photo0 = photoArg(optarg);                break;            case 's':                stoponerr = 1;                break;            case 'w':                owarning = TIFFSetWarningHandler(owarning);                break;            case 'v':                verbose = 1;                break;            case '?':                usage();                            }        filenum = argc - optind;        if ( filenum < 1)                usage();        glutInit(&argc, argv);        glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);                xmax = glutGet(GLUT_SCREEN_WIDTH);        ymax = glutGet(GLUT_SCREEN_HEIGHT);                xmax = xmax - xmax / 10.0;        ymax = ymax - ymax / 10.0;        filelist = (char **) _TIFFmalloc(filenum * sizeof(char*));        if (!filelist) {                TIFFError(argv[0], \"Can not allocate space for the file list.\");                return 1;        }        _TIFFmemcpy(filelist, argv + optind, filenum * sizeof(char*));        fileindex = -1;        if (nextImage() < 0) {                _TIFFfree(filelist);                return 2;        }                if (dirnum != -1 && !TIFFSetDirectory(tif, dirnum))            TIFFError(argv[0], \"Error, seeking to directory %d\", dirnum);        if (diroff != 0 && !TIFFSetSubDirectory(tif, diroff))            TIFFError(argv[0], \"Error, setting subdirectory at %#x\", diroff);        order = order0;        photo = photo0;\tif (initImage() < 0){                _TIFFfree(filelist);                return 3;        }                glutInitWindowSize(width, height);        snprintf(title, TITLE_LENGTH - 1, \"%s [%u]\", filelist[fileindex],                (unsigned int) TIFFCurrentDirectory(tif));        glutCreateWindow(title);        glutDisplayFunc(raster_draw);        glutReshapeFunc(raster_reshape);        glutKeyboardFunc(raster_keys);        glutSpecialFunc(raster_special);        glutMainLoop();        cleanup_and_exit();        return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidhorizontalAccumulate11(uint16 *wp, int n, int stride, uint16 *op){    register unsigned int cr, cg, cb, ca, mask;    if (n >= stride) {\tmask = CODE_MASK;\tif (stride == 3) {\t    op[0] = wp[0];  op[1] = wp[1];  op[2] = wp[2];            cr = wp[0];  cg = wp[1];  cb = wp[2];\t    n -= 3;\t    while (n > 0) {\t\twp += 3;\t\top += 3;\t\tn -= 3;\t\top[0] = (uint16)((cr += wp[0]) & mask);\t\top[1] = (uint16)((cg += wp[1]) & mask);\t\top[2] = (uint16)((cb += wp[2]) & mask);\t    }\t} else if (stride == 4) {\t    op[0] = wp[0];  op[1] = wp[1];\t    op[2] = wp[2];  op[3] = wp[3];            cr = wp[0]; cg = wp[1]; cb = wp[2]; ca = wp[3];\t    n -= 4;\t    while (n > 0) {\t\twp += 4;\t\top += 4;\t\tn -= 4;\t\top[0] = (uint16)((cr += wp[0]) & mask);\t\top[1] = (uint16)((cg += wp[1]) & mask);\t\top[2] = (uint16)((cb += wp[2]) & mask);\t\top[3] = (uint16)((ca += wp[3]) & mask);\t    } \t} else {\t    REPEAT(stride, *op = *wp&mask; wp++; op++)\t    n -= stride;\t    while (n > 0) {\t\tREPEAT(stride,\t\t    wp[stride] += *wp; *op = *wp&mask; wp++; op++)\t\tn -= stride;\t    }\t}    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchShortArray(TIFF* tif, TIFFDirEntry* dir, uint16* v){\tif (dir->tdir_count <= 2) {\t\tif (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {\t\t\tswitch (dir->tdir_count) {\t\t\tcase 2: v[1] = dir->tdir_offset & 0xffff;\t\t\tcase 1: v[0] = dir->tdir_offset >> 16;\t\t\t}\t\t} else {\t\t\tswitch (dir->tdir_count) {\t\t\tcase 2: v[1] = dir->tdir_offset >> 16;\t\t\tcase 1: v[0] = dir->tdir_offset & 0xffff;\t\t\t}\t\t}\t\treturn (1);\t} else\t\treturn (TIFFFetchData(tif, dir, (char *)v) != 0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidError(const char* fmt, ...){\tva_list ap;\tva_start(ap, fmt);\tvError(stderr, fmt, ap);\tva_end(ap);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int_TIFFNoRowDecode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s){\t(void) pp; (void) cc; (void) s;\treturn (TIFFNoDecode(tif, \"scanline\"));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPixarLogPreDecode(TIFF* tif, uint16 s){\tstatic const char module[] = \"PixarLogPreDecode\";\tPixarLogState* sp = DecoderState(tif);\t(void) s;\tassert(sp != NULL);\tsp->stream.next_in = tif->tif_rawdata;\tassert(sizeof(sp->stream.avail_in)==4);  \tsp->stream.avail_in = (uInt) tif->tif_rawcc;\tif ((tmsize_t)sp->stream.avail_in != tif->tif_rawcc)\t{\t\tTIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\");\t\treturn (0);\t}\treturn (inflateReset(&sp->stream) == Z_OK);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFFOvrCache *TIFFCreateOvrCache( TIFF *hTIFF, toff_t nDirOffset ){    TIFFOvrCache\t*psCache;    toff_t\t\tnBaseDirOffset;    psCache = (TIFFOvrCache *) _TIFFmalloc(sizeof(TIFFOvrCache));    psCache->nDirOffset = nDirOffset;    psCache->hTIFF = hTIFF;    nBaseDirOffset = TIFFCurrentDirOffset( psCache->hTIFF );    TIFFSetSubDirectory( hTIFF, nDirOffset );    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &(psCache->nXSize) );    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &(psCache->nYSize) );    TIFFGetField( hTIFF, TIFFTAG_BITSPERSAMPLE, &(psCache->nBitsPerPixel) );    TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, &(psCache->nSamples) );    TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(psCache->nPlanarConfig) );    if( !TIFFIsTiled( hTIFF ) )    {        TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP, &(psCache->nBlockYSize) );        psCache->nBlockXSize = psCache->nXSize;        psCache->nBytesPerBlock = TIFFStripSize(hTIFF);        psCache->bTiled = FALSE;    }    else    {        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(psCache->nBlockXSize) );        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(psCache->nBlockYSize) );        psCache->nBytesPerBlock = TIFFTileSize(hTIFF);        psCache->bTiled = TRUE;    }    psCache->nBlocksPerRow = (psCache->nXSize + psCache->nBlockXSize - 1)        \t\t/ psCache->nBlockXSize;    psCache->nBlocksPerColumn = (psCache->nYSize + psCache->nBlockYSize - 1)        \t\t/ psCache->nBlockYSize;    if (psCache->nPlanarConfig == PLANARCONFIG_SEPARATE)        psCache->nBytesPerRow = psCache->nBytesPerBlock            * psCache->nBlocksPerRow * psCache->nSamples;    else        psCache->nBytesPerRow =            psCache->nBytesPerBlock * psCache->nBlocksPerRow;    psCache->pabyRow1Blocks =        (unsigned char *) _TIFFmalloc(psCache->nBytesPerRow);    psCache->pabyRow2Blocks =        (unsigned char *) _TIFFmalloc(psCache->nBytesPerRow);    if( psCache->pabyRow1Blocks == NULL        || psCache->pabyRow2Blocks == NULL )    {\t\tTIFFErrorExt( hTIFF->tif_clientdata, hTIFF->tif_name,\t\t\t\t\t  \"Can't allocate memory for overview cache.\" );                return NULL;    }    _TIFFmemset( psCache->pabyRow1Blocks, 0, psCache->nBytesPerRow );    _TIFFmemset( psCache->pabyRow2Blocks, 0, psCache->nBytesPerRow );    psCache->nBlockOffset = 0;    TIFFSetSubDirectory( psCache->hTIFF, nBaseDirOffset );    return psCache;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void formatString(FILE *ofile, const char *s, int len){  putc('\"', ofile);  for (; len > 0; --len, ++s) {    int c = *s;    switch (c) {    case '&':      fputs(\"&amp;\", ofile);      break;#ifdef HANDLE_GT_LT    case '<':      fputs(\"&lt;\", ofile);      break;    case '>':      fputs(\"&gt;\", ofile);      break;#endif    case '\"':      fputs(\"&quot;\", ofile);      break;    default:      if (iscntrl(c))        fprintf(ofile, \"&#%d;\", c);      else        putc(*s, ofile);      break;    }  }  fputs(\"\\\"\\n\", ofile);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char* argv[]){\tTIFF *tif1, *tif2;\tint c, dirnum;\textern int optind;\textern char* optarg;\twhile ((c = getopt(argc, argv, \"ltz:\")) != -1)\t\tswitch (c) {\t\tcase 'l':\t\t\tstopondiff = 0;\t\t\tbreak;\t\tcase 'z':\t\t\tstopondiff = atoi(optarg);\t\t\tbreak;\t\tcase 't':\t\t\tstoponfirsttag = 0;\t\t\tbreak;\t\tcase '?':\t\t\tusage();\t\t\t\t\t}\tif (argc - optind < 2)\t\tusage();\ttif1 = TIFFOpen(argv[optind], \"r\");\tif (tif1 == NULL)\t\treturn (-1);\ttif2 = TIFFOpen(argv[optind+1], \"r\");\tif (tif2 == NULL)\t\treturn (-2);\tdirnum = 0;\twhile (tiffcmp(tif1, tif2)) {\t\tif (!TIFFReadDirectory(tif1)) {\t\t\tif (!TIFFReadDirectory(tif2))\t\t\t\tbreak;\t\t\tprintf(\"No more directories for %s\\n\",\t\t\t    TIFFFileName(tif1));\t\t\treturn (1);\t\t} else if (!TIFFReadDirectory(tif2)) {\t\t\tprintf(\"No more directories for %s\\n\",\t\t\t    TIFFFileName(tif2));\t\t\treturn (1);\t\t}\t\tprintf(\"Directory %d:\\n\", ++dirnum);\t}\tTIFFClose(tif1);\tTIFFClose(tif2);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchRationalArray(TIFF* tif, TIFFDirEntry* dir, float* v){\tint ok = 0;\tuint32* l;\tl = (uint32*)CheckMalloc(tif,\t    dir->tdir_count*TIFFDataWidth(dir->tdir_type),\t    \"to fetch array of rationals\");\tif (l) {\t\tif (TIFFFetchData(tif, dir, (char *)l)) {\t\t\tuint32 i;\t\t\tfor (i = 0; i < dir->tdir_count; i++) {\t\t\t\tok = cvtRational(tif, dir,\t\t\t\t    l[2*i+0], l[2*i+1], &v[i]);\t\t\t\tif (!ok)\t\t\t\t\tbreak;\t\t\t}\t\t}\t\t_TIFFfree((char *)l);\t}\treturn (ok);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int t2p_tile_is_edge(T2P_TILES tiles, ttile_t tile){\treturn(t2p_tile_is_right_edge(tiles, tile) | t2p_tile_is_bottom_edge(tiles, tile) );}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidtiffinfo(TIFF* tif, uint16 order, long flags){\tTIFFPrintDirectory(tif, stdout, flags);\tif (!readdata)\t\treturn;\tif (rawdata) {\t\tif (order) {\t\t\tuint16 o;\t\t\tTIFFGetFieldDefaulted(tif,\t\t\t    TIFFTAG_FILLORDER, &o);\t\t\tTIFFReadRawData(tif, o != order);\t\t} else\t\t\tTIFFReadRawData(tif, 0);\t} else {\t\tif (order)\t\t\tTIFFSetField(tif, TIFFTAG_FILLORDER, order);\t\tTIFFReadData(tif);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*TIFFFdOpen(int fd, const char* name, const char* mode){\tTIFF* tif;\ttif = TIFFClientOpen(name, mode,\t\t(thandle_t) fd,\t\t_tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,\t\t_tiffSizeProc, _tiffMapProc, _tiffUnmapProc);\tif (tif)\t\ttif->tif_fd = fd;\treturn (tif);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcomputeOutputPixelOffsets (struct crop_mask *crop, struct image_data *image,                           struct pagedef *page, struct pageseg *sections,                           struct dump_opts* dump)  {  double scale;  double pwidth, plength;            uint32 iwidth, ilength;            uint32 owidth, olength;            uint32 orows, ocols;               uint32 hmargin, vmargin;           uint32 x1, x2, y1, y2, line_bytes;    uint32 i, j, k;  scale = 1.0;  if (page->res_unit == RESUNIT_NONE)    page->res_unit = image->res_unit;  switch (image->res_unit) {    case RESUNIT_CENTIMETER:         if (page->res_unit == RESUNIT_INCH)\t   scale = 1.0/2.54;\t break;    case RESUNIT_INCH:\t if (page->res_unit == RESUNIT_CENTIMETER)\t     scale = 2.54;\t break;    case RESUNIT_NONE:     default:    break;    }    if (crop->combined_width > 0)    iwidth = crop->combined_width;  else    iwidth = image->width;  if (crop->combined_length > 0)    ilength = crop->combined_length;  else    ilength = image->length;  if (page->hres <= 1.0)    page->hres = image->xres;  if (page->vres <= 1.0)    page->vres = image->yres;  if ((page->hres < 1.0) || (page->vres < 1.0))    {    TIFFError(\"computeOutputPixelOffsets\",    \"Invalid horizontal or vertical resolution specified or read from input image\");    return (1);    }    if (page->width <= 0)    pwidth = iwidth;  else    pwidth = page->width;  if (page->length <= 0)    plength = ilength;  else    plength = page->length;  if (dump->debug)    {    TIFFError(\"\", \"Page size: %s, Vres: %3.2f, Hres: %3.2f, \"                   \"Hmargin: %3.2f, Vmargin: %3.2f\",\t     page->name, page->vres, page->hres,             page->hmargin, page->vmargin);    TIFFError(\"\", \"Res_unit: %d, Scale: %3.2f, Page width: %3.2f, length: %3.2f\",            page->res_unit, scale, pwidth, plength);    }    if (page->mode & PAGE_MODE_MARGINS)    {    if (page->res_unit == RESUNIT_INCH || page->res_unit == RESUNIT_CENTIMETER)      {       hmargin = (uint32)(page->hmargin * scale * page->hres * ((image->bps + 7)/ 8));      vmargin = (uint32)(page->vmargin * scale * page->vres * ((image->bps + 7)/ 8));      }    else      {       hmargin = (uint32)(page->hmargin * scale * ((image->bps + 7)/ 8));      vmargin = (uint32)(page->vmargin * scale * ((image->bps + 7)/ 8));      }    if ((hmargin * 2.0) > (pwidth * page->hres))      {      TIFFError(\"computeOutputPixelOffsets\",                 \"Combined left and right margins exceed page width\");      hmargin = (uint32) 0;      return (-1);      }    if ((vmargin * 2.0) > (plength * page->vres))      {      TIFFError(\"computeOutputPixelOffsets\",                 \"Combined top and bottom margins exceed page length\");       vmargin = (uint32) 0;       return (-1);      }    }  else    {    hmargin = 0;    vmargin = 0;    }  if (page->mode & PAGE_MODE_ROWSCOLS )    {        if (page->mode & PAGE_MODE_MARGINS)      TIFFError(\"computeOutputPixelOffsets\",       \"Output margins cannot be specified with rows and columns\");     owidth  = TIFFhowmany(iwidth, page->cols);    olength = TIFFhowmany(ilength, page->rows);    }  else    {    if (page->mode & PAGE_MODE_PAPERSIZE )      {      owidth  = (uint32)((pwidth * page->hres) - (hmargin * 2));      olength = (uint32)((plength * page->vres) - (vmargin * 2));      }    else      {      owidth = (uint32)(iwidth - (hmargin * 2 * page->hres));      olength = (uint32)(ilength - (vmargin * 2 * page->vres));      }    }  if (owidth > iwidth)    owidth = iwidth;  if (olength > ilength)    olength = ilength;    switch (page->orient)    {    case ORIENTATION_NONE:    case ORIENTATION_PORTRAIT:         ocols = TIFFhowmany(iwidth, owidth);         orows = TIFFhowmany(ilength, olength);                  break;    case ORIENTATION_LANDSCAPE:         ocols = TIFFhowmany(iwidth, olength);         orows = TIFFhowmany(ilength, owidth);         x1 = olength;         olength = owidth;         owidth = x1;                  break;    case ORIENTATION_AUTO:    default:         x1 = TIFFhowmany(iwidth, owidth);         x2 = TIFFhowmany(ilength, olength);          y1 = TIFFhowmany(iwidth, olength);         y2 = TIFFhowmany(ilength, owidth);          if ( (x1 * x2) < (y1 * y2))           {            ocols = x1;           orows = x2;           \t   }         else           {            ocols = y1;           orows = y2;           x1 = olength;           olength = owidth;           owidth = x1;                      }    }  if (ocols < 1)    ocols = 1;  if (orows < 1)    orows = 1;    if (page->rows < 1)    page->rows = orows;  if (page->cols < 1)    page->cols = ocols;  line_bytes = TIFFhowmany8(owidth * image->bps) * image->spp;  if ((page->rows * page->cols) > MAX_SECTIONS)   {   TIFFError(\"computeOutputPixelOffsets\",\t     \"Rows and Columns exceed maximum sections\\nIncrease resolution or reduce sections\");   return (-1);   }    for (k = 0, i = 0 && k <= MAX_SECTIONS; i < orows; i++)    {    y1 = (uint32)(olength * i);    y2 = (uint32)(olength * (i +  1) - 1);    if (y2 >= ilength)      y2 = ilength - 1;    for (j = 0; j < ocols; j++, k++)      {      x1 = (uint32)(owidth * j);       x2 = (uint32)(owidth * (j + 1) - 1);      if (x2 >= iwidth)        x2 = iwidth - 1;      sections[k].x1 = x1;      sections[k].x2 = x2;      sections[k].y1 = y1;      sections[k].y2 = y2;      sections[k].buffsize = line_bytes * olength;      sections[k].position = k + 1;      sections[k].total = orows * ocols;      }     }   return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char* argv[]){\tint dirnum = -1, multiplefiles, c;\tuint16 order = 0;\tTIFF* tif;\textern int optind;\textern char* optarg;\tlong flags = 0;\tuint64 diroff = 0;\tint chopstrips = 0;\t\t\twhile ((c = getopt(argc, argv, \"f:o:cdDSjilmrsvwz0123456789\")) != -1)\t\tswitch (c) {\t\tcase '0': case '1': case '2': case '3':\t\tcase '4': case '5': case '6': case '7':\t\tcase '8': case '9':\t\t\tdirnum = atoi(&argv[optind-1][1]);\t\t\tbreak;\t\tcase 'd':\t\t\tshowdata++;\t\t\t\t\tcase 'D':\t\t\treaddata++;\t\t\tbreak;\t\tcase 'c':\t\t\tflags |= TIFFPRINT_COLORMAP | TIFFPRINT_CURVES;\t\t\tbreak;\t\tcase 'f':\t\t\t\t\tif (streq(optarg, \"lsb2msb\"))\t\t\t\torder = FILLORDER_LSB2MSB;\t\t\telse if (streq(optarg, \"msb2lsb\"))\t\t\t\torder = FILLORDER_MSB2LSB;\t\t\telse\t\t\t\tusage();\t\t\tbreak;\t\tcase 'i':\t\t\tstoponerr = 0;\t\t\tbreak;\t\tcase 'o':\t\t\tdiroff = strtoul(optarg, NULL, 0);\t\t\tbreak;\t\tcase 'j':\t\t\tflags |= TIFFPRINT_JPEGQTABLES |\t\t\t\t TIFFPRINT_JPEGACTABLES |\t\t\t\t TIFFPRINT_JPEGDCTABLES;\t\t\tbreak;\t\tcase 'r':\t\t\trawdata = 1;\t\t\tbreak;\t\tcase 's':\t\t\tflags |= TIFFPRINT_STRIPS;\t\t\tbreak;\t\tcase 'w':\t\t\tshowwords = 1;\t\t\tbreak;\t\tcase 'z':\t\t\tchopstrips = 1;\t\t\tbreak;\t\tcase '?':\t\t\tusage();\t\t\t\t\t}\tif (optind >= argc)\t\tusage();\told_error_handler = TIFFSetErrorHandler(PrivateErrorHandler);\tmultiplefiles = (argc - optind > 1);\tfor (; optind < argc; optind++) {\t\tif (multiplefiles)\t\t\tprintf(\"%s:\\n\", argv[optind]);\t\ttif = TIFFOpen(argv[optind], chopstrips ? \"rC\" : \"rc\");\t\tif (tif != NULL) {\t\t\tif (dirnum != -1) {\t\t\t\tif (TIFFSetDirectory(tif, (tdir_t) dirnum))\t\t\t\t\ttiffinfo(tif, order, flags, 1);\t\t\t} else if (diroff != 0) {\t\t\t\tif (TIFFSetSubDirectory(tif, diroff))\t\t\t\t\ttiffinfo(tif, order, flags, 1);\t\t\t} else {\t\t\t\tdo {\t\t\t\t\ttoff_t offset;\t\t\t\t\ttiffinfo(tif, order, flags, 1);\t\t\t\t\tif (TIFFGetField(tif, TIFFTAG_EXIFIFD,\t\t\t\t\t\t\t &offset)) {\t\t\t\t\t\tif (TIFFReadEXIFDirectory(tif, offset)) {\t\t\t\t\t\t\ttiffinfo(tif, order, flags, 0);\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t} while (TIFFReadDirectory(tif));\t\t\t}\t\t\tTIFFClose(tif);\t\t}\t}\treturn (status);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static unsignedV2Code(float f, unsigned long RB, unsigned long RW, int CR){    unsigned int c = (unsigned int)((((f)*(RW-RB)/CR)+RB)+.5);    return (c > 255 ? 255 : c);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPackBitsPreEncode(TIFF* tif, uint16 s){\t(void) s;\tif (!(tif->tif_data = (uint8*)_TIFFmalloc(sizeof(tmsize_t))))\t\treturn (0);\t\tif (isTiled(tif))\t\t*(tmsize_t*)tif->tif_data = TIFFTileRowSize(tif);\telse\t\t*(tmsize_t*)tif->tif_data = TIFFScanlineSize(tif);\treturn (1);}",
        "label": 1,
        "cve": "cve-2015-8668"
    },
    {
        "code": "static intTIFFWritePerSampleShorts(TIFF* tif, ttag_t tag, TIFFDirEntry* dir){\tuint16 buf[10], v;\tuint16* w = buf;\tint i, status, samples = tif->tif_dir.td_samplesperpixel;\tif (samples > NITEMS(buf))\t\tw = (uint16*) _TIFFmalloc(samples * sizeof (uint16));\tTIFFGetField(tif, tag, &v);\tfor (i = 0; i < samples; i++)\t\tw[i] = v;\tstatus = TIFFWriteShortArray(tif, TIFF_SHORT, tag, dir, samples, w);\tif (w != buf)\t\t_TIFFfree((char*) w);\treturn (status);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static inthorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc){\tTIFFPredictorState* sp = PredictorState(tif);\ttmsize_t stride = sp->stride;\tuint16 *wp = (uint16*) cp0;\ttmsize_t wc = cc/2;    if((cc%(2*stride))!=0)    {        TIFFErrorExt(tif->tif_clientdata, \"horDiff8\",                     \"%s\", \"(cc%(2*stride))!=0\");        return 0;    }\tif (wc > stride) {\t\twc -= stride;\t\twp += wc - 1;\t\tdo {\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] - (unsigned int)wp[0]) & 0xffff); wp--)\t\t\twc -= stride;\t\t} while (wc > 0);\t}\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFfree(tdata_t p){\tGlobalFreePtr(p);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFFErrorHandlerExtTIFFSetWarningHandlerExt(TIFFErrorHandlerExt handler){\tTIFFErrorHandlerExt prev = _TIFFwarningHandlerExt;\t_TIFFwarningHandlerExt = handler;\treturn (prev);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tmsize_t t2p_writeproc(thandle_t handle, tdata_t data, tmsize_t size) {\tT2P *t2p = (T2P*) handle;\tif (t2p->outputdisable <= 0 && t2p->outputfile) {\t\ttsize_t written = fwrite(data, 1, size, t2p->outputfile);\t\tt2p->outputwritten += written;\t\treturn written;\t}\treturn size; }",
        "label": 1,
        "cve": "CVE-2017-17973"
    },
    {
        "code": "static intTIFFSetupShortPair(TIFF* tif, ttag_t tag, TIFFDirEntry* dir){\tuint16 v[2];\tTIFFGetField(tif, tag, &v[0], &v[1]);\treturn (TIFFWriteShortArray(tif, TIFF_SHORT, tag, dir, 2, v));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static toff_t_tiffSeekProc(thandle_t fd, toff_t off, int whence){\treturn ((toff_t) _TIFF_lseek_f((int) fd, (_TIFF_off_t) off, whence));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int dump_byte (FILE *dumpfile, int format, char *dump_tag, unsigned char data)  {  int j, k;  char  dump_array[10];  unsigned char bitset;  if (dumpfile == NULL)    {    TIFFError (\"\", \"Invalid FILE pointer for dump file\");    return (1);    }  if (format == DUMP_TEXT)    {    fprintf (dumpfile,\" %s  \", dump_tag);    for (j = 0, k = 7; j < 8; j++, k--)      {      bitset = data & (((unsigned char)1 << k)) ? 1 : 0;      sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");      }    dump_array[8] = '\\0';    fprintf (dumpfile,\" %s\\n\", dump_array);    }  else    {    if ((fwrite (&data, 1, 1, dumpfile)) != 1)      {      TIFFError (\"\", \"Unable to write binary data to dump file\");      return (1);      }    }  return (0);  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static uint64t2pSeekFile(TIFF *tif, toff_t offset, int whence){\tthandle_t client = TIFFClientdata(tif);\tTIFFSeekProc proc = TIFFGetSeekProc(tif);\tif (proc)\t\treturn proc(client, offset, whence);\treturn -1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tsize_t_tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size){\treturn (_hwrite(fd, buf, size));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tdata_t_TIFFrealloc(tdata_t p, tsize_t s){        void* pvTmp;        tsize_t old;        if(p == NULL)                return ((tdata_t)GlobalAlloc(GMEM_FIXED, s));        old = GlobalSize(p);        if (old>=s) {                if ((pvTmp = GlobalAlloc(GMEM_FIXED, s)) != NULL) {\t                CopyMemory(pvTmp, p, s);\t                GlobalFree(p);                }        } else {                if ((pvTmp = GlobalAlloc(GMEM_FIXED, s)) != NULL) {\t                CopyMemory(pvTmp, p, old);\t                GlobalFree(p);                }        }        return ((tdata_t)pvTmp);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static uint16photoArg(const char* arg){        if (strcmp(arg, \"miniswhite\") == 0)            return (PHOTOMETRIC_MINISWHITE);        else if (strcmp(arg, \"minisblack\") == 0)            return (PHOTOMETRIC_MINISBLACK);        else if (strcmp(arg, \"rgb\") == 0)            return (PHOTOMETRIC_RGB);        else if (strcmp(arg, \"palette\") == 0)            return (PHOTOMETRIC_PALETTE);        else if (strcmp(arg, \"mask\") == 0)            return (PHOTOMETRIC_MASK);        else if (strcmp(arg, \"separated\") == 0)            return (PHOTOMETRIC_SEPARATED);        else if (strcmp(arg, \"ycbcr\") == 0)            return (PHOTOMETRIC_YCBCR);        else if (strcmp(arg, \"cielab\") == 0)            return (PHOTOMETRIC_CIELAB);        else if (strcmp(arg, \"logl\") == 0)            return (PHOTOMETRIC_LOGL);        else if (strcmp(arg, \"logluv\") == 0)            return (PHOTOMETRIC_LOGLUV);        else            return ((uint16) -1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize){\ttoff_t size;\tHANDLE hMapFile;\tif ((size = _tiffSizeProc(fd)) == 0xFFFFFFFF)\t\treturn (0);\thMapFile = CreateFileMapping(fd, NULL, PAGE_READONLY, 0, size, NULL);\tif (hMapFile == NULL)\t\treturn (0);\t*pbase = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);\tCloseHandle(hMapFile);\tif (*pbase == NULL)\t\treturn (0);\t*psize = size;\treturn(1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchSubjectDistance(TIFF* tif, TIFFDirEntry* dir){\tuint32 l[2];\tfloat v;\tint ok = 0;\tif (TIFFFetchData(tif, dir, (char *)l)\t    && cvtRational(tif, dir, l[0], l[1], &v)) {\t\t\t\tok = TIFFSetField(tif, dir->tdir_tag,\t\t\t\t  (l[0] != 0xFFFFFFFF) ? v : -v);\t}\treturn ok;}",
        "label": 1,
        "cve": "cve-2010-2067"
    },
    {
        "code": "voidcheck(int R, int G, int B){    float Y, Cb, Cr;    int iY, iCb, iCr;    float rY, rCb, rCr;    float rR, rG, rB;    int eR, eG, eB;    Y = lumaRed[R] + lumaGreen[G] + lumaBlue[B];    Cb = (B - Y)*D2;    Cr = (R - Y)*D1;    iY = V2Code(Y, refBlackWhite[0], refBlackWhite[1], 255);    iCb = V2Code(Cb, refBlackWhite[2], refBlackWhite[3], 127);    iCr = V2Code(Cr, refBlackWhite[4], refBlackWhite[5], 127);    rCb = Code2V(iCb, refBlackWhite[2], refBlackWhite[3], 127);    rCr = Code2V(iCr, refBlackWhite[4], refBlackWhite[5], 127);    rY = Code2V(iY, refBlackWhite[0], refBlackWhite[1], 255);    rR = rY + rCr*D3;    rB = rY + rCb*D4;    rG = rY - rCb*D6 - rCr*D5;    eR = R - CLAMP(rR,0,255);    eG = G - CLAMP(rG,0,255);    eB = B - CLAMP(rB,0,255);    if (abs(eR) > 1 || abs(eG) > 1 || abs(eB) > 1) {\tprintf(\"R %u G %u B %u\", R, G, B);\tprintf(\" Y %g Cb %g Cr %g\", Y, Cb, Cr);\tprintf(\" iY %u iCb %u iCr %u\", iY, iCb, iCr);\tprintf(\"\\n -> Y %g Cb %g Cr %g\", rY, rCb, rCr);\tprintf(\" R %g (%u) G %g (%u) B %g (%u) E=[%d %d %d])\\n\"\t    , rR, CLAMP(rR,0,255)\t    , rG, CLAMP(rG,0,255)\t    , rB, CLAMP(rB,0,255)\t    , eR, eG, eB\t);    }    eRtotal += eR;    eGtotal += eG;    eBtotal += eB;    AbseRtotal += abs(eR);    AbseGtotal += abs(eG);    AbseBtotal += abs(eB);    if (eR | eG | eB)\teCodes++;    eBits += abs(eR) + abs(eG) + abs(eB);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(){\tTIFF\t\t*tif;\tsize_t\t\ti;\tunsigned char\tbuf[] = { 0, 127, 255 };\tchar\t\t*value;\t\ttif = TIFFOpen(filename, \"w\");\tif (!tif) {\t\tfprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename);\t\treturn 1;\t}\tif (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, 1)) {\t\tfprintf (stderr, \"Can't set ImageWidth tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, 1)) {\t\tfprintf (stderr, \"Can't set ImageLength tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8)) {\t\tfprintf (stderr, \"Can't set BitsPerSample tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, sizeof(buf))) {\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) {\t\tfprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)) {\t\tfprintf (stderr, \"Can't set PhotometricInterpretation tag.\\n\");\t\tgoto failure;\t}\tfor (i = 0; i < NTAGS; i++) {\t\tif (!TIFFSetField(tif, ascii_tags[i].tag,\t\t\t\t  ascii_tags[i].value)) {\t\t\tfprintf(stderr, \"Can't set tag %lu.\\n\",\t\t\t\t(unsigned long)ascii_tags[i].tag);\t\t\tgoto failure;\t\t}\t}\t\tif (!TIFFSetField(tif, TIFFTAG_NUMBEROFINKS, 3)) {\t\tfprintf (stderr, \"Can't set tag %d (NUMBEROFINKS).\\n\",                         TIFFTAG_NUMBEROFINKS);\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_INKNAMES, ink_names_size, ink_names)) {\t\tfprintf (stderr, \"Can't set tag %d (INKNAMES).\\n\",\t\t\t TIFFTAG_INKNAMES);\t\tgoto failure;\t}\t\tif (TIFFWriteScanline(tif, buf, 0, 0) == -1) {\t\tfprintf (stderr, \"Can't write image data.\\n\");\t\tgoto failure;\t}\tTIFFClose(tif);\t\ttif = TIFFOpen(filename, \"r\");\tif (!tif) {\t\tfprintf (stderr, \"Can't open test TIFF file %s.\\n\", filename);\t\treturn 1;\t}\tfor (i = 0; i < NTAGS; i++) {\t\tif (!TIFFGetField(tif, ascii_tags[i].tag, &value)\t\t    || strcmp(value, ascii_tags[i].value)) {\t\t\tfprintf(stderr, \"Can't get tag %lu.\\n\",\t\t\t\t(unsigned long)ascii_tags[i].tag);\t\t\tgoto failure;\t\t}\t}\tif (!TIFFGetField(tif, TIFFTAG_INKNAMES, &value)\t    || memcmp(value, ink_names, ink_names_size)) {\t\tfprintf (stderr, \"Can't get tag %d (INKNAMES).\\n\",\t\t\t TIFFTAG_INKNAMES);\t\tgoto failure;\t}\tTIFFClose(tif);\t\tunlink(filename);\treturn 0;failure:\t\tTIFFClose(tif);\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_tiffCloseProc(thandle_t fd){\tlong r;\tr = Fclose((int) fd);\tif (r < 0) {\t\terrno = (int)-r;\t\tr = -1;\t}\treturn (int)r;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int mfs_size (int fd){    int ret;    if (fds[fd] == -1)      {        ret = -1;        errno = EBADF;    }    else        ret = buf_size[fd];    return (ret);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFImageIterGet(TIFFImageIter* img, void *udata, uint32 w, uint32 h){    if (img->get == NULL) {\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"No \\\"get\\\" routine setup\");\treturn (0);    }    if (img->callback.any == NULL) {\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif),\t\t\"No \\\"put\\\" routine setupl; probably can not handle image format\");\treturn (0);    }    return (*img->get)(img, udata, w, h);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "WORD FAR PaletteSize(LPSTR lpDIB){      if (IS_WIN30_DIB (lpDIB))      return (DIBNumColors(lpDIB) * sizeof(RGBQUAD));   else      return (DIBNumColors(lpDIB) * sizeof(RGBTRIPLE));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intNeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s){\tstatic const char module[] = \"NeXTDecode\";\tunsigned char *bp, *op;\ttmsize_t cc;\tuint8* row;\ttmsize_t scanline, n;\t(void) s;\t\tfor (op = (unsigned char*) buf, cc = occ; cc-- > 0;)\t\t*op++ = 0xff;\tbp = (unsigned char *)tif->tif_rawcp;\tcc = tif->tif_rawcc;\tscanline = tif->tif_scanlinesize;\tif (occ % scanline)\t{\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\t\treturn (0);\t}\tfor (row = buf; occ > 0; occ -= scanline, row += scanline) {\t\tn = *bp++, cc--;\t\tswitch (n) {\t\tcase LITERALROW:\t\t\t\t\t\tif (cc < scanline)\t\t\t\tgoto bad;\t\t\t_TIFFmemcpy(row, bp, scanline);\t\t\tbp += scanline;\t\t\tcc -= scanline;\t\t\tbreak;\t\tcase LITERALSPAN: {\t\t\ttmsize_t off;\t\t\t\t\t\toff = (bp[0] * 256) + bp[1];\t\t\tn = (bp[2] * 256) + bp[3];\t\t\tif (cc < 4+n || off+n > scanline)\t\t\t\tgoto bad;\t\t\t_TIFFmemcpy(row+off, bp+4, n);\t\t\tbp += 4+n;\t\t\tcc -= 4+n;\t\t\tbreak;\t\t}\t\tdefault: {\t\t\tuint32 npixels = 0, grey;\t\t\tuint32 imagewidth = tif->tif_dir.td_imagewidth;\t\t\t\t\t\top = row;\t\t\tfor (;;) {\t\t\t\tgrey = (uint32)((n>>6) & 0x3);\t\t\t\tn &= 0x3f;\t\t\t\t\t\t\t\twhile (n-- > 0 && npixels < imagewidth)\t\t\t\t\tSETPIXEL(op, grey);\t\t\t\tif (npixels >= imagewidth)\t\t\t\t\tbreak;\t\t\t\tif (cc == 0)\t\t\t\t\tgoto bad;\t\t\t\tn = *bp++, cc--;\t\t\t}\t\t\tbreak;\t\t}\t\t}\t}\ttif->tif_rawcp = (uint8*) bp;\ttif->tif_rawcc = cc;\treturn (1);bad:\tTIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\",\t    (long) tif->tif_row);\treturn (0);}",
        "label": 1,
        "cve": "cve-2014-9655"
    },
    {
        "code": "static voidPixarLogClose(TIFF* tif){        PixarLogState* sp = (PixarLogState*) tif->tif_data;\tTIFFDirectory *td = &tif->tif_dir;\tassert(sp != 0);\t        if (sp->state&PLSTATE_INIT) {                        td->td_bitspersample = 8;            td->td_sampleformat = SAMPLEFORMAT_UINT;        }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_TIFFPrettyPrintField(TIFF* tif, const TIFFField *fip, FILE* fd, uint32 tag,\t\t      uint32 value_count, void *raw_data){        (void) tif;\t\tif (strncmp(fip->field_name,\"Tag \", 4) == 0) {\t\treturn 0;\t}\tswitch (tag)\t{\t\tcase TIFFTAG_INKSET:\t\t\tif (value_count == 2 && fip->field_type == TIFF_SHORT) {\t\t\t\tfprintf(fd, \"  Ink Set: \");\t\t\t\tswitch (*((uint16*)raw_data)) {\t\t\t\tcase INKSET_CMYK:\t\t\t\t\tfprintf(fd, \"CMYK\\n\");\t\t\t\t\tbreak;\t\t\t\tdefault:\t\t\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t\t\t\t*((uint16*)raw_data),\t\t\t\t\t\t*((uint16*)raw_data));\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\treturn 1;\t\t\t}\t\t\treturn 0;\t\tcase TIFFTAG_DOTRANGE:\t\t\tif (value_count == 2 && fip->field_type == TIFF_SHORT) {\t\t\t\tfprintf(fd, \"  Dot Range: %u-%u\\n\",\t\t\t\t\t((uint16*)raw_data)[0], ((uint16*)raw_data)[1]);\t\t\t\treturn 1;\t\t\t}\t\t\treturn 0;\t\tcase TIFFTAG_WHITEPOINT:\t\t\tif (value_count == 2 && fip->field_type == TIFF_RATIONAL) {\t\t\t\tfprintf(fd, \"  White Point: %g-%g\\n\",\t\t\t\t\t((float *)raw_data)[0], ((float *)raw_data)[1]);\t\t\t\treturn 1;\t\t\t} \t\t\treturn 0;\t\tcase TIFFTAG_XMLPACKET:\t\t{\t\t\tuint32 i;\t\t\tfprintf(fd, \"  XMLPacket (XMP Metadata):\\n\" );\t\t\tfor(i = 0; i < value_count; i++)\t\t\t\tfputc(((char *)raw_data)[i], fd);\t\t\tfprintf( fd, \"\\n\" );\t\t\treturn 1;\t\t}\t\tcase TIFFTAG_RICHTIFFIPTC:\t\t\t\t\t\tfprintf(fd,\t\t\t    \"  RichTIFFIPTC Data: <present>, %lu bytes\\n\",\t\t\t    (unsigned long) value_count * 4);\t\t\treturn 1;\t\tcase TIFFTAG_PHOTOSHOP:\t\t\tfprintf(fd, \"  Photoshop Data: <present>, %lu bytes\\n\",\t\t\t    (unsigned long) value_count);\t\t\treturn 1;\t\tcase TIFFTAG_ICCPROFILE:\t\t\tfprintf(fd, \"  ICC Profile: <present>, %lu bytes\\n\",\t\t\t    (unsigned long) value_count);\t\t\treturn 1;\t\tcase TIFFTAG_STONITS:\t\t\tif (value_count == 1 && fip->field_type == TIFF_DOUBLE) { \t\t\t\tfprintf(fd,\t\t\t\t\t\"  Sample to Nits conversion factor: %.4e\\n\",\t\t\t\t\t*((double*)raw_data));\t\t\t\treturn 1;\t\t\t}\t\t\treturn 0;\t}\treturn 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidPrintType(FILE* fd, uint16 type){\tstatic const char *typenames[] = {\t    \"0\",\t    \"BYTE\",\t    \"ASCII\",\t    \"SHORT\",\t    \"LONG\",\t    \"RATIONAL\",\t    \"SBYTE\",\t    \"UNDEFINED\",\t    \"SSHORT\",\t    \"SLONG\",\t    \"SRATIONAL\",\t    \"FLOAT\",\t    \"DOUBLE\",\t    \"IFD\",\t    \"14\",\t    \"15\",\t    \"LONG8\",\t    \"SLONG8\",\t    \"IFD8\"\t};#define\tNTYPES\t(sizeof (typenames) / sizeof (typenames[0]))\tif (type < NTYPES)\t\tfprintf(fd, \"%s (%u)\", typenames[type], type);\telse\t\tfprintf(fd, \"%u (%#x)\", type, type);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_tiffCloseProc(thandle_t fd){\treturn (close((int) fd));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidLZWCleanup(TIFF* tif){\t(void)TIFFPredictorCleanup(tif);\tassert(tif->tif_data != 0);\tif (DecoderState(tif)->dec_codetab)\t\t_TIFFfree(DecoderState(tif)->dec_codetab);\tif (EncoderState(tif)->enc_hashtab)\t\t_TIFFfree(EncoderState(tif)->enc_hashtab);\t_TIFFfree(tif->tif_data);\ttif->tif_data = NULL;\t_TIFFSetDefaultCompressionState(tif);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(void){\t\tint i;\t        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\tfor (i = 0; stuff[i] != NULL; i++)\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\texit(-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "uint32TIFFCurrentDirOffset(TIFF* tif){\treturn (tif->tif_diroff);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidhorizontalAccumulateF(uint16 *wp, int n, int stride, float *op,\tfloat *ToLinearF){    register unsigned int  cr, cg, cb, ca, mask;    register float  t0, t1, t2, t3;    if (n >= stride) {\tmask = CODE_MASK;\tif (stride == 3) {\t    t0 = ToLinearF[cr = (wp[0] & mask)];\t    t1 = ToLinearF[cg = (wp[1] & mask)];\t    t2 = ToLinearF[cb = (wp[2] & mask)];\t    op[0] = t0;\t    op[1] = t1;\t    op[2] = t2;\t    n -= 3;\t    while (n > 0) {\t\twp += 3;\t\top += 3;\t\tn -= 3;\t\tt0 = ToLinearF[(cr += wp[0]) & mask];\t\tt1 = ToLinearF[(cg += wp[1]) & mask];\t\tt2 = ToLinearF[(cb += wp[2]) & mask];\t\top[0] = t0;\t\top[1] = t1;\t\top[2] = t2;\t    }\t} else if (stride == 4) {\t    t0 = ToLinearF[cr = (wp[0] & mask)];\t    t1 = ToLinearF[cg = (wp[1] & mask)];\t    t2 = ToLinearF[cb = (wp[2] & mask)];\t    t3 = ToLinearF[ca = (wp[3] & mask)];\t    op[0] = t0;\t    op[1] = t1;\t    op[2] = t2;\t    op[3] = t3;\t    n -= 4;\t    while (n > 0) {\t\twp += 4;\t\top += 4;\t\tn -= 4;\t\tt0 = ToLinearF[(cr += wp[0]) & mask];\t\tt1 = ToLinearF[(cg += wp[1]) & mask];\t\tt2 = ToLinearF[(cb += wp[2]) & mask];\t\tt3 = ToLinearF[(ca += wp[3]) & mask];\t\top[0] = t0;\t\top[1] = t1;\t\top[2] = t2;\t\top[3] = t3;\t    }\t} else {\t    REPEAT(stride, *op = ToLinearF[*wp&mask]; wp++; op++)\t    n -= stride;\t    while (n > 0) {\t\tREPEAT(stride,\t\t    wp[stride] += *wp; *op = ToLinearF[*wp&mask]; wp++; op++)\t\tn -= stride;\t    }\t}    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFFlush(TIFF* tif){    if( tif->tif_mode == O_RDONLY )        return 1;    if (!TIFFFlushData(tif))        return (0);        if( (tif->tif_flags & TIFF_DIRTYSTRIP)        && !(tif->tif_flags & TIFF_DIRTYDIRECT)         && tif->tif_mode == O_RDWR )    {        uint64  *offsets=NULL, *sizes=NULL;        if( TIFFIsTiled(tif) )        {            if( TIFFGetField( tif, TIFFTAG_TILEOFFSETS, &offsets )                 && TIFFGetField( tif, TIFFTAG_TILEBYTECOUNTS, &sizes )                 && _TIFFRewriteField( tif, TIFFTAG_TILEOFFSETS, TIFF_LONG8,                                       tif->tif_dir.td_nstrips, offsets )                && _TIFFRewriteField( tif, TIFFTAG_TILEBYTECOUNTS, TIFF_LONG8,                                       tif->tif_dir.td_nstrips, sizes ) )            {                tif->tif_flags &= ~TIFF_DIRTYSTRIP;                tif->tif_flags &= ~TIFF_BEENWRITING;                return 1;            }        }        else        {            if( TIFFGetField( tif, TIFFTAG_STRIPOFFSETS, &offsets )                 && TIFFGetField( tif, TIFFTAG_STRIPBYTECOUNTS, &sizes )                 && _TIFFRewriteField( tif, TIFFTAG_STRIPOFFSETS, TIFF_LONG8,                                       tif->tif_dir.td_nstrips, offsets )                && _TIFFRewriteField( tif, TIFFTAG_STRIPBYTECOUNTS, TIFF_LONG8,                                       tif->tif_dir.td_nstrips, sizes ) )            {                tif->tif_flags &= ~TIFF_DIRTYSTRIP;                tif->tif_flags &= ~TIFF_BEENWRITING;                return 1;            }        }    }    if ((tif->tif_flags & (TIFF_DIRTYDIRECT|TIFF_DIRTYSTRIP))         && !TIFFRewriteDirectory(tif))        return (0);    return (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFPrintDirectory(TIFF* tif, FILE* fd, long flags){\tTIFFDirectory *td = &tif->tif_dir;\tchar *sep;\tlong l, n;#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\tfprintf(fd, \"TIFF Directory at offset 0x%I64x (%I64u)\\n\",\t\t(unsigned __int64) tif->tif_diroff,\t\t(unsigned __int64) tif->tif_diroff);#else\tfprintf(fd, \"TIFF Directory at offset 0x%llx (%llu)\\n\",\t\t(unsigned long long) tif->tif_diroff,\t\t(unsigned long long) tif->tif_diroff);#endif\tif (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) {\t\tfprintf(fd, \"  Subfile Type:\");\t\tsep = \" \";\t\tif (td->td_subfiletype & FILETYPE_REDUCEDIMAGE) {\t\t\tfprintf(fd, \"%sreduced-resolution image\", sep);\t\t\tsep = \"/\";\t\t}\t\tif (td->td_subfiletype & FILETYPE_PAGE) {\t\t\tfprintf(fd, \"%smulti-page document\", sep);\t\t\tsep = \"/\";\t\t}\t\tif (td->td_subfiletype & FILETYPE_MASK)\t\t\tfprintf(fd, \"%stransparency mask\", sep);\t\tfprintf(fd, \" (%lu = 0x%lx)\\n\",\t\t    (unsigned long) td->td_subfiletype, (long) td->td_subfiletype);\t}\tif (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) {\t\tfprintf(fd, \"  Image Width: %lu Image Length: %lu\",\t\t    (unsigned long) td->td_imagewidth, (unsigned long) td->td_imagelength);\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))\t\t\tfprintf(fd, \" Image Depth: %lu\",\t\t\t    (unsigned long) td->td_imagedepth);\t\tfprintf(fd, \"\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) {\t\tfprintf(fd, \"  Tile Width: %lu Tile Length: %lu\",\t\t    (unsigned long) td->td_tilewidth, (unsigned long) td->td_tilelength);\t\tif (TIFFFieldSet(tif,FIELD_TILEDEPTH))\t\t\tfprintf(fd, \" Tile Depth: %lu\",\t\t\t    (unsigned long) td->td_tiledepth);\t\tfprintf(fd, \"\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_RESOLUTION)) {\t\tfprintf(fd, \"  Resolution: %g, %g\",\t\t    td->td_xresolution, td->td_yresolution);\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) {\t\t\tswitch (td->td_resolutionunit) {\t\t\tcase RESUNIT_NONE:\t\t\t\tfprintf(fd, \" (unitless)\");\t\t\t\tbreak;\t\t\tcase RESUNIT_INCH:\t\t\t\tfprintf(fd, \" pixels/inch\");\t\t\t\tbreak;\t\t\tcase RESUNIT_CENTIMETER:\t\t\t\tfprintf(fd, \" pixels/cm\");\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tfprintf(fd, \" (unit %u = 0x%x)\",\t\t\t\t    td->td_resolutionunit,\t\t\t\t    td->td_resolutionunit);\t\t\t\tbreak;\t\t\t}\t\t}\t\tfprintf(fd, \"\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_POSITION))\t\tfprintf(fd, \"  Position: %g, %g\\n\",\t\t    td->td_xposition, td->td_yposition);\tif (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\t\tfprintf(fd, \"  Bits/Sample: %u\\n\", td->td_bitspersample);\tif (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) {\t\tfprintf(fd, \"  Sample Format: \");\t\tswitch (td->td_sampleformat) {\t\tcase SAMPLEFORMAT_VOID:\t\t\tfprintf(fd, \"void\\n\");\t\t\tbreak;\t\tcase SAMPLEFORMAT_INT:\t\t\tfprintf(fd, \"signed integer\\n\");\t\t\tbreak;\t\tcase SAMPLEFORMAT_UINT:\t\t\tfprintf(fd, \"unsigned integer\\n\");\t\t\tbreak;\t\tcase SAMPLEFORMAT_IEEEFP:\t\t\tfprintf(fd, \"IEEE floating point\\n\");\t\t\tbreak;\t\tcase SAMPLEFORMAT_COMPLEXINT:\t\t\tfprintf(fd, \"complex signed integer\\n\");\t\t\tbreak;\t\tcase SAMPLEFORMAT_COMPLEXIEEEFP:\t\t\tfprintf(fd, \"complex IEEE floating point\\n\");\t\t\tbreak;\t\tdefault:\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_sampleformat, td->td_sampleformat);\t\t\tbreak;\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_COMPRESSION)) {\t\tconst TIFFCodec* c = TIFFFindCODEC(td->td_compression);\t\tfprintf(fd, \"  Compression Scheme: \");\t\tif (c)\t\t\tfprintf(fd, \"%s\\n\", c->name);\t\telse\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_compression, td->td_compression);\t}\tif (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) {\t\tfprintf(fd, \"  Photometric Interpretation: \");\t\tif (td->td_photometric < NPHOTONAMES)\t\t\tfprintf(fd, \"%s\\n\", photoNames[td->td_photometric]);\t\telse {\t\t\tswitch (td->td_photometric) {\t\t\tcase PHOTOMETRIC_LOGL:\t\t\t\tfprintf(fd, \"CIE Log2(L)\\n\");\t\t\t\tbreak;\t\t\tcase PHOTOMETRIC_LOGLUV:\t\t\t\tfprintf(fd, \"CIE Log2(L) (u',v')\\n\");\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t\t    td->td_photometric, td->td_photometric);\t\t\t\tbreak;\t\t\t}\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_EXTRASAMPLES) && td->td_extrasamples) {\t\tuint16 i;\t\tfprintf(fd, \"  Extra Samples: %u<\", td->td_extrasamples);\t\tsep = \"\";\t\tfor (i = 0; i < td->td_extrasamples; i++) {\t\t\tswitch (td->td_sampleinfo[i]) {\t\t\tcase EXTRASAMPLE_UNSPECIFIED:\t\t\t\tfprintf(fd, \"%sunspecified\", sep);\t\t\t\tbreak;\t\t\tcase EXTRASAMPLE_ASSOCALPHA:\t\t\t\tfprintf(fd, \"%sassoc-alpha\", sep);\t\t\t\tbreak;\t\t\tcase EXTRASAMPLE_UNASSALPHA:\t\t\t\tfprintf(fd, \"%sunassoc-alpha\", sep);\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tfprintf(fd, \"%s%u (0x%x)\", sep,\t\t\t\t    td->td_sampleinfo[i], td->td_sampleinfo[i]);\t\t\t\tbreak;\t\t\t}\t\t\tsep = \", \";\t\t}\t\tfprintf(fd, \">\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_INKNAMES)) {\t\tchar* cp;\t\tuint16 i;\t\tfprintf(fd, \"  Ink Names: \");\t\ti = td->td_samplesperpixel;\t\tsep = \"\";\t\tfor (cp = td->td_inknames; \t\t     i > 0 && cp < td->td_inknames + td->td_inknameslen; \t\t     cp = strchr(cp,'\\0')+1, i--) {\t\t\tsize_t max_chars = \t\t\t\ttd->td_inknameslen - (cp - td->td_inknames);\t\t\tfputs(sep, fd);\t\t\t_TIFFprintAsciiBounded(fd, cp, max_chars);\t\t\tsep = \", \";\t\t}                fputs(\"\\n\", fd);\t}\tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) {\t\tfprintf(fd, \"  Thresholding: \");\t\tswitch (td->td_threshholding) {\t\tcase THRESHHOLD_BILEVEL:\t\t\tfprintf(fd, \"bilevel art scan\\n\");\t\t\tbreak;\t\tcase THRESHHOLD_HALFTONE:\t\t\tfprintf(fd, \"halftone or dithered scan\\n\");\t\t\tbreak;\t\tcase THRESHHOLD_ERRORDIFFUSE:\t\t\tfprintf(fd, \"error diffused\\n\");\t\t\tbreak;\t\tdefault:\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_threshholding, td->td_threshholding);\t\t\tbreak;\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_FILLORDER)) {\t\tfprintf(fd, \"  FillOrder: \");\t\tswitch (td->td_fillorder) {\t\tcase FILLORDER_MSB2LSB:\t\t\tfprintf(fd, \"msb-to-lsb\\n\");\t\t\tbreak;\t\tcase FILLORDER_LSB2MSB:\t\t\tfprintf(fd, \"lsb-to-msb\\n\");\t\t\tbreak;\t\tdefault:\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_fillorder, td->td_fillorder);\t\t\tbreak;\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))        {\t\tfprintf(fd, \"  YCbCr Subsampling: %u, %u\\n\",\t\t\ttd->td_ycbcrsubsampling[0], td->td_ycbcrsubsampling[1] );\t}\tif (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) {\t\tfprintf(fd, \"  YCbCr Positioning: \");\t\tswitch (td->td_ycbcrpositioning) {\t\tcase YCBCRPOSITION_CENTERED:\t\t\tfprintf(fd, \"centered\\n\");\t\t\tbreak;\t\tcase YCBCRPOSITION_COSITED:\t\t\tfprintf(fd, \"cosited\\n\");\t\t\tbreak;\t\tdefault:\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_ycbcrpositioning, td->td_ycbcrpositioning);\t\t\tbreak;\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))\t\tfprintf(fd, \"  Halftone Hints: light %u dark %u\\n\",\t\t    td->td_halftonehints[0], td->td_halftonehints[1]);\tif (TIFFFieldSet(tif,FIELD_ORIENTATION)) {\t\tfprintf(fd, \"  Orientation: \");\t\tif (td->td_orientation < NORIENTNAMES)\t\t\tfprintf(fd, \"%s\\n\", orientNames[td->td_orientation]);\t\telse\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_orientation, td->td_orientation);\t}\tif (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\t\tfprintf(fd, \"  Samples/Pixel: %u\\n\", td->td_samplesperpixel);\tif (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) {\t\tfprintf(fd, \"  Rows/Strip: \");\t\tif (td->td_rowsperstrip == (uint32) -1)\t\t\tfprintf(fd, \"(infinite)\\n\");\t\telse\t\t\tfprintf(fd, \"%lu\\n\", (unsigned long) td->td_rowsperstrip);\t}\tif (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))\t\tfprintf(fd, \"  Min Sample Value: %u\\n\", td->td_minsamplevalue);\tif (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))\t\tfprintf(fd, \"  Max Sample Value: %u\\n\", td->td_maxsamplevalue);\tif (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) {\t\tint i;\t\tint count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;\t\tfprintf(fd, \"  SMin Sample Value:\");\t\tfor (i = 0; i < count; ++i)\t\t\tfprintf(fd, \" %g\", td->td_sminsamplevalue[i]);\t\tfprintf(fd, \"\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) {\t\tint i;\t\tint count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;\t\tfprintf(fd, \"  SMax Sample Value:\");\t\tfor (i = 0; i < count; ++i)\t\t\tfprintf(fd, \" %g\", td->td_smaxsamplevalue[i]);\t\tfprintf(fd, \"\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) {\t\tfprintf(fd, \"  Planar Configuration: \");\t\tswitch (td->td_planarconfig) {\t\tcase PLANARCONFIG_CONTIG:\t\t\tfprintf(fd, \"single image plane\\n\");\t\t\tbreak;\t\tcase PLANARCONFIG_SEPARATE:\t\t\tfprintf(fd, \"separate image planes\\n\");\t\t\tbreak;\t\tdefault:\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\t\t\t    td->td_planarconfig, td->td_planarconfig);\t\t\tbreak;\t\t}\t}\tif (TIFFFieldSet(tif,FIELD_PAGENUMBER))\t\tfprintf(fd, \"  Page Number: %u-%u\\n\",\t\t    td->td_pagenumber[0], td->td_pagenumber[1]);\tif (TIFFFieldSet(tif,FIELD_COLORMAP)) {\t\tfprintf(fd, \"  Color Map: \");\t\tif (flags & TIFFPRINT_COLORMAP) {\t\t\tfprintf(fd, \"\\n\");\t\t\tn = 1L<<td->td_bitspersample;\t\t\tfor (l = 0; l < n; l++)\t\t\t\tfprintf(fd, \"   %5ld: %5u %5u %5u\\n\",\t\t\t\t    l,\t\t\t\t    td->td_colormap[0][l],\t\t\t\t    td->td_colormap[1][l],\t\t\t\t    td->td_colormap[2][l]);\t\t} else\t\t\tfprintf(fd, \"(present)\\n\");\t}\tif (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) {\t\tint i;\t\tfprintf(fd, \"  Reference Black/White:\\n\");\t\tfor (i = 0; i < 3; i++)\t\tfprintf(fd, \"    %2d: %5g %5g\\n\", i,\t\t\ttd->td_refblackwhite[2*i+0],\t\t\ttd->td_refblackwhite[2*i+1]);\t}\tif (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) {\t\tfprintf(fd, \"  Transfer Function: \");\t\tif (flags & TIFFPRINT_CURVES) {\t\t\tfprintf(fd, \"\\n\");\t\t\tn = 1L<<td->td_bitspersample;\t\t\tfor (l = 0; l < n; l++) {\t\t\t\tuint16 i;\t\t\t\tfprintf(fd, \"    %2ld: %5u\",\t\t\t\t    l, td->td_transferfunction[0][l]);\t\t\t\tfor (i = 1; i < td->td_samplesperpixel; i++)\t\t\t\t\tfprintf(fd, \" %5u\",\t\t\t\t\t    td->td_transferfunction[i][l]);\t\t\t\tfputc('\\n', fd);\t\t\t}\t\t} else\t\t\tfprintf(fd, \"(present)\\n\");\t}\tif (TIFFFieldSet(tif, FIELD_SUBIFD) && (td->td_subifd)) {\t\tuint16 i;\t\tfprintf(fd, \"  SubIFD Offsets:\");\t\tfor (i = 0; i < td->td_nsubifd; i++)#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\t\tfprintf(fd, \" %5I64u\",\t\t\t\t(unsigned __int64) td->td_subifd[i]);#else\t\t\tfprintf(fd, \" %5llu\",\t\t\t\t(unsigned long long) td->td_subifd[i]);#endif\t\tfputc('\\n', fd);\t}\t \t{\t\tint  i;\t\tshort count;\t\tcount = (short) TIFFGetTagListCount(tif);\t\tfor(i = 0; i < count; i++) {\t\t\tuint32 tag = TIFFGetTagListEntry(tif, i);\t\t\tconst TIFFField *fip;\t\t\tuint32 value_count;\t\t\tint mem_alloc = 0;\t\t\tvoid *raw_data;\t\t\tfip = TIFFFieldWithTag(tif, tag);\t\t\tif(fip == NULL)\t\t\t\tcontinue;\t\t\tif(fip->field_passcount) {\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2 ) {\t\t\t\t\tif(TIFFGetField(tif, tag, &value_count, &raw_data) != 1)\t\t\t\t\t\tcontinue;\t\t\t\t} else if (fip->field_readcount == TIFF_VARIABLE ) {\t\t\t\t\tuint16 small_value_count;\t\t\t\t\tif(TIFFGetField(tif, tag, &small_value_count, &raw_data) != 1)\t\t\t\t\t\tcontinue;\t\t\t\t\tvalue_count = small_value_count;\t\t\t\t} else {\t\t\t\t\tassert (fip->field_readcount == TIFF_VARIABLE\t\t\t\t\t\t|| fip->field_readcount == TIFF_VARIABLE2);\t\t\t\t\tcontinue;\t\t\t\t} \t\t\t} else {\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2)\t\t\t\t\tvalue_count = 1;\t\t\t\telse if (fip->field_readcount == TIFF_SPP)\t\t\t\t\tvalue_count = td->td_samplesperpixel;\t\t\t\telse\t\t\t\t\tvalue_count = fip->field_readcount;\t\t\t\tif (fip->field_tag == TIFFTAG_DOTRANGE\t\t\t\t    && strcmp(fip->field_name,\"DotRange\") == 0) {\t\t\t\t\t \t\t\t\t\tstatic uint16 dotrange[2];\t\t\t\t\traw_data = dotrange;\t\t\t\t\tTIFFGetField(tif, tag, dotrange+0, dotrange+1);\t\t\t\t} else if (fip->field_type == TIFF_ASCII\t\t\t\t\t   || fip->field_readcount == TIFF_VARIABLE\t\t\t\t\t   || fip->field_readcount == TIFF_VARIABLE2\t\t\t\t\t   || fip->field_readcount == TIFF_SPP\t\t\t\t\t   || value_count > 1) {\t\t\t\t\tif(TIFFGetField(tif, tag, &raw_data) != 1)\t\t\t\t\t\tcontinue;\t\t\t\t} else {\t\t\t\t\traw_data = _TIFFmalloc(\t\t\t\t\t    _TIFFDataSize(fip->field_type)\t\t\t\t\t    * value_count);\t\t\t\t\tmem_alloc = 1;\t\t\t\t\tif(TIFFGetField(tif, tag, raw_data) != 1) {\t\t\t\t\t\t_TIFFfree(raw_data);\t\t\t\t\t\tcontinue;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\t \t\t\tif (!_TIFFPrettyPrintField(tif, fip, fd, tag, value_count, raw_data))\t\t\t\t_TIFFPrintField(fd, fip, value_count, raw_data);\t\t\tif(mem_alloc)\t\t\t\t_TIFFfree(raw_data);\t\t}\t}        \tif (tif->tif_tagmethods.printdir)\t\t(*tif->tif_tagmethods.printdir)(tif, fd, flags);        _TIFFFillStriles( tif );        \tif ((flags & TIFFPRINT_STRIPS) &&\t    TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) {\t\tuint32 s;\t\tfprintf(fd, \"  %lu %s:\\n\",\t\t    (unsigned long) td->td_nstrips,\t\t    isTiled(tif) ? \"Tiles\" : \"Strips\");\t\tfor (s = 0; s < td->td_nstrips; s++)#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\t\tfprintf(fd, \"    %3lu: [%8I64u, %8I64u]\\n\",\t\t\t    (unsigned long) s,\t\t\t    (unsigned __int64) td->td_stripoffset[s],\t\t\t    (unsigned __int64) td->td_stripbytecount[s]);#else\t\t\tfprintf(fd, \"    %3lu: [%8llu, %8llu]\\n\",\t\t\t    (unsigned long) s,\t\t\t    (unsigned long long) td->td_stripoffset[s],\t\t\t    (unsigned long long) td->td_stripbytecount[s]);#endif\t}}",
        "label": 1,
        "cve": "CVE-2018-7456"
    },
    {
        "code": "static copyFuncpickCopyFunc(TIFF* in, TIFF* out, uint16 bitspersample, uint16 samplesperpixel){\tuint16 shortv;\tuint32 w, l, tw, tl;\tint bychunk;\t(void) TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &shortv);\tif (shortv != config && bitspersample != 8 && samplesperpixel > 1) {\t\tfprintf(stderr,\t\t    \"%s: Cannot handle different planar configuration w/ bits/sample != 8\\n\",\t\t    TIFFFileName(in));\t\treturn (NULL);\t}\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w);\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &l);\tif (!(TIFFIsTiled(out) || TIFFIsTiled(in))) {\t\tuint32 irps = (uint32) -1L;\t\tTIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &irps);\t\t\t\tbychunk = !bias && (rowsperstrip == irps);\t}else{  \t\tif (bias) {\t\t\tfprintf(stderr,\t\t\t    \"%s: Cannot handle tiled configuration w/bias image\\n\",\t\t\tTIFFFileName(in));\t\t\treturn (NULL);\t\t}\t\tif (TIFFIsTiled(out)) {\t\t\tif (!TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw))\t\t\t\ttw = w;\t\t\tif (!TIFFGetField(in, TIFFTAG_TILELENGTH, &tl))\t\t\t\ttl = l;\t\t\tbychunk = (tw == tilewidth && tl == tilelength);\t\t} else {  \t\t\tTIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\t\t\tTIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\t\t\tbychunk = (tw == w && tl == rowsperstrip);\t\t}\t}#define\tT 1#define\tF 0#define pack(a,b,c,d,e)\t((long)(((a)<<11)|((b)<<3)|((c)<<2)|((d)<<1)|(e)))\tswitch(pack(shortv,config,TIFFIsTiled(in),TIFFIsTiled(out),bychunk)) {\t\t\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,T,F):\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,T,T):\t\t\treturn cpContigStrips2ContigTiles;\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, F,T,F):\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, F,T,T):\t\t\treturn cpContigStrips2SeparateTiles;\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,T,F):\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,T,T):\t\t\treturn cpSeparateStrips2ContigTiles;\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,F):\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,T):\t\t\treturn cpSeparateStrips2SeparateTiles;\t\t\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,T,F):\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,T,T):\t\t\treturn cpContigTiles2ContigTiles;\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,T,F):\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,T,T):\t\t\treturn cpContigTiles2SeparateTiles;\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,T,F):\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,T,T):\t\t\treturn cpSeparateTiles2ContigTiles;\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,F):\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,T):\t\t\treturn cpSeparateTiles2SeparateTiles;\t\t\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,F,F):\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,F,T):\t\t\treturn cpContigTiles2ContigStrips;\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,F,F):\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,F,T):\t\t\treturn cpContigTiles2SeparateStrips;\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,F,F):\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,F,T):\t\t\treturn cpSeparateTiles2ContigStrips;\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,F):\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,T):\t\t\treturn cpSeparateTiles2SeparateStrips;\t\t\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,F,F):\t\t\treturn bias ? cpBiasedContig2Contig : cpContig2ContigByRow;\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,F,T):\t\t\treturn cpDecodedStrips;\t\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE,   F,F,F):\t\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE,   F,F,T):\t\t\treturn cpContig2SeparateByRow;\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,F,F):\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,F,T):\t\t\treturn cpSeparate2ContigByRow;\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,F):\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,T):\t\t\treturn cpSeparate2SeparateByRow;\t}#undef pack#undef F#undef T\tfprintf(stderr, \"tiffcp: %s: Don't know how to copy/convert image.\\n\",\t    TIFFFileName(in));\treturn (NULL);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int TIFFInitJBIG(TIFF* tif, int scheme){\tassert(scheme == COMPRESSION_JBIG);\t\ttif->tif_flags |= TIFF_NOBITREV;\ttif->tif_flags &= ~TIFF_MAPPED;\t\ttif->tif_setupdecode = JBIGSetupDecode;\ttif->tif_decodestrip = JBIGDecode;\ttif->tif_setupencode = JBIGSetupEncode;\ttif->tif_encodestrip = JBIGEncode;\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intCheckStringTag(TIFF* tif1, TIFF* tif2, int tag, char* name){\tchar *v1, *v2;\tCHECK(strcmp(v1, v2) == 0, \"%s: \\\"%s\\\" \\\"%s\\\"\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcpImage(TIFF* in, TIFF* out, readFunc fin, writeFunc fout,\tuint32 imagelength, uint32 imagewidth, tsample_t spp){\tint status = 0;\ttdata_t buf = NULL;\ttsize_t scanlinesize = TIFFRasterScanlineSize(in);\ttsize_t bytes = scanlinesize * (tsize_t)imagelength;\t\tif (scanlinesize\t    && imagelength\t    && bytes / (tsize_t)imagelength == scanlinesize) {\t\tbuf = _TIFFmalloc(bytes);\t\tif (buf) {\t\t\tif ((*fin)(in, (uint8*)buf, imagelength,\t\t\t    imagewidth, spp)) {\t\t\t\tstatus = (*fout)(out, (uint8*)buf,\t\t\t\t    imagelength, imagewidth, spp);\t\t\t}\t\t\t_TIFFfree(buf);\t\t} else {\t\t\tTIFFError(TIFFFileName(in),\t\t\t    \"Error, can't allocate space for image buffer\");\t\t}\t} else {\t\tTIFFError(TIFFFileName(in), \"Error, no space for image buffer\");\t}\treturn status;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intFax3SetupState(TIFF* tif){\tTIFFDirectory* td = &tif->tif_dir;\tFax3BaseState* sp = Fax3State(tif);\tint needsRefLine;\tFax3CodecState* dsp = (Fax3CodecState*) Fax3State(tif);\tuint32 rowbytes, rowpixels, nruns;\tif (td->td_bitspersample != 1) {\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t    \"Bits/sample must be 1 for Group 3/4 encoding/decoding\");\t\treturn (0);\t}\t\tif (isTiled(tif)) {\t\trowbytes = TIFFTileRowSize(tif);\t\trowpixels = td->td_tilewidth;\t} else {\t\trowbytes = TIFFScanlineSize(tif);\t\trowpixels = td->td_imagewidth;\t}\tsp->rowbytes = (uint32) rowbytes;\tsp->rowpixels = (uint32) rowpixels;\t\tneedsRefLine = (\t    (sp->groupoptions & GROUP3OPT_2DENCODING) ||\t    td->td_compression == COMPRESSION_CCITTFAX4\t);\tnruns = needsRefLine ? 2*TIFFroundup(rowpixels,32) : rowpixels;\tdsp->runs = (uint32*) _TIFFCheckMalloc(tif, 2*nruns+3, sizeof (uint32),\t\t\t\t\t  \"for Group 3/4 run arrays\");\tif (dsp->runs == NULL)\t\treturn (0);\tdsp->curruns = dsp->runs;\tif (needsRefLine)\t\tdsp->refruns = dsp->runs + (nruns>>1);\telse\t\tdsp->refruns = NULL;\tif (td->td_compression == COMPRESSION_CCITTFAX3\t    && is2DEncoding(dsp)) {\t\t\ttif->tif_decoderow = Fax3Decode2D;\t\ttif->tif_decodestrip = Fax3Decode2D;\t\ttif->tif_decodetile = Fax3Decode2D;\t}\tif (needsRefLine) {\t\t\t\tFax3CodecState* esp = EncoderState(tif);\t\t\t\tesp->refline = (unsigned char*) _TIFFmalloc(rowbytes);\t\tif (esp->refline == NULL) {\t\t\tTIFFErrorExt(tif->tif_clientdata, \"Fax3SetupState\",\t\t\t    \"%s: No space for Group 3/4 reference line\",\t\t\t    tif->tif_name);\t\t\treturn (0);\t\t}\t} else\t\t\t\t\t\t\tEncoderState(tif)->refline = NULL;\treturn (1);}",
        "label": 1,
        "cve": "cve-2010-1411"
    },
    {
        "code": "extern int read(int fd, char *buf, int nbytes){\t\treturn (nbytes - osgbpb_read((os_f) fd, (byte*) buf, nbytes));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intFax4Encode(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s){\tFax3CodecState *sp = EncoderState(tif);\t(void) s;\twhile ((long)cc > 0) {\t\tif (!Fax3Encode2DRow(tif, bp, sp->refline, sp->b.rowpixels))\t\t\treturn (0);\t\t_TIFFmemcpy(sp->refline, bp, sp->b.rowbytes);\t\tbp += sp->b.rowbytes;\t\tcc -= sp->b.rowbytes;\t}\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_TIFFVSetField(TIFF* tif, uint32 tag, va_list ap){\tstatic const char module[] = \"_TIFFVSetField\";\tTIFFDirectory* td = &tif->tif_dir;\tint status = 1;\tuint32 v32, i, v;    double dblval;\tchar* s;\tconst TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY);\tuint32 standard_tag = tag;\tif( fip == NULL ) \t    return 0;\t\tif (fip->field_bit == FIELD_CUSTOM) {\t\tstandard_tag = 0;\t}\tswitch (standard_tag) {\tcase TIFFTAG_SUBFILETYPE:\t\ttd->td_subfiletype = (uint32) va_arg(ap, uint32);\t\tbreak;\tcase TIFFTAG_IMAGEWIDTH:\t\ttd->td_imagewidth = (uint32) va_arg(ap, uint32);\t\tbreak;\tcase TIFFTAG_IMAGELENGTH:\t\ttd->td_imagelength = (uint32) va_arg(ap, uint32);\t\tbreak;\tcase TIFFTAG_BITSPERSAMPLE:\t\ttd->td_bitspersample = (uint16) va_arg(ap, uint16_vap);\t\t\t\tif (tif->tif_flags & TIFF_SWAB) {\t\t\tif (td->td_bitspersample == 8)\t\t\t\ttif->tif_postdecode = _TIFFNoPostDecode;\t\t\telse if (td->td_bitspersample == 16)\t\t\t\ttif->tif_postdecode = _TIFFSwab16BitData;\t\t\telse if (td->td_bitspersample == 24)\t\t\t\ttif->tif_postdecode = _TIFFSwab24BitData;\t\t\telse if (td->td_bitspersample == 32)\t\t\t\ttif->tif_postdecode = _TIFFSwab32BitData;\t\t\telse if (td->td_bitspersample == 64)\t\t\t\ttif->tif_postdecode = _TIFFSwab64BitData;\t\t\telse if (td->td_bitspersample == 128) \t\t\t\ttif->tif_postdecode = _TIFFSwab64BitData;\t\t}\t\tbreak;\tcase TIFFTAG_COMPRESSION:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\t\t\tif (TIFFFieldSet(tif, FIELD_COMPRESSION)) {\t\t\tif ((uint32)td->td_compression == v)\t\t\t\tbreak;\t\t\t(*tif->tif_cleanup)(tif);\t\t\ttif->tif_flags &= ~TIFF_CODERSETUP;\t\t}\t\t\t\tif( (status = TIFFSetCompressionScheme(tif, v)) != 0 )\t\t    td->td_compression = (uint16) v;\t\telse\t\t    status = 0;\t\tbreak;\tcase TIFFTAG_PHOTOMETRIC:\t\ttd->td_photometric = (uint16) va_arg(ap, uint16_vap);\t\tbreak;\tcase TIFFTAG_THRESHHOLDING:\t\ttd->td_threshholding = (uint16) va_arg(ap, uint16_vap);\t\tbreak;\tcase TIFFTAG_FILLORDER:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\tif (v != FILLORDER_LSB2MSB && v != FILLORDER_MSB2LSB)\t\t\tgoto badvalue;\t\ttd->td_fillorder = (uint16) v;\t\tbreak;\tcase TIFFTAG_ORIENTATION:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\tif (v < ORIENTATION_TOPLEFT || ORIENTATION_LEFTBOT < v)\t\t\tgoto badvalue;\t\telse\t\t\ttd->td_orientation = (uint16) v;\t\tbreak;\tcase TIFFTAG_SAMPLESPERPIXEL:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\tif (v == 0)\t\t\tgoto badvalue;\t\ttd->td_samplesperpixel = (uint16) v;\t\tbreak;\tcase TIFFTAG_ROWSPERSTRIP:\t\tv32 = (uint32) va_arg(ap, uint32);\t\tif (v32 == 0)\t\t\tgoto badvalue32;\t\ttd->td_rowsperstrip = v32;\t\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\t\t\ttd->td_tilelength = v32;\t\t\ttd->td_tilewidth = td->td_imagewidth;\t\t}\t\tbreak;\tcase TIFFTAG_MINSAMPLEVALUE:\t\ttd->td_minsamplevalue = (uint16) va_arg(ap, uint16_vap);\t\tbreak;\tcase TIFFTAG_MAXSAMPLEVALUE:\t\ttd->td_maxsamplevalue = (uint16) va_arg(ap, uint16_vap);\t\tbreak;\tcase TIFFTAG_SMINSAMPLEVALUE:\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\t\t\t_TIFFsetDoubleArray(&td->td_sminsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);\t\telse\t\t\tsetDoubleArrayOneValue(&td->td_sminsamplevalue, va_arg(ap, double), td->td_samplesperpixel);\t\tbreak;\tcase TIFFTAG_SMAXSAMPLEVALUE:\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\t\t\t_TIFFsetDoubleArray(&td->td_smaxsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);\t\telse\t\t\tsetDoubleArrayOneValue(&td->td_smaxsamplevalue, va_arg(ap, double), td->td_samplesperpixel);\t\tbreak;\tcase TIFFTAG_XRESOLUTION:        dblval = va_arg(ap, double);        if( dblval < 0 )            goto badvaluedouble;\t\ttd->td_xresolution = (float) dblval;\t\tbreak;\tcase TIFFTAG_YRESOLUTION:        dblval = va_arg(ap, double);        if( dblval < 0 )            goto badvaluedouble;\t\ttd->td_yresolution = (float) dblval;\t\tbreak;\tcase TIFFTAG_PLANARCONFIG:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\tif (v != PLANARCONFIG_CONTIG && v != PLANARCONFIG_SEPARATE)\t\t\tgoto badvalue;\t\ttd->td_planarconfig = (uint16) v;\t\tbreak;\tcase TIFFTAG_XPOSITION:\t\ttd->td_xposition = (float) va_arg(ap, double);\t\tbreak;\tcase TIFFTAG_YPOSITION:\t\ttd->td_yposition = (float) va_arg(ap, double);\t\tbreak;\tcase TIFFTAG_RESOLUTIONUNIT:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\tif (v < RESUNIT_NONE || RESUNIT_CENTIMETER < v)\t\t\tgoto badvalue;\t\ttd->td_resolutionunit = (uint16) v;\t\tbreak;\tcase TIFFTAG_PAGENUMBER:\t\ttd->td_pagenumber[0] = (uint16) va_arg(ap, uint16_vap);\t\ttd->td_pagenumber[1] = (uint16) va_arg(ap, uint16_vap);\t\tbreak;\tcase TIFFTAG_HALFTONEHINTS:\t\ttd->td_halftonehints[0] = (uint16) va_arg(ap, uint16_vap);\t\ttd->td_halftonehints[1] = (uint16) va_arg(ap, uint16_vap);\t\tbreak;\tcase TIFFTAG_COLORMAP:\t\tv32 = (uint32)(1L<<td->td_bitspersample);\t\t_TIFFsetShortArray(&td->td_colormap[0], va_arg(ap, uint16*), v32);\t\t_TIFFsetShortArray(&td->td_colormap[1], va_arg(ap, uint16*), v32);\t\t_TIFFsetShortArray(&td->td_colormap[2], va_arg(ap, uint16*), v32);\t\tbreak;\tcase TIFFTAG_EXTRASAMPLES:\t\tif (!setExtraSamples(td, ap, &v))\t\t\tgoto badvalue;\t\tbreak;\tcase TIFFTAG_MATTEING:\t\ttd->td_extrasamples =  (((uint16) va_arg(ap, uint16_vap)) != 0);\t\tif (td->td_extrasamples) {\t\t\tuint16 sv = EXTRASAMPLE_ASSOCALPHA;\t\t\t_TIFFsetShortArray(&td->td_sampleinfo, &sv, 1);\t\t}\t\tbreak;\tcase TIFFTAG_TILEWIDTH:\t\tv32 = (uint32) va_arg(ap, uint32);\t\tif (v32 % 16) {\t\t\tif (tif->tif_mode != O_RDONLY)\t\t\t\tgoto badvalue32;\t\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\t\t\t\t\"Nonstandard tile width %d, convert file\", v32);\t\t}\t\ttd->td_tilewidth = v32;\t\ttif->tif_flags |= TIFF_ISTILED;\t\tbreak;\tcase TIFFTAG_TILELENGTH:\t\tv32 = (uint32) va_arg(ap, uint32);\t\tif (v32 % 16) {\t\t\tif (tif->tif_mode != O_RDONLY)\t\t\t\tgoto badvalue32;\t\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\t\t\t    \"Nonstandard tile length %d, convert file\", v32);\t\t}\t\ttd->td_tilelength = v32;\t\ttif->tif_flags |= TIFF_ISTILED;\t\tbreak;\tcase TIFFTAG_TILEDEPTH:\t\tv32 = (uint32) va_arg(ap, uint32);\t\tif (v32 == 0)\t\t\tgoto badvalue32;\t\ttd->td_tiledepth = v32;\t\tbreak;\tcase TIFFTAG_DATATYPE:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\tswitch (v) {\t\tcase DATATYPE_VOID:\tv = SAMPLEFORMAT_VOID;\tbreak;\t\tcase DATATYPE_INT:\tv = SAMPLEFORMAT_INT;\tbreak;\t\tcase DATATYPE_UINT:\tv = SAMPLEFORMAT_UINT;\tbreak;\t\tcase DATATYPE_IEEEFP:\tv = SAMPLEFORMAT_IEEEFP;break;\t\tdefault:\t\tgoto badvalue;\t\t}\t\ttd->td_sampleformat = (uint16) v;\t\tbreak;\tcase TIFFTAG_SAMPLEFORMAT:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\tif (v < SAMPLEFORMAT_UINT || SAMPLEFORMAT_COMPLEXIEEEFP < v)\t\t\tgoto badvalue;\t\ttd->td_sampleformat = (uint16) v;\t\t\t\tif( td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT\t\t    && td->td_bitspersample == 32\t\t    && tif->tif_postdecode == _TIFFSwab32BitData )\t\t    tif->tif_postdecode = _TIFFSwab16BitData;\t\telse if( (td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT\t\t\t  || td->td_sampleformat == SAMPLEFORMAT_COMPLEXIEEEFP)\t\t\t && td->td_bitspersample == 64\t\t\t && tif->tif_postdecode == _TIFFSwab64BitData )\t\t    tif->tif_postdecode = _TIFFSwab32BitData;\t\tbreak;\tcase TIFFTAG_IMAGEDEPTH:\t\ttd->td_imagedepth = (uint32) va_arg(ap, uint32);\t\tbreak;\tcase TIFFTAG_SUBIFD:\t\tif ((tif->tif_flags & TIFF_INSUBIFD) == 0) {\t\t\ttd->td_nsubifd = (uint16) va_arg(ap, uint16_vap);\t\t\t_TIFFsetLong8Array(&td->td_subifd, (uint64*) va_arg(ap, uint64*),\t\t\t    (long) td->td_nsubifd);\t\t} else {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t     \"%s: Sorry, cannot nest SubIFDs\",\t\t\t\t     tif->tif_name);\t\t\tstatus = 0;\t\t}\t\tbreak;\tcase TIFFTAG_YCBCRPOSITIONING:\t\ttd->td_ycbcrpositioning = (uint16) va_arg(ap, uint16_vap);\t\tbreak;\tcase TIFFTAG_YCBCRSUBSAMPLING:\t\ttd->td_ycbcrsubsampling[0] = (uint16) va_arg(ap, uint16_vap);\t\ttd->td_ycbcrsubsampling[1] = (uint16) va_arg(ap, uint16_vap);\t\tbreak;\tcase TIFFTAG_TRANSFERFUNCTION:\t\tv = (td->td_samplesperpixel - td->td_extrasamples) > 1 ? 3 : 1;\t\tfor (i = 0; i < v; i++)\t\t\t_TIFFsetShortArray(&td->td_transferfunction[i],\t\t\t    va_arg(ap, uint16*), 1L<<td->td_bitspersample);\t\tbreak;\tcase TIFFTAG_REFERENCEBLACKWHITE:\t\t\t\t_TIFFsetFloatArray(&td->td_refblackwhite, va_arg(ap, float*), 6);\t\tbreak;\tcase TIFFTAG_INKNAMES:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\ts = va_arg(ap, char*);\t\tv = checkInkNamesString(tif, v, s);\t\tstatus = v > 0;\t\tif( v > 0 ) {\t\t\t_TIFFsetNString(&td->td_inknames, s, v);\t\t\ttd->td_inknameslen = v;\t\t}\t\tbreak;\tcase TIFFTAG_PERSAMPLE:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\tif( v == PERSAMPLE_MULTI )\t\t\ttif->tif_flags |= TIFF_PERSAMPLE;\t\telse\t\t\ttif->tif_flags &= ~TIFF_PERSAMPLE;\t\tbreak;\tdefault: {\t\tTIFFTagValue *tv;\t\tint tv_size, iCustom;\t\t\t\tif(fip->field_bit != FIELD_CUSTOM) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"%s: Invalid %stag \\\"%s\\\" (not supported by codec)\",\t\t\t    tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\",\t\t\t    fip->field_name);\t\t\tstatus = 0;\t\t\tbreak;\t\t}\t\t\t\ttv = NULL;\t\tfor (iCustom = 0; iCustom < td->td_customValueCount; iCustom++) {\t\t\tif (td->td_customValues[iCustom].info->field_tag == tag) {\t\t\t\ttv = td->td_customValues + iCustom;\t\t\t\tif (tv->value != NULL) {\t\t\t\t\t_TIFFfree(tv->value);\t\t\t\t\ttv->value = NULL;\t\t\t\t}\t\t\t\tbreak;\t\t\t}\t\t}\t\t\t\tif(tv == NULL) {\t\t\tTIFFTagValue *new_customValues;\t\t\ttd->td_customValueCount++;\t\t\tnew_customValues = (TIFFTagValue *)\t\t\t    _TIFFrealloc(td->td_customValues,\t\t\t    sizeof(TIFFTagValue) * td->td_customValueCount);\t\t\tif (!new_customValues) {\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t    \"%s: Failed to allocate space for list of custom values\",\t\t\t\t    tif->tif_name);\t\t\t\tstatus = 0;\t\t\t\tgoto end;\t\t\t}\t\t\ttd->td_customValues = new_customValues;\t\t\ttv = td->td_customValues + (td->td_customValueCount - 1);\t\t\ttv->info = fip;\t\t\ttv->value = NULL;\t\t\ttv->count = 0;\t\t}\t\t\t\ttv_size = _TIFFDataSize(fip->field_type);\t\tif (tv_size == 0) {\t\t\tstatus = 0;\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"%s: Bad field type %d for \\\"%s\\\"\",\t\t\t    tif->tif_name, fip->field_type,\t\t\t    fip->field_name);\t\t\tgoto end;\t\t}\t\tif (fip->field_type == TIFF_ASCII)\t\t{\t\t\tuint32 ma;\t\t\tchar* mb;\t\t\tif (fip->field_passcount)\t\t\t{\t\t\t\tassert(fip->field_writecount==TIFF_VARIABLE2);\t\t\t\tma=(uint32)va_arg(ap,uint32);\t\t\t\tmb=(char*)va_arg(ap,char*);\t\t\t}\t\t\telse\t\t\t{\t\t\t\tmb=(char*)va_arg(ap,char*);\t\t\t\tma=(uint32)(strlen(mb)+1);\t\t\t}\t\t\ttv->count=ma;\t\t\tsetByteArray(&tv->value,mb,ma,1);\t\t}\t\telse\t\t{\t\t\tif (fip->field_passcount) {\t\t\t\tif (fip->field_writecount == TIFF_VARIABLE2)\t\t\t\t\ttv->count = (uint32) va_arg(ap, uint32);\t\t\t\telse\t\t\t\t\ttv->count = (int) va_arg(ap, int);\t\t\t} else if (fip->field_writecount == TIFF_VARIABLE\t\t\t   || fip->field_writecount == TIFF_VARIABLE2)\t\t\t\ttv->count = 1;\t\t\telse if (fip->field_writecount == TIFF_SPP)\t\t\t\ttv->count = td->td_samplesperpixel;\t\t\telse\t\t\t\ttv->count = fip->field_writecount;\t\t\tif (tv->count == 0) {\t\t\t\tstatus = 0;\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t\t     \"%s: Null count for \\\"%s\\\" (type \"\t\t\t\t\t     \"%d, writecount %d, passcount %d)\",\t\t\t\t\t     tif->tif_name,\t\t\t\t\t     fip->field_name,\t\t\t\t\t     fip->field_type,\t\t\t\t\t     fip->field_writecount,\t\t\t\t\t     fip->field_passcount);\t\t\t\tgoto end;\t\t\t}\t\t\ttv->value = _TIFFCheckMalloc(tif, tv->count, tv_size,\t\t\t    \"custom tag binary object\");\t\t\tif (!tv->value) {\t\t\t\tstatus = 0;\t\t\t\tgoto end;\t\t\t}\t\t\tif (fip->field_tag == TIFFTAG_DOTRANGE \t\t\t    && strcmp(fip->field_name,\"DotRange\") == 0) {\t\t\t\t\t\t\t\tuint16 v[2];\t\t\t\tv[0] = (uint16)va_arg(ap, int);\t\t\t\tv[1] = (uint16)va_arg(ap, int);\t\t\t\t_TIFFmemcpy(tv->value, &v, 4);\t\t\t}\t\t\telse if (fip->field_passcount\t\t\t\t  || fip->field_writecount == TIFF_VARIABLE\t\t\t\t  || fip->field_writecount == TIFF_VARIABLE2\t\t\t\t  || fip->field_writecount == TIFF_SPP\t\t\t\t  || tv->count > 1) {\t\t\t\t_TIFFmemcpy(tv->value, va_arg(ap, void *),\t\t\t\t    tv->count * tv_size);\t\t\t} else {\t\t\t\tchar *val = (char *)tv->value;\t\t\t\tassert( tv->count == 1 );\t\t\t\tswitch (fip->field_type) {\t\t\t\tcase TIFF_BYTE:\t\t\t\tcase TIFF_UNDEFINED:\t\t\t\t\t{\t\t\t\t\t\tuint8 v = (uint8)va_arg(ap, int);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SBYTE:\t\t\t\t\t{\t\t\t\t\t\tint8 v = (int8)va_arg(ap, int);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SHORT:\t\t\t\t\t{\t\t\t\t\t\tuint16 v = (uint16)va_arg(ap, int);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SSHORT:\t\t\t\t\t{\t\t\t\t\t\tint16 v = (int16)va_arg(ap, int);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_LONG:\t\t\t\tcase TIFF_IFD:\t\t\t\t\t{\t\t\t\t\t\tuint32 v = va_arg(ap, uint32);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SLONG:\t\t\t\t\t{\t\t\t\t\t\tint32 v = va_arg(ap, int32);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_LONG8:\t\t\t\tcase TIFF_IFD8:\t\t\t\t\t{\t\t\t\t\t\tuint64 v = va_arg(ap, uint64);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SLONG8:\t\t\t\t\t{\t\t\t\t\t\tint64 v = va_arg(ap, int64);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_RATIONAL:\t\t\t\tcase TIFF_SRATIONAL:\t\t\t\tcase TIFF_FLOAT:\t\t\t\t\t{\t\t\t\t\t\tfloat v = (float)va_arg(ap, double);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_DOUBLE:\t\t\t\t\t{\t\t\t\t\t\tdouble v = va_arg(ap, double);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tdefault:\t\t\t\t\t_TIFFmemset(val, 0, tv_size);\t\t\t\t\tstatus = 0;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t}\t}\t}\tif (status) {\t\tconst TIFFField* fip=TIFFFieldWithTag(tif,tag);\t\tif (fip)                \t\t\tTIFFSetFieldBit(tif, fip->field_bit);\t\ttif->tif_flags |= TIFF_DIRTYDIRECT;\t}end:\tva_end(ap);\treturn (status);badvalue:        {\t\tconst TIFFField* fip=TIFFFieldWithTag(tif,tag);\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t     \"%s: Bad value %u for \\\"%s\\\" tag\",\t\t     tif->tif_name, v,\t\t     fip ? fip->field_name : \"Unknown\");\t\tva_end(ap);        }\treturn (0);badvalue32:        {\t\tconst TIFFField* fip=TIFFFieldWithTag(tif,tag);\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t     \"%s: Bad value %u for \\\"%s\\\" tag\",\t\t     tif->tif_name, v32,\t\t     fip ? fip->field_name : \"Unknown\");\t\tva_end(ap);        }\treturn (0);badvaluedouble:        {        const TIFFField* fip=TIFFFieldWithTag(tif,tag);        TIFFErrorExt(tif->tif_clientdata, module,             \"%s: Bad value %f for \\\"%s\\\" tag\",             tif->tif_name, dblval,             fip ? fip->field_name : \"Unknown\");        va_end(ap);        }    return (0);}",
        "label": 1,
        "cve": "cve-2016-8331"
    },
    {
        "code": "static tsize_tTIFFFetchString(TIFF* tif, TIFFDirEntry* dir, char* cp){\tif (dir->tdir_count <= 4) {\t\tuint32 l = dir->tdir_offset;\t\tif (tif->tif_flags & TIFF_SWAB)\t\t\tTIFFSwabLong(&l);\t\t_TIFFmemcpy(cp, &l, dir->tdir_count);\t\treturn (1);\t}\treturn (TIFFFetchData(tif, dir, cp));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFFErrorHandlerExtTIFFSetErrorHandlerExt(TIFFErrorHandlerExt handler){\tTIFFErrorHandlerExt prev = _TIFFerrorHandlerExt;\t_TIFFerrorHandlerExt = handler;\treturn (prev);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tsize_t_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size){\treturn ((tsize_t) read((int) fd, buf, (size_t) size));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPixarLogSetupEncode(TIFF* tif){\tstatic const char module[] = \"PixarLogSetupEncode\";\tTIFFDirectory *td = &tif->tif_dir;\tPixarLogState* sp = EncoderState(tif);\ttmsize_t tbuf_size;\tassert(sp != NULL);\t\tsp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?\t    td->td_samplesperpixel : 1);\ttbuf_size = multiply_ms(multiply_ms(multiply_ms(sp->stride, td->td_imagewidth),\t\t\t\t      td->td_rowsperstrip), sizeof(uint16));\tif (tbuf_size == 0)\t\treturn (0);  \tsp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size);\tif (sp->tbuf == NULL)\t\treturn (0);\tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN)\t\tsp->user_datafmt = PixarLogGuessDataFmt(td);\tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) {\t\tTIFFErrorExt(tif->tif_clientdata, module, \"PixarLog compression can't handle %d bit linear encodings\", td->td_bitspersample);\t\treturn (0);\t}\tif (deflateInit(&sp->stream, sp->quality) != Z_OK) {\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s\", sp->stream.msg ? sp->stream.msg : \"(null)\");\t\treturn (0);\t} else {\t\tsp->state |= PLSTATE_INIT;\t\treturn (1);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchShortPair(TIFF* tif, TIFFDirEntry* dir){\tuint16 v[2];\tint ok = 0;\tswitch (dir->tdir_type) {\tcase TIFF_SHORT:\tcase TIFF_SSHORT:\t\tok = TIFFFetchShortArray(tif, dir, v);\t\tbreak;\tcase TIFF_BYTE:\tcase TIFF_SBYTE:\t\tok  = TIFFFetchByteArray(tif, dir, v);\t\tbreak;\t}\tif (ok)\t\tTIFFSetField(tif, dir->tdir_tag, v[0], v[1]);\treturn (ok);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int main( int argc, char ** argv ){    int\t\tanOverviews[100];       int\t\tnOverviewCount = 0;    int\t\tbUseSubIFD = 0;    TIFF\t*hTIFF;    const char  *pszResampling = \"nearest\";    if( argc < 2 )    {        printf( \"Usage: addtiffo [-r {nearest,average,mode}]\\n\"                \"                tiff_filename [resolution_reductions]\\n\"                \"\\n\"                \"Example:\\n\"                \" %% addtiffo abc.tif 2 4 8 16\\n\" );        return( 1 );    }    while( argv[1][0] == '-' )    {        if( strcmp(argv[1],\"-subifd\") == 0 )        {            bUseSubIFD = 1;            argv++;            argc--;        }        else if( strcmp(argv[1],\"-r\") == 0 )        {            argv += 2;            argc -= 2;            pszResampling = *argv;        }        else        {            fprintf( stderr, \"Incorrect parameters\\n\" );            return( 1 );        }    }        while( nOverviewCount < argc - 2 && nOverviewCount < 100 )    {        anOverviews[nOverviewCount] = atoi(argv[nOverviewCount+2]);        if( anOverviews[nOverviewCount] <= 0)        {            fprintf( stderr, \"Incorrect parameters\\n\" );            return(1);        }        nOverviewCount++;    }        if( nOverviewCount == 0 )    {        nOverviewCount = 4;        anOverviews[0] = 2;        anOverviews[1] = 4;        anOverviews[2] = 8;        anOverviews[3] = 16;    }    hTIFF = TIFFOpen( argv[1], \"r+\" );    if( hTIFF == NULL )    {        fprintf( stderr, \"TIFFOpen(%s) failed.\\n\", argv[1] );        return( 1 );    }    TIFFBuildOverviews( hTIFF, nOverviewCount, anOverviews, bUseSubIFD,                        pszResampling, NULL, NULL );    TIFFClose( hTIFF );#ifdef DBMALLOC    malloc_dump(1);#endif    return( 0 );}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFInitLZW(TIFF* tif, int scheme){\tstatic const char module[] = \"TIFFInitLZW\";\tassert(scheme == COMPRESSION_LZW);\t\ttif->tif_data = (uint8*) _TIFFmalloc(sizeof (LZWCodecState));\tif (tif->tif_data == NULL)\t\tgoto bad;\tDecoderState(tif)->dec_codetab = NULL;\tDecoderState(tif)->dec_decode = NULL;\tEncoderState(tif)->enc_hashtab = NULL;        LZWState(tif)->rw_mode = tif->tif_mode;\t\ttif->tif_fixuptags = LZWFixupTags; \ttif->tif_setupdecode = LZWSetupDecode;\ttif->tif_predecode = LZWPreDecode;\ttif->tif_decoderow = LZWDecode;\ttif->tif_decodestrip = LZWDecode;\ttif->tif_decodetile = LZWDecode;\ttif->tif_setupencode = LZWSetupEncode;\ttif->tif_preencode = LZWPreEncode;\ttif->tif_postencode = LZWPostEncode;\ttif->tif_encoderow = LZWEncode;\ttif->tif_encodestrip = LZWEncode;\ttif->tif_encodetile = LZWEncode;\ttif->tif_cleanup = LZWCleanup;\t\t(void) TIFFPredictorInit(tif);\treturn (1);bad:\tTIFFErrorExt(tif->tif_clientdata, module, \t\t     \"No space for LZW state block\");\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(void){\tchar buf[BUFSIZ];\tint i;\tsetbuf(stderr, buf);        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\tfor (i = 0; stuff[i] != NULL; i++)\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\texit(EXIT_FAILURE);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteNormalSubTag(TIFF* tif, TIFFDirEntry* dir, const TIFFFieldInfo* fip,\t\t      int (*getFieldFn)(TIFF *tif, ttag_t tag, ...)){\tu_short wc = (u_short) fip->field_writecount;\tdir->tdir_tag = fip->field_tag;\tdir->tdir_type = (u_short) fip->field_type;\tdir->tdir_count = wc;#define\tWRITEF(x,y)\tx(tif, fip->field_type, fip->field_tag, dir, wc, y)\tswitch (fip->field_type) {\tcase TIFF_SHORT:\tcase TIFF_SSHORT:\t\tif (wc > 1) {\t\t\tuint16* wp;\t\t\tif (wc == (u_short) TIFF_VARIABLE) {\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &wc, &wp);\t\t\t\tdir->tdir_count = wc;\t\t\t} else\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &wp);\t\t\tif (!WRITEF(TIFFWriteShortArray, wp))\t\t\t\treturn (0);\t\t} else {\t\t\tuint16 sv;\t\t\t(*getFieldFn)(tif, fip->field_tag, &sv);\t\t\tdir->tdir_offset =\t\t\t    TIFFInsertData(tif, dir->tdir_type, sv);\t\t}\t\tbreak;\tcase TIFF_LONG:\tcase TIFF_SLONG:\t\tif (wc > 1) {\t\t\tuint32* lp;\t\t\tif (wc == (u_short) TIFF_VARIABLE) {\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &wc, &lp);\t\t\t\tdir->tdir_count = wc;\t\t\t} else\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &lp);\t\t\tif (!WRITEF(TIFFWriteLongArray, lp))\t\t\t\treturn (0);\t\t} else {\t\t\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &dir->tdir_offset);\t\t}\t\tbreak;\tcase TIFF_RATIONAL:\tcase TIFF_SRATIONAL:\t\tif (wc > 1) {\t\t\tfloat* fp;\t\t\tif (wc == (u_short) TIFF_VARIABLE) {\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &wc, &fp);\t\t\t\tdir->tdir_count = wc;\t\t\t} else\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &fp);\t\t\tif (!WRITEF(TIFFWriteRationalArray, fp))\t\t\t\treturn (0);\t\t} else {\t\t\tfloat fv;\t\t\t(*getFieldFn)(tif, fip->field_tag, &fv);\t\t\tif (!WRITEF(TIFFWriteRationalArray, &fv))\t\t\t\treturn (0);\t\t}\t\tbreak;\tcase TIFF_FLOAT:\t\tif (wc > 1) {\t\t\tfloat* fp;\t\t\tif (wc == (u_short) TIFF_VARIABLE) {\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &wc, &fp);\t\t\t\tdir->tdir_count = wc;\t\t\t} else\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &fp);\t\t\tif (!WRITEF(TIFFWriteFloatArray, fp))\t\t\t\treturn (0);\t\t} else {\t\t\tfloat fv;\t\t\t(*getFieldFn)(tif, fip->field_tag, &fv);\t\t\tif (!WRITEF(TIFFWriteFloatArray, &fv))\t\t\t\treturn (0);\t\t}\t\tbreak;\tcase TIFF_DOUBLE:\t\t#if (0)\t\t{ double* dp;\t\t  if (wc == (u_short) TIFF_VARIABLE) {\t\t\t(*getFieldFn)(tif, fip->field_tag, &wc, &dp);\t\t\tdir->tdir_count = wc;\t\t  } else\t\t\t(*getFieldFn)(tif, fip->field_tag, &dp);\t\t  TIFFCvtNativeToIEEEDouble(tif, wc, dp);\t\t  if (!TIFFWriteData(tif, dir, (char*) dp))\t\t\treturn (0);\t\t}#else\t\tif (wc > 1) {\t\t\tdouble* dp;\t\t\tif (wc == (u_short) TIFF_VARIABLE) {\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &wc, &dp);\t\t\t\tdir->tdir_count = wc;\t\t\t} else\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &dp);\t\t\tif (!WRITEF(TIFFWriteDoubleArray, dp))\t\t\t\treturn (0);\t\t} else {\t\t\tdouble dv;\t\t\t(*getFieldFn)(tif, fip->field_tag, &dv);\t\t\tif (!WRITEF(TIFFWriteDoubleArray, &dv))\t\t\t\treturn (0);\t\t}#endif\t\tbreak;\tcase TIFF_ASCII:\t\t{ char* cp;\t\t  (*getFieldFn)(tif, fip->field_tag, &cp);\t\t  dir->tdir_count = (uint32) (strlen(cp) + 1);\t\t  if (!TIFFWriteByteArray(tif, dir, cp))\t\t\treturn (0);\t\t}\t\tbreak;\tcase TIFF_UNDEFINED:\t\t{ char* cp;\t\t  if (wc == (u_short) TIFF_VARIABLE) {\t\t\t(*getFieldFn)(tif, fip->field_tag, &wc, &cp);\t\t\tdir->tdir_count = wc;\t\t  } else \t\t\t(*getFieldFn)(tif, fip->field_tag, &cp);\t\t  if (!TIFFWriteByteArray(tif, dir, cp))\t\t\treturn (0);\t\t}\t\tbreak;\t}\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidhorizontalAccumulate12(uint16 *wp, int n, int stride, int16 *op,\tfloat *ToLinearF){    register unsigned int  cr, cg, cb, ca, mask;    register float  t0, t1, t2, t3;    if (n >= stride) {\tmask = CODE_MASK;\tif (stride == 3) {\t    t0 = ToLinearF[cr = (wp[0] & mask)] * SCALE12;\t    t1 = ToLinearF[cg = (wp[1] & mask)] * SCALE12;\t    t2 = ToLinearF[cb = (wp[2] & mask)] * SCALE12;\t    op[0] = CLAMP12(t0);\t    op[1] = CLAMP12(t1);\t    op[2] = CLAMP12(t2);\t    n -= 3;\t    while (n > 0) {\t\twp += 3;\t\top += 3;\t\tn -= 3;\t\tt0 = ToLinearF[(cr += wp[0]) & mask] * SCALE12;\t\tt1 = ToLinearF[(cg += wp[1]) & mask] * SCALE12;\t\tt2 = ToLinearF[(cb += wp[2]) & mask] * SCALE12;\t\top[0] = CLAMP12(t0);\t\top[1] = CLAMP12(t1);\t\top[2] = CLAMP12(t2);\t    }\t} else if (stride == 4) {\t    t0 = ToLinearF[cr = (wp[0] & mask)] * SCALE12;\t    t1 = ToLinearF[cg = (wp[1] & mask)] * SCALE12;\t    t2 = ToLinearF[cb = (wp[2] & mask)] * SCALE12;\t    t3 = ToLinearF[ca = (wp[3] & mask)] * SCALE12;\t    op[0] = CLAMP12(t0);\t    op[1] = CLAMP12(t1);\t    op[2] = CLAMP12(t2);\t    op[3] = CLAMP12(t3);\t    n -= 4;\t    while (n > 0) {\t\twp += 4;\t\top += 4;\t\tn -= 4;\t\tt0 = ToLinearF[(cr += wp[0]) & mask] * SCALE12;\t\tt1 = ToLinearF[(cg += wp[1]) & mask] * SCALE12;\t\tt2 = ToLinearF[(cb += wp[2]) & mask] * SCALE12;\t\tt3 = ToLinearF[(ca += wp[3]) & mask] * SCALE12;\t\top[0] = CLAMP12(t0);\t\top[1] = CLAMP12(t1);\t\top[2] = CLAMP12(t2);\t\top[3] = CLAMP12(t3);\t    }\t} else {\t    REPEAT(stride, t0 = ToLinearF[*wp&mask] * SCALE12;                           *op = CLAMP12(t0); wp++; op++)\t    n -= stride;\t    while (n > 0) {\t\tREPEAT(stride,\t\t    wp[stride] += *wp; t0 = ToLinearF[wp[stride]&mask]*SCALE12;\t\t    *op = CLAMP12(t0);  wp++; op++)\t\tn -= stride;\t    }\t}    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFSwabLong(uint32* lp){\tregister unsigned char* cp = (unsigned char*) lp;\tunsigned char t;\tassert(sizeof(uint32)==4);\tt = cp[3]; cp[3] = cp[0]; cp[0] = t;\tt = cp[2]; cp[2] = cp[1]; cp[1] = t;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int t2p_tile_is_corner_edge(T2P_TILES tiles, ttile_t tile){\treturn(t2p_tile_is_right_edge(tiles, tile) & t2p_tile_is_bottom_edge(tiles, tile) );}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover){\tstatic const char module[] = \"TIFFFetchNormalTag\";\tenum TIFFReadDirEntryErr err;\tuint32 fii;\tconst TIFFField* fip = NULL;\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);        if( fii == FAILED_FII )        {            TIFFErrorExt(tif->tif_clientdata, \"TIFFFetchNormalTag\",                         \"No definition found for tag %d\",                         dp->tdir_tag);            return 0;        }\tfip=tif->tif_fields[fii];\tassert(fip != NULL); \tassert(fip->set_field_type!=TIFF_SETGET_OTHER);  \tassert(fip->set_field_type!=TIFF_SETGET_INT);    \terr=TIFFReadDirEntryErrOk;\tswitch (fip->set_field_type)\t{\t\tcase TIFF_SETGET_UNDEFINED:\t\t\tbreak;\t\tcase TIFF_SETGET_ASCII:\t\t\t{\t\t\t\tuint8* data;\t\t\t\tassert(fip->field_passcount==0);\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tuint8* ma;\t\t\t\t\tuint32 mb;\t\t\t\t\tint n;\t\t\t\t\tma=data;\t\t\t\t\tmb=0;\t\t\t\t\twhile (mb<(uint32)dp->tdir_count)\t\t\t\t\t{\t\t\t\t\t\tif (*ma==0)\t\t\t\t\t\t\tbreak;\t\t\t\t\t\tma++;\t\t\t\t\t\tmb++;\t\t\t\t\t}\t\t\t\t\tif (mb+1<(uint32)dp->tdir_count)\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" contains null byte in value; value incorrectly truncated during reading due to implementation limitations\",fip->field_name);\t\t\t\t\telse if (mb+1>(uint32)dp->tdir_count)\t\t\t\t\t{\t\t\t\t\t\tuint8* o;\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte\",fip->field_name);\t\t\t\t\t\tif ((uint32)dp->tdir_count+1!=dp->tdir_count+1)\t\t\t\t\t\t\to=NULL;\t\t\t\t\t\telse\t\t\t\t\t\t\to=_TIFFmalloc((uint32)dp->tdir_count+1);\t\t\t\t\t\tif (o==NULL)\t\t\t\t\t\t{\t\t\t\t\t\t\tif (data!=NULL)\t\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\t\treturn(0);\t\t\t\t\t\t}\t\t\t\t\t\t_TIFFmemcpy(o,data,(uint32)dp->tdir_count);\t\t\t\t\t\to[(uint32)dp->tdir_count]=0;\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tdata=o;\t\t\t\t\t}\t\t\t\t\tn=TIFFSetField(tif,dp->tdir_tag,data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!n)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_UINT8:\t\t\t{\t\t\t\tuint8 data=0;\t\t\t\tassert(fip->field_readcount==1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\terr=TIFFReadDirEntryByte(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_UINT16:\t\t\t{\t\t\t\tuint16 data;\t\t\t\tassert(fip->field_readcount==1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\terr=TIFFReadDirEntryShort(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_UINT32:\t\t\t{\t\t\t\tuint32 data;\t\t\t\tassert(fip->field_readcount==1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\terr=TIFFReadDirEntryLong(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_UINT64:\t\t\t{\t\t\t\tuint64 data;\t\t\t\tassert(fip->field_readcount==1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\terr=TIFFReadDirEntryLong8(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_FLOAT:\t\t\t{\t\t\t\tfloat data;\t\t\t\tassert(fip->field_readcount==1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\terr=TIFFReadDirEntryFloat(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_DOUBLE:\t\t\t{\t\t\t\tdouble data;\t\t\t\tassert(fip->field_readcount==1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\terr=TIFFReadDirEntryDouble(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_IFD8:\t\t\t{\t\t\t\tuint64 data;\t\t\t\tassert(fip->field_readcount==1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\terr=TIFFReadDirEntryIfd8(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_UINT16_PAIR:\t\t\t{\t\t\t\tuint16* data;\t\t\t\tassert(fip->field_readcount==2);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\tif (dp->tdir_count!=2) {\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\t\t\t\t\t\t       \"incorrect count for field \\\"%s\\\", expected 2, got %d\",\t\t\t\t\t\t       fip->field_name,(int)dp->tdir_count);\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data[0],data[1]);\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C0_UINT8:\t\t\t{\t\t\t\tuint8* data;\t\t\t\tassert(fip->field_readcount>=1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount) {\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\t\t\t\t\t\t       \"incorrect count for field \\\"%s\\\", expected %d, got %d\",\t\t\t\t\t\t       fip->field_name,(int) fip->field_readcount, (int)dp->tdir_count);\t\t\t\t\treturn 0;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C0_UINT16:\t\t\t{\t\t\t\tuint16* data;\t\t\t\tassert(fip->field_readcount>=1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)                                    ;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C0_UINT32:\t\t\t{\t\t\t\tuint32* data;\t\t\t\tassert(fip->field_readcount>=1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)                                    ;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C0_FLOAT:\t\t\t{\t\t\t\tfloat* data;\t\t\t\tassert(fip->field_readcount>=1);\t\t\t\tassert(fip->field_passcount==0);\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)                                    ;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C16_ASCII:\t\t\t{\t\t\t\tuint8* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\tif (dp->tdir_count>0xFFFF)\t\t\t\t\terr=TIFFReadDirEntryErrCount;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C16_UINT8:\t\t\t{\t\t\t\tuint8* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\tif (dp->tdir_count>0xFFFF)\t\t\t\t\terr=TIFFReadDirEntryErrCount;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C16_UINT16:\t\t\t{\t\t\t\tuint16* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\tif (dp->tdir_count>0xFFFF)\t\t\t\t\terr=TIFFReadDirEntryErrCount;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C16_UINT32:\t\t\t{\t\t\t\tuint32* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\tif (dp->tdir_count>0xFFFF)\t\t\t\t\terr=TIFFReadDirEntryErrCount;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C16_UINT64:\t\t\t{\t\t\t\tuint64* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\tif (dp->tdir_count>0xFFFF)\t\t\t\t\terr=TIFFReadDirEntryErrCount;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryLong8Array(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C16_FLOAT:\t\t\t{\t\t\t\tfloat* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\tif (dp->tdir_count>0xFFFF)\t\t\t\t\terr=TIFFReadDirEntryErrCount;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C16_DOUBLE:\t\t\t{\t\t\t\tdouble* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\tif (dp->tdir_count>0xFFFF)\t\t\t\t\terr=TIFFReadDirEntryErrCount;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryDoubleArray(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C16_IFD8:\t\t\t{\t\t\t\tuint64* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\tif (dp->tdir_count>0xFFFF)\t\t\t\t\terr=TIFFReadDirEntryErrCount;\t\t\t\telse\t\t\t\t{\t\t\t\t\terr=TIFFReadDirEntryIfd8Array(tif,dp,&data);\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t\t{\t\t\t\t\t\tint m;\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\t\t\t\t\t\tif (data!=0)\t\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\t\tif (!m)\t\t\t\t\t\t\treturn(0);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_ASCII:\t\t\t{\t\t\t\tuint8* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_UINT8:\t\t\t{\t\t\t\tuint8* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_SINT8:\t\t\t{\t\t\t\tint8* data = NULL;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntrySbyteArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_UINT16:\t\t\t{\t\t\t\tuint16* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_SINT16:\t\t\t{\t\t\t\tint16* data = NULL;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntrySshortArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_UINT32:\t\t\t{\t\t\t\tuint32* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_SINT32:\t\t\t{\t\t\t\tint32* data = NULL;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntrySlongArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_UINT64:\t\t\t{\t\t\t\tuint64* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntryLong8Array(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_SINT64:\t\t\t{\t\t\t\tint64* data = NULL;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntrySlong8Array(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_FLOAT:\t\t\t{\t\t\t\tfloat* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_DOUBLE:\t\t\t{\t\t\t\tdouble* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntryDoubleArray(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tcase TIFF_SETGET_C32_IFD8:\t\t\t{\t\t\t\tuint64* data;\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\t\t\t\tassert(fip->field_passcount==1);\t\t\t\terr=TIFFReadDirEntryIfd8Array(tif,dp,&data);\t\t\t\tif (err==TIFFReadDirEntryErrOk)\t\t\t\t{\t\t\t\t\tint m;\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\t\t\t\t\tif (data!=0)\t\t\t\t\t\t_TIFFfree(data);\t\t\t\t\tif (!m)\t\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t}\t\t\tbreak;\t\tdefault:\t\t\tassert(0);    \t\t\tbreak;\t}\tif (err!=TIFFReadDirEntryErrOk)\t{\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip->field_name,recover);\t\treturn(0);\t}\treturn(1);}",
        "label": 1,
        "cve": "cve-2016-9297"
    },
    {
        "code": "voidCheckAndCorrectColormap(){    register int i;    for (i = 0; i < colormapSize; i++)        if ((redMap[i] > 255) || (greenMap[i] > 255) || (blueMap[i] > 255))            return;    for (i = 0; i < colormapSize; i++) {        redMap[i] = SCALE(redMap[i], 255);        greenMap[i] = SCALE(greenMap[i], 255);        blueMap[i] = SCALE(blueMap[i], 255);    }    TIFFWarning(fileName, \"Assuming 8-bit colormap\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "uint32_TIFFMultiply32(TIFF* tif, uint32 first, uint32 second, const char* where){\tuint32 bytes = first * second;\tif (second && bytes / second != first) {\t\tTIFFErrorExt(tif->tif_clientdata, where, \"Integer overflow in %s\", where);\t\tbytes = 0;\t}\treturn bytes;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidChopUpSingleUncompressedStrip(TIFF* tif){\tregister TIFFDirectory *td = &tif->tif_dir;\tuint64 bytecount;\tuint64 offset;\tuint32 rowblock;\tuint64 rowblockbytes;\tuint64 stripbytes;\tuint32 strip;\tuint32 nstrips;\tuint32 rowsperstrip;\tuint64* newcounts;\tuint64* newoffsets;\tbytecount = td->td_stripbytecount[0];                                   if( bytecount == 0 && tif->tif_mode != O_RDONLY )            return;\toffset = td->td_stripoffset[0];\tassert(td->td_planarconfig == PLANARCONFIG_CONTIG);\tif ((td->td_photometric == PHOTOMETRIC_YCBCR)&&\t    (!isUpSampled(tif)))\t\trowblock = td->td_ycbcrsubsampling[1];\telse\t\trowblock = 1;\trowblockbytes = TIFFVTileSize64(tif, rowblock);\t \tif (rowblockbytes > STRIP_SIZE_DEFAULT) {\t\tstripbytes = rowblockbytes;\t\trowsperstrip = rowblock;\t} else if (rowblockbytes > 0 ) {\t\tuint32 rowblocksperstrip;\t\trowblocksperstrip = (uint32) (STRIP_SIZE_DEFAULT / rowblockbytes);\t\trowsperstrip = rowblocksperstrip * rowblock;\t\tstripbytes = rowblocksperstrip * rowblockbytes;\t}\telse\t    return;\t \tif (rowsperstrip >= td->td_rowsperstrip)\t\treturn;        nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);        if( nstrips == 0 )            return;\tnewcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),\t\t\t\t\"for chopped \\\"StripByteCounts\\\" array\");\tnewoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),\t\t\t\t\"for chopped \\\"StripOffsets\\\" array\");\tif (newcounts == NULL || newoffsets == NULL) {\t\t \t\tif (newcounts != NULL)\t\t\t_TIFFfree(newcounts);\t\tif (newoffsets != NULL)\t\t\t_TIFFfree(newoffsets);\t\treturn;\t}\t \tfor (strip = 0; strip < nstrips; strip++) {\t\tif (stripbytes > bytecount)\t\t\tstripbytes = bytecount;\t\tnewcounts[strip] = stripbytes;\t\tnewoffsets[strip] = stripbytes ? offset : 0;\t\toffset += stripbytes;\t\tbytecount -= stripbytes;\t}\t \ttd->td_stripsperimage = td->td_nstrips = nstrips;\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\t_TIFFfree(td->td_stripbytecount);\t_TIFFfree(td->td_stripoffset);\ttd->td_stripbytecount = newcounts;\ttd->td_stripoffset = newoffsets;\ttd->td_stripbytecountsorted = 1;}",
        "label": 1,
        "cve": "CVE-2018-15209"
    },
    {
        "code": "static voidprocessG3Options(char* cp){\tg3opts = 0;        if( (cp = strchr(cp, ':')) ) {                do {                        cp++;                        if (strneq(cp, \"1d\", 2))                                g3opts &= ~GROUP3OPT_2DENCODING;                        else if (strneq(cp, \"2d\", 2))                                g3opts |= GROUP3OPT_2DENCODING;                        else if (strneq(cp, \"fill\", 4))                                g3opts |= GROUP3OPT_FILLBITS;                        else                                usage();                } while( (cp = strchr(cp, ':')) );        }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int_TIFFNoSeek(TIFF* tif, uint32 off){\t(void) off;\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t     \"Compression algorithm does not support random access\");\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidShowTile(uint32 row, uint32 col, tsample_t sample,    unsigned char* pp, uint32 nrow, uint32 rowsize){\tuint32 cc;\tprintf(\"Tile (%lu,%lu\", (unsigned long) row, (unsigned long) col);\tif (sample != (tsample_t) -1)\t\tprintf(\",%u\", sample);\tprintf(\"):\\n\");\twhile (nrow-- > 0) {\t\tfor (cc = 0; cc < rowsize; cc++) {\t\t\tprintf(\" %02x\", *pp++);\t\t\tif (((cc+1) % 24) == 0)\t\t\t\tputchar('\\n');\t\t}\t\tputchar('\\n');\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intwrite_scanlines(TIFF *tif, const tdata_t array, const tsize_t size){\tuint32\t\tlength, row;\ttsize_t\t\tscanlinesize, offset;        (void) size;\tif (!TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &length)) {\t\tfprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_IMAGELENGTH);\t\treturn -1;\t}\tscanlinesize = TIFFScanlineSize(tif);\tif (!scanlinesize) {\t\tfprintf (stderr, \"Wrong size of scanline.\\n\");\t\treturn -1;\t}\tfor (offset = 0, row = 0; row < length; offset+=scanlinesize, row++) {\t\tif (TIFFWriteScanline(tif, (char *)array + offset, row, 0) == -1) {\t\t\tfprintf (stderr,\t\t\t\t \"Can't write image data at row %lu.\\n\", (long) row);\t\t\treturn -1;\t\t}        }\treturn 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void ourc2pstr( char* inString ){\tint\tsLen = strlen( inString );\tBlockMoveData( inString, &inString[1], sLen );\tinString[0] = sLen;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidprocessG3Options(char* cp){\tif( (cp = strchr(cp, ':')) ) {\t\tif (defg3opts == (uint32) -1)\t\t\tdefg3opts = 0;\t\tdo {\t\t\tcp++;\t\t\tif (strneq(cp, \"1d\", 2))\t\t\t\tdefg3opts &= ~GROUP3OPT_2DENCODING;\t\t\telse if (strneq(cp, \"2d\", 2))\t\t\t\tdefg3opts |= GROUP3OPT_2DENCODING;\t\t\telse if (strneq(cp, \"fill\", 4))\t\t\t\tdefg3opts |= GROUP3OPT_FILLBITS;\t\t\telse\t\t\t\tusage();\t\t} while( (cp = strchr(cp, ':')) );\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidPrintIntDiff(uint32 row, int sample, uint32 pix, uint32 w1, uint32 w2){\tif (sample < 0)\t\tsample = 0;\tswitch (bitspersample) {\tcase 1:\tcase 2:\tcase 4:\t    {\t\tint32 mask1, mask2, s;\t\tmask1 =  ~((-1) << bitspersample);\t\ts = (8 - bitspersample);\t\tmask2 = mask1 << s;\t\tfor (; mask2 && pix < imagewidth;\t\t     mask2 >>= bitspersample, s -= bitspersample, pix++) {\t\t\tif ((w1 & mask2) ^ (w2 & mask2)) {\t\t\t\tprintf(\t\t\t\"Scanline %lu, pixel %lu, sample %d: %01x %01x\\n\",\t    \t\t\t\t(unsigned long) row,\t\t\t\t\t(unsigned long) pix,\t\t\t\t\tsample,\t\t\t\t\t(unsigned int)((w1 >> s) & mask1),\t\t\t\t\t(unsigned int)((w2 >> s) & mask1));\t\t\t\tif (--stopondiff == 0)\t\t\t\t\texit(1);\t\t\t}\t\t}\t\tbreak;\t    }\tcase 8: \t\tprintf(\"Scanline %lu, pixel %lu, sample %d: %02x %02x\\n\",\t\t       (unsigned long) row, (unsigned long) pix, sample,\t\t       (unsigned int) w1, (unsigned int) w2);\t\tif (--stopondiff == 0)\t\t\texit(1);\t\tbreak;\tcase 16:\t\tprintf(\"Scanline %lu, pixel %lu, sample %d: %04x %04x\\n\",\t\t    (unsigned long) row, (unsigned long) pix, sample,\t\t    (unsigned int) w1, (unsigned int) w2);\t\tif (--stopondiff == 0)\t\t\texit(1);\t\tbreak;\tcase 32:\t\tprintf(\"Scanline %lu, pixel %lu, sample %d: %08x %08x\\n\",\t\t    (unsigned long) row, (unsigned long) pix, sample,\t\t    (unsigned int) w1, (unsigned int) w2);\t\tif (--stopondiff == 0)\t\t\texit(1);\t\tbreak;\tdefault:\t\tbreak;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intreadgifimage(char* mode){    unsigned char buf[9];    int local, interleaved;    unsigned char localmap[256][3];    int localbits;    int status;    if (fread(buf, 1, 9, infile) == 0) {        perror(filename);\treturn (0);    }    width = buf[4] + (buf[5] << 8);    height = buf[6] + (buf[7] << 8);    local = buf[8] & 0x80;    interleaved = buf[8] & 0x40;    if (local == 0 && global == 0) {        fprintf(stderr, \"no colormap present for image\\n\");        return (0);    }    if ((raster = (unsigned char*) _TIFFmalloc(width*height+EXTRAFUDGE)) == NULL) {        fprintf(stderr, \"not enough memory for image\\n\");        return (0);    }    if (local) {        localbits = (buf[8] & 0x7) + 1;        fprintf(stderr, \"   local colors: %d\\n\", 1<<localbits);        fread(localmap, 3, ((size_t)1)<<localbits, infile);        initcolors(localmap, 1<<localbits);    } else if (global) {        initcolors(globalmap, 1<<globalbits);    }    if ((status = readraster()))\trasterize(interleaved, mode);    _TIFFfree(raster);    return status;}",
        "label": 1,
        "cve": "cve-2013-4243"
    },
    {
        "code": "voidTIFFFreeDirectory(TIFF* tif){\tTIFFDirectory *td = &tif->tif_dir;\tint            i;\t_TIFFmemset(td->td_fieldsset, 0, FIELD_SETLONGS);\tCleanupField(td_colormap[0]);\tCleanupField(td_colormap[1]);\tCleanupField(td_colormap[2]);\tCleanupField(td_sampleinfo);\tCleanupField(td_subifd);\tCleanupField(td_inknames);\tCleanupField(td_transferfunction[0]);\tCleanupField(td_transferfunction[1]);\tCleanupField(td_transferfunction[2]);\tCleanupField(td_stripoffset);\tCleanupField(td_stripbytecount);\tTIFFClrFieldBit(tif, FIELD_YCBCRSUBSAMPLING);\tTIFFClrFieldBit(tif, FIELD_YCBCRPOSITIONING);\t\tfor( i = 0; i < td->td_customValueCount; i++ ) {\t\tif (td->td_customValues[i].value)\t\t\t_TIFFfree(td->td_customValues[i].value);\t}\ttd->td_customValueCount = 0;\tCleanupField(td_customValues);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int *next,char *quoted);char *super_fgets(char *b, int *blen, FILE *file){  int    c,    len;  char    *q;  len=*blen;  for (q=b; ; q++)    {      c=fgetc(file);      if (c == EOF || c == '\\n')        break;      if (((long)q - (long)b + 1 ) >= (long) len)        {          long            tlen;          tlen=(long)q-(long)b;          len<<=1;          b=(char *) realloc((char *) b,(len+2));          if ((char *) b == (char *) NULL)            break;          q=b+tlen;        }      *q=(unsigned char) c;    }  *blen=0;  if ((unsigned char *)b != (unsigned char *) NULL)    {      int        tlen;      tlen=(long)q - (long)b;      if (tlen == 0)        return (char *) NULL;      b[tlen] = '\\0';      *blen=++tlen;    }  return b;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFReadContigTileData(TIFF* tif){\tunsigned char *buf;\ttsize_t rowsize = TIFFTileRowSize(tif);\tbuf = (unsigned char *)_TIFFmalloc(TIFFTileSize(tif));\tif (buf) {\t\tuint32 tw, th, w, h;\t\tuint32 row, col;\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\t\tfor (row = 0; row < h; row += th) {\t\t\tfor (col = 0; col < w; col += tw) {\t\t\t\tif (TIFFReadTile(tif, buf, col, row, 0, 0) < 0) {\t\t\t\t\tif (stoponerr)\t\t\t\t\t\tbreak;\t\t\t\t} else if (showdata)\t\t\t\t\tShowTile(row, col, (tsample_t) -1, buf, th, rowsize);\t\t\t}\t\t}\t\t_TIFFfree(buf);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "DECLARESepCallbackFunc(TestSepCallback){    printf(\"Sep Callback called with x = %d, y = %d, w = %d, h = %d, fromskew = %d\\n\",\t   x, y, w, h, fromskew);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,                             uint32 cols, uint32 rows, uint16 spp, uint16 bps,                             FILE *dumpfile, int format, int level)  {  int i, bytes_per_sample;  uint32 row, col, col_offset, src_rowsize, dst_rowsize, row_offset;  unsigned char *src;  unsigned char *dst;  tsample_t s;  src = srcbuffs[0];  dst = out;  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"combineSeparateSamplesBytes\",\"Invalid buffer address\");    return (1);    }  bytes_per_sample = (bps + 7) / 8;   src_rowsize = ((bps * cols) + 7) / 8;  dst_rowsize = ((bps * spp * cols) + 7) / 8;  for (row = 0; row < rows; row++)    {    if ((dumpfile != NULL) && (level == 2))      {      for (s = 0; s < spp; s++)        {        dump_info (dumpfile, format, \"combineSeparateSamplesBytes\",\"Input data, Sample %d\", s);        dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));        }      }    dst = out + (row * dst_rowsize);    row_offset = row * src_rowsize;    for (col = 0; col < cols; col++)      {      col_offset = row_offset + (col * (bps / 8));       for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)        {        src = srcbuffs[s] + col_offset;         for (i = 0; i < bytes_per_sample; i++)          *(dst + i) = *(src + i);        src += bytes_per_sample;        dst += bytes_per_sample;        }         }    if ((dumpfile != NULL) && (level == 2))      {      dump_info (dumpfile, format, \"combineSeparateSamplesBytes\",\"Output data, combined samples\");      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));      }    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intFax3DecodeRLE(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s){\tDECLARE_STATE(tif, sp, \"Fax3DecodeRLE\");\tint mode = sp->b.mode;        int line = 0;\t(void) s;\tCACHE_STATE(tif, sp);\tthisrun = sp->curruns;\twhile ((long)occ > 0) {\t\ta0 = 0;\t\tRunLength = 0;\t\tpa = thisrun;#ifdef FAX3_DEBUG\t\tprintf(\"\\nBitAcc=%08X, BitsAvail = %d\\n\", BitAcc, BitsAvail);\t\tprintf(\"-------------------- %d\\n\", tif->tif_row);\t\tfflush(stdout);#endif\t\tEXPAND1D(EOFRLE);\t\t(*sp->fill)(buf, thisrun, pa, lastx);\t\t\t\tif (mode & FAXMODE_BYTEALIGN) {\t\t\tint n = BitsAvail - (BitsAvail &~ 7);\t\t\tClrBits(n);\t\t} else if (mode & FAXMODE_WORDALIGN) {\t\t\tint n = BitsAvail - (BitsAvail &~ 15);\t\t\tClrBits(n);\t\t\tif (BitsAvail == 0 && !isAligned(cp, uint16))\t\t\t    cp++;\t\t}\t\tbuf += sp->b.rowbytes;\t\tocc -= sp->b.rowbytes;                line++;\t\tcontinue;\tEOFRLE:\t\t\t\t\t\t(*sp->fill)(buf, thisrun, pa, lastx);\t\tUNCACHE_STATE(tif, sp);\t\treturn (-1);\t}\tUNCACHE_STATE(tif, sp);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidprintTIF(TIFF* tif, uint16 pageNumber){    uint32 w, h;    uint16 unit, compression;    float xres, yres, scale = 1.0;    tstrip_t s, ns;    time_t creation_time;    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);    if (!TIFFGetField(tif, TIFFTAG_COMPRESSION, &compression)\t|| compression < COMPRESSION_CCITTRLE\t|| compression > COMPRESSION_CCITT_T6)\treturn;    if (!TIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres) || !xres) {\tTIFFWarning(TIFFFileName(tif),\t    \"No x-resolution, assuming %g dpi\", defxres);\txres = defxres;    }    if (!TIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres) || !yres) {\tTIFFWarning(TIFFFileName(tif),\t    \"No y-resolution, assuming %g lpi\", defyres);\tyres = defyres;\t\t\t\t\t    }    if (TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &unit) &&      unit == RESUNIT_CENTIMETER) {\txres *= 2.54F;\tyres *= 2.54F;    }    if (pageWidth == 0)\tpageWidth = w / xres;    if (pageHeight == 0)\tpageHeight = h / yres;    printf(\"%%!PS-Adobe-3.0\\n\");    printf(\"%%%%Creator: fax2ps\\n\");#ifdef notdef    printf(\"%%%%Title: %s\\n\", file);#endif    creation_time = time(0);    printf(\"%%%%CreationDate: %s\", ctime(&creation_time));    printf(\"%%%%Origin: 0 0\\n\");    printf(\"%%%%BoundingBox: 0 0 %u %u\\n\",\t(int)(pageWidth * points), (int)(pageHeight * points));\t    printf(\"%%%%Pages: (atend)\\n\");    printf(\"%%%%EndComments\\n\");    printf(\"%%%%BeginProlog\\n\");    emitFont(stdout);    printf(\"/d{bind def}def\\n\");     printf(\"/m{0 exch moveto}d\\n\");    printf(\"/s{show}d\\n\");    printf(\"/p{showpage}d \\n\");\t    printf(\"%%%%EndProlog\\n\");    printf(\"%%%%Page: \\\"%u\\\" %u\\n\", pageNumber, pageNumber);    printf(\"/$pageTop save def gsave\\n\");    if (scaleToPage)        scale = pageHeight / (h/yres) < pageWidth / (w/xres) ?            pageHeight / (h/yres) : pageWidth / (w/xres);    printf(\"%g %g translate\\n\",           points * (pageWidth - scale*w/xres) * half,           points * (scale*h/yres + (pageHeight - scale*h/yres) * half));    printf(\"%g %g scale\\n\", points/xres*scale, -points/yres*scale);    printf(\"0 setgray\\n\");    TIFFSetField(tif, TIFFTAG_FAXFILLFUNC, printruns);    ns = TIFFNumberOfStrips(tif);    row = 0;    for (s = 0; s < ns; s++)\t(void) TIFFReadEncodedStrip(tif, s, (tdata_t) NULL, (tsize_t) -1);    printf(\"p\\n\");    printf(\"grestore $pageTop restore\\n\");    totalPages++;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPixarLogVGetField(TIFF* tif, uint32 tag, va_list ap){    PixarLogState *sp = (PixarLogState *)tif->tif_data;    switch (tag) {     case TIFFTAG_PIXARLOGQUALITY:\t*va_arg(ap, int*) = sp->quality;\tbreak;     case TIFFTAG_PIXARLOGDATAFMT:\t*va_arg(ap, int*) = sp->user_datafmt;\tbreak;     default:\treturn (*sp->vgetparent)(tif, tag, ap);    }    return (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tmsize_tmultiply_ms(tmsize_t m1, tmsize_t m2){\ttmsize_t bytes = m1 * m2;\tif (m1 && bytes / m1 != m2)\t\tbytes = 0;\treturn bytes;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFfree(tdata_t p){\tGlobalFree(p);\treturn;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap){\tTIFFDirectory* td = &tif->tif_dir;\tint ret_val = 1;\tuint32 standard_tag = tag;\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\tif( fip == NULL ) \t    return 0;\t\t\tif (fip->field_bit == FIELD_CUSTOM) {\t\tstandard_tag = 0;\t}\tswitch (standard_tag) {\t\tcase TIFFTAG_SUBFILETYPE:\t\t\t*va_arg(ap, uint32*) = td->td_subfiletype;\t\t\tbreak;\t\tcase TIFFTAG_IMAGEWIDTH:\t\t\t*va_arg(ap, uint32*) = td->td_imagewidth;\t\t\tbreak;\t\tcase TIFFTAG_IMAGELENGTH:\t\t\t*va_arg(ap, uint32*) = td->td_imagelength;\t\t\tbreak;\t\tcase TIFFTAG_BITSPERSAMPLE:\t\t\t*va_arg(ap, uint16*) = td->td_bitspersample;\t\t\tbreak;\t\tcase TIFFTAG_COMPRESSION:\t\t\t*va_arg(ap, uint16*) = td->td_compression;\t\t\tbreak;\t\tcase TIFFTAG_PHOTOMETRIC:\t\t\t*va_arg(ap, uint16*) = td->td_photometric;\t\t\tbreak;\t\tcase TIFFTAG_THRESHHOLDING:\t\t\t*va_arg(ap, uint16*) = td->td_threshholding;\t\t\tbreak;\t\tcase TIFFTAG_FILLORDER:\t\t\t*va_arg(ap, uint16*) = td->td_fillorder;\t\t\tbreak;\t\tcase TIFFTAG_ORIENTATION:\t\t\t*va_arg(ap, uint16*) = td->td_orientation;\t\t\tbreak;\t\tcase TIFFTAG_SAMPLESPERPIXEL:\t\t\t*va_arg(ap, uint16*) = td->td_samplesperpixel;\t\t\tbreak;\t\tcase TIFFTAG_ROWSPERSTRIP:\t\t\t*va_arg(ap, uint32*) = td->td_rowsperstrip;\t\t\tbreak;\t\tcase TIFFTAG_MINSAMPLEVALUE:\t\t\t*va_arg(ap, uint16*) = td->td_minsamplevalue;\t\t\tbreak;\t\tcase TIFFTAG_MAXSAMPLEVALUE:\t\t\t*va_arg(ap, uint16*) = td->td_maxsamplevalue;\t\t\tbreak;\t\tcase TIFFTAG_SMINSAMPLEVALUE:\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\t\t\t\t*va_arg(ap, double**) = td->td_sminsamplevalue;\t\t\telse\t\t\t{\t\t\t\t\t\t\t\tuint16 i;\t\t\t\tdouble v = td->td_sminsamplevalue[0];\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\t\t\t\t\tif( td->td_sminsamplevalue[i] < v )\t\t\t\t\t\tv = td->td_sminsamplevalue[i];\t\t\t\t*va_arg(ap, double*) = v;\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\t\t\t\t*va_arg(ap, double**) = td->td_smaxsamplevalue;\t\t\telse\t\t\t{\t\t\t\t\t\t\t\tuint16 i;\t\t\t\tdouble v = td->td_smaxsamplevalue[0];\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\t\t\t\t\tif( td->td_smaxsamplevalue[i] > v )\t\t\t\t\t\tv = td->td_smaxsamplevalue[i];\t\t\t\t*va_arg(ap, double*) = v;\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_XRESOLUTION:\t\t\t*va_arg(ap, float*) = td->td_xresolution;\t\t\tbreak;\t\tcase TIFFTAG_YRESOLUTION:\t\t\t*va_arg(ap, float*) = td->td_yresolution;\t\t\tbreak;\t\tcase TIFFTAG_PLANARCONFIG:\t\t\t*va_arg(ap, uint16*) = td->td_planarconfig;\t\t\tbreak;\t\tcase TIFFTAG_XPOSITION:\t\t\t*va_arg(ap, float*) = td->td_xposition;\t\t\tbreak;\t\tcase TIFFTAG_YPOSITION:\t\t\t*va_arg(ap, float*) = td->td_yposition;\t\t\tbreak;\t\tcase TIFFTAG_RESOLUTIONUNIT:\t\t\t*va_arg(ap, uint16*) = td->td_resolutionunit;\t\t\tbreak;\t\tcase TIFFTAG_PAGENUMBER:\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[0];\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[1];\t\t\tbreak;\t\tcase TIFFTAG_HALFTONEHINTS:\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[0];\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[1];\t\t\tbreak;\t\tcase TIFFTAG_COLORMAP:\t\t\t*va_arg(ap, uint16**) = td->td_colormap[0];\t\t\t*va_arg(ap, uint16**) = td->td_colormap[1];\t\t\t*va_arg(ap, uint16**) = td->td_colormap[2];\t\t\tbreak;\t\tcase TIFFTAG_STRIPOFFSETS:\t\tcase TIFFTAG_TILEOFFSETS:\t\t\t_TIFFFillStriles( tif );\t\t\t*va_arg(ap, uint64**) = td->td_stripoffset;\t\t\tbreak;\t\tcase TIFFTAG_STRIPBYTECOUNTS:\t\tcase TIFFTAG_TILEBYTECOUNTS:\t\t\t_TIFFFillStriles( tif );\t\t\t*va_arg(ap, uint64**) = td->td_stripbytecount;\t\t\tbreak;\t\tcase TIFFTAG_MATTEING:\t\t\t*va_arg(ap, uint16*) =\t\t\t    (td->td_extrasamples == 1 &&\t\t\t    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\t\t\tbreak;\t\tcase TIFFTAG_EXTRASAMPLES:\t\t\t*va_arg(ap, uint16*) = td->td_extrasamples;\t\t\t*va_arg(ap, uint16**) = td->td_sampleinfo;\t\t\tbreak;\t\tcase TIFFTAG_TILEWIDTH:\t\t\t*va_arg(ap, uint32*) = td->td_tilewidth;\t\t\tbreak;\t\tcase TIFFTAG_TILELENGTH:\t\t\t*va_arg(ap, uint32*) = td->td_tilelength;\t\t\tbreak;\t\tcase TIFFTAG_TILEDEPTH:\t\t\t*va_arg(ap, uint32*) = td->td_tiledepth;\t\t\tbreak;\t\tcase TIFFTAG_DATATYPE:\t\t\tswitch (td->td_sampleformat) {\t\t\t\tcase SAMPLEFORMAT_UINT:\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_UINT;\t\t\t\t\tbreak;\t\t\t\tcase SAMPLEFORMAT_INT:\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_INT;\t\t\t\t\tbreak;\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_IEEEFP;\t\t\t\t\tbreak;\t\t\t\tcase SAMPLEFORMAT_VOID:\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_VOID;\t\t\t\t\tbreak;\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_SAMPLEFORMAT:\t\t\t*va_arg(ap, uint16*) = td->td_sampleformat;\t\t\tbreak;\t\tcase TIFFTAG_IMAGEDEPTH:\t\t\t*va_arg(ap, uint32*) = td->td_imagedepth;\t\t\tbreak;\t\tcase TIFFTAG_SUBIFD:\t\t\t*va_arg(ap, uint16*) = td->td_nsubifd;\t\t\t*va_arg(ap, uint64**) = td->td_subifd;\t\t\tbreak;\t\tcase TIFFTAG_YCBCRPOSITIONING:\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrpositioning;\t\t\tbreak;\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];\t\t\tbreak;\t\tcase TIFFTAG_TRANSFERFUNCTION:\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[0];\t\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[1];\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[2];\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\t\t\t*va_arg(ap, float**) = td->td_refblackwhite;\t\t\tbreak;\t\tcase TIFFTAG_INKNAMES:\t\t\t*va_arg(ap, char**) = td->td_inknames;\t\t\tbreak;\t\tdefault:\t\t\t{\t\t\t\tint i;\t\t\t\t\t\t\t\tif( fip->field_bit != FIELD_CUSTOM )\t\t\t\t{\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFVGetField\",\t\t\t\t\t    \"%s: Invalid %stag \\\"%s\\\" \"\t\t\t\t\t    \"(not supported by codec)\",\t\t\t\t\t    tif->tif_name,\t\t\t\t\t    isPseudoTag(tag) ? \"pseudo-\" : \"\",\t\t\t\t\t    fip->field_name);\t\t\t\t\tret_val = 0;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\t\t\t\t\tret_val = 0;\t\t\t\tfor (i = 0; i < td->td_customValueCount; i++) {\t\t\t\t\tTIFFTagValue *tv = td->td_customValues + i;\t\t\t\t\tif (tv->info->field_tag != tag)\t\t\t\t\t\tcontinue;\t\t\t\t\tif (fip->field_passcount) {\t\t\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2)\t\t\t\t\t\t\t*va_arg(ap, uint32*) = (uint32)tv->count;\t\t\t\t\t\telse  \t\t\t\t\t\t\t*va_arg(ap, uint16*) = (uint16)tv->count;\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\t\t\t\t\t\tret_val = 1;\t\t\t\t\t} else if (fip->field_tag == TIFFTAG_DOTRANGE\t\t\t\t\t\t   && strcmp(fip->field_name,\"DotRange\") == 0) {\t\t\t\t\t\t\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];\t\t\t\t\t\tret_val = 1;\t\t\t\t\t} else {\t\t\t\t\t\tif (fip->field_type == TIFF_ASCII\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2\t\t\t\t\t\t    || fip->field_readcount == TIFF_SPP\t\t\t\t\t\t    || tv->count > 1) {\t\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t} else {\t\t\t\t\t\t\tchar *val = (char *)tv->value;\t\t\t\t\t\t\tassert( tv->count == 1 );\t\t\t\t\t\t\tswitch (fip->field_type) {\t\t\t\t\t\t\tcase TIFF_BYTE:\t\t\t\t\t\t\tcase TIFF_UNDEFINED:\t\t\t\t\t\t\t\t*va_arg(ap, uint8*) =\t\t\t\t\t\t\t\t\t*(uint8 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SBYTE:\t\t\t\t\t\t\t\t*va_arg(ap, int8*) =\t\t\t\t\t\t\t\t\t*(int8 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SHORT:\t\t\t\t\t\t\t\t*va_arg(ap, uint16*) =\t\t\t\t\t\t\t\t\t*(uint16 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SSHORT:\t\t\t\t\t\t\t\t*va_arg(ap, int16*) =\t\t\t\t\t\t\t\t\t*(int16 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_LONG:\t\t\t\t\t\t\tcase TIFF_IFD:\t\t\t\t\t\t\t\t*va_arg(ap, uint32*) =\t\t\t\t\t\t\t\t\t*(uint32 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SLONG:\t\t\t\t\t\t\t\t*va_arg(ap, int32*) =\t\t\t\t\t\t\t\t\t*(int32 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_LONG8:\t\t\t\t\t\t\tcase TIFF_IFD8:\t\t\t\t\t\t\t\t*va_arg(ap, uint64*) =\t\t\t\t\t\t\t\t\t*(uint64 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SLONG8:\t\t\t\t\t\t\t\t*va_arg(ap, int64*) =\t\t\t\t\t\t\t\t\t*(int64 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_RATIONAL:\t\t\t\t\t\t\tcase TIFF_SRATIONAL:\t\t\t\t\t\t\tcase TIFF_FLOAT:\t\t\t\t\t\t\t\t*va_arg(ap, float*) =\t\t\t\t\t\t\t\t\t*(float *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_DOUBLE:\t\t\t\t\t\t\t\t*va_arg(ap, double*) =\t\t\t\t\t\t\t\t\t*(double *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tdefault:\t\t\t\t\t\t\t\tret_val = 0;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t}\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t}\treturn(ret_val);}",
        "label": 1,
        "cve": "cve-2017-9147"
    },
    {
        "code": "static toff_t_tiffSizeProc(thandle_t fd){\tstruct stat sb;\treturn (fstat((int) fd, &sb) < 0 ? 0 : sb.st_size);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static introtateContigSamples16bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,                          uint32 length,   uint32 col, uint8 *src, uint8 *dst)  {  int      ready_bits = 0;  uint32   row, rowsize, bit_offset;  uint32   src_byte = 0, src_bit = 0;  uint16   matchbits = 0, maskbits = 0;  uint16   buff1 = 0, buff2 = 0;  uint8    bytebuff = 0;  uint8   *next;  tsample_t sample;  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"rotateContigSamples16bits\",\"Invalid src or destination buffer\");    return (1);    }  rowsize = ((bps * spp * width) + 7) / 8;  ready_bits = 0;  maskbits =  (uint16)-1 >> (16 - bps);  buff1 = buff2 = 0;  for (row = 0; row < length; row++)    {    bit_offset = col * bps * spp;    for (sample = 0; sample < spp; sample++)      {      if (sample == 0)        {        src_byte = bit_offset / 8;        src_bit  = bit_offset % 8;        }      else        {        src_byte = (bit_offset + (sample * bps)) / 8;        src_bit  = (bit_offset + (sample * bps)) % 8;        }      switch (rotation)\t{        case  90: next = src + src_byte - (row * rowsize);                  break;        case 270: next = src + src_byte + (row * rowsize);\t          break;\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);                  return (1);        }      matchbits = maskbits << (16 - src_bit - bps);       if (little_endian)        buff1 = (next[0] << 8) | next[1];      else        buff1 = (next[1] << 8) | next[0];      buff1 = (buff1 & matchbits) << (src_bit);            if (ready_bits >= 8)        {        bytebuff = (buff2 >> 8);        *dst++ = bytebuff;        ready_bits -= 8;                buff2 = ((buff2 << 8) | (buff1 >> ready_bits));        }      else        {         bytebuff = 0;        buff2 = (buff2 | (buff1 >> ready_bits));        }      ready_bits += bps;      }    }  if (ready_bits > 0)    {    bytebuff = (buff2 >> 8);    *dst++ = bytebuff;    }  return (0);  }  ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static introtateContigSamples24bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,                           uint32 length,   uint32 col, uint8 *src, uint8 *dst)  {  int      ready_bits = 0;  uint32   row, rowsize, bit_offset;  uint32   src_byte = 0, src_bit = 0;  uint32   matchbits = 0, maskbits = 0;  uint32   buff1 = 0, buff2 = 0;  uint8    bytebuff1 = 0, bytebuff2 = 0;  uint8   *next;  tsample_t sample;  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"rotateContigSamples24bits\",\"Invalid src or destination buffer\");    return (1);    }  rowsize = ((bps * spp * width) + 7) / 8;  ready_bits = 0;  maskbits =  (uint32)-1 >> (32 - bps);  buff1 = buff2 = 0;  for (row = 0; row < length; row++)    {    bit_offset = col * bps * spp;    for (sample = 0; sample < spp; sample++)      {      if (sample == 0)        {        src_byte = bit_offset / 8;        src_bit  = bit_offset % 8;        }      else        {        src_byte = (bit_offset + (sample * bps)) / 8;        src_bit  = (bit_offset + (sample * bps)) % 8;        }      switch (rotation)\t{        case  90: next = src + src_byte - (row * rowsize);                  break;        case 270: next = src + src_byte + (row * rowsize);\t          break;\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);                  return (1);        }      matchbits = maskbits << (32 - src_bit - bps);       if (little_endian)\tbuff1 = (next[0] << 24) | (next[1] << 16) | (next[2] << 8) | next[3];      else\tbuff1 = (next[3] << 24) | (next[2] << 16) | (next[1] << 8) | next[0];      buff1 = (buff1 & matchbits) << (src_bit);            if (ready_bits >= 16)        {        bytebuff1 = (buff2 >> 24);        *dst++ = bytebuff1;        bytebuff2 = (buff2 >> 16);        *dst++ = bytebuff2;        ready_bits -= 16;                buff2 = ((buff2 << 16) | (buff1 >> ready_bits));        }      else        {         bytebuff1 = bytebuff2 = 0;        buff2 = (buff2 | (buff1 >> ready_bits));        }      ready_bits += bps;      }    }   while (ready_bits > 0)    {    bytebuff1 = (buff2 >> 24);    *dst++ = bytebuff1;    buff2 = (buff2 << 8);    bytebuff2 = bytebuff1;    ready_bits -= 8;    }  return (0);  }  ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidShowRawBytes(unsigned char* pp, uint32 n){\tuint32 i;\tfor (i = 0; i < n; i++) {\t\tprintf(\" %02x\", *pp++);\t\tif (((i+1) % 24) == 0)\t\t\tprintf(\"\\n \");\t}\tputchar('\\n');}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tmsize_tTIFFReadRawTile1(TIFF* tif, uint32 tile, void* buf, tmsize_t size, const char* module){\tTIFFDirectory *td = &tif->tif_dir;    if (!_TIFFFillStriles( tif ))        return ((tmsize_t)(-1));\tassert((tif->tif_flags&TIFF_NOREADRAW)==0);\tif (!isMapped(tif)) {\t\ttmsize_t cc;\t\tif (!SeekOK(tif, td->td_stripoffset[tile])) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"Seek error at row %lu, col %lu, tile %lu\",\t\t\t    (unsigned long) tif->tif_row,\t\t\t    (unsigned long) tif->tif_col,\t\t\t    (unsigned long) tile);\t\t\treturn ((tmsize_t)(-1));\t\t}\t\tcc = TIFFReadFile(tif, buf, size);\t\tif (cc != size) {#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\"Read error at row %lu, col %lu; got %I64u bytes, expected %I64u\",\t\t\t\t     (unsigned long) tif->tif_row,\t\t\t\t     (unsigned long) tif->tif_col,\t\t\t\t     (unsigned __int64) cc,\t\t\t\t     (unsigned __int64) size);#else\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\"Read error at row %lu, col %lu; got %llu bytes, expected %llu\",\t\t\t\t     (unsigned long) tif->tif_row,\t\t\t\t     (unsigned long) tif->tif_col,\t\t\t\t     (unsigned long long) cc,\t\t\t\t     (unsigned long long) size);#endif\t\t\treturn ((tmsize_t)(-1));\t\t}\t} else {\t\ttmsize_t ma,mb;\t\ttmsize_t n;\t\tma=(tmsize_t)td->td_stripoffset[tile];\t\tmb=ma+size;\t\tif (((uint64)ma!=td->td_stripoffset[tile])||(ma>tif->tif_size))\t\t\tn=0;\t\telse if ((mb<ma)||(mb<size)||(mb>tif->tif_size))\t\t\tn=tif->tif_size-ma;\t\telse\t\t\tn=size;\t\tif (n!=size) {#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\"Read error at row %lu, col %lu, tile %lu; got %I64u bytes, expected %I64u\",\t\t\t\t     (unsigned long) tif->tif_row,\t\t\t\t     (unsigned long) tif->tif_col,\t\t\t\t     (unsigned long) tile,\t\t\t\t     (unsigned __int64) n,\t\t\t\t     (unsigned __int64) size);#else\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\"Read error at row %lu, col %lu, tile %lu; got %llu bytes, expected %llu\",\t\t\t\t     (unsigned long) tif->tif_row,\t\t\t\t     (unsigned long) tif->tif_col,\t\t\t\t     (unsigned long) tile,\t\t\t\t     (unsigned long long) n,\t\t\t\t     (unsigned long long) size);#endif\t\t\treturn ((tmsize_t)(-1));\t\t}\t\t_TIFFmemcpy(buf, tif->tif_base + ma, size);\t}\treturn (size);}",
        "label": 1,
        "cve": "cve-2016-6223_1"
    },
    {
        "code": "static voidmap_colortable(void){\tregister uint32 *histp = &histogram[0][0][0];\tregister C_cell *cell;\tregister int j, tmp, d2, dist;\tint ir, ig, ib, i;\tfor (ir = 0; ir < B_LEN; ++ir)\t\tfor (ig = 0; ig < B_LEN; ++ig)\t\t\tfor (ib = 0; ib < B_LEN; ++ib, histp++) {\t\t\t\tif (*histp == 0) {\t\t\t\t\t*histp = -1;\t\t\t\t\tcontinue;\t\t\t\t}\t\t\t\tcell = *(ColorCells +\t\t\t\t    (((ir>>(B_DEPTH-C_DEPTH)) << C_DEPTH*2) +\t\t\t\t    ((ig>>(B_DEPTH-C_DEPTH)) << C_DEPTH) +\t\t\t\t    (ib>>(B_DEPTH-C_DEPTH))));\t\t\t\tif (cell == NULL )\t\t\t\t\tcell = create_colorcell(\t\t\t\t\t    ir << COLOR_SHIFT,\t\t\t\t\t    ig << COLOR_SHIFT,\t\t\t\t\t    ib << COLOR_SHIFT);\t\t\t\tdist = 9999999;\t\t\t\tfor (i = 0; i < cell->num_ents &&\t\t\t\t    dist > cell->entries[i][1]; ++i) {\t\t\t\t\tj = cell->entries[i][0];\t\t\t\t\td2 = rm[j] - (ir << COLOR_SHIFT);\t\t\t\t\td2 *= d2;\t\t\t\t\ttmp = gm[j] - (ig << COLOR_SHIFT);\t\t\t\t\td2 += tmp*tmp;\t\t\t\t\ttmp = bm[j] - (ib << COLOR_SHIFT);\t\t\t\t\td2 += tmp*tmp;\t\t\t\t\tif (d2 < dist) {\t\t\t\t\t\tdist = d2;\t\t\t\t\t\t*histp = j;\t\t\t\t\t}\t\t\t\t}\t\t\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidraster_draw(void){  glDrawPixels(img.width, img.height, GL_RGBA, GL_UNSIGNED_BYTE, (const GLvoid *) raster);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchLongArray(TIFF* tif, TIFFDirEntry* dir, uint32* v){\tif (dir->tdir_count == 1) {\t\tv[0] = dir->tdir_offset;\t\treturn (1);\t} else\t\treturn (TIFFFetchData(tif, dir, (char*) v) != 0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize){\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidFax3Cleanup(TIFF* tif){\tFax3CodecState* sp = DecoderState(tif);\tassert(sp != 0);\ttif->tif_tagmethods.vgetfield = sp->b.vgetparent;\ttif->tif_tagmethods.vsetfield = sp->b.vsetparent;\tif (sp->runs)\t\t_TIFFfree(sp->runs);\tif (sp->refline)\t\t_TIFFfree(sp->refline);\tif (Fax3State(tif)->subaddress)\t\t_TIFFfree(Fax3State(tif)->subaddress);\t_TIFFfree(tif->tif_data);\ttif->tif_data = NULL;\t_TIFFSetDefaultCompressionState(tif);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intOJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc){\tstatic const char module[]=\"OJPEGDecodeRaw\";\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\tuint8* m;\ttmsize_t n;\tuint8* oy;\tuint8* ocb;\tuint8* ocr;\tuint8* p;\tuint32 q;\tuint8* r;\tuint8 sx,sy;\tif (cc%sp->bytes_per_line!=0)\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Fractional scanline not read\");\t\treturn(0);\t}\tassert(cc>0);\tm=buf;\tn=cc;\tdo\t{\t\tif (sp->subsampling_convert_state==0)\t\t{\t\t\tif (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)\t\t\t\treturn(0);\t\t}\t\toy=sp->subsampling_convert_ybuf+sp->subsampling_convert_state*sp->subsampling_ver*sp->subsampling_convert_ylinelen;\t\tocb=sp->subsampling_convert_cbbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen;\t\tocr=sp->subsampling_convert_crbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen;\t\tp=m;\t\tfor (q=0; q<sp->subsampling_convert_clinelenout; q++)\t\t{\t\t\tr=oy;\t\t\tfor (sy=0; sy<sp->subsampling_ver; sy++)\t\t\t{\t\t\t\tfor (sx=0; sx<sp->subsampling_hor; sx++)\t\t\t\t\t*p++=*r++;\t\t\t\tr+=sp->subsampling_convert_ylinelen-sp->subsampling_hor;\t\t\t}\t\t\toy+=sp->subsampling_hor;\t\t\t*p++=*ocb++;\t\t\t*p++=*ocr++;\t\t}\t\tsp->subsampling_convert_state++;\t\tif (sp->subsampling_convert_state==sp->subsampling_convert_clines)\t\t\tsp->subsampling_convert_state=0;\t\tm+=sp->bytes_per_line;\t\tn-=sp->bytes_per_line;\t} while(n>0);\treturn(1);}",
        "label": 1,
        "cve": "cve-2016-10267"
    },
    {
        "code": "int mfs_close (int fd){    int ret;     if (fds[fd] == -1)      {        ret = -1;        errno = EBADF;    }    else    {        fds[fd] = -1;        ret = 0;    }    return (ret);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void main(){\tTIFF *tif=(TIFF*)0;  \ttif=XTIFFOpen(\"newtif.tif\",\"w\");\tif (!tif) goto failure;\tSetUpTIFFDirectory(tif);\tWriteImage(tif);\tXTIFFClose(tif);\texit (0);failure:\tprintf(\"failure in maketif\\n\");\tif (tif) XTIFFClose(tif);\texit (-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFFTagMethods *TIFFAccessTagMethods( TIFF *tif ){    return &(tif->tif_tagmethods);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int checkcmap(int n, uint16* r, uint16* g, uint16* b){    while (n-- > 0)        if (*r++ >= 256 || *g++ >= 256 || *b++ >= 256)        return (16);    return (8);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intcopyFaxFile(TIFF* tifin, TIFF* tifout){\tuint32 row;\tuint32 linesize = TIFFhowmany8(xsize);\tuint16 badrun;\tint ok;\ttifin->tif_rawdatasize = (tmsize_t)TIFFGetFileSize(tifin);\ttifin->tif_rawdata = _TIFFmalloc(tifin->tif_rawdatasize);\tif (tifin->tif_rawdata == NULL) {\t\tTIFFError(tifin->tif_name, \"Not enough memory\");\t\treturn (0);\t}\tif (!ReadOK(tifin, tifin->tif_rawdata, tifin->tif_rawdatasize)) {\t\tTIFFError(tifin->tif_name, \"Read error at scanline 0\");\t\treturn (0);\t}\ttifin->tif_rawcp = tifin->tif_rawdata;\ttifin->tif_rawcc = tifin->tif_rawdatasize;\t(*tifin->tif_setupdecode)(tifin);\t(*tifin->tif_predecode)(tifin, (tsample_t) 0);\ttifin->tif_row = 0;\tbadfaxlines = 0;\tbadfaxrun = 0;\t_TIFFmemset(refbuf, 0, linesize);\trow = 0;\tbadrun = 0;\t\t\twhile (tifin->tif_rawcc > 0) {\t\tok = (*tifin->tif_decoderow)(tifin, (tdata_t) rowbuf, \t\t\t\t\t     linesize, 0);\t\tif (!ok) {\t\t\tbadfaxlines++;\t\t\tbadrun++;\t\t\t\t\t\t_TIFFmemcpy(rowbuf, refbuf, linesize);\t\t} else {\t\t\tif (badrun > badfaxrun)\t\t\t\tbadfaxrun = badrun;\t\t\tbadrun = 0;\t\t\t_TIFFmemcpy(refbuf, rowbuf, linesize);\t\t}\t\ttifin->tif_row++;\t\tif (TIFFWriteScanline(tifout, rowbuf, row, 0) < 0) {\t\t\tfprintf(stderr, \"%s: Write error at row %ld.\\n\",\t\t\t    tifout->tif_name, (long) row);\t\t\tbreak;\t\t}\t\trow++;\t\tif (stretch) {\t\t\tif (TIFFWriteScanline(tifout, rowbuf, row, 0) < 0) {\t\t\t\tfprintf(stderr, \"%s: Write error at row %ld.\\n\",\t\t\t\t    tifout->tif_name, (long) row);\t\t\t\tbreak;\t\t\t}\t\t\trow++;\t\t}\t}\tif (badrun > badfaxrun)\t\tbadfaxrun = badrun;\t_TIFFfree(tifin->tif_rawdata);\treturn (row);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPredictorDecodeRow(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s){\tTIFFPredictorState *sp = PredictorState(tif);\tassert(sp != NULL);\tassert(sp->decoderow != NULL);\tassert(sp->decodepfunc != NULL);  \tif ((*sp->decoderow)(tif, op0, occ0, s)) {\t\treturn (*sp->decodepfunc)(tif, op0, occ0);\t} else\t\treturn 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidusage(){    error(\"usage: %s -[vq] [-|rasterfile] TIFFfile\\n\", NULL);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void WriteImage(TIFF *tif){\tint i;\tchar buffer[WIDTH];\tmemset(buffer,0,sizeof(buffer));\tfor (i=0;i<HEIGHT;i++)\t\tif (!TIFFWriteScanline(tif, buffer, i, 0))\t\t\tTIFFErrorExt(tif->tif_clientdata, \"WriteImage\",\"failure in WriteScanline\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int TIFFGetTagListCount( TIFF *tif ){    TIFFDirectory* td = &tif->tif_dir;    return td->td_customValueCount;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchNormalSubTag(TIFF* tif, TIFFDirEntry* dp, const TIFFFieldInfo* fip,\t\t      int (*setFieldFn)(TIFF *tif, ttag_t tag, ...)){\tstatic char mesg[] = \"to fetch tag value\";\tint ok = 0;\tif (dp->tdir_count > 1) {\t\t\t\tchar* cp = NULL;\t\tswitch (dp->tdir_type) {\t\tcase TIFF_BYTE:\t\tcase TIFF_SBYTE:\t\t\t\t\t\tcp = CheckMalloc(tif,\t\t\t    dp->tdir_count * sizeof (uint16), mesg);\t\t\tok = cp && TIFFFetchByteArray(tif, dp, (uint16*) cp);\t\t\tbreak;\t\tcase TIFF_SHORT:\t\tcase TIFF_SSHORT:\t\t\tcp = CheckMalloc(tif,\t\t\t    dp->tdir_count * sizeof (uint16), mesg);\t\t\tok = cp && TIFFFetchShortArray(tif, dp, (uint16*) cp);\t\t\tbreak;\t\tcase TIFF_LONG:\t\tcase TIFF_SLONG:\t\t\tcp = CheckMalloc(tif,\t\t\t    dp->tdir_count * sizeof (uint32), mesg);\t\t\tok = cp && TIFFFetchLongArray(tif, dp, (uint32*) cp);\t\t\tbreak;\t\tcase TIFF_RATIONAL:\t\tcase TIFF_SRATIONAL:\t\t\tcp = CheckMalloc(tif,\t\t\t    dp->tdir_count * sizeof (float), mesg);\t\t\tok = cp && TIFFFetchRationalArray(tif, dp, (float*) cp);\t\t\tbreak;\t\tcase TIFF_FLOAT:\t\t\tcp = CheckMalloc(tif,\t\t\t    dp->tdir_count * sizeof (float), mesg);\t\t\tok = cp && TIFFFetchFloatArray(tif, dp, (float*) cp);\t\t\tbreak;\t\tcase TIFF_DOUBLE:\t\t\tcp = CheckMalloc(tif,\t\t\t    dp->tdir_count * sizeof (double), mesg);\t\t\tok = cp && TIFFFetchDoubleArray(tif, dp, (double*) cp);\t\t\tbreak;\t\tcase TIFF_ASCII:\t\tcase TIFF_UNDEFINED:\t\t\t\t\t\t\t\tcp = CheckMalloc(tif, dp->tdir_count+1, mesg);\t\t\tif (ok = (cp && TIFFFetchString(tif, dp, cp)))\t\t\t\tcp[dp->tdir_count] = '\\0';\t\t\t\tbreak;\t\t}\t\tif (ok) {\t\t\tok = (fip->field_passcount ?\t\t\t    (*setFieldFn)(tif, dp->tdir_tag, dp->tdir_count, cp)\t\t\t  : (*setFieldFn)(tif, dp->tdir_tag, cp));\t\t}\t\tif (cp != NULL)\t\t\t_TIFFfree(cp);\t} else if (CheckDirCount(tif, dp, 1)) {\t\t\tswitch (dp->tdir_type) {\t\tcase TIFF_BYTE:\t\tcase TIFF_SBYTE:\t\tcase TIFF_SHORT:\t\tcase TIFF_SSHORT:\t\t\t\t\t\t{ TIFFDataType type = fip->field_type;\t\t\t  if (type != TIFF_LONG && type != TIFF_SLONG) {\t\t\t\tuint16 v = (uint16)\t\t\t   TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset);\t\t\t\tok = (fip->field_passcount ?\t\t\t\t    (*setFieldFn)(tif, dp->tdir_tag, 1, &v)\t\t\t\t  : (*setFieldFn)(tif, dp->tdir_tag, v));\t\t\t\tbreak;\t\t\t  }\t\t\t}\t\t\t\t\tcase TIFF_LONG:\t\tcase TIFF_SLONG:\t\t\t{ uint32 v32 =\t\t    TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset);\t\t\t  ok = (fip->field_passcount ? \t\t\t      (*setFieldFn)(tif, dp->tdir_tag, 1, &v32)\t\t\t    : (*setFieldFn)(tif, dp->tdir_tag, v32));\t\t\t}\t\t\tbreak;\t\tcase TIFF_RATIONAL:\t\tcase TIFF_SRATIONAL:\t\tcase TIFF_FLOAT:\t\t\t{ float v = (dp->tdir_type == TIFF_FLOAT ? \t\t\t      TIFFFetchFloat(tif, dp)\t\t\t    : TIFFFetchRational(tif, dp));\t\t\t  ok = (fip->field_passcount ?\t\t\t      (*setFieldFn)(tif, dp->tdir_tag, 1, &v)\t\t\t    : (*setFieldFn)(tif, dp->tdir_tag, v));\t\t\t}\t\t\tbreak;\t\tcase TIFF_DOUBLE:\t\t\t{ double v;\t\t\t  ok = (TIFFFetchDoubleArray(tif, dp, &v) &&\t\t\t    (fip->field_passcount ?\t\t\t      (*setFieldFn)(tif, dp->tdir_tag, 1, &v)\t\t\t    : (*setFieldFn)(tif, dp->tdir_tag, v))\t\t\t  );\t\t\t}\t\t\tbreak;\t\tcase TIFF_ASCII:\t\tcase TIFF_UNDEFINED:\t\t\t\t\t{ char c[2];\t\t\t  if (ok = (TIFFFetchString(tif, dp, c) != 0)) {\t\t\t\tc[1] = '\\0';\t\t\t\t\t\tok = (*setFieldFn)(tif, dp->tdir_tag, c);\t\t\t  }\t\t\t}\t\t\tbreak;\t\t}\t}\treturn (ok);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value){\tuint32 m[2];\tassert(value>=0.0);\tassert(sizeof(uint32)==4);\tif (value<=0.0)\t{\t\tm[0]=0;\t\tm[1]=1;\t}\telse if (value==(double)(uint32)value)\t{\t\tm[0]=(uint32)value;\t\tm[1]=1;\t}\telse if (value<1.0)\t{\t\tm[0]=(uint32)(value*0xFFFFFFFF);\t\tm[1]=0xFFFFFFFF;\t}\telse\t{\t\tm[0]=0xFFFFFFFF;\t\tm[1]=(uint32)(0xFFFFFFFF/value);\t}\tif (tif->tif_flags&TIFF_SWAB)\t{\t\tTIFFSwabLong(&m[0]);\t\tTIFFSwabLong(&m[1]);\t}\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,1,8,&m[0]));}",
        "label": 1,
        "cve": "cve-2016-10371"
    },
    {
        "code": "static floatTIFFFetchFloat(TIFF* tif, TIFFDirEntry* dir){\t#if (0)\tfloat v = (float)\t    TIFFExtractData(tif, dir->tdir_type, dir->tdir_offset);\tTIFFCvtIEEEFloatToNative(tif, 1, &v);#else\tfloat v;\t\tuint32 l = (uint32)\t    TIFFExtractData(tif, dir->tdir_type, dir->tdir_offset);\tv = * (float *) &l;\tTIFFCvtIEEEFloatToNative(tif, 1, &v);#endif\treturn (v);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*TIFFOpen(const char* name, const char* mode){\tstatic const char module[] = \"TIFFOpen\";\tint m, fd;\tm = _TIFFgetMode(mode, module);\tif (m == -1)\t\treturn ((TIFF*)0);        if (m&O_TRUNC){                                fd = creat((char *)  name, 0666,\t\t    \"alq = 128\", \"deq = 64\", \"mbc = 32\",\t\t    \"fop = tef\");\t} else if (m&O_RDWR) {\t\tfd = open(name, m, 0666,\t\t    \"deq = 64\", \"mbc = 32\", \"fop = tef\", \"ctx = stm\");\t} else\t\tfd = open(name, m, 0666, \"mbc = 32\", \"ctx = stm\");\tif (fd < 0) {\t\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\t\treturn ((TIFF*)0);\t}\treturn (TIFFFdOpen(fd, name, mode));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void TIFF_SetSample( unsigned char * pabyData, int nPixelBytes, int nSampleFormat,                 double dfValue ){    if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 1 )    {        *pabyData = (unsigned char) MAX(0,MIN(255,dfValue));    }    else if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 2 )    {        *((uint16 *)pabyData) = (uint16) MAX(0,MIN(65535,dfValue));    }    else if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 4 )    {        *((uint32 *)pabyData) = (uint32) dfValue;    }    else if( nSampleFormat == SAMPLEFORMAT_INT && nPixelBytes == 2 )    {        *((int16 *)pabyData) = (int16) MAX(-32768,MIN(32767,dfValue));    }    else if( nSampleFormat == SAMPLEFORMAT_INT && nPixelBytes == 32 )    {        *((int32 *)pabyData) = (int32) dfValue;    }    else if( nSampleFormat == SAMPLEFORMAT_IEEEFP && nPixelBytes == 4 )    {        *((float *)pabyData) = (float) dfValue;    }    else if( nSampleFormat == SAMPLEFORMAT_IEEEFP && nPixelBytes == 8 )    {        *((double *)pabyData) = dfValue;    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static inttiffcvt(TIFF* in, TIFF* out){\tuint32 width, height;\t\t\tuint32* raster;\t\t\t\tuint16 shortv;\tfloat floatv;\tchar *stringv;\tuint32 longv;\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width);\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &height);\traster = (uint32*)_TIFFmalloc(width * height * sizeof (uint32));\tif (raster == 0) {\t\tTIFFError(TIFFFileName(in), \"No space for raster buffer\");\t\treturn (0);\t}\tif (!TIFFReadRGBAImage(in, width, height, raster, 0)) {\t\t_TIFFfree(raster);\t\treturn (0);\t}\tCopyField(TIFFTAG_SUBFILETYPE, longv);\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, height);\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\tif (compression == COMPRESSION_JPEG)\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\tCopyField(TIFFTAG_FILLORDER, shortv);\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3);\tCopyField(TIFFTAG_XRESOLUTION, floatv);\tCopyField(TIFFTAG_YRESOLUTION, floatv);\tCopyField(TIFFTAG_RESOLUTIONUNIT, shortv);\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\t{ char buf[2048];\t  char *cp = strrchr(TIFFFileName(in), '/');\t  sprintf(buf, \"YCbCr conversion of %s\", cp ? cp+1 : TIFFFileName(in));\t  TIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, buf);\t}\tTIFFSetField(out, TIFFTAG_SOFTWARE, TIFFGetVersion());\tCopyField(TIFFTAG_DOCUMENTNAME, stringv);\tTIFFSetField(out, TIFFTAG_REFERENCEBLACKWHITE, refBlackWhite);\tTIFFSetField(out, TIFFTAG_YCBCRSUBSAMPLING,\t    horizSubSampling, vertSubSampling);\tTIFFSetField(out, TIFFTAG_YCBCRPOSITIONING, YCBCRPOSITION_CENTERED);\tTIFFSetField(out, TIFFTAG_YCBCRCOEFFICIENTS, ycbcrCoeffs);\trowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\treturn (cvtRaster(out, raster, width, height));}",
        "label": 1,
        "cve": "cve-2009-2347-1"
    },
    {
        "code": "static intTIFFWriteAnyArray(TIFF* tif,    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, double* v){\tchar buf[10 * sizeof(double)];\tchar* w = buf;\tint i, status = 0;\tif (n * TIFFDataWidth(type) > sizeof buf)\t\tw = (char*) _TIFFmalloc(n * TIFFDataWidth(type));\tswitch (type) {\tcase TIFF_BYTE:\t\t{ unsigned char* bp = (unsigned char*) w;\t\t  for (i = 0; i < n; i++)\t\t\tbp[i] = (unsigned char) v[i];\t\t  dir->tdir_tag = tag;\t\t  dir->tdir_type = (short) type;\t\t  dir->tdir_count = n;\t\t  if (!TIFFWriteByteArray(tif, dir, (char*) bp))\t\t\tgoto out;\t\t}\t\tbreak;\tcase TIFF_SBYTE:\t\t{ signed char* bp = (signed char*) w;\t\t  for (i = 0; i < n; i++)\t\t\tbp[i] = (signed char) v[i];\t\t  dir->tdir_tag = tag;\t\t  dir->tdir_type = (short) type;\t\t  dir->tdir_count = n;\t\t  if (!TIFFWriteByteArray(tif, dir, (char*) bp))\t\t\tgoto out;\t\t}\t\tbreak;\tcase TIFF_SHORT:\t\t{ uint16* bp = (uint16*) w;\t\t  for (i = 0; i < n; i++)\t\t\tbp[i] = (uint16) v[i];\t\t  if (!TIFFWriteShortArray(tif, type, tag, dir, n, (uint16*)bp))\t\t\t\tgoto out;\t\t}\t\tbreak;\tcase TIFF_SSHORT:\t\t{ int16* bp = (int16*) w;\t\t  for (i = 0; i < n; i++)\t\t\tbp[i] = (int16) v[i];\t\t  if (!TIFFWriteShortArray(tif, type, tag, dir, n, (uint16*)bp))\t\t\tgoto out;\t\t}\t\tbreak;\tcase TIFF_LONG:\t\t{ uint32* bp = (uint32*) w;\t\t  for (i = 0; i < n; i++)\t\t\tbp[i] = (uint32) v[i];\t\t  if (!TIFFWriteLongArray(tif, type, tag, dir, n, bp))\t\t\tgoto out;\t\t}\t\tbreak;\tcase TIFF_SLONG:\t\t{ int32* bp = (int32*) w;\t\t  for (i = 0; i < n; i++)\t\t\tbp[i] = (int32) v[i];\t\t  if (!TIFFWriteLongArray(tif, type, tag, dir, n, (uint32*) bp))\t\t\tgoto out;\t\t}\t\tbreak;\tcase TIFF_FLOAT:\t\t{ float* bp = (float*) w;\t\t  for (i = 0; i < n; i++)\t\t\tbp[i] = (float) v[i];\t\t  if (!TIFFWriteFloatArray(tif, type, tag, dir, n, bp))\t\t\tgoto out;\t\t}\t\tbreak;\tcase TIFF_DOUBLE:\t\treturn (TIFFWriteDoubleArray(tif, type, tag, dir, n, v));\tdefault:\t\t\t\t\t\t\t\t\t\t\t\tgoto out;\t}\tstatus = 1; out:\tif (w != buf)\t\t_TIFFfree(w);\treturn (status);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tmsize_tadd_ms(tmsize_t m1, tmsize_t m2){\t\tif (m1 == 0 || m2 == 0)\t\treturn 0;\telse if (m1 > TIFF_TMSIZE_T_MAX - m2)\t\treturn 0;\treturn m1 + m2;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidResizeProc(){    Dimension w_width, w_height;    int xo, yo, ww, wh;    XEvent fake_event;    Arg args[2];    if ((xOffset == 0) && (yOffset == 0))        return;    XtSetArg(args[0], XtNwidth, &w_width);    XtSetArg(args[1], XtNheight, &w_height);    XtGetValues(shellWidget, args, 2);    ww = w_width;    wh = w_height;    XtGetValues(listWidget, args, 2);    wh -= w_height;    xo = xOffset; yo = yOffset;    if ((xOffset + ww) >= tfImageWidth)        xOffset = MAX((int) tfImageWidth - ww, 0);    if ((yOffset + wh) >= tfImageHeight)        yOffset = MAX((int) tfImageHeight - wh, 0);        if ((xo != xOffset) || (yo != yOffset)) {        fake_event.type = Expose;        fake_event.xexpose.x = fake_event.xexpose.y = 0;        fake_event.xexpose.width = tfImageWidth;        fake_event.xexpose.height = tfImageHeight;        EventProc(imageWidget, NULL, &fake_event);    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchShortPair(TIFF* tif, TIFFDirEntry* dir){\tswitch (dir->tdir_type) {\t\tcase TIFF_BYTE:\t\tcase TIFF_SBYTE:\t\t\t{\t\t\tuint8 v[4];\t\t\treturn TIFFFetchByteArray(tif, dir, v)\t\t\t\t&& TIFFSetField(tif, dir->tdir_tag, v[0], v[1]);\t\t\t}\t\tcase TIFF_SHORT:\t\tcase TIFF_SSHORT:\t\t\t{\t\t\tuint16 v[4];\t\t\treturn TIFFFetchShortArray(tif, dir, v)\t\t\t\t&& TIFFSetField(tif, dir->tdir_tag, v[0], v[1]);\t\t\t}\t\tdefault:\t\t\treturn 0;\t}}",
        "label": 1,
        "cve": "cve-2006-3459"
    },
    {
        "code": "DECLAREContigPutFunc(putRGBAAcontig8bittile){    int samplesperpixel = img->samplesperpixel;    (void) x; (void) y;    fromskew *= samplesperpixel;    while (h-- > 0) {\tUNROLL8(w, NOP,\t    *cp++ = PACK4(pp[0], pp[1], pp[2], pp[3]);\t    pp += samplesperpixel);\tcp += toskew;\tpp += fromskew;    }}",
        "label": 1,
        "cve": "cve-2015-8665"
    },
    {
        "code": "static intnextImage(void){        if (fileindex < filenum - 1)                fileindex++;        else if (tif)                return fileindex;        if (tif)                TIFFClose(tif);        tif = TIFFOpen(filelist[fileindex], \"r\");        if (tif == NULL)                return -1;        return fileindex;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidlibport_dummy_function(){        return;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidemitFont(FILE* fd){    static const char* fontPrologue[] = {\t\"/newfont 10 dict def newfont begin /FontType 3 def /FontMatrix [1\",\t\"0 0 1 0 0] def /FontBBox [0 0 512 1] def /Encoding 256 array def\",\t\"0 1 31{Encoding exch /255 put}for 120 1 255{Encoding exch /255\",\t\"put}for Encoding 37 /255 put Encoding 40 /255 put Encoding 41 /255\",\t\"put Encoding 92 /255 put /count 0 def /ls{Encoding exch count 3\",\t\"string cvs cvn put /count count 1 add def}def 32 1 36{ls}for\",\t\"38 1 39{ls}for 42 1 91{ls}for 93 1 99{ls}for /count 100\",\t\"def 100 1 119{ls}for /CharDict 5 dict def CharDict begin /white\",\t\"{dup 255 eq{pop}{1 dict begin 100 sub neg 512 exch bitshift\",\t\"/cw exch def cw 0 0 0 cw 1 setcachedevice end}ifelse}def /black\",\t\"{dup 255 eq{pop}{1 dict begin 110 sub neg 512 exch bitshift\",\t\"/cw exch def cw 0 0 0 cw 1 setcachedevice 0 0 moveto cw 0 rlineto\",\t\"0 1 rlineto cw neg 0 rlineto closepath fill end}ifelse}def /numbuild\",",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFSetDirectory(TIFF* tif, tdir_t dirn){\ttoff_t nextdir;\ttdir_t n;\tnextdir = tif->tif_header.tiff_diroff;\tfor (n = dirn; n > 0 && nextdir != 0; n--)\t\tif (!TIFFAdvanceDirectory(tif, &nextdir, NULL))\t\t\treturn (0);\ttif->tif_nextdiroff = nextdir;\t\ttif->tif_curdir = (dirn - n) - 1;\t\ttif->tif_dirnumber = 0;\treturn (TIFFReadDirectory(tif));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intLZWDecodeCompat(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s){\tstatic const char module[] = \"LZWDecodeCompat\";\tLZWCodecState *sp = DecoderState(tif);\tchar *op = (char*) op0;\tlong occ = (long) occ0;\tchar *tp;\tunsigned char *bp;\tint code, nbits;\tlong nextbits, nextdata, nbitsmask;\tcode_t *codep, *free_entp, *maxcodep, *oldcodep;\t(void) s;\tassert(sp != NULL);\t \tif ((tmsize_t) occ != occ0)\t        return (0);\t \tif (sp->dec_restart) {\t\tlong residue;\t\tcodep = sp->dec_codep;\t\tresidue = codep->length - sp->dec_restart;\t\tif (residue > occ) {\t\t\t \t\t\tsp->dec_restart += occ;\t\t\tdo {\t\t\t\tcodep = codep->next;\t\t\t} while (--residue > occ);\t\t\ttp = op + occ;\t\t\tdo {\t\t\t\t*--tp = codep->value;\t\t\t\tcodep = codep->next;\t\t\t} while (--occ);\t\t\treturn (1);\t\t}\t\t \t\top += residue;\t\tocc -= residue;\t\ttp = op;\t\tdo {\t\t\t*--tp = codep->value;\t\t\tcodep = codep->next;\t\t} while (--residue);\t\tsp->dec_restart = 0;\t}\tbp = (unsigned char *)tif->tif_rawcp;#ifdef LZW_CHECKEOS\tsp->dec_bitsleft = (((uint64)tif->tif_rawcc) << 3);#endif\tnbits = sp->lzw_nbits;\tnextdata = sp->lzw_nextdata;\tnextbits = sp->lzw_nextbits;\tnbitsmask = sp->dec_nbitsmask;\toldcodep = sp->dec_oldcodep;\tfree_entp = sp->dec_free_entp;\tmaxcodep = sp->dec_maxcodep;\twhile (occ > 0) {\t\tNextCode(tif, sp, bp, code, GetNextCodeCompat);\t\tif (code == CODE_EOI)\t\t\tbreak;\t\tif (code == CODE_CLEAR) {\t\t\tdo {\t\t\t\tfree_entp = sp->dec_codetab + CODE_FIRST;\t\t\t\t_TIFFmemset(free_entp, 0,\t\t\t\t\t    (CSIZE - CODE_FIRST) * sizeof (code_t));\t\t\t\tnbits = BITS_MIN;\t\t\t\tnbitsmask = MAXCODE(BITS_MIN);\t\t\t\tmaxcodep = sp->dec_codetab + nbitsmask;\t\t\t\tNextCode(tif, sp, bp, code, GetNextCodeCompat);\t\t\t} while (code == CODE_CLEAR);\t \t\t\tif (code == CODE_EOI)\t\t\t\tbreak;\t\t\tif (code > CODE_CLEAR) {\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\t\t\"LZWDecode: Corrupted LZW table at scanline %d\",\t\t\t\t\t     tif->tif_row);\t\t\t\treturn (0);\t\t\t}\t\t\t*op++ = (char)code;\t\t\tocc--;\t\t\toldcodep = sp->dec_codetab + code;\t\t\tcontinue;\t\t}\t\tcodep = sp->dec_codetab + code;\t\t \t\tif (free_entp < &sp->dec_codetab[0] ||\t\t    free_entp >= &sp->dec_codetab[CSIZE]) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"Corrupted LZW table at scanline %d\", tif->tif_row);\t\t\treturn (0);\t\t}\t\tfree_entp->next = oldcodep;\t\tif (free_entp->next < &sp->dec_codetab[0] ||\t\t    free_entp->next >= &sp->dec_codetab[CSIZE]) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"Corrupted LZW table at scanline %d\", tif->tif_row);\t\t\treturn (0);\t\t}\t\tfree_entp->firstchar = free_entp->next->firstchar;\t\tfree_entp->length = free_entp->next->length+1;\t\tfree_entp->value = (codep < free_entp) ?\t\t    codep->firstchar : free_entp->firstchar;\t\tif (++free_entp > maxcodep) {\t\t\tif (++nbits > BITS_MAX)\t\t \t\t\t\tnbits = BITS_MAX;\t\t\tnbitsmask = MAXCODE(nbits);\t\t\tmaxcodep = sp->dec_codetab + nbitsmask;\t\t}\t\toldcodep = codep;\t\tif (code >= 256) {\t\t\t \t\t\tif(codep->length == 0) {\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t    \"Wrong length of decoded \"\t\t\t\t    \"string: data probably corrupted at scanline %d\",\t\t\t\t    tif->tif_row);\t\t\t\treturn (0);\t\t\t}\t\t\tif (codep->length > occ) {\t\t\t\t \t\t\t\tsp->dec_codep = codep;\t\t\t\tdo {\t\t\t\t\tcodep = codep->next;\t\t\t\t} while (codep->length > occ);\t\t\t\tsp->dec_restart = occ;\t\t\t\ttp = op + occ;\t\t\t\tdo  {\t\t\t\t\t*--tp = codep->value;\t\t\t\t\tcodep = codep->next;\t\t\t\t}  while (--occ);\t\t\t\tbreak;\t\t\t}\t\t\tassert(occ >= codep->length);\t\t\top += codep->length;\t\t\tocc -= codep->length;\t\t\ttp = op;\t\t\tdo {\t\t\t\t*--tp = codep->value;\t\t\t} while( (codep = codep->next) != NULL );\t\t} else {\t\t\t*op++ = (char)code;\t\t\tocc--;\t\t}\t}\ttif->tif_rawcc -= (tmsize_t)( (uint8*) bp - tif->tif_rawcp );\ttif->tif_rawcp = (uint8*) bp;\tsp->lzw_nbits = (unsigned short)nbits;\tsp->lzw_nextdata = nextdata;\tsp->lzw_nextbits = nextbits;\tsp->dec_nbitsmask = nbitsmask;\tsp->dec_oldcodep = oldcodep;\tsp->dec_free_entp = free_entp;\tsp->dec_maxcodep = maxcodep;\tif (occ > 0) {#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\"Not enough data at scanline %d (short %I64d bytes)\",\t\t\t     tif->tif_row, (unsigned __int64) occ);#else\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\"Not enough data at scanline %d (short %llu bytes)\",\t\t\t     tif->tif_row, (unsigned long long) occ);#endif\t\treturn (0);\t}\treturn (1);}",
        "label": 1,
        "cve": "CVE-2018-8905"
    },
    {
        "code": "INLINE static voiddtoieee(double *dp){\tdouble_t num;\tdouble x;\tint exp;\tnum.d = *dp;\tif (!num.d) {\t\t\t\t\tnum.l[0] = num.l[1] = 0;\t\treturn;\t}\tif (num.d < 0) {\t\t\t\tnum.d = -num.d;\t\tnum.ieee.sign = 1;\t} else {\t\tnum.ieee.sign = 0;\t}\t\tx = frexp(num.d, &exp);\t\tif (exp < -1022) {\t\t\t\tx = ldexp(x, -1023-exp);\t\texp = 0;\t} else if (exp > 1023) {\t\t\tx = 0;\t\texp = 2047;\t} else {\t\t\t\t\tx *= 2;\t\tx -= 1;\t\texp += 1022; \t}\tnum.ieee.exp = exp;\tx *= (double) (1<<20);\tnum.ieee.mant = (long) x;\tx -= (double) num.ieee.mant;\tnum.ieee.mant2 = (long) (x*((double) (1<<16)*(double) (1<<16)));\tif (!(num.ieee.mant || num.ieee.exp || num.ieee.mant2)) {\t\t\t\tnum.ieee.sign = 0;\t}\t((double_t*)dp)->ieee = num.ieee;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*TIFFFdOpen(int fd, const char* name, const char* mode){\tTIFF* tif;\ttif = TIFFClientOpen(name, mode,\t    (thandle_t) fd,\t    _tiffReadProc, _tiffWriteProc,\t    _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\t    _tiffMapProc, _tiffUnmapProc);\tif (tif)\t\ttif->tif_fd = fd;\treturn (tif);}",
        "label": 1,
        "cve": "CVE-2018-10801"
    },
    {
        "code": "static tsize_t_tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size){\tlong r;\tr = Fwrite((int) fd, size, buf);\tif (r < 0) {\t\terrno = (int)-r;\t\tr = -1;\t}\treturn r;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidShowStrip(tstrip_t strip, unsigned char* pp, uint32 nrow, tsize_t scanline){\tregister tsize_t cc;\tprintf(\"Strip %lu:\\n\", (unsigned long) strip);\twhile (nrow-- > 0) {\t\tfor (cc = 0; cc < scanline; cc++) {\t\t\tprintf(\" %02x\", *pp++);\t\t\tif (((cc+1) % 24) == 0)\t\t\t\tputchar('\\n');\t\t}\t\tputchar('\\n');\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "staticvoid TIFF_DownSample_Subsampled( unsigned char *pabySrcTile, int nSample,                                 uint32 nBlockXSize, uint32 nBlockYSize,                                 unsigned char * pabyOTile,                                 uint32 nOBlockXSize, uint32 nOBlockYSize,                                 uint32 nTXOff, uint32 nTYOff, int nOMult,                                 const char *pszResampling,                                 int nHorSubsampling, int nVerSubsampling ){        int nSampleBlockSize;    int nSourceSampleRowSize;    int nDestSampleRowSize;    uint32  nSourceX, nSourceY;    uint32  nSourceXSec, nSourceYSec;    uint32  nSourceXSecEnd, nSourceYSecEnd;    uint32  nDestX, nDestY;    int nSampleOffsetInSampleBlock;    unsigned int nCummulator;    unsigned int nCummulatorCount;    nSampleBlockSize = nHorSubsampling * nVerSubsampling + 2;    nSourceSampleRowSize =         ( ( nBlockXSize + nHorSubsampling - 1 ) / nHorSubsampling ) * nSampleBlockSize;    nDestSampleRowSize =         ( ( nOBlockXSize + nHorSubsampling - 1 ) / nHorSubsampling ) * nSampleBlockSize;    if( strncmp(pszResampling,\"nearest\",4) == 0        || strncmp(pszResampling,\"NEAR\",4) == 0 )    {    \tif( nSample == 0 )        {            for( nSourceY = 0, nDestY = nTYOff;                  nSourceY < nBlockYSize;                  nSourceY += nOMult, nDestY ++)            {                if( nDestY >= nOBlockYSize )                    break;                for( nSourceX = 0, nDestX = nTXOff;                      nSourceX < nBlockXSize;                      nSourceX += nOMult, nDestX ++)                {                    if( nDestX >= nOBlockXSize )                        break;                    * ( pabyOTile + ( nDestY / nVerSubsampling ) * nDestSampleRowSize                        + ( nDestY % nVerSubsampling ) * nHorSubsampling                        + ( nDestX / nHorSubsampling ) * nSampleBlockSize                        + ( nDestX % nHorSubsampling ) ) =                        * ( pabySrcTile + ( nSourceY / nVerSubsampling ) * nSourceSampleRowSize                            + ( nSourceY % nVerSubsampling ) * nHorSubsampling                            + ( nSourceX / nHorSubsampling ) * nSampleBlockSize                            + ( nSourceX % nHorSubsampling ) );                }            }        }        else        {            nSampleOffsetInSampleBlock = nHorSubsampling * nVerSubsampling + nSample - 1;            for( nSourceY = 0, nDestY = ( nTYOff / nVerSubsampling );                  nSourceY < ( nBlockYSize / nVerSubsampling );                 nSourceY += nOMult, nDestY ++)            {                if( nDestY*nVerSubsampling >= nOBlockYSize )                    break;            \tfor( nSourceX = 0, nDestX = ( nTXOff / nHorSubsampling );                      nSourceX < ( nBlockXSize / nHorSubsampling );                     nSourceX += nOMult, nDestX ++)                {                    if( nDestX*nHorSubsampling >= nOBlockXSize )                        break;                    * ( pabyOTile + nDestY * nDestSampleRowSize                        + nDestX * nSampleBlockSize                        + nSampleOffsetInSampleBlock ) =                    \t* ( pabySrcTile + nSourceY * nSourceSampleRowSize                            + nSourceX * nSampleBlockSize                            + nSampleOffsetInSampleBlock );                }            }        }    }    else if( strncmp(pszResampling,\"averag\",6) == 0             || strncmp(pszResampling,\"AVERAG\",6) == 0 )    {    \tif( nSample == 0 )        {            for( nSourceY = 0, nDestY = nTYOff; nSourceY < nBlockYSize; nSourceY += nOMult, nDestY ++)            {                if( nDestY >= nOBlockYSize )                    break;                for( nSourceX = 0, nDestX = nTXOff; nSourceX < nBlockXSize; nSourceX += nOMult, nDestX ++)                {                    if( nDestX >= nOBlockXSize )                        break;                    nSourceXSecEnd = nSourceX + nOMult;                    if( nSourceXSecEnd > nBlockXSize )                        nSourceXSecEnd = nBlockXSize;                    nSourceYSecEnd = nSourceY + nOMult;                    if( nSourceYSecEnd > nBlockYSize )                        nSourceYSecEnd = nBlockYSize;                    nCummulator = 0;                    for( nSourceYSec = nSourceY; nSourceYSec < nSourceYSecEnd; nSourceYSec ++)                    {                        for( nSourceXSec = nSourceX; nSourceXSec < nSourceXSecEnd; nSourceXSec ++)                        {                            nCummulator += * ( pabySrcTile + ( nSourceYSec / nVerSubsampling ) * nSourceSampleRowSize                                               + ( nSourceYSec % nVerSubsampling ) * nHorSubsampling                                               + ( nSourceXSec / nHorSubsampling ) * nSampleBlockSize                                               + ( nSourceXSec % nHorSubsampling ) );                        }                    }                    nCummulatorCount = ( nSourceXSecEnd - nSourceX ) * ( nSourceYSecEnd - nSourceY );                    * ( pabyOTile + ( nDestY / nVerSubsampling ) * nDestSampleRowSize                        + ( nDestY % nVerSubsampling ) * nHorSubsampling                        + ( nDestX / nHorSubsampling ) * nSampleBlockSize                        + ( nDestX % nHorSubsampling ) ) =                        ( ( nCummulator + ( nCummulatorCount >> 1 ) ) / nCummulatorCount );                }            }        }        else        {            nSampleOffsetInSampleBlock = nHorSubsampling * nVerSubsampling + nSample - 1;            for( nSourceY = 0, nDestY = ( nTYOff / nVerSubsampling ); nSourceY < ( nBlockYSize / nVerSubsampling );                 nSourceY += nOMult, nDestY ++)            {                if( nDestY*nVerSubsampling >= nOBlockYSize )                    break;                for( nSourceX = 0, nDestX = ( nTXOff / nHorSubsampling ); nSourceX < ( nBlockXSize / nHorSubsampling );                     nSourceX += nOMult, nDestX ++)                {                    if( nDestX*nHorSubsampling >= nOBlockXSize )                        break;                    nSourceXSecEnd = nSourceX + nOMult;                    if( nSourceXSecEnd > ( nBlockXSize / nHorSubsampling ) )                        nSourceXSecEnd = ( nBlockXSize / nHorSubsampling );                    nSourceYSecEnd = nSourceY + nOMult;                    if( nSourceYSecEnd > ( nBlockYSize / nVerSubsampling ) )                        nSourceYSecEnd = ( nBlockYSize / nVerSubsampling );                    nCummulator = 0;                    for( nSourceYSec = nSourceY; nSourceYSec < nSourceYSecEnd; nSourceYSec ++)                    {                        for( nSourceXSec = nSourceX; nSourceXSec < nSourceXSecEnd; nSourceXSec ++)                        {                            nCummulator += * ( pabySrcTile + nSourceYSec * nSourceSampleRowSize                                               + nSourceXSec * nSampleBlockSize                                               + nSampleOffsetInSampleBlock );                        }                    }                    nCummulatorCount = ( nSourceXSecEnd - nSourceX ) * ( nSourceYSecEnd - nSourceY );                    * ( pabyOTile + nDestY * nDestSampleRowSize                        + nDestX * nSampleBlockSize                        + nSampleOffsetInSampleBlock ) =                        ( ( nCummulator + ( nCummulatorCount >> 1 ) ) / nCummulatorCount );                }            }        }    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tmsize_t t2pWriteFile(TIFF *tif, tdata_t data, tmsize_t size){\tthandle_t client = TIFFClientdata(tif);\tTIFFReadWriteProc proc = TIFFGetWriteProc(tif);\tif (proc)\t\treturn proc(client, data, size);\treturn -1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int_TIFFmemcmp(const void* p1, const void* p2, tmsize_t c){\treturn (memcmp(p1, p2, (size_t) c));}",
        "label": 1,
        "cve": "CVE-2018-17000"
    },
    {
        "code": "DECLAREwriteFunc(writeBufferToSeparateTiles){\tuint32 imagew = TIFFScanlineSize(out);\ttsize_t tilew  = TIFFTileRowSize(out);\tuint32 iimagew = TIFFRasterScanlineSize(out);\tint iskew = iimagew - tilew*spp;\ttsize_t tilesize = TIFFTileSize(out);\ttdata_t obuf;\tuint8* bufp = (uint8*) buf;\tuint32 tl, tw;\tuint32 row;\tuint16 bps = 0, bytes_per_sample;\tobuf = _TIFFmalloc(TIFFTileSize(out));\tif (obuf == NULL)\t\treturn 0;\t_TIFFmemset(obuf, 0, tilesize);\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\t(void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);        if( bps == 0 )        {            TIFFError(TIFFFileName(out), \"Error, cannot read BitsPerSample\");            _TIFFfree(obuf);            return 0;        }        if( (bps % 8) != 0 )        {            TIFFError(TIFFFileName(out), \"Error, cannot handle BitsPerSample that is not a multiple of 8\");            _TIFFfree(obuf);            return 0;        }\tbytes_per_sample = bps/8;\tfor (row = 0; row < imagelength; row += tl) {\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\t\tuint32 colb = 0;\t\tuint32 col;\t\tfor (col = 0; col < imagewidth; col += tw) {\t\t\ttsample_t s;\t\t\tfor (s = 0; s < spp; s++) {\t\t\t\t\t\t\t\tif (colb + tilew > imagew) {\t\t\t\t\tuint32 width = (imagew - colb);\t\t\t\t\tint oskew = tilew - width;\t\t\t\t\tcpContigBufToSeparateBuf(obuf,\t\t\t\t\t    bufp + (colb*spp) + s,\t\t\t\t\t    nrow, width/bytes_per_sample,\t\t\t\t\t    oskew, (oskew*spp)+iskew, spp,\t\t\t\t\t    bytes_per_sample);\t\t\t\t} else\t\t\t\t\tcpContigBufToSeparateBuf(obuf,\t\t\t\t\t    bufp + (colb*spp) + s,\t\t\t\t\t    nrow, tilewidth,\t\t\t\t\t    0, iskew, spp,\t\t\t\t\t    bytes_per_sample);\t\t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, s) < 0) {\t\t\t\t\tTIFFError(TIFFFileName(out),\t\t\t\t\t    \"Error, can't write tile at %lu %lu \"\t\t\t\t\t    \"sample %lu\",\t\t\t\t\t    (unsigned long) col,\t\t\t\t\t    (unsigned long) row,\t\t\t\t\t    (unsigned long) s);\t\t\t\t\t_TIFFfree(obuf);\t\t\t\t\treturn 0;\t\t\t\t}\t\t\t}\t\t\tcolb += tilew;\t\t}\t\tbufp += nrow * iimagew;\t}\t_TIFFfree(obuf);\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFSwabArrayOfDouble(double* dp, tmsize_t n){\tregister unsigned char *cp;\tregister unsigned char t;\tassert(sizeof(double)==8);\t\twhile (n-- > 0) {\t\tcp = (unsigned char *)dp;\t\tt = cp[7]; cp[7] = cp[0]; cp[0] = t;\t\tt = cp[6]; cp[6] = cp[1]; cp[1] = t;\t\tt = cp[5]; cp[5] = cp[2]; cp[2] = t;\t\tt = cp[4]; cp[4] = cp[3]; cp[3] = t;\t\tdp++;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidWriteTable(FILE* fd, const TIFFFaxTabEnt* T, int Size, const char* name){    int i;    char* sep;    fprintf(fd, \"%s %s TIFFFaxTabEnt %s[%d] = {\",\tstorage_class, const_class, name, Size);    if (packoutput) {\tsep = \"\\n\";\tfor (i = 0; i < Size; i++) {\t    fprintf(fd, \"%s%s%d,%d,%d%s\",\t\tsep, prebrace, T->State, T->Width, (int) T->Param, postbrace);\t    if (((i+1) % 10) == 0)\t\t    sep = \",\\n\";\t    else\t\t    sep = \",\";\t    T++;\t}    } else {\tsep = \"\\n \";\tfor (i = 0; i < Size; i++) {\t    fprintf(fd, \"%s%s%3d,%3d,%4d%s\",\t\tsep, prebrace, T->State, T->Width, (int) T->Param, postbrace);\t    if (((i+1) % 6) == 0)\t\t    sep = \",\\n \";\t    else\t\t    sep = \",\";\t    T++;\t}    }    fprintf(fd, \"\\n};\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tsize_t_tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size){\treturn (write((int) fd, buf, size));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFSwabShort(uint16* wp){\tregister unsigned char* cp = (unsigned char*) wp;\tunsigned char t;\tassert(sizeof(uint16)==2);\tt = cp[1]; cp[1] = cp[0]; cp[0] = t;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": " static voidfpAcc(TIFF* tif, uint8* cp0, tmsize_t cc){\ttmsize_t stride = PredictorState(tif)->stride;\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\ttmsize_t wc = cc / bps;\ttmsize_t count = cc;\tuint8 *cp = (uint8 *) cp0;\tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);\tassert((cc%(bps*stride))==0);\tif (!tmp)\t\treturn;\twhile (count > stride) {\t\tREPEAT4(stride, cp[stride] =                        (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++)\t\tcount -= stride;\t}\t_TIFFmemcpy(tmp, cp0, cc);\tcp = (uint8 *) cp0;\tfor (count = 0; count < wc; count++) {\t\tuint32 byte;\t\tfor (byte = 0; byte < bps; byte++) {\t\t\t#if WORDS_BIGENDIAN\t\t\tcp[bps * count + byte] = tmp[byte * wc + count];\t\t\t#else\t\t\tcp[bps * count + byte] =\t\t\t\ttmp[(bps - byte - 1) * wc + count];\t\t\t#endif\t\t}\t}\t_TIFFfree(tmp);}",
        "label": 1,
        "cve": "cve-2016-3622"
    },
    {
        "code": "static voidprocessZIPOptions(char* cp){\tif ( (cp = strchr(cp, ':')) ) {\t\tdo {\t\t\tcp++;\t\t\tif (isdigit((int)*cp))\t\t\t\tdefpredictor = atoi(cp);\t\t\telse if (*cp == 'p')\t\t\t\tdefpreset = atoi(++cp);\t\t\telse\t\t\t\tusage();\t\t} while( (cp = strchr(cp, ':')) );\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intLZWEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s){\tregister LZWCodecState *sp = EncoderState(tif);\tregister long fcode;\tregister hash_t *hp;\tregister int h, c;\thcode_t ent;\tlong disp;\tlong incount, outcount, checkpoint;\tunsigned long nextdata;        long nextbits;\tint free_ent, maxcode, nbits;\tuint8* op;\tuint8* limit;\t(void) s;\tif (sp == NULL)\t\treturn (0);        assert(sp->enc_hashtab != NULL);\t\tincount = sp->enc_incount;\toutcount = sp->enc_outcount;\tcheckpoint = sp->enc_checkpoint;\tnextdata = sp->lzw_nextdata;\tnextbits = sp->lzw_nextbits;\tfree_ent = sp->lzw_free_ent;\tmaxcode = sp->lzw_maxcode;\tnbits = sp->lzw_nbits;\top = tif->tif_rawcp;\tlimit = sp->enc_rawlimit;\tent = (hcode_t)sp->enc_oldcode;\tif (ent == (hcode_t) -1 && cc > 0) {\t\t\t\tPutNextCode(op, CODE_CLEAR);\t\tent = *bp++; cc--; incount++;\t}\twhile (cc > 0) {\t\tc = *bp++; cc--; incount++;\t\tfcode = ((long)c << BITS_MAX) + ent;\t\th = (c << HSHIFT) ^ ent;\t#ifdef _WINDOWS\t\t\t\tif (h >= HSIZE)\t\t\th -= HSIZE;#endif\t\thp = &sp->enc_hashtab[h];\t\tif (hp->hash == fcode) {\t\t\tent = hp->code;\t\t\tcontinue;\t\t}\t\tif (hp->hash >= 0) {\t\t\t\t\t\tdisp = HSIZE - h;\t\t\tif (h == 0)\t\t\t\tdisp = 1;\t\t\tdo {\t\t\t\t\t\t\t\tif ((h -= disp) < 0)\t\t\t\t\th += HSIZE;\t\t\t\thp = &sp->enc_hashtab[h];\t\t\t\tif (hp->hash == fcode) {\t\t\t\t\tent = hp->code;\t\t\t\t\tgoto hit;\t\t\t\t}\t\t\t} while (hp->hash >= 0);\t\t}\t\t\t\t\t\tif (op > limit) {\t\t\ttif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata);\t\t\tTIFFFlushData1(tif);\t\t\top = tif->tif_rawdata;\t\t}\t\tPutNextCode(op, ent);\t\tent = (hcode_t)c;\t\thp->code = (hcode_t)(free_ent++);\t\thp->hash = fcode;\t\tif (free_ent == CODE_MAX-1) {\t\t\t\t\t\tcl_hash(sp);\t\t\tsp->enc_ratio = 0;\t\t\tincount = 0;\t\t\toutcount = 0;\t\t\tfree_ent = CODE_FIRST;\t\t\tPutNextCode(op, CODE_CLEAR);\t\t\tnbits = BITS_MIN;\t\t\tmaxcode = MAXCODE(BITS_MIN);\t\t} else {\t\t\t\t\t\tif (free_ent > maxcode) {\t\t\t\tnbits++;\t\t\t\tassert(nbits <= BITS_MAX);\t\t\t\tmaxcode = (int) MAXCODE(nbits);\t\t\t} else if (incount >= checkpoint) {\t\t\t\tlong rat;\t\t\t\t\t\t\t\tcheckpoint = incount+CHECK_GAP;\t\t\t\tCALCRATIO(sp, rat);\t\t\t\tif (rat <= sp->enc_ratio) {\t\t\t\t\tcl_hash(sp);\t\t\t\t\tsp->enc_ratio = 0;\t\t\t\t\tincount = 0;\t\t\t\t\toutcount = 0;\t\t\t\t\tfree_ent = CODE_FIRST;\t\t\t\t\tPutNextCode(op, CODE_CLEAR);\t\t\t\t\tnbits = BITS_MIN;\t\t\t\t\tmaxcode = MAXCODE(BITS_MIN);\t\t\t\t} else\t\t\t\t\tsp->enc_ratio = rat;\t\t\t}\t\t}\thit:\t\t;\t}\t\tsp->enc_incount = incount;\tsp->enc_outcount = outcount;\tsp->enc_checkpoint = checkpoint;\tsp->enc_oldcode = ent;\tsp->lzw_nextdata = nextdata;\tsp->lzw_nextbits = nextbits;\tsp->lzw_free_ent = (unsigned short)free_ent;\tsp->lzw_maxcode = (unsigned short)maxcode;\tsp->lzw_nbits = (unsigned short)nbits;\ttif->tif_rawcp = op;\treturn (1);}",
        "label": 1,
        "cve": "cve-2017-5563"
    },
    {
        "code": "tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){\tuint16 edge=0;\ttsize_t written=0;\tunsigned char* buffer=NULL;\ttsize_t bufferoffset=0;\tunsigned char* samplebuffer=NULL;\ttsize_t samplebufferoffset=0;\ttsize_t read=0;\tuint16 i=0;\tttile_t tilecount=0;\t \tttile_t septilecount=0;\ttsize_t septilesize=0;#ifdef JPEG_SUPPORT\tunsigned char* jpt;\tfloat* xfloatp;\tuint32 xuint32=0;#endif\t \tif (t2p->t2p_error != T2P_ERR_OK)\t\treturn(0);\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\tif( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\t\t|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)#endif\t)\t){#ifdef CCITT_SUPPORT\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\t\tif(buffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate %lu bytes of memory \"                                        \"for t2p_readwrite_pdf_image_tile, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\t\t\t}\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\t\t\t_TIFFfree(buffer);\t\t\treturn(t2p->tiff_datasize);\t\t}#endif#ifdef ZIP_SUPPORT\t\tif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\t\tif(buffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate %lu bytes of memory \"                                        \"for t2p_readwrite_pdf_image_tile, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\t\t\t}\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\t\t\t_TIFFfree(buffer);\t\t\treturn(t2p->tiff_datasize);\t\t}#endif#ifdef OJPEG_SUPPORT\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG){\t\t\tif(! t2p->pdf_ojpegdata){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"No support for OJPEG image %s with \"                                        \"bad tables\", \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tbuffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\t\tif(buffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate %lu bytes of memory \"                                        \"for t2p_readwrite_pdf_image, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\t\t\tif(edge!=0){\t\t\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\t\t\t\t\tbuffer[7]=\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;\t\t\t\t\tbuffer[8]=\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;\t\t\t\t}\t\t\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\t\t\t\t\tbuffer[9]=\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;\t\t\t\t\tbuffer[10]=\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;\t\t\t\t}\t\t\t}\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\t\t\tbufferoffset+=TIFFReadRawTile(input, \t\t\t\t\ttile, \t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \t\t\t\t\t-1);\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xff;\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xd9;\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\t\t\t_TIFFfree(buffer);\t\t\treturn(bufferoffset);\t\t}#endif#ifdef JPEG_SUPPORT\t\tif(t2p->tiff_compression == COMPRESSION_JPEG){\t\t\tunsigned char table_end[2];\t\t\tuint32 count = 0;\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\t\tif(buffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \"                                        \"for t2p_readwrite_pdf_image_tile, %s\",                                           (TIFF_SIZE_T) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\t\t\t\tif (count > 0) {\t\t\t\t\t_TIFFmemcpy(buffer, jpt, count);\t\t\t\t\tbufferoffset += count - 2;\t\t\t\t\ttable_end[0] = buffer[bufferoffset-2];\t\t\t\t\ttable_end[1] = buffer[bufferoffset-1];\t\t\t\t}\t\t\t\tif (count > 0) {\t\t\t\t\txuint32 = bufferoffset;\t\t\t\t\tbufferoffset += TIFFReadRawTile(\t\t\t\t\t\tinput, \t\t\t\t\t\ttile, \t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset-2]), \t\t\t\t\t\t-1);\t\t\t\t\t\tbuffer[xuint32-2]=table_end[0];\t\t\t\t\t\tbuffer[xuint32-1]=table_end[1];\t\t\t\t} else {\t\t\t\t\tbufferoffset += TIFFReadRawTile(\t\t\t\t\t\tinput, \t\t\t\t\t\ttile, \t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \t\t\t\t\t\t-1);\t\t\t\t}\t\t\t}\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\t\t\t_TIFFfree(buffer);\t\t\treturn(bufferoffset);\t\t}#endif\t\t(void)0;\t}\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\tif(buffer==NULL){\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\"Can't allocate %lu bytes of memory for \"                                \"t2p_readwrite_pdf_image_tile, %s\", \t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\tTIFFFileName(input));\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\treturn(0);\t\t}\t\tread = TIFFReadEncodedTile(\t\t\tinput, \t\t\ttile, \t\t\t(tdata_t) &buffer[bufferoffset], \t\t\tt2p->tiff_datasize);\t\tif(read==-1){\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\"Error on decoding tile %u of %s\", \t\t\t\ttile, \t\t\t\tTIFFFileName(input));\t\t\t_TIFFfree(buffer);\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\t\t\treturn(0);\t\t}\t} else {\t\tif(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\t\t\tseptilesize=TIFFTileSize(input);\t\t\tseptilecount=TIFFNumberOfTiles(input);\t\t\t \t\t\ttilecount=septilecount/t2p->tiff_samplesperpixel;\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\t\tif(buffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate %lu bytes of memory \"                                        \"for t2p_readwrite_pdf_image_tile, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\t\tif(samplebuffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate %lu bytes of memory \"                                        \"for t2p_readwrite_pdf_image_tile, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tsamplebufferoffset=0;\t\t\tfor(i=0;i<t2p->tiff_samplesperpixel;i++){\t\t\t\tread = \t\t\t\t\tTIFFReadEncodedTile(input, \t\t\t\t\t\ttile + i*tilecount, \t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \t\t\t\t\t\tseptilesize);\t\t\t\tif(read==-1){\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\t\"Error on decoding tile %u of %s\", \t\t\t\t\t\ttile + i*tilecount, \t\t\t\t\t\tTIFFFileName(input));\t\t\t\t\t\t_TIFFfree(samplebuffer);\t\t\t\t\t\t_TIFFfree(buffer);\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t\tsamplebufferoffset+=read;\t\t\t}\t\t\tt2p_sample_planar_separate_to_contig(\t\t\t\tt2p,\t\t\t\t&(buffer[bufferoffset]),\t\t\t\tsamplebuffer, \t\t\t\tsamplebufferoffset); \t\t\tbufferoffset+=samplebufferoffset;\t\t\t_TIFFfree(samplebuffer);\t\t}\t\tif(buffer==NULL){\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\t\tif(buffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate %lu bytes of memory \"                                        \"for t2p_readwrite_pdf_image_tile, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tread = TIFFReadEncodedTile(\t\t\t\tinput, \t\t\t\ttile, \t\t\t\t(tdata_t) &buffer[bufferoffset], \t\t\t\tt2p->tiff_datasize);\t\t\tif(read==-1){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Error on decoding tile %u of %s\", \t\t\t\t\ttile, \t\t\t\t\tTIFFFileName(input));\t\t\t\t_TIFFfree(buffer);\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t}\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\t\t\t\t(tdata_t)buffer, \t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\t\t}\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\t\t\t\t(tdata_t)buffer, \t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\t\t}\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\"No support for YCbCr to RGB in tile for %s\", \t\t\t\tTIFFFileName(input));\t\t\t_TIFFfree(buffer);\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\treturn(0);\t\t}\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\t\t\t\t(tdata_t)buffer, \t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\t\t}\t}\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){\t\tt2p_tile_collapse_left(\t\t\tbuffer, \t\t\tTIFFTileRowSize(input),\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth, \t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\t}\tt2p_disable(output);\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\t\tTIFFSetField(\t\t\toutput, \t\t\tTIFFTAG_IMAGEWIDTH, \t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\t} else {\t\tTIFFSetField(\t\t\toutput, \t\t\tTIFFTAG_IMAGEWIDTH, \t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\t}\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\t\tTIFFSetField(\t\t\toutput, \t\t\tTIFFTAG_IMAGELENGTH, \t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\t\tTIFFSetField(\t\t\toutput, \t\t\tTIFFTAG_ROWSPERSTRIP, \t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\t} else {\t\tTIFFSetField(\t\t\toutput, \t\t\tTIFFTAG_IMAGELENGTH, \t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\t\tTIFFSetField(\t\t\toutput, \t\t\tTIFFTAG_ROWSPERSTRIP, \t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\t}\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\tswitch(t2p->pdf_compression){\tcase T2P_COMPRESS_NONE:\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\t\tbreak;#ifdef CCITT_SUPPORT\tcase T2P_COMPRESS_G4:\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\t\tbreak;#endif#ifdef JPEG_SUPPORT\tcase T2P_COMPRESS_JPEG:\t\tif (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\t\t\tuint16 hor = 0, ver = 0;\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {\t\t\t\tif (hor != 0 && ver != 0) {\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\t\t\t\t}\t\t\t}\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\t\t\t}\t\t}\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0);  \t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\t\t\t} else {\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\t\t\t}\t\t}\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\t\t\t(void)0;\t\t}\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\t\t\t(void)0;\t\t}\t\tif(t2p->pdf_defaultcompressionquality != 0){\t\t\tTIFFSetField(output, \t\t\t\tTIFFTAG_JPEGQUALITY, \t\t\t\tt2p->pdf_defaultcompressionquality);\t\t}\t\tbreak;#endif#ifdef ZIP_SUPPORT\tcase T2P_COMPRESS_ZIP:\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\t\t\tTIFFSetField(output, \t\t\t\tTIFFTAG_PREDICTOR, \t\t\t\tt2p->pdf_defaultcompressionquality % 100);\t\t}\t\tif(t2p->pdf_defaultcompressionquality/100 != 0){\t\t\tTIFFSetField(output, \t\t\t\tTIFFTAG_ZIPQUALITY, \t\t\t\t(t2p->pdf_defaultcompressionquality / 100));\t\t}\t\tbreak;#endif\tdefault:\t\tbreak;\t}\tt2p_enable(output);\tt2p->outputwritten = 0;\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,\t\t\t\t\t     TIFFStripSize(output)); \tif (buffer != NULL) {\t\t_TIFFfree(buffer);\t\tbuffer = NULL;\t}\tif (bufferoffset == -1) {\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t  \"Error writing encoded tile to output PDF %s\", \t\t\t  TIFFFileName(output));\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn(0);\t}\t\twritten = t2p->outputwritten;\t\treturn(written);}",
        "label": 1,
        "cve": "CVE-2016-9453"
    },
    {
        "code": "static intPredictorSetup(TIFF* tif){\tstatic const char module[] = \"PredictorSetup\";\tTIFFPredictorState* sp = PredictorState(tif);\tTIFFDirectory* td = &tif->tif_dir;\tswitch (sp->predictor)\t\t\t{\t\tcase PREDICTOR_NONE:\t\t\treturn 1;\t\tcase PREDICTOR_HORIZONTAL:\t\t\tif (td->td_bitspersample != 8\t\t\t    && td->td_bitspersample != 16\t\t\t    && td->td_bitspersample != 32) {\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t    \"Horizontal differencing \\\"Predictor\\\" not supported with %d-bit samples\",\t\t\t\t    td->td_bitspersample);\t\t\t\treturn 0;\t\t\t}\t\t\tbreak;\t\tcase PREDICTOR_FLOATINGPOINT:\t\t\tif (td->td_sampleformat != SAMPLEFORMAT_IEEEFP) {\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t    \"Floating point \\\"Predictor\\\" not supported with %d data format\",\t\t\t\t    td->td_sampleformat);\t\t\t\treturn 0;\t\t\t}                        if (td->td_bitspersample != 16                            && td->td_bitspersample != 24                            && td->td_bitspersample != 32                            && td->td_bitspersample != 64) {                                 TIFFErrorExt(tif->tif_clientdata, module,                                             \"Floating point \\\"Predictor\\\" not supported with %d-bit samples\",                                             td->td_bitspersample);\t\t\t\treturn 0;                            }\t\t\tbreak;\t\tdefault:\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"\\\"Predictor\\\" value %d not supported\",\t\t\t    sp->predictor);\t\t\treturn 0;\t}\tsp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?\t    td->td_samplesperpixel : 1);\t\tif (isTiled(tif))\t\tsp->rowsize = TIFFTileRowSize(tif);\telse\t\tsp->rowsize = TIFFScanlineSize(tif);\tif (sp->rowsize == 0)\t\treturn 0;\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type){\tswitch (type) {\tcase TIFF_SHORT:\t\tif (count == 1) {\t\t\tuint16 shortv;\t\t\tCopyField(tag, shortv);\t\t} else if (count == 2) {\t\t\tuint16 shortv1, shortv2;\t\t\tCopyField2(tag, shortv1, shortv2);\t\t} else if (count == 4) {\t\t\tuint16 *tr, *tg, *tb, *ta;\t\t\tCopyField4(tag, tr, tg, tb, ta);\t\t} else if (count == (uint16) -1) {\t\t\tuint16 shortv1;\t\t\tuint16* shortav;\t\t\tCopyField2(tag, shortv1, shortav);\t\t}\t\tbreak;\tcase TIFF_LONG:\t\t{ uint32 longv;\t\t  CopyField(tag, longv);\t\t}\t\tbreak;\tcase TIFF_RATIONAL:\t\tif (count == 1) {\t\t\tfloat floatv;\t\t\tCopyField(tag, floatv);\t\t} else if (count == (uint16) -1) {\t\t\tfloat* floatav;\t\t\tCopyField(tag, floatav);\t\t}\t\tbreak;\tcase TIFF_ASCII:\t\t{ char* stringv;\t\t  CopyField(tag, stringv);\t\t}\t\tbreak;\tcase TIFF_DOUBLE:\t\tif (count == 1) {\t\t\tdouble doublev;\t\t\tCopyField(tag, doublev);\t\t} else if (count == (uint16) -1) {\t\t\tdouble* doubleav;\t\t\tCopyField(tag, doubleav);\t\t}\t\tbreak;\tdefault:\t\tTIFFError(TIFFFileName(in),\t\t    \"Data type %d is not supported, tag %d skipped.\",\t\t    tag, type);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcreateCroppedImage(struct image_data *image, struct crop_mask *crop,                    unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr)  {  tsize_t   cropsize;  unsigned  char *read_buff = NULL;  unsigned  char *crop_buff = NULL;  unsigned  char *new_buff  = NULL;  static    tsize_t  prev_cropsize = 0;  read_buff = *read_buff_ptr;    crop_buff = read_buff;  *crop_buff_ptr = read_buff;  crop->combined_width = image->width;  crop->combined_length = image->length;  cropsize = crop->bufftotal;  crop_buff = *crop_buff_ptr;  if (!crop_buff)    {    crop_buff = (unsigned char *)_TIFFmalloc(cropsize);    *crop_buff_ptr = crop_buff;    _TIFFmemset(crop_buff, 0, cropsize);    prev_cropsize = cropsize;    }  else    {    if (prev_cropsize < cropsize)      {      new_buff = _TIFFrealloc(crop_buff, cropsize);      if (!new_buff)        {\tfree (crop_buff);        crop_buff = (unsigned char *)_TIFFmalloc(cropsize);        }      else        crop_buff = new_buff;      _TIFFmemset(crop_buff, 0, cropsize);      }    }  if (!crop_buff)    {    TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");    return (-1);    }  *crop_buff_ptr = crop_buff;  if (crop->crop_mode & CROP_INVERT)    {    switch (crop->photometric)      {            case PHOTOMETRIC_MINISWHITE:      case PHOTOMETRIC_MINISBLACK:\t   image->photometric = crop->photometric;\t   break;      case INVERT_DATA_ONLY:      case INVERT_DATA_AND_TAG:           if (invertImage(image->photometric, image->spp, image->bps,                            crop->combined_width, crop->combined_length, crop_buff))             {             TIFFError(\"createCroppedImage\",                        \"Failed to invert colorspace for image or cropped selection\");             return (-1);             }           if (crop->photometric == INVERT_DATA_AND_TAG)             {             switch (image->photometric)               {               case PHOTOMETRIC_MINISWHITE: \t            image->photometric = PHOTOMETRIC_MINISBLACK;\t            break;               case PHOTOMETRIC_MINISBLACK: \t            image->photometric = PHOTOMETRIC_MINISWHITE;\t            break;               default:\t            break;\t       }\t     }           break;      default: break;      }    }  if (crop->crop_mode & CROP_MIRROR)    {    if (mirrorImage(image->spp, image->bps, crop->mirror,                     crop->combined_width, crop->combined_length, crop_buff))      {      TIFFError(\"createCroppedImage\", \"Failed to mirror image or cropped selection %s\", \t       (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");      return (-1);      }    }  if (crop->crop_mode & CROP_ROTATE)     {    if (rotateImage(crop->rotation, image, &crop->combined_width,                     &crop->combined_length, crop_buff_ptr))      {      TIFFError(\"createCroppedImage\",                 \"Failed to rotate image or cropped selection by %d degrees\", crop->rotation);      return (-1);      }    }  if (crop_buff == read_buff)     *read_buff_ptr = NULL;      return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFReadImageIter(TIFF* tif,    uint32 rwidth, uint32 rheight, uint8* raster, int stop){    char emsg[1024];    TIFFImageIter img;    int ok;    if (TIFFImageIterBegin(&img, tif, stop, emsg)) {\t\tok = TIFFImageIterGet(&img, raster, rwidth, img.height);\tTIFFImageIterEnd(&img);    } else {\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), emsg);\tok = 0;    }    return (ok);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tdata_t_TIFFmalloc(tsize_t s){\treturn (tdata_t) GlobalAllocPtr(GHND, (DWORD) s);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(void){\tchar buf[BUFSIZ];\tint i;\tsetbuf(stderr, buf);        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\tfor (i = 0; stuff[i] != NULL; i++)\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\texit(-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static uint64checkAdd64(uint64 summand1, uint64 summand2, T2P* t2p){\tuint64 bytes = summand1 + summand2;\tif (bytes < summand1) {\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\tbytes = 0;\t}\treturn bytes;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*TIFFOpenW(const wchar_t* name, const char* mode){\tstatic const char module[] = \"TIFFOpenW\";\tthandle_t fd;\tint m;\tDWORD dwMode;\tint mbsize;\tchar *mbname;\tTIFF *tif;\tm = _TIFFgetMode(mode, module);\tswitch(m) {\t\tcase O_RDONLY:\t\t\tdwMode = OPEN_EXISTING; break;\t\tcase O_RDWR:\t\t\tdwMode = OPEN_ALWAYS;   break;\t\tcase O_RDWR|O_CREAT:\t\tdwMode = OPEN_ALWAYS;   break;\t\tcase O_RDWR|O_TRUNC:\t\tdwMode = CREATE_ALWAYS; break;\t\tcase O_RDWR|O_CREAT|O_TRUNC:\tdwMode = CREATE_ALWAYS; break;\t\tdefault:\t\t\treturn ((TIFF*)0);\t}\tfd = (thandle_t)CreateFileW(name,\t\t(m == O_RDONLY)?GENERIC_READ:(GENERIC_READ|GENERIC_WRITE),\t\tFILE_SHARE_READ, NULL, dwMode,\t\t(m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL,\t\tNULL);\tif (fd == INVALID_HANDLE_VALUE) {\t\tTIFFErrorExt(0, module, \"%S: Cannot open\", name);\t\treturn ((TIFF *)0);\t}\tmbname = NULL;\tmbsize = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL);\tif (mbsize > 0) {\t\tmbname = _TIFFmalloc(mbsize);\t\tif (!mbname) {\t\t\tTIFFErrorExt(0, module,\t\t\t\"Can't allocate space for filename conversion buffer\");\t\t\treturn ((TIFF*)0);\t\t}\t\tWideCharToMultiByte(CP_ACP, 0, name, -1, mbname, mbsize,\t\t\t\t    NULL, NULL);\t}\ttif = TIFFFdOpen((int)fd,\t\t\t (mbname != NULL) ? mbname : \"<unknown>\", mode);\tif(!tif)\t\tCloseHandle(fd);\t_TIFFfree(mbname);\treturn tif;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFmemset(tdata_t p, int v, tsize_t c){\tmemset(p, v, (size_t) c);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFFErrorHandlerTIFFSetWarningHandler(TIFFErrorHandler handler){\tTIFFErrorHandler prev = _TIFFwarningHandler;\t_TIFFwarningHandler = handler;\treturn (prev);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPredictorVGetField(TIFF* tif, uint32 tag, va_list ap){\tTIFFPredictorState *sp = PredictorState(tif);\tassert(sp != NULL);\tassert(sp->vgetparent != NULL);\tswitch (tag) {\tcase TIFFTAG_PREDICTOR:\t\t*va_arg(ap, uint16*) = (uint16)sp->predictor;\t\tbreak;\tdefault:\t\treturn (*sp->vgetparent)(tif, tag, ap);\t}\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidOpenTIFFFile(){    if (tfFile != NULL)        TIFFClose(tfFile);    if ((tfFile = TIFFOpen(fileName, \"r\")) == NULL) {\tfprintf(appData.verbose ? stderr : stdout,\t    \"xtiff: can't open %s as a TIFF file\\n\", fileName);        exit(0);    }    tfMultiPage = (TIFFLastDirectory(tfFile) ? False : True);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intContigCompare(int sample, uint32 row,\t      unsigned char* p1, unsigned char* p2, tsize_t size){    uint32 pix;    int ppb = 8 / bitspersample;    int\t samples_to_test;    if (memcmp(p1, p2, size) == 0)        return 0;    samples_to_test = (sample == -1) ? samplesperpixel : 1;    switch (bitspersample) {      case 1: case 2: case 4: case 8:       {          unsigned char *pix1 = p1, *pix2 = p2;          for (pix = 0; pix < imagewidth; pix += ppb) {              int\t\ts;              for(s = 0; s < samples_to_test; s++) {                  if (*pix1 != *pix2) {                      if( sample == -1 )                          PrintIntDiff(row, s, pix, *pix1, *pix2);                      else                          PrintIntDiff(row, sample, pix, *pix1, *pix2);                  }                  pix1++;                  pix2++;              }          }          break;      }      case 16:       {          uint16 *pix1 = (uint16 *)p1, *pix2 = (uint16 *)p2;          for (pix = 0; pix < imagewidth; pix++) {              int\ts;              for(s = 0; s < samples_to_test; s++) {                  if (*pix1 != *pix2)                      PrintIntDiff(row, sample, pix, *pix1, *pix2);                  pix1++;                  pix2++;              }          }          break;      }      case 32: \tif (sampleformat == SAMPLEFORMAT_UINT\t    || sampleformat == SAMPLEFORMAT_INT) {\t\tuint32 *pix1 = (uint32 *)p1, *pix2 = (uint32 *)p2;\t\tfor (pix = 0; pix < imagewidth; pix++) {\t\t\tint\ts;\t\t\tfor(s = 0; s < samples_to_test; s++) {\t\t\t\tif (*pix1 != *pix2) {\t\t\t\t\tPrintIntDiff(row, sample, pix,\t\t\t\t\t\t     *pix1, *pix2);\t\t\t\t}\t\t\t\tpix1++;\t\t\t\tpix2++;\t\t\t}\t\t}\t} else if (sampleformat == SAMPLEFORMAT_IEEEFP) {\t\tfloat *pix1 = (float *)p1, *pix2 = (float *)p2;\t\tfor (pix = 0; pix < imagewidth; pix++) {\t\t\tint\ts;\t\t\tfor(s = 0; s < samples_to_test; s++) {\t\t\t\tif (fabs(*pix1 - *pix2) < 0.000000000001) {\t\t\t\t\tPrintFloatDiff(row, sample, pix,\t\t\t\t\t\t       *pix1, *pix2);\t\t\t\t}\t\t\t\tpix1++;\t\t\t\tpix2++;\t\t\t}\t\t}\t} else {\t\t  fprintf(stderr, \"Sample format %d is not supported.\\n\",\t\t\t  sampleformat);\t\t  return -1;\t}        break;      default:\tfprintf(stderr, \"Bit depth %d is not supported.\\n\", bitspersample);\treturn -1;    }    return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcombineSeparateSamples8bits (uint8 *in[], uint8 *out, uint32 cols,                            uint32 rows, uint16 spp, uint16 bps,  \t                    FILE *dumpfile, int format, int level)  {  int    ready_bits = 0;    uint32 src_rowsize, dst_rowsize, src_offset;   uint32 bit_offset;  uint32 row, col, src_byte = 0, src_bit = 0;  uint8  maskbits = 0, matchbits = 0;  uint8  buff1 = 0, buff2 = 0;  tsample_t s;  unsigned char *src = in[0];  unsigned char *dst = out;  char           action[32];  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"combineSeparateSamples8bits\",\"Invalid input or output buffer\");    return (1);    }     src_rowsize = ((bps * cols) + 7) / 8;  dst_rowsize = ((bps * cols * spp) + 7) / 8;  maskbits =  (uint8)-1 >> ( 8 - bps);  for (row = 0; row < rows; row++)    {    ready_bits = 0;    buff1 = buff2 = 0;    dst = out + (row * dst_rowsize);    src_offset = row * src_rowsize;    for (col = 0; col < cols; col++)      {            bit_offset = col * bps;      src_byte = bit_offset / 8;      src_bit  = bit_offset % 8;      matchbits = maskbits << (8 - src_bit - bps);             for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)        {\tsrc = in[s] + src_offset + src_byte;        buff1 = ((*src) & matchbits) << (src_bit);                if (ready_bits >= 8)          {          *dst++ = buff2;          buff2 = buff1;          ready_bits -= 8;          strcpy (action, \"Flush\");          }        else          {          buff2 = (buff2 | (buff1 >> ready_bits));          strcpy (action, \"Update\");          }        ready_bits += bps;        if ((dumpfile != NULL) && (level == 3))          {          dump_info (dumpfile, format, \"\",                   \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);          dump_byte (dumpfile, format, \"Match bits\", matchbits);          dump_byte (dumpfile, format, \"Src   bits\", *src);          dump_byte (dumpfile, format, \"Buff1 bits\", buff1);          dump_byte (dumpfile, format, \"Buff2 bits\", buff2);          dump_info (dumpfile, format, \"\",\"%s\", action); \t  }        }      }    if (ready_bits > 0)      {      buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));      *dst++ = buff1;      if ((dumpfile != NULL) && (level == 3))        {        dump_info (dumpfile, format, \"\",\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\t         row + 1, col + 1, src_byte, src_bit, dst - out);                 dump_byte (dumpfile, format, \"Final bits\", buff1);        }      }    if ((dumpfile != NULL) && (level >= 2))      {      dump_info (dumpfile, format, \"combineSeparateSamples8bits\",\"Output data\");      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));      }    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int main(int argc, char **argv){    int             i;    unsigned char * scan_line;    TIFF *          tif;    if (argc != 2) {        fprintf(stderr, \"Usage: %s tiff-image\\n\", argv[0]);        return 0;    }    if ((tif = TIFFOpen(argv[1], \"w\")) == NULL) {        fprintf(stderr, \"can't open %s as a TIFF file\\n\", argv[1]);        return 0;    }    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, WIDTH);    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, HEIGHT);    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 1);    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);    TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_NONE);    scan_line = (unsigned char *) malloc(WIDTH / 8);    for (i = 0; i < (WIDTH / 8) / 2; i++)        scan_line[i] = 0;    for (i = (WIDTH / 8) / 2; i < (WIDTH / 8); i++)        scan_line[i] = 255;    for (i = 0; i < HEIGHT / 2; i++)        TIFFWriteScanline(tif, scan_line, i, 0);    for (i = 0; i < (WIDTH / 8) / 2; i++)        scan_line[i] = 255;    for (i = (WIDTH / 8) / 2; i < (WIDTH / 8); i++)        scan_line[i] = 0;    for (i = HEIGHT / 2; i < HEIGHT; i++)        TIFFWriteScanline(tif, scan_line, i, 0);    free(scan_line);    TIFFClose(tif);    return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intswabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc){    uint16* wp = (uint16*) cp0;    tmsize_t wc = cc / 2;    if( !horDiff16(tif, cp0, cc) )        return 0;    TIFFSwabArrayOfShort(wp, wc);    return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_tiffCloseProc(thandle_t fd){\treturn (FSClose((short) fd));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void SetUpTIFFDirectory(TIFF *tif){\tdouble mymulti[6]={0.0,1.0,2.0,  3.1415926, 5.0,1.0};\tuint32 mysingle=3456;\tchar *ascii=\"This file was produced by Steven Spielberg. NOT\";\tTIFFSetField(tif,TIFFTAG_IMAGEWIDTH,WIDTH);\tTIFFSetField(tif,TIFFTAG_IMAGELENGTH,HEIGHT);\tTIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE);\tTIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_MINISBLACK);\tTIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\tTIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8);\tTIFFSetField(tif,TIFFTAG_ROWSPERSTRIP,20);\t\tTIFFSetField(tif,TIFFTAG_EXAMPLE_MULTI,6,mymulti);\tTIFFSetField(tif,TIFFTAG_EXAMPLE_SINGLE,mysingle);\tTIFFSetField(tif,TIFFTAG_EXAMPLE_ASCII,ascii);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidShowRawWords(uint16* pp, uint32 n){\tuint32 i;\tfor (i = 0; i < n; i++) {\t\tprintf(\" %04x\", *pp++);\t\tif (((i+1) % 15) == 0)\t\t\tprintf(\"\\n \");\t}\tputchar('\\n');}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intgtTileContig(TIFFImageIter* img, void *udata, uint32 w, uint32 h){    TIFF* tif = img->tif;    ImageIterTileContigRoutine callback = img->callback.contig;    uint16 orientation;    uint32 col, row;    uint32 tw, th;    u_char* buf;    int32 fromskew;    uint32 nrow;    buf = (u_char*) _TIFFmalloc(TIFFTileSize(tif));    if (buf == 0) {\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for tile buffer\");\treturn (0);    }    TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);    TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);    orientation = img->orientation;    for (row = 0; row < h; row += th) {\tnrow = (row + th > h ? h - row : th);\tfor (col = 0; col < w; col += tw) {\t    if (TIFFReadTile(tif, buf, col, row, 0, 0) < 0 && img->stoponerr)\t\tbreak;\t    if (col + tw > w) {\t\t\t\tuint32 npix = w - col;\t\tfromskew = tw - npix;\t\t(*callback)(img, udata, col, row, npix, nrow, fromskew, buf);\t    } else {\t\t(*callback)(img, udata, col, row, tw, nrow, 0, buf);\t    }\t}    }    _TIFFfree(buf);    return (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int t2p_process_jpeg_strip(\tunsigned char* strip, \ttsize_t* striplength, \tunsigned char* buffer, \ttsize_t* bufferoffset, \ttstrip_t no, \tuint32 height){\ttsize_t i=0;\tuint16 ri =0;\tuint16 v_samp=1;\tuint16 h_samp=1;\tint j=0;\t\ti++;\t\twhile(i<(*striplength)){\t\tswitch( strip[i] ){\t\t\tcase 0xd8:\t\t\t\ti+=2;\t\t\t\tbreak;\t\t\tcase 0xc0:\t\t\tcase 0xc1:\t\t\tcase 0xc3:\t\t\tcase 0xc9:\t\t\tcase 0xca:\t\t\t\tif(no==0){\t\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), strip[i+2]+2);\t\t\t\t\tfor(j=0;j<buffer[*bufferoffset+9];j++){\t\t\t\t\t\tif( (buffer[*bufferoffset+11+(2*j)]>>4) > h_samp) \t\t\t\t\t\t\th_samp = (buffer[*bufferoffset+11+(2*j)]>>4);\t\t\t\t\t\tif( (buffer[*bufferoffset+11+(2*j)] & 0x0f) > v_samp) \t\t\t\t\t\t\tv_samp = (buffer[*bufferoffset+11+(2*j)] & 0x0f);\t\t\t\t\t}\t\t\t\t\tv_samp*=8;\t\t\t\t\th_samp*=8;\t\t\t\t\tri=((( ((uint16)(buffer[*bufferoffset+5])<<8) | \t\t\t\t\t(uint16)(buffer[*bufferoffset+6]) )+v_samp-1)/ \t\t\t\t\tv_samp);\t\t\t\t\tri*=((( ((uint16)(buffer[*bufferoffset+7])<<8) | \t\t\t\t\t(uint16)(buffer[*bufferoffset+8]) )+h_samp-1)/ \t\t\t\t\th_samp);\t\t\t\t\tbuffer[*bufferoffset+5]=                                          (unsigned char) ((height>>8) & 0xff);\t\t\t\t\tbuffer[*bufferoffset+6]=                                            (unsigned char) (height & 0xff);\t\t\t\t\t*bufferoffset+=strip[i+2]+2;\t\t\t\t\ti+=strip[i+2]+2;\t\t\t\t\tbuffer[(*bufferoffset)++]=0xff;\t\t\t\t\tbuffer[(*bufferoffset)++]=0xdd;\t\t\t\t\tbuffer[(*bufferoffset)++]=0x00;\t\t\t\t\tbuffer[(*bufferoffset)++]=0x04;\t\t\t\t\tbuffer[(*bufferoffset)++]=(ri >> 8) & 0xff;\t\t\t\t\tbuffer[(*bufferoffset)++]= ri & 0xff;\t\t\t\t} else {\t\t\t\t\ti+=strip[i+2]+2;\t\t\t\t}\t\t\t\tbreak;\t\t\tcase 0xc4:\t\t\tcase 0xdb:\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), strip[i+2]+2);\t\t\t\t*bufferoffset+=strip[i+2]+2;\t\t\t\ti+=strip[i+2]+2;\t\t\t\tbreak;\t\t\tcase 0xda:\t\t\t\tif(no==0){\t\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), strip[i+2]+2);\t\t\t\t\t*bufferoffset+=strip[i+2]+2;\t\t\t\t\ti+=strip[i+2]+2;\t\t\t\t} else {\t\t\t\t\tbuffer[(*bufferoffset)++]=0xff;\t\t\t\t\tbuffer[(*bufferoffset)++]=                                            (unsigned char)(0xd0 | ((no-1)%8));\t\t\t\t\ti+=strip[i+2]+2;\t\t\t\t}\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), (*striplength)-i-1);\t\t\t\t*bufferoffset+=(*striplength)-i-1;\t\t\t\treturn(1);\t\t\tdefault:\t\t\t\ti+=strip[i+2]+2;\t\t}\t}\t\treturn(0);}",
        "label": 1,
        "cve": "cve-2013-1960"
    },
    {
        "code": "static intPixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s){\tstatic const char module[] = \"PixarLogDecode\";\tTIFFDirectory *td = &tif->tif_dir;\tPixarLogState* sp = DecoderState(tif);\ttmsize_t i;\ttmsize_t nsamples;\tint llen;\tuint16 *up;\tswitch (sp->user_datafmt) {\tcase PIXARLOGDATAFMT_FLOAT:\t\tnsamples = occ / sizeof(float);\t\t\tbreak;\tcase PIXARLOGDATAFMT_16BIT:\tcase PIXARLOGDATAFMT_12BITPICIO:\tcase PIXARLOGDATAFMT_11BITLOG:\t\tnsamples = occ / sizeof(uint16); \t\tbreak;\tcase PIXARLOGDATAFMT_8BIT:\tcase PIXARLOGDATAFMT_8BITABGR:\t\tnsamples = occ;\t\tbreak;\tdefault:\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\"%d bit input not supported in PixarLog\",\t\t\ttd->td_bitspersample);\t\treturn 0;\t}\tllen = sp->stride * td->td_imagewidth;\t(void) s;\tassert(sp != NULL);        sp->stream.next_in = tif->tif_rawcp;\tsp->stream.avail_in = (uInt) tif->tif_rawcc;\tsp->stream.next_out = (unsigned char *) sp->tbuf;\tassert(sizeof(sp->stream.avail_out)==4);  \tsp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));\tif (sp->stream.avail_out != nsamples * sizeof(uint16))\t{\t\tTIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\");\t\treturn (0);\t}\t\tif ((tmsize_t)sp->stream.avail_out > sp->tbuf_size)\t{\t\tTIFFErrorExt(tif->tif_clientdata, module, \"sp->stream.avail_out > sp->tbuf_size\");\t\treturn (0);\t}\tdo {\t\tint state = inflate(&sp->stream, Z_PARTIAL_FLUSH);\t\tif (state == Z_STREAM_END) {\t\t\tbreak;\t\t\t\t\t}\t\tif (state == Z_DATA_ERROR) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"Decoding error at scanline %lu, %s\",\t\t\t    (unsigned long) tif->tif_row, sp->stream.msg ? sp->stream.msg : \"(null)\");\t\t\tif (inflateSync(&sp->stream) != Z_OK)\t\t\t\treturn (0);\t\t\tcontinue;\t\t}\t\tif (state != Z_OK) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"ZLib error: %s\",\t\t\t    sp->stream.msg ? sp->stream.msg : \"(null)\");\t\t\treturn (0);\t\t}\t} while (sp->stream.avail_out > 0);\t\tif (sp->stream.avail_out != 0) {\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t    \"Not enough data at scanline %lu (short \" TIFF_UINT64_FORMAT \" bytes)\",\t\t    (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);\t\treturn (0);\t}        tif->tif_rawcp = sp->stream.next_in;        tif->tif_rawcc = sp->stream.avail_in;\tup = sp->tbuf;\t\tif (tif->tif_flags & TIFF_SWAB)\t\tTIFFSwabArrayOfShort(up, nsamples);\t\tif (nsamples % llen) { \t\tTIFFWarningExt(tif->tif_clientdata, module,\t\t\t\"stride %lu is not a multiple of sample count, \"\t\t\t\"%lu, data truncated.\", (unsigned long) llen, (unsigned long) nsamples);\t\tnsamples -= nsamples % llen;\t}\tfor (i = 0; i < nsamples; i += llen, up += llen) {\t\tswitch (sp->user_datafmt)  {\t\tcase PIXARLOGDATAFMT_FLOAT:\t\t\thorizontalAccumulateF(up, llen, sp->stride,\t\t\t\t\t(float *)op, sp->ToLinearF);\t\t\top += llen * sizeof(float);\t\t\tbreak;\t\tcase PIXARLOGDATAFMT_16BIT:\t\t\thorizontalAccumulate16(up, llen, sp->stride,\t\t\t\t\t(uint16 *)op, sp->ToLinear16);\t\t\top += llen * sizeof(uint16);\t\t\tbreak;\t\tcase PIXARLOGDATAFMT_12BITPICIO:\t\t\thorizontalAccumulate12(up, llen, sp->stride,\t\t\t\t\t(int16 *)op, sp->ToLinearF);\t\t\top += llen * sizeof(int16);\t\t\tbreak;\t\tcase PIXARLOGDATAFMT_11BITLOG:\t\t\thorizontalAccumulate11(up, llen, sp->stride,\t\t\t\t\t(uint16 *)op);\t\t\top += llen * sizeof(uint16);\t\t\tbreak;\t\tcase PIXARLOGDATAFMT_8BIT:\t\t\thorizontalAccumulate8(up, llen, sp->stride,\t\t\t\t\t(unsigned char *)op, sp->ToLinear8);\t\t\top += llen * sizeof(unsigned char);\t\t\tbreak;\t\tcase PIXARLOGDATAFMT_8BITABGR:\t\t\thorizontalAccumulate8abgr(up, llen, sp->stride,\t\t\t\t\t(unsigned char *)op, sp->ToLinear8);\t\t\top += llen * sizeof(unsigned char);\t\t\tbreak;\t\tdefault:\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t  \"Unsupported bits/sample: %d\",\t\t\t\t  td->td_bitspersample);\t\t\treturn (0);\t\t}\t}\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcvt_by_strip( TIFF *in, TIFF *out ){    uint32* raster;\t\t\t    uint32  width, height;\t\t    uint32  row;    uint32  *wrk_line;    int\t    ok = 1;    TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width);    TIFFGetField(in, TIFFTAG_IMAGELENGTH, &height);    if( !TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip) ) {        TIFFError(TIFFFileName(in), \"Source image not in strips\");        return (0);    }        TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);        raster = (uint32*)_TIFFmalloc(width * rowsperstrip * sizeof (uint32));    if (raster == 0) {        TIFFError(TIFFFileName(in), \"No space for raster buffer\");        return (0);    }        wrk_line = (uint32*)_TIFFmalloc(width * sizeof (uint32));    if (!wrk_line) {        TIFFError(TIFFFileName(in), \"No space for raster scanline buffer\");        ok = 0;    }            for( row = 0; ok && row < height; row += rowsperstrip )    {        int\trows_to_write, i_row;                if (!TIFFReadRGBAStrip(in, row, raster)) {            ok = 0;            break;        }\t#if HOST_BIGENDIAN\tTIFFSwabArrayOfLong(raster, width * rowsperstrip);#endif                if( row + rowsperstrip > height )            rows_to_write = height - row;        else            rows_to_write = rowsperstrip;                for( i_row = 0; i_row < rows_to_write / 2; i_row++ )        {            uint32\t*top_line, *bottom_line;            top_line = raster + width * i_row;            bottom_line = raster + width * (rows_to_write-i_row-1);            _TIFFmemcpy(wrk_line, top_line, 4*width);            _TIFFmemcpy(top_line, bottom_line, 4*width);            _TIFFmemcpy(bottom_line, wrk_line, 4*width);        }                if( TIFFWriteEncodedStrip( out, row / rowsperstrip, raster,                                   4 * rows_to_write * width ) == -1 )        {            ok = 0;            break;        }    }    _TIFFfree( raster );    _TIFFfree( wrk_line );    return ok;}",
        "label": 1,
        "cve": "cve-2016-3945-1"
    },
    {
        "code": "static doublecorrelation(void *buf1, void *buf2, uint32 n_elem, TIFFDataType dtype){\tdouble\tX, Y, M1 = 0.0, M2 = 0.0, D1 = 0.0, D2 = 0.0, K = 0.0;\tuint32\ti;\tswitch (dtype) {\t\tcase TIFF_BYTE:\t\tdefault:                        for (i = 0; i < n_elem; i++) {\t\t\t\tX = ((unsigned char *)buf1)[i];\t\t\t\tY = ((unsigned char *)buf2)[i];\t\t\t\tM1 += X, M2 += Y;\t\t\t\tD1 += X * X, D2 += Y * Y;\t\t\t\tK += X * Y;                        }\t\t\tbreak;\t\tcase TIFF_SBYTE:                        for (i = 0; i < n_elem; i++) {\t\t\t\tX = ((signed char *)buf1)[i];\t\t\t\tY = ((signed char *)buf2)[i];\t\t\t\tM1 += X, M2 += Y;\t\t\t\tD1 += X * X, D2 += Y * Y;\t\t\t\tK += X * Y;                        }\t\t\tbreak;\t\tcase TIFF_SHORT:                        for (i = 0; i < n_elem; i++) {\t\t\t\tX = ((uint16 *)buf1)[i];\t\t\t\tY = ((uint16 *)buf2)[i];\t\t\t\tM1 += X, M2 += Y;\t\t\t\tD1 += X * X, D2 += Y * Y;\t\t\t\tK += X * Y;                        }\t\t\tbreak;\t\tcase TIFF_SSHORT:                        for (i = 0; i < n_elem; i++) {\t\t\t\tX = ((int16 *)buf1)[i];\t\t\t\tY = ((int16 *)buf2)[i];\t\t\t\tM1 += X, M2 += Y;\t\t\t\tD1 += X * X, D2 += Y * Y;\t\t\t\tK += X * Y;                        }\t\t\tbreak;\t\tcase TIFF_LONG:                        for (i = 0; i < n_elem; i++) {\t\t\t\tX = ((uint32 *)buf1)[i];\t\t\t\tY = ((uint32 *)buf2)[i];\t\t\t\tM1 += X, M2 += Y;\t\t\t\tD1 += X * X, D2 += Y * Y;\t\t\t\tK += X * Y;                        }\t\t\tbreak;\t\tcase TIFF_SLONG:                        for (i = 0; i < n_elem; i++) {\t\t\t\tX = ((int32 *)buf1)[i];\t\t\t\tY = ((int32 *)buf2)[i];\t\t\t\tM1 += X, M2 += Y;\t\t\t\tD1 += X * X, D2 += Y * Y;\t\t\t\tK += X * Y;                        }\t\t\tbreak;\t\tcase TIFF_FLOAT:                        for (i = 0; i < n_elem; i++) {\t\t\t\tX = ((float *)buf1)[i];\t\t\t\tY = ((float *)buf2)[i];\t\t\t\tM1 += X, M2 += Y;\t\t\t\tD1 += X * X, D2 += Y * Y;\t\t\t\tK += X * Y;                        }\t\t\tbreak;\t\tcase TIFF_DOUBLE:                        for (i = 0; i < n_elem; i++) {\t\t\t\tX = ((double *)buf1)[i];\t\t\t\tY = ((double *)buf2)[i];\t\t\t\tM1 += X, M2 += Y;\t\t\t\tD1 += X * X, D2 += Y * Y;\t\t\t\tK += X * Y;                        }\t\t\tbreak;\t}\tM1 /= n_elem;\tM2 /= n_elem;\tD1 -= M1 * M1 * n_elem;\tD2 -= M2 * M2 * n_elem;\tK = (K - M1 * M2 * n_elem) / sqrt(D1 * D2);\treturn K;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intLZWEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s){\tregister LZWCodecState *sp = EncoderState(tif);\tregister long fcode;\tregister hash_t *hp;\tregister int h, c;\thcode_t ent;\tlong disp;\tlong incount, outcount, checkpoint;\tunsigned long nextdata;        long nextbits;\tint free_ent, maxcode, nbits;\tuint8* op;\tuint8* limit;\t(void) s;\tif (sp == NULL)\t\treturn (0);        assert(sp->enc_hashtab != NULL);\t\tincount = sp->enc_incount;\toutcount = sp->enc_outcount;\tcheckpoint = sp->enc_checkpoint;\tnextdata = sp->lzw_nextdata;\tnextbits = sp->lzw_nextbits;\tfree_ent = sp->lzw_free_ent;\tmaxcode = sp->lzw_maxcode;\tnbits = sp->lzw_nbits;\top = tif->tif_rawcp;\tlimit = sp->enc_rawlimit;\tent = sp->enc_oldcode;\tif (ent == (hcode_t) -1 && cc > 0) {\t\t\t\tPutNextCode(op, CODE_CLEAR);\t\tent = *bp++; cc--; incount++;\t}\twhile (cc > 0) {\t\tc = *bp++; cc--; incount++;\t\tfcode = ((long)c << BITS_MAX) + ent;\t\th = (c << HSHIFT) ^ ent;\t#ifdef _WINDOWS\t\t\t\tif (h >= HSIZE)\t\t\th -= HSIZE;#endif\t\thp = &sp->enc_hashtab[h];\t\tif (hp->hash == fcode) {\t\t\tent = hp->code;\t\t\tcontinue;\t\t}\t\tif (hp->hash >= 0) {\t\t\t\t\t\tdisp = HSIZE - h;\t\t\tif (h == 0)\t\t\t\tdisp = 1;\t\t\tdo {\t\t\t\t\t\t\t\tif ((h -= disp) < 0)\t\t\t\t\th += HSIZE;\t\t\t\thp = &sp->enc_hashtab[h];\t\t\t\tif (hp->hash == fcode) {\t\t\t\t\tent = hp->code;\t\t\t\t\tgoto hit;\t\t\t\t}\t\t\t} while (hp->hash >= 0);\t\t}\t\t\t\t\t\tif (op > limit) {\t\t\ttif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata);\t\t\tTIFFFlushData1(tif);\t\t\top = tif->tif_rawdata;\t\t}\t\tPutNextCode(op, ent);\t\tent = c;\t\thp->code = free_ent++;\t\thp->hash = fcode;\t\tif (free_ent == CODE_MAX-1) {\t\t\t\t\t\tcl_hash(sp);\t\t\tsp->enc_ratio = 0;\t\t\tincount = 0;\t\t\toutcount = 0;\t\t\tfree_ent = CODE_FIRST;\t\t\tPutNextCode(op, CODE_CLEAR);\t\t\tnbits = BITS_MIN;\t\t\tmaxcode = MAXCODE(BITS_MIN);\t\t} else {\t\t\t\t\t\tif (free_ent > maxcode) {\t\t\t\tnbits++;\t\t\t\tassert(nbits <= BITS_MAX);\t\t\t\tmaxcode = (int) MAXCODE(nbits);\t\t\t} else if (incount >= checkpoint) {\t\t\t\tlong rat;\t\t\t\t\t\t\t\tcheckpoint = incount+CHECK_GAP;\t\t\t\tCALCRATIO(sp, rat);\t\t\t\tif (rat <= sp->enc_ratio) {\t\t\t\t\tcl_hash(sp);\t\t\t\t\tsp->enc_ratio = 0;\t\t\t\t\tincount = 0;\t\t\t\t\toutcount = 0;\t\t\t\t\tfree_ent = CODE_FIRST;\t\t\t\t\tPutNextCode(op, CODE_CLEAR);\t\t\t\t\tnbits = BITS_MIN;\t\t\t\t\tmaxcode = MAXCODE(BITS_MIN);\t\t\t\t} else\t\t\t\t\tsp->enc_ratio = rat;\t\t\t}\t\t}\thit:\t\t;\t}\t\tsp->enc_incount = incount;\tsp->enc_outcount = outcount;\tsp->enc_checkpoint = checkpoint;\tsp->enc_oldcode = ent;\tsp->lzw_nextdata = nextdata;\tsp->lzw_nextbits = nextbits;\tsp->lzw_free_ent = free_ent;\tsp->lzw_maxcode = maxcode;\tsp->lzw_nbits = nbits;\ttif->tif_rawcp = op;\treturn (1);}",
        "label": 1,
        "cve": "cve-2016-3621"
    },
    {
        "code": "static introtateContigSamples8bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,                          uint32 length,   uint32 col, uint8 *src, uint8 *dst)  {  int      ready_bits = 0;  uint32   src_byte = 0, src_bit = 0;  uint32   row, rowsize = 0, bit_offset = 0;  uint8    matchbits = 0, maskbits = 0;  uint8    buff1 = 0, buff2 = 0;  uint8   *next;  tsample_t sample;  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"rotateContigSamples8bits\",\"Invalid src or destination buffer\");    return (1);    }  rowsize = ((bps * spp * width) + 7) / 8;  ready_bits = 0;  maskbits =  (uint8)-1 >> ( 8 - bps);  buff1 = buff2 = 0;  for (row = 0; row < length ; row++)    {    bit_offset = col * bps * spp;    for (sample = 0; sample < spp; sample++)      {      if (sample == 0)        {        src_byte = bit_offset / 8;        src_bit  = bit_offset % 8;        }      else        {        src_byte = (bit_offset + (sample * bps)) / 8;        src_bit  = (bit_offset + (sample * bps)) % 8;        }      switch (rotation)\t{        case  90: next = src + src_byte - (row * rowsize);                  break;        case 270: next = src + src_byte + (row * rowsize);\t          break;\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);                  return (1);        }      matchbits = maskbits << (8 - src_bit - bps);       buff1 = ((*next) & matchbits) << (src_bit);             if (ready_bits >= 8)        {        *dst++ = buff2;        buff2 = buff1;        ready_bits -= 8;        }      else        {        buff2 = (buff2 | (buff1 >> ready_bits));        }      ready_bits += bps;      }    }  if (ready_bits > 0)    {    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));    *dst++ = buff1;    }  return (0);  }  ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidPrivateErrorHandler(const char* module, const char* fmt, va_list ap){        if (old_error_handler)                (*old_error_handler)(module,fmt,ap);\tstatus = 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidshrinkbox(Colorbox* box){\tregister uint32 *histp;\tregister int\tir, ig, ib;\tif (box->rmax > box->rmin) {\t\tfor (ir = box->rmin; ir <= box->rmax; ++ir)\t\t\tfor (ig = box->gmin; ig <= box->gmax; ++ig) {\t\t\t\thistp = &histogram[ir][ig][box->bmin];\t\t\t        for (ib = box->bmin; ib <= box->bmax; ++ib)\t\t\t\t\tif (*histp++ != 0) {\t\t\t\t\t\tbox->rmin = ir;\t\t\t\t\t\tgoto have_rmin;\t\t\t\t\t}\t\t\t}\thave_rmin:\t\tif (box->rmax > box->rmin)\t\t\tfor (ir = box->rmax; ir >= box->rmin; --ir)\t\t\t\tfor (ig = box->gmin; ig <= box->gmax; ++ig) {\t\t\t\t\thistp = &histogram[ir][ig][box->bmin];\t\t\t\t\tib = box->bmin;\t\t\t\t\tfor (; ib <= box->bmax; ++ib)\t\t\t\t\t\tif (*histp++ != 0) {\t\t\t\t\t\t\tbox->rmax = ir;\t\t\t\t\t\t\tgoto have_rmax;\t\t\t\t\t\t}\t\t\t        }\t}have_rmax:\tif (box->gmax > box->gmin) {\t\tfor (ig = box->gmin; ig <= box->gmax; ++ig)\t\t\tfor (ir = box->rmin; ir <= box->rmax; ++ir) {\t\t\t\thistp = &histogram[ir][ig][box->bmin];\t\t\t        for (ib = box->bmin; ib <= box->bmax; ++ib)\t\t\t\tif (*histp++ != 0) {\t\t\t\t\tbox->gmin = ig;\t\t\t\t\tgoto have_gmin;\t\t\t\t}\t\t\t}\thave_gmin:\t\tif (box->gmax > box->gmin)\t\t\tfor (ig = box->gmax; ig >= box->gmin; --ig)\t\t\t\tfor (ir = box->rmin; ir <= box->rmax; ++ir) {\t\t\t\t\thistp = &histogram[ir][ig][box->bmin];\t\t\t\t\tib = box->bmin;\t\t\t\t\tfor (; ib <= box->bmax; ++ib)\t\t\t\t\t\tif (*histp++ != 0) {\t\t\t\t\t\t\tbox->gmax = ig;\t\t\t\t\t\t\tgoto have_gmax;\t\t\t\t\t\t}\t\t\t        }\t}have_gmax:\tif (box->bmax > box->bmin) {\t\tfor (ib = box->bmin; ib <= box->bmax; ++ib)\t\t\tfor (ir = box->rmin; ir <= box->rmax; ++ir) {\t\t\t\thistp = &histogram[ir][box->gmin][ib];\t\t\t        for (ig = box->gmin; ig <= box->gmax; ++ig) {\t\t\t\t\tif (*histp != 0) {\t\t\t\t\t\tbox->bmin = ib;\t\t\t\t\t\tgoto have_bmin;\t\t\t\t\t}\t\t\t\t\thistp += B_LEN;\t\t\t        }\t\t        }\thave_bmin:\t\tif (box->bmax > box->bmin)\t\t\tfor (ib = box->bmax; ib >= box->bmin; --ib)\t\t\t\tfor (ir = box->rmin; ir <= box->rmax; ++ir) {\t\t\t\t\thistp = &histogram[ir][box->gmin][ib];\t\t\t\t\tig = box->gmin;\t\t\t\t\tfor (; ig <= box->gmax; ++ig) {\t\t\t\t\t\tif (*histp != 0) {\t\t\t\t\t\t\tbox->bmax = ib;\t\t\t\t\t\t\tgoto have_bmax;\t\t\t\t\t\t}\t\t\t\t\t\thistp += B_LEN;\t\t\t\t\t}\t\t\t        }\t}have_bmax:\t;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int extend_mem_file (int fd, int size){    void *new_mem;    int ret;    if ((new_mem = realloc (buf[fd], size)) == (void *) NULL)        ret = -1;    else    {        buf[fd] = (char *) new_mem;        ret = 0;    }    return (ret);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidChopUpSingleUncompressedStrip(TIFF* tif){\tregister TIFFDirectory *td = &tif->tif_dir;\tuint64 bytecount;\tuint64 offset;\tuint32 rowblock;\tuint64 rowblockbytes;\tuint64 stripbytes;\tuint32 strip;\tuint32 nstrips;\tuint32 rowsperstrip;\tuint64* newcounts;\tuint64* newoffsets;\tbytecount = td->td_stripbytecount[0];                                   if( bytecount == 0 && tif->tif_mode != O_RDONLY )            return;\toffset = td->td_stripoffset[0];\tassert(td->td_planarconfig == PLANARCONFIG_CONTIG);\tif ((td->td_photometric == PHOTOMETRIC_YCBCR)&&\t    (!isUpSampled(tif)))\t\trowblock = td->td_ycbcrsubsampling[1];\telse\t\trowblock = 1;\trowblockbytes = TIFFVTileSize64(tif, rowblock);\t \tif (rowblockbytes > STRIP_SIZE_DEFAULT) {\t\tstripbytes = rowblockbytes;\t\trowsperstrip = rowblock;\t} else if (rowblockbytes > 0 ) {\t\tuint32 rowblocksperstrip;\t\trowblocksperstrip = (uint32) (STRIP_SIZE_DEFAULT / rowblockbytes);\t\trowsperstrip = rowblocksperstrip * rowblock;\t\tstripbytes = rowblocksperstrip * rowblockbytes;\t}\telse\t    return;\t \tif (rowsperstrip >= td->td_rowsperstrip)\t\treturn;        nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);        if( nstrips == 0 )            return;\tnewcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),\t\t\t\t\"for chopped \\\"StripByteCounts\\\" array\");\tnewoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),\t\t\t\t\"for chopped \\\"StripOffsets\\\" array\");\tif (newcounts == NULL || newoffsets == NULL) {\t\t \t\tif (newcounts != NULL)\t\t\t_TIFFfree(newcounts);\t\tif (newoffsets != NULL)\t\t\t_TIFFfree(newoffsets);\t\treturn;\t}\t \tfor (strip = 0; strip < nstrips; strip++) {\t\tif (stripbytes > bytecount)\t\t\tstripbytes = bytecount;\t\tnewcounts[strip] = stripbytes;\t\tnewoffsets[strip] = stripbytes ? offset : 0;\t\toffset += stripbytes;\t\tbytecount -= stripbytes;\t}\t \ttd->td_stripsperimage = td->td_nstrips = nstrips;\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\t_TIFFfree(td->td_stripbytecount);\t_TIFFfree(td->td_stripoffset);\ttd->td_stripbytecount = newcounts;\ttd->td_stripoffset = newoffsets;\ttd->td_stripbytecountsorted = 1;}",
        "label": 1,
        "cve": "CVE-2018-16335"
    },
    {
        "code": "static voidPrintTag(FILE* fd, uint16 tag){\tconst struct tagname *tp;\tfor (tp = tagnames; tp < &tagnames[NTAGS]; tp++)\t\tif (tp->tag == tag) {\t\t\tfprintf(fd, \"%s (%u)\", tp->name, tag);\t\t\treturn;\t\t}\tfprintf(fd, \"%u (%#x)\", tag, tag);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int mfs_unmap (int fd){    return (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidhorizontalDifferenceF(float *ip, int n, int stride, uint16 *wp, uint16 *FromLT2){    int32 r1, g1, b1, a1, r2, g2, b2, a2, mask;    float fltsize = Fltsize;#define  CLAMP(v) ( (v<(float)0.)   ? 0\t\t\t\t\\\t\t  : (v<(float)2.)   ? FromLT2[(int)(v*fltsize)]\t\\\t\t  : (v>(float)24.2) ? 2047\t\t\t\\\t\t  : LogK1*log(v*LogK2) + 0.5 )    mask = CODE_MASK;    if (n >= stride) {\tif (stride == 3) {\t    r2 = wp[0] = (uint16) CLAMP(ip[0]);\t    g2 = wp[1] = (uint16) CLAMP(ip[1]);\t    b2 = wp[2] = (uint16) CLAMP(ip[2]);\t    n -= 3;\t    while (n > 0) {\t\tn -= 3;\t\twp += 3;\t\tip += 3;\t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\t    }\t} else if (stride == 4) {\t    r2 = wp[0] = (uint16) CLAMP(ip[0]);\t    g2 = wp[1] = (uint16) CLAMP(ip[1]);\t    b2 = wp[2] = (uint16) CLAMP(ip[2]);\t    a2 = wp[3] = (uint16) CLAMP(ip[3]);\t    n -= 4;\t    while (n > 0) {\t\tn -= 4;\t\twp += 4;\t\tip += 4;\t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\t\ta1 = (int32) CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\t    }\t} else {        REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]); wp++; ip++)        n -= stride;        while (n > 0) {            REPEAT(stride,                wp[0] = (uint16)(((int32)CLAMP(ip[0])-(int32)CLAMP(ip[-stride])) & mask);                wp++; ip++)            n -= stride;        }\t}    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int_TIFFNoTileDecode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s){\t(void) pp; (void) cc; (void) s;\treturn (TIFFNoDecode(tif, \"tile\"));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidShowStrip(tstrip_t strip, unsigned char* pp, uint32 nrow, tsize_t scanline){\tregister tsize_t cc;\tprintf(\"Strip %lu:\\n\", (unsigned long) strip);\twhile (nrow-- > 0) {\t\tfor (cc = 0; cc < scanline; cc++) {\t\t\tprintf(\" %02x\", *pp++);\t\t\tif (((cc+1) % 24) == 0)\t\t\t\tputchar('\\n');\t\t}\t\tputchar('\\n');\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tmsize_t t2p_writeproc(thandle_t handle, tdata_t data, tmsize_t size) {\tT2P *t2p = (T2P*) handle;\tif (t2p->outputdisable <= 0 && t2p->outputfile) {\t\ttsize_t written = fwrite(data, 1, size, t2p->outputfile);\t\tt2p->outputwritten += written;\t\treturn written;\t}\treturn size; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intFax3VGetField(TIFF* tif, ttag_t tag, va_list ap){\tFax3BaseState* sp = Fax3State(tif);\tswitch (tag) {\tcase TIFFTAG_FAXMODE:\t\t*va_arg(ap, int*) = sp->mode;\t\tbreak;\tcase TIFFTAG_FAXFILLFUNC:\t\t*va_arg(ap, TIFFFaxFillFunc*) = DecoderState(tif)->fill;\t\tbreak;\tcase TIFFTAG_GROUP3OPTIONS:\tcase TIFFTAG_GROUP4OPTIONS:\t\t*va_arg(ap, uint32*) = sp->groupoptions;\t\tbreak;\tcase TIFFTAG_BADFAXLINES:\t\t*va_arg(ap, uint32*) = sp->badfaxlines;\t\tbreak;\tcase TIFFTAG_CLEANFAXDATA:\t\t*va_arg(ap, uint16*) = sp->cleanfaxdata;\t\tbreak;\tcase TIFFTAG_CONSECUTIVEBADFAXLINES:\t\t*va_arg(ap, uint32*) = sp->badfaxrun;\t\tbreak;\tcase TIFFTAG_FAXRECVPARAMS:\t\t*va_arg(ap, uint32*) = sp->recvparams;\t\tbreak;\tcase TIFFTAG_FAXSUBADDRESS:\t\t*va_arg(ap, char**) = sp->subaddress;\t\tbreak;\tcase TIFFTAG_FAXRECVTIME:\t\t*va_arg(ap, uint32*) = sp->recvtime;\t\tbreak;\tcase TIFFTAG_FAXDCS:\t\t*va_arg(ap, char**) = sp->faxdcs;\t\tbreak;\tdefault:\t\treturn (*sp->vgetparent)(tif, tag, ap);\t}\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int mfs_open (void *buffer, int size, char *mode){    int ret, i;    void *tmp;    if (library_init_done == FALSE)    {        mem_init ();        library_init_done = TRUE;    }    ret = -1;        for (i = 0; i < MAX_BUFFS; i++)    {        if (fds[i] == -1)        {            ret = i;            break;        }    }    if (i == MAX_BUFFS)         {        ret = -1;        errno = EMFILE;    }    if (ret >= 0 && *mode == 'r')    {        if (buffer == (void *)NULL)        {            ret = -1;            errno = EINVAL;        }        else        {            buf[ret] = (char *)buffer;            buf_size[ret] = size;            buf_off[ret] = 0;        }    }    else if (ret >= 0 && *mode == 'w')    {        if (buffer != (void *)NULL)        {            ret = -1;            errno = EINVAL;        }        else        {            tmp = malloc (0);               if (tmp == (void *)NULL)            {                ret = -1;                errno = EDQUOT;            }            else            {                buf[ret] = (char *)tmp;                buf_size[ret] = 0;                buf_off[ret] = 0;            }        }    }    else if (ret >= 0 && *mode == 'a')    {        if (buffer == (void *) NULL)            {            tmp = malloc (0);               if (tmp == (void *)NULL)            {                ret = -1;                errno = EDQUOT;            }            else            {                buf[ret] = (char *)tmp;                buf_size[ret] = 0;                buf_off[ret] = 0;            }        }        else                                    {            buf[ret] = (char *)buffer;            buf_size[ret] = size;            buf_off[ret] = 0;        }    }    else            {        ret = -1;        errno = EINVAL;    }    if (ret != -1)    {        fds[ret] = 0;        buf_mode[ret] = *mode;    }    return (ret);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidhorizontalDifference8(unsigned char *ip, int n, int stride, \tunsigned short *wp, uint16 *From8){    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;#undef\t CLAMP#define  CLAMP(v) (From8[(v)])    mask = CODE_MASK;    if (n >= stride) {\tif (stride == 3) {\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\t    b2 = wp[2] = CLAMP(ip[2]);\t    n -= 3;\t    while (n > 0) {\t\tn -= 3;\t\tr1 = CLAMP(ip[3]); wp[3] = (r1-r2) & mask; r2 = r1;\t\tg1 = CLAMP(ip[4]); wp[4] = (g1-g2) & mask; g2 = g1;\t\tb1 = CLAMP(ip[5]); wp[5] = (b1-b2) & mask; b2 = b1;\t\twp += 3;\t\tip += 3;\t    }\t} else if (stride == 4) {\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\t    n -= 4;\t    while (n > 0) {\t\tn -= 4;\t\tr1 = CLAMP(ip[4]); wp[4] = (r1-r2) & mask; r2 = r1;\t\tg1 = CLAMP(ip[5]); wp[5] = (g1-g2) & mask; g2 = g1;\t\tb1 = CLAMP(ip[6]); wp[6] = (b1-b2) & mask; b2 = b1;\t\ta1 = CLAMP(ip[7]); wp[7] = (a1-a2) & mask; a2 = a1;\t\twp += 4;\t\tip += 4;\t    }\t} else {\t    wp += n + stride - 1;\t\t    ip += n + stride - 1;\t\t    n -= stride;\t    while (n > 0) {\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\t\t\t\twp[stride] -= wp[0];\t\t\t\twp[stride] &= mask;\t\t\t\twp--; ip--)\t\tn -= stride;\t    }\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\t}    }}",
        "label": 1,
        "cve": "cve-2016-3990"
    },
    {
        "code": "static voidt2p_disable(TIFF *tif){\tT2P *t2p = (T2P*) TIFFClientdata(tif);\tt2p->outputdisable = 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intguessSize(int fd, TIFFDataType dtype, off_t hdr_size, uint32 nbands,\t  int swab, uint32 *width, uint32 *length){\tconst float longt = 40.0;    \tchar\t    *buf1, *buf2;\tstruct stat filestat;\tuint32\t    w, h, scanlinesize, imagesize;\tuint32\t    depth = TIFFDataWidth(dtype);\tfloat\t    cor_coef = 0, tmp;\tfstat(fd, &filestat);\tif (filestat.st_size < hdr_size) {\t\tfprintf(stderr, \"Too large header size specified.\\n\");\t\treturn -1;\t}\timagesize = (filestat.st_size - hdr_size) / nbands / depth;\tif (*width != 0 && *length == 0) {\t\tfprintf(stderr,\t\"Image height is not specified.\\n\");\t\t*length = imagesize / *width;\t\tfprintf(stderr, \"Height is guessed as %lu.\\n\",\t\t\t(unsigned long)*length);\t\treturn 1;\t} else if (*width == 0 && *length != 0) {\t\tfprintf(stderr, \"Image width is not specified.\\n\");\t\t*width = imagesize / *length;\t\tfprintf(stderr,\t\"Width is guessed as %lu.\\n\",\t\t\t(unsigned long)*width);\t\treturn 1;\t} else if (*width == 0 && *length == 0) {\t\tfprintf(stderr,\t\"Image width and height are not specified.\\n\");\t\tfor (w = (uint32) sqrt(imagesize / longt);\t\t     w < sqrt(imagesize * longt);\t\t     w++) {\t\t\tif (imagesize % w == 0) {\t\t\t\tscanlinesize = w * depth;\t\t\t\tbuf1 = _TIFFmalloc(scanlinesize);\t\t\t\tbuf2 = _TIFFmalloc(scanlinesize);\t\t\t\th = imagesize / w;\t\t\t\tlseek(fd, hdr_size + (int)(h/2)*scanlinesize,\t\t\t\t      SEEK_SET);\t\t\t\tread(fd, buf1, scanlinesize);\t\t\t\tread(fd, buf2, scanlinesize);\t\t\t\tif (swab) {\t\t\t\t\tswapBytesInScanline(buf1, w, dtype);\t\t\t\t\tswapBytesInScanline(buf2, w, dtype);\t\t\t\t}\t\t\t\ttmp = (float) fabs(correlation(buf1, buf2,\t\t\t\t\t\t\t       w, dtype));\t\t\t\tif (tmp > cor_coef) {\t\t\t\t\tcor_coef = tmp;\t\t\t\t\t*width = w, *length = h;\t\t\t\t}\t\t\t\t_TIFFfree(buf1);\t\t\t\t_TIFFfree(buf2);\t\t\t}\t\t}\t\tfprintf(stderr,\t\t\t\"Width is guessed as %lu, height is guessed as %lu.\\n\",\t\t\t(unsigned long)*width, (unsigned long)*length);\t\treturn 1;\t} else {\t\tif (filestat.st_size<(off_t)(hdr_size+(*width)*(*length)*nbands*depth)) {\t\t\tfprintf(stderr, \"Input file too small.\\n\");\t\treturn -1;\t\t}\t}\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFFax3fillruns(unsigned char* buf, uint32* runs, uint32* erun, uint32 lastx){\tstatic const unsigned char _fillmasks[] =\t    { 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff };\tunsigned char* cp;\tuint32 x, bx, run;\tint32 n, nw;\tlong* lp;\tif ((erun-runs)&1)\t    *erun++ = 0;\tx = 0;\tfor (; runs < erun; runs += 2) {\t    run = runs[0];\t    if (x+run > lastx || run > lastx )\t\trun = runs[0] = (uint32) (lastx - x);\t    if (run) {\t\tcp = buf + (x>>3);\t\tbx = x&7;\t\tif (run > 8-bx) {\t\t    if (bx) {\t\t\t\t\t\t*cp++ &= 0xff << (8-bx);\t\t\trun -= 8-bx;\t\t    }\t\t    if( (n = run >> 3) != 0 ) {\t\t\t\tif ((n/sizeof (long)) > 1) {\t\t\t    \t\t\t    for (; n && !isAligned(cp, long); n--)\t\t\t\t    *cp++ = 0x00;\t\t\t    lp = (long*) cp;\t\t\t    nw = (int32)(n / sizeof (long));\t\t\t    n -= nw * sizeof (long);\t\t\t    do {\t\t\t\t    *lp++ = 0L;\t\t\t    } while (--nw);\t\t\t    cp = (unsigned char*) lp;\t\t\t}\t\t\tZERO(n, cp);\t\t\trun &= 7;\t\t    }\t\t    if (run)\t\t\tcp[0] &= 0xff >> run;\t\t} else\t\t    cp[0] &= ~(_fillmasks[run]>>bx);\t\tx += runs[0];\t    }\t    run = runs[1];\t    if (x+run > lastx || run > lastx )\t\trun = runs[1] = lastx - x;\t    if (run) {\t\tcp = buf + (x>>3);\t\tbx = x&7;\t\tif (run > 8-bx) {\t\t    if (bx) {\t\t\t\t\t\t*cp++ |= 0xff >> bx;\t\t\trun -= 8-bx;\t\t    }\t\t    if( (n = run>>3) != 0 ) {\t\t\t\tif ((n/sizeof (long)) > 1) {\t\t\t    \t\t\t    for (; n && !isAligned(cp, long); n--)\t\t\t\t*cp++ = 0xff;\t\t\t    lp = (long*) cp;\t\t\t    nw = (int32)(n / sizeof (long));\t\t\t    n -= nw * sizeof (long);\t\t\t    do {\t\t\t\t*lp++ = -1L;\t\t\t    } while (--nw);\t\t\t    cp = (unsigned char*) lp;\t\t\t}\t\t\tFILL(n, cp);\t\t\trun &= 7;\t\t    }                    \t\t    if (run)\t\t\tcp[0] = (unsigned char)((cp[0] | (0xff00 >> run))&0xff);\t\t} else\t\t    cp[0] |= _fillmasks[run]>>bx;\t\tx += runs[1];\t    }\t}\tassert(x == lastx);}",
        "label": 1,
        "cve": "cve-2016-5323"
    },
    {
        "code": "voidTIFFSwabArrayOfFloat(register float* fp, tmsize_t n){\tregister unsigned char *cp;\tregister unsigned char t;\tassert(sizeof(float)==4);\t\twhile (n-- > 0) {\t\tcp = (unsigned char *)fp;\t\tt = cp[3]; cp[3] = cp[0]; cp[0] = t;\t\tt = cp[2]; cp[2] = cp[1]; cp[1] = t;\t\tfp++;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidFax3PutBits(TIFF* tif, unsigned int bits, unsigned int length){\tFax3CodecState* sp = EncoderState(tif);\tunsigned int bit = sp->bit;\tint data = sp->data;\t_PutBits(tif, bits, length);\tsp->data = data;\tsp->bit = bit;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tmsize_tTIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size){\tstatic const char module[] = \"TIFFReadEncodedStrip\";\tTIFFDirectory *td = &tif->tif_dir;\tuint32 rowsperstrip;\tuint32 stripsperplane;\tuint32 stripinplane;\tuint16 plane;\tuint32 rows;\ttmsize_t stripsize;\tif (!TIFFCheckRead(tif,0))\t\treturn((tmsize_t)(-1));\tif (strip>=td->td_nstrips)\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\t\t    \"%lu: Strip out of range, max %lu\",(unsigned long)strip,\t\t    (unsigned long)td->td_nstrips);\t\treturn((tmsize_t)(-1));\t}\t\trowsperstrip=td->td_rowsperstrip;\tif (rowsperstrip>td->td_imagelength)\t\trowsperstrip=td->td_imagelength;\tstripsperplane=((td->td_imagelength+rowsperstrip-1)/rowsperstrip);\tstripinplane=(strip%stripsperplane);\tplane=(uint16)(strip/stripsperplane);\trows=td->td_imagelength-stripinplane*rowsperstrip;\tif (rows>rowsperstrip)\t\trows=rowsperstrip;\tstripsize=TIFFVStripSize(tif,rows);\tif (stripsize==0)\t\treturn((tmsize_t)(-1));        if( td->td_compression == COMPRESSION_NONE &&        size!=(tmsize_t)(-1) && size >= stripsize &&        !isMapped(tif) &&        ((tif->tif_flags&TIFF_NOREADRAW)==0) )    {        if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize)            return ((tmsize_t)(-1));        if (!isFillOrder(tif, td->td_fillorder) &&            (tif->tif_flags & TIFF_NOBITREV) == 0)            TIFFReverseBits(buf,stripsize);        (*tif->tif_postdecode)(tif,buf,stripsize);        return (stripsize);    }\tif ((size!=(tmsize_t)(-1))&&(size<stripsize))\t\tstripsize=size;\tif (!TIFFFillStrip(tif,strip))\t\treturn((tmsize_t)(-1));\tif ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0)\t\treturn((tmsize_t)(-1));\t(*tif->tif_postdecode)(tif,buf,stripsize);\treturn(stripsize);}",
        "label": 1,
        "cve": "cve-2016-10266"
    },
    {
        "code": "static intcombineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 cols,                              uint32 rows, uint16 spp, uint16 bps, \t                      FILE *dumpfile, int format, int level)  {  int    ready_bits = 0 ;  uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;  uint32 src_byte = 0, src_bit = 0;  uint32 row, col;  uint32 longbuff1 = 0, longbuff2 = 0;  uint64 maskbits = 0, matchbits = 0;  uint64 buff1 = 0, buff2 = 0, buff3 = 0;  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;  tsample_t s;  unsigned char *src = in[0];  unsigned char *dst = out;  char           action[8];  if ((src == NULL) || (dst == NULL))    {    TIFFError(\"combineSeparateSamples32bits\",\"Invalid input or output buffer\");    return (1);    }     src_rowsize = ((bps * cols) + 7) / 8;  dst_rowsize = ((bps * cols * spp) + 7) / 8;  maskbits =  (uint64)-1 >> ( 64 - bps);     for (row = 0; row < rows; row++)    {    ready_bits = 0;    buff1 = buff2 = 0;    dst = out + (row * dst_rowsize);    src_offset = row * src_rowsize;    for (col = 0; col < cols; col++)      {            bit_offset = col * bps;      src_byte = bit_offset / 8;      src_bit  = bit_offset % 8;      matchbits = maskbits << (64 - src_bit - bps);       for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\t{\tsrc = in[s] + src_offset + src_byte;\tif (little_endian)\t  {\t  longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];          longbuff2 = longbuff1;\t  }\telse\t  {\t  longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];          longbuff2 = longbuff1;\t  }\tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;\tbuff1 = (buff3 & matchbits) << (src_bit);\t\tif (ready_bits >= 32)\t  {\t  bytebuff1 = (buff2 >> 56);\t  *dst++ = bytebuff1;\t  bytebuff2 = (buff2 >> 48);\t  *dst++ = bytebuff2;\t  bytebuff3 = (buff2 >> 40);\t  *dst++ = bytebuff3;\t  bytebuff4 = (buff2 >> 32);\t  *dst++ = bytebuff4;\t  ready_bits -= 32;\t  \t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\t  strcpy (action, \"Flush\");\t  }\telse\t  { \t  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\t  buff2 = (buff2 | (buff1 >> ready_bits));\t  strcpy (action, \"Update\");\t  }\tready_bits += bps;\tif ((dumpfile != NULL) && (level == 3))\t  { \t  dump_info (dumpfile, format, \"\",\t\t     \"Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);\t  dump_wide (dumpfile, format, \"Match bits \", matchbits);\t  dump_data (dumpfile, format, \"Src   bits \", src, 8);\t  dump_wide (dumpfile, format, \"Buff1 bits \", buff1);\t  dump_wide (dumpfile, format, \"Buff2 bits \", buff2);\t  dump_info (dumpfile, format, \"\", \"Ready bits:   %d, %s\", ready_bits, action); \t  }\t}      }    while (ready_bits > 0)      {      bytebuff1 = (buff2 >> 56);      *dst++ = bytebuff1;      buff2 = (buff2 << 8);      ready_bits -= 8;      }    if ((dumpfile != NULL) && (level == 3))      {      dump_info (dumpfile, format, \"\",\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\t\t row + 1, col + 1, src_byte, src_bit, dst - out);      dump_long (dumpfile, format, \"Match bits \", matchbits);      dump_data (dumpfile, format, \"Src   bits \", src, 4);      dump_long (dumpfile, format, \"Buff1 bits \", buff1);      dump_long (dumpfile, format, \"Buff2 bits \", buff2);      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits);       }    if ((dumpfile != NULL) && (level == 2))      {      dump_info (dumpfile, format, \"combineSeparateSamples32bits\",\"Output data\");      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);      }    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static unsigned char cluster_128[] = { 44, 40, 63, 59, 230, 95 };static int check_cluster( int cluster, unsigned char *buffer, unsigned char *expected_cluster ) {\tunsigned char *target = buffer + cluster*6;\tif (memcmp(target, expected_cluster, 6) == 0) {\t\treturn 0;\t}\tfprintf( stderr, \"Cluster %d did not match expected results.\\n\", cluster );\tfprintf( stderr, \t\t \"Expect: %3d %3d   %3d   %3d\\n\"\t\t \"        %3d %3d\\n\", \t\t expected_cluster[0], expected_cluster[1],\t\t expected_cluster[4], expected_cluster[5],\t\t expected_cluster[2], expected_cluster[3] );\tfprintf( stderr, \t\t \"   Got: %3d %3d   %3d   %3d\\n\"\t\t \"        %3d %3d\\n\", \t\t target[0], target[1], \t\t target[4], target[5],\t\t target[2], target[3] );\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char* argv[])  {#if !HAVE_DECL_OPTARG  extern int optind;#endif  uint16 defconfig = (uint16) -1;  uint16 deffillorder = 0;  uint32 deftilewidth = (uint32) 0;  uint32 deftilelength = (uint32) 0;  uint32 defrowsperstrip = (uint32) 0;  uint32 dirnum = 0;  TIFF *in = NULL;  TIFF *out = NULL;  char  mode[10];  char *mp = mode;    struct image_data image;       struct crop_mask  crop;        struct pagedef    page;        struct pageseg    sections[MAX_SECTIONS];    struct buffinfo   seg_buffs[MAX_SECTIONS];   struct dump_opts  dump;                    unsigned char *read_buff    = NULL;        unsigned char *crop_buff    = NULL;        unsigned char *sect_buff    = NULL;        unsigned char *sect_src     = NULL;        unsigned int  imagelist[MAX_IMAGES + 1];   unsigned int  image_count  = 0;  unsigned int  dump_images  = 0;  unsigned int  next_image   = 0;  unsigned int  next_page    = 0;  unsigned int  total_pages  = 0;  unsigned int  total_images = 0;  unsigned int  end_of_input = FALSE;  int    seg, length;  char   temp_filename[PATH_MAX + 1];  little_endian = *((unsigned char *)&little_endian) & '1';  initImageData(&image);  initCropMasks(&crop);  initPageSetup(&page, sections, seg_buffs);  initDumpOptions(&dump);  process_command_opts (argc, argv, mp, mode, &dirnum, &defconfig,                         &deffillorder, &deftilewidth, &deftilelength, &defrowsperstrip,\t                &crop, &page, &dump, imagelist, &image_count);  if (argc - optind < 2)    usage();  if ((argc - optind) == 2)    pageNum = -1;  else    total_images = 0;    while (optind < argc - 1)    {    in = TIFFOpen (argv[optind], \"r\");    if (in == NULL)      return (-3);        total_images = TIFFNumberOfDirectories(in);     if (image_count == 0)      {      dirnum = 0;      total_pages = total_images;       }    else      {      dirnum = (tdir_t)(imagelist[next_image] - 1);      next_image++;            if (image_count >  total_images)\timage_count = total_images;      total_pages = image_count;      }        if (dirnum == (MAX_IMAGES - 1))      dirnum = total_images - 1;    if (dirnum > (total_images))      {      TIFFError (TIFFFileName(in),       \"Invalid image number %d, File contains only %d images\", \t\t (int)dirnum + 1, total_images);      if (out != NULL)        (void) TIFFClose(out);      return (1);      }    if (dirnum != 0 && !TIFFSetDirectory(in, (tdir_t)dirnum))      {      TIFFError(TIFFFileName(in),\"Error, setting subdirectory at %d\", dirnum);      if (out != NULL)        (void) TIFFClose(out);      return (1);      }    end_of_input = FALSE;    while (end_of_input == FALSE)      {      config = defconfig;      compression = defcompression;      predictor = defpredictor;      fillorder = deffillorder;      rowsperstrip = defrowsperstrip;      tilewidth = deftilewidth;      tilelength = deftilelength;      g3opts = defg3opts;      if (dump.format != DUMP_NONE)        {        \tdump_images++;        length = strlen(dump.infilename);        if (length > 0)          {          if (dump.infile != NULL)            fclose (dump.infile);                     snprintf(temp_filename, sizeof(temp_filename), \"%s-read-%03d.%s\",\t\t   dump.infilename, dump_images,                  (dump.format == DUMP_TEXT) ? \"txt\" : \"raw\");          if ((dump.infile = fopen(temp_filename, dump.mode)) == NULL)            {\t    TIFFError (\"Unable to open dump file for writing\", \"%s\", temp_filename);\t    exit (-1);            }          dump_info(dump.infile, dump.format, \"Reading image\",\"%d from %s\",                     dump_images, TIFFFileName(in));          }         length = strlen(dump.outfilename);        if (length > 0)          {          if (dump.outfile != NULL)            fclose (dump.outfile);                     snprintf(temp_filename, sizeof(temp_filename), \"%s-write-%03d.%s\",\t\t   dump.outfilename, dump_images,                  (dump.format == DUMP_TEXT) ? \"txt\" : \"raw\");          if ((dump.outfile = fopen(temp_filename, dump.mode)) == NULL)            {\t      TIFFError (\"Unable to open dump file for writing\", \"%s\", temp_filename);\t    exit (-1);            }          dump_info(dump.outfile, dump.format, \"Writing image\",\"%d from %s\",                     dump_images, TIFFFileName(in));          }         }      if (dump.debug)         TIFFError(\"main\", \"Reading image %4d of %4d total pages.\", dirnum + 1, total_pages);      if (loadImage(in, &image, &dump, &read_buff))        {        TIFFError(\"main\", \"Unable to load source image\");        exit (-1);        }            if (image.adjustments != 0)        {\tif (correct_orientation(&image, &read_buff))\t    TIFFError(\"main\", \"Unable to correct image orientation\");        }      if (getCropOffsets(&image, &crop, &dump))        {        TIFFError(\"main\", \"Unable to define crop regions\");        exit (-1);\t}      if (crop.selections > 0)        {        if (processCropSelections(&image, &crop, &read_buff, seg_buffs))          {          TIFFError(\"main\", \"Unable to process image selections\");          exit (-1);\t  }\t}      else          {        if (createCroppedImage(&image, &crop, &read_buff, &crop_buff))          {          TIFFError(\"main\", \"Unable to create output image\");          exit (-1);\t  }\t}      if (page.mode == PAGE_MODE_NONE)        {          if (crop.selections > 0)          {\t  writeSelections(in, &out, &crop, &image, &dump, seg_buffs,                          mp, argv[argc - 1], &next_page, total_pages);          }\telse            {\t  if (update_output_file (&out, mp, crop.exp_mode, argv[argc - 1],                                  &next_page))             exit (1);          if (writeCroppedImage(in, out, &image, &dump,crop.combined_width,                                 crop.combined_length, crop_buff, next_page, total_pages))            {             TIFFError(\"main\", \"Unable to write new image\");             exit (-1);\t    }          }\t}      else        {\t\tif (crop_buff != NULL)  \t  sect_src = crop_buff;        else          sect_src = read_buff;                if (computeOutputPixelOffsets(&crop, &image, &page, sections, &dump))          {          TIFFError(\"main\", \"Unable to compute output section data\");          exit (-1);\t  }        \tif (update_output_file (&out, mp, crop.exp_mode, argv[argc - 1], &next_page))          exit (1);\tif (writeImageSections(in, out, &image, &page, sections, &dump, sect_src, &sect_buff))          {          TIFFError(\"main\", \"Unable to write image sections\");          exit (-1);\t  }        }            if (image_count == 0)        dirnum++;      else        {\tdirnum = (tdir_t)(imagelist[next_image] - 1);        next_image++;        }      if (dirnum == MAX_IMAGES - 1)        dirnum = TIFFNumberOfDirectories(in) - 1;      if (!TIFFSetDirectory(in, (tdir_t)dirnum))        end_of_input = TRUE;      }    TIFFClose(in);    optind++;    }    if (read_buff)    _TIFFfree(read_buff);  if (crop_buff)    _TIFFfree(crop_buff);  if (sect_buff)    _TIFFfree(sect_buff);     for (seg = 0; seg < crop.selections; seg++)    _TIFFfree (seg_buffs[seg].buffer);  if (dump.format != DUMP_NONE)    {    if (dump.infile != NULL)     fclose (dump.infile);    if (dump.outfile != NULL)      {      dump_info (dump.outfile, dump.format, \"\", \"Completed run for %s\", TIFFFileName(out));      fclose (dump.outfile);      }    }  TIFFClose(out);  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFPredictorCleanup(TIFF* tif){\tTIFFPredictorState* sp = PredictorState(tif);\tassert(sp != 0);\ttif->tif_tagmethods.vgetfield = sp->vgetparent;\ttif->tif_tagmethods.vsetfield = sp->vsetparent;\ttif->tif_tagmethods.printdir = sp->printdir;\ttif->tif_setupdecode = sp->setupdecode;\ttif->tif_setupencode = sp->setupencode;\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static uint64checkMultiply64(uint64 first, uint64 second, T2P* t2p){\tuint64 bytes = first * second;\tif (second && bytes / second != first) {\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\tbytes = 0;\t}\treturn bytes;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static Colorbox *largest_box(void){\tregister Colorbox *p, *b;\tregister uint32 size;\tb = NULL;\tsize = 0;\tfor (p = usedboxes; p != NULL; p = p->next)\t\tif ((p->rmax > p->rmin || p->gmax > p->gmin ||\t\t    p->bmax > p->bmin) &&  p->total > size)\t\t        size = (b = p)->total;\treturn (b);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFReadSeparateTileData(TIFF* tif){\tunsigned char *buf;\ttsize_t rowsize = TIFFTileRowSize(tif);\tbuf = (unsigned char *)_TIFFmalloc(TIFFTileSize(tif));\tif (buf) {\t\tuint32 tw, th, w, h;\t\tuint32 row, col;\t\ttsample_t s, samplesperpixel;\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\t\tfor (row = 0; row < h; row += th) {\t\t\tfor (col = 0; col < w; col += tw) {\t\t\t\tfor (s = 0; s < samplesperpixel; s++) {\t\t\t\t\tif (TIFFReadTile(tif, buf, col, row, 0, s) < 0) {\t\t\t\t\t\tif (stoponerr)\t\t\t\t\t\t\tbreak;\t\t\t\t\t} else if (showdata)\t\t\t\t\t\tShowTile(row, col, s, buf, th, rowsize);\t\t\t\t}\t\t\t}\t\t}\t\t_TIFFfree(buf);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static C_cell *create_colorcell(int red, int green, int blue){\tregister int ir, ig, ib, i;\tregister C_cell *ptr;\tint mindist, next_n;\tregister int tmp, dist, n;\tir = red >> (COLOR_DEPTH-C_DEPTH);\tig = green >> (COLOR_DEPTH-C_DEPTH);\tib = blue >> (COLOR_DEPTH-C_DEPTH);\tptr = (C_cell *)_TIFFmalloc(sizeof (C_cell));\t*(ColorCells + ir*C_LEN*C_LEN + ig*C_LEN + ib) = ptr;\tptr->num_ents = 0;\t\tmindist = 99999999;\tfor (i = 0; i < num_colors; ++i) {\t\tif (rm[i]>>(COLOR_DEPTH-C_DEPTH) != ir  ||\t\t    gm[i]>>(COLOR_DEPTH-C_DEPTH) != ig  ||\t\t    bm[i]>>(COLOR_DEPTH-C_DEPTH) != ib)\t\t\tcontinue;\t\tptr->entries[ptr->num_ents][0] = i;\t\tptr->entries[ptr->num_ents][1] = 0;\t\t++ptr->num_ents;\t        tmp = rm[i] - red;\t        if (tmp < (MAX_COLOR/C_LEN/2))\t\t\ttmp = MAX_COLOR/C_LEN-1 - tmp;\t        dist = tmp*tmp;\t        tmp = gm[i] - green;\t        if (tmp < (MAX_COLOR/C_LEN/2))\t\t\ttmp = MAX_COLOR/C_LEN-1 - tmp;\t        dist += tmp*tmp;\t        tmp = bm[i] - blue;\t        if (tmp < (MAX_COLOR/C_LEN/2))\t\t\ttmp = MAX_COLOR/C_LEN-1 - tmp;\t        dist += tmp*tmp;\t        if (dist < mindist)\t\t\tmindist = dist;\t}\t\tfor (i = 0; i < num_colors; ++i) {\t\tif (rm[i] >> (COLOR_DEPTH-C_DEPTH) == ir  &&\t\t    gm[i] >> (COLOR_DEPTH-C_DEPTH) == ig  &&\t\t    bm[i] >> (COLOR_DEPTH-C_DEPTH) == ib)\t\t\tcontinue;\t\tdist = 0;\t        if ((tmp = red - rm[i]) > 0 ||\t\t    (tmp = rm[i] - (red + MAX_COLOR/C_LEN-1)) > 0 )\t\t\tdist += tmp*tmp;\t        if ((tmp = green - gm[i]) > 0 ||\t\t    (tmp = gm[i] - (green + MAX_COLOR/C_LEN-1)) > 0 )\t\t\tdist += tmp*tmp;\t        if ((tmp = blue - bm[i]) > 0 ||\t\t    (tmp = bm[i] - (blue + MAX_COLOR/C_LEN-1)) > 0 )\t\t\tdist += tmp*tmp;\t        if (dist < mindist) {\t\t\tptr->entries[ptr->num_ents][0] = i;\t\t\tptr->entries[ptr->num_ents][1] = dist;\t\t\t++ptr->num_ents;\t        }\t}\t\tfor (n = ptr->num_ents - 1; n > 0; n = next_n) {\t\tnext_n = 0;\t\tfor (i = 0; i < n; ++i)\t\t\tif (ptr->entries[i][1] > ptr->entries[i+1][1]) {\t\t\t\ttmp = ptr->entries[i][0];\t\t\t\tptr->entries[i][0] = ptr->entries[i+1][0];\t\t\t\tptr->entries[i+1][0] = tmp;\t\t\t\ttmp = ptr->entries[i][1];\t\t\t\tptr->entries[i][1] = ptr->entries[i+1][1];\t\t\t\tptr->entries[i+1][1] = tmp;\t\t\t\tnext_n = i;\t\t        }\t}\treturn (ptr);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intget_page_geometry (char *name, struct pagedef *page)    {    char *ptr;    int n;     for (ptr = name; *ptr; ptr++)      *ptr = (char)tolower((int)*ptr);    for (n = 0; n < MAX_PAPERNAMES; n++)      {      if (strcmp(name, PaperTable[n].name) == 0)        {\tpage->width = PaperTable[n].width;\tpage->length = PaperTable[n].length;        strncpy (page->name, PaperTable[n].name, 15);        page->name[15] = '\\0';        return (0);        }      }  return (1);  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*TIFFOpen(const char* name, const char* mode){\tstatic const char module[] = \"TIFFOpen\";\tint m, fd;\tm = _TIFFgetMode(mode, module);\tif (m == -1)\t{\t\treturn ((TIFF*) 0);\t}\tfd = open(name, 0, m);\tif (fd < 0)\t{\t\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\t\treturn ((TIFF *)0);\t}\treturn (TIFFFdOpen(fd, name, mode));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap){\tTIFFDirectory* td = &tif->tif_dir;\tint ret_val = 1;\tuint32 standard_tag = tag;\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\tif( fip == NULL ) \t    return 0;\t\t\tif (fip->field_bit == FIELD_CUSTOM) {\t\tstandard_tag = 0;\t}\tswitch (standard_tag) {\t\tcase TIFFTAG_SUBFILETYPE:\t\t\t*va_arg(ap, uint32*) = td->td_subfiletype;\t\t\tbreak;\t\tcase TIFFTAG_IMAGEWIDTH:\t\t\t*va_arg(ap, uint32*) = td->td_imagewidth;\t\t\tbreak;\t\tcase TIFFTAG_IMAGELENGTH:\t\t\t*va_arg(ap, uint32*) = td->td_imagelength;\t\t\tbreak;\t\tcase TIFFTAG_BITSPERSAMPLE:\t\t\t*va_arg(ap, uint16*) = td->td_bitspersample;\t\t\tbreak;\t\tcase TIFFTAG_COMPRESSION:\t\t\t*va_arg(ap, uint16*) = td->td_compression;\t\t\tbreak;\t\tcase TIFFTAG_PHOTOMETRIC:\t\t\t*va_arg(ap, uint16*) = td->td_photometric;\t\t\tbreak;\t\tcase TIFFTAG_THRESHHOLDING:\t\t\t*va_arg(ap, uint16*) = td->td_threshholding;\t\t\tbreak;\t\tcase TIFFTAG_FILLORDER:\t\t\t*va_arg(ap, uint16*) = td->td_fillorder;\t\t\tbreak;\t\tcase TIFFTAG_ORIENTATION:\t\t\t*va_arg(ap, uint16*) = td->td_orientation;\t\t\tbreak;\t\tcase TIFFTAG_SAMPLESPERPIXEL:\t\t\t*va_arg(ap, uint16*) = td->td_samplesperpixel;\t\t\tbreak;\t\tcase TIFFTAG_ROWSPERSTRIP:\t\t\t*va_arg(ap, uint32*) = td->td_rowsperstrip;\t\t\tbreak;\t\tcase TIFFTAG_MINSAMPLEVALUE:\t\t\t*va_arg(ap, uint16*) = td->td_minsamplevalue;\t\t\tbreak;\t\tcase TIFFTAG_MAXSAMPLEVALUE:\t\t\t*va_arg(ap, uint16*) = td->td_maxsamplevalue;\t\t\tbreak;\t\tcase TIFFTAG_SMINSAMPLEVALUE:\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\t\t\t\t*va_arg(ap, double**) = td->td_sminsamplevalue;\t\t\telse\t\t\t{\t\t\t\t\t\t\t\tuint16 i;\t\t\t\tdouble v = td->td_sminsamplevalue[0];\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\t\t\t\t\tif( td->td_sminsamplevalue[i] < v )\t\t\t\t\t\tv = td->td_sminsamplevalue[i];\t\t\t\t*va_arg(ap, double*) = v;\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\t\t\t\t*va_arg(ap, double**) = td->td_smaxsamplevalue;\t\t\telse\t\t\t{\t\t\t\t\t\t\t\tuint16 i;\t\t\t\tdouble v = td->td_smaxsamplevalue[0];\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\t\t\t\t\tif( td->td_smaxsamplevalue[i] > v )\t\t\t\t\t\tv = td->td_smaxsamplevalue[i];\t\t\t\t*va_arg(ap, double*) = v;\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_XRESOLUTION:\t\t\t*va_arg(ap, float*) = td->td_xresolution;\t\t\tbreak;\t\tcase TIFFTAG_YRESOLUTION:\t\t\t*va_arg(ap, float*) = td->td_yresolution;\t\t\tbreak;\t\tcase TIFFTAG_PLANARCONFIG:\t\t\t*va_arg(ap, uint16*) = td->td_planarconfig;\t\t\tbreak;\t\tcase TIFFTAG_XPOSITION:\t\t\t*va_arg(ap, float*) = td->td_xposition;\t\t\tbreak;\t\tcase TIFFTAG_YPOSITION:\t\t\t*va_arg(ap, float*) = td->td_yposition;\t\t\tbreak;\t\tcase TIFFTAG_RESOLUTIONUNIT:\t\t\t*va_arg(ap, uint16*) = td->td_resolutionunit;\t\t\tbreak;\t\tcase TIFFTAG_PAGENUMBER:\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[0];\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[1];\t\t\tbreak;\t\tcase TIFFTAG_HALFTONEHINTS:\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[0];\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[1];\t\t\tbreak;\t\tcase TIFFTAG_COLORMAP:\t\t\t*va_arg(ap, uint16**) = td->td_colormap[0];\t\t\t*va_arg(ap, uint16**) = td->td_colormap[1];\t\t\t*va_arg(ap, uint16**) = td->td_colormap[2];\t\t\tbreak;\t\tcase TIFFTAG_STRIPOFFSETS:\t\tcase TIFFTAG_TILEOFFSETS:\t\t\t_TIFFFillStriles( tif );\t\t\t*va_arg(ap, uint64**) = td->td_stripoffset;\t\t\tbreak;\t\tcase TIFFTAG_STRIPBYTECOUNTS:\t\tcase TIFFTAG_TILEBYTECOUNTS:\t\t\t_TIFFFillStriles( tif );\t\t\t*va_arg(ap, uint64**) = td->td_stripbytecount;\t\t\tbreak;\t\tcase TIFFTAG_MATTEING:\t\t\t*va_arg(ap, uint16*) =\t\t\t    (td->td_extrasamples == 1 &&\t\t\t    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\t\t\tbreak;\t\tcase TIFFTAG_EXTRASAMPLES:\t\t\t*va_arg(ap, uint16*) = td->td_extrasamples;\t\t\t*va_arg(ap, uint16**) = td->td_sampleinfo;\t\t\tbreak;\t\tcase TIFFTAG_TILEWIDTH:\t\t\t*va_arg(ap, uint32*) = td->td_tilewidth;\t\t\tbreak;\t\tcase TIFFTAG_TILELENGTH:\t\t\t*va_arg(ap, uint32*) = td->td_tilelength;\t\t\tbreak;\t\tcase TIFFTAG_TILEDEPTH:\t\t\t*va_arg(ap, uint32*) = td->td_tiledepth;\t\t\tbreak;\t\tcase TIFFTAG_DATATYPE:\t\t\tswitch (td->td_sampleformat) {\t\t\t\tcase SAMPLEFORMAT_UINT:\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_UINT;\t\t\t\t\tbreak;\t\t\t\tcase SAMPLEFORMAT_INT:\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_INT;\t\t\t\t\tbreak;\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_IEEEFP;\t\t\t\t\tbreak;\t\t\t\tcase SAMPLEFORMAT_VOID:\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_VOID;\t\t\t\t\tbreak;\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_SAMPLEFORMAT:\t\t\t*va_arg(ap, uint16*) = td->td_sampleformat;\t\t\tbreak;\t\tcase TIFFTAG_IMAGEDEPTH:\t\t\t*va_arg(ap, uint32*) = td->td_imagedepth;\t\t\tbreak;\t\tcase TIFFTAG_SUBIFD:\t\t\t*va_arg(ap, uint16*) = td->td_nsubifd;\t\t\t*va_arg(ap, uint64**) = td->td_subifd;\t\t\tbreak;\t\tcase TIFFTAG_YCBCRPOSITIONING:\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrpositioning;\t\t\tbreak;\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];\t\t\tbreak;\t\tcase TIFFTAG_TRANSFERFUNCTION:\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[0];\t\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[1];\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[2];\t\t\t}\t\t\tbreak;\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\t\t\t*va_arg(ap, float**) = td->td_refblackwhite;\t\t\tbreak;\t\tcase TIFFTAG_INKNAMES:\t\t\t*va_arg(ap, char**) = td->td_inknames;\t\t\tbreak;\t\tdefault:\t\t\t{\t\t\t\tint i;\t\t\t\t\t\t\t\tif( fip->field_bit != FIELD_CUSTOM )\t\t\t\t{\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFVGetField\",\t\t\t\t\t    \"%s: Invalid %stag \\\"%s\\\" \"\t\t\t\t\t    \"(not supported by codec)\",\t\t\t\t\t    tif->tif_name,\t\t\t\t\t    isPseudoTag(tag) ? \"pseudo-\" : \"\",\t\t\t\t\t    fip->field_name);\t\t\t\t\tret_val = 0;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\t\t\t\t\tret_val = 0;\t\t\t\tfor (i = 0; i < td->td_customValueCount; i++) {\t\t\t\t\tTIFFTagValue *tv = td->td_customValues + i;\t\t\t\t\tif (tv->info->field_tag != tag)\t\t\t\t\t\tcontinue;\t\t\t\t\tif (fip->field_passcount) {\t\t\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2)\t\t\t\t\t\t\t*va_arg(ap, uint32*) = (uint32)tv->count;\t\t\t\t\t\telse  \t\t\t\t\t\t\t*va_arg(ap, uint16*) = (uint16)tv->count;\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\t\t\t\t\t\tret_val = 1;\t\t\t\t\t} else if (fip->field_tag == TIFFTAG_DOTRANGE\t\t\t\t\t\t   && strcmp(fip->field_name,\"DotRange\") == 0) {\t\t\t\t\t\t\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];\t\t\t\t\t\tret_val = 1;\t\t\t\t\t} else {\t\t\t\t\t\tif (fip->field_type == TIFF_ASCII\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2\t\t\t\t\t\t    || fip->field_readcount == TIFF_SPP\t\t\t\t\t\t    || tv->count > 1) {\t\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t} else {\t\t\t\t\t\t\tchar *val = (char *)tv->value;\t\t\t\t\t\t\tassert( tv->count == 1 );\t\t\t\t\t\t\tswitch (fip->field_type) {\t\t\t\t\t\t\tcase TIFF_BYTE:\t\t\t\t\t\t\tcase TIFF_UNDEFINED:\t\t\t\t\t\t\t\t*va_arg(ap, uint8*) =\t\t\t\t\t\t\t\t\t*(uint8 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SBYTE:\t\t\t\t\t\t\t\t*va_arg(ap, int8*) =\t\t\t\t\t\t\t\t\t*(int8 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SHORT:\t\t\t\t\t\t\t\t*va_arg(ap, uint16*) =\t\t\t\t\t\t\t\t\t*(uint16 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SSHORT:\t\t\t\t\t\t\t\t*va_arg(ap, int16*) =\t\t\t\t\t\t\t\t\t*(int16 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_LONG:\t\t\t\t\t\t\tcase TIFF_IFD:\t\t\t\t\t\t\t\t*va_arg(ap, uint32*) =\t\t\t\t\t\t\t\t\t*(uint32 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SLONG:\t\t\t\t\t\t\t\t*va_arg(ap, int32*) =\t\t\t\t\t\t\t\t\t*(int32 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_LONG8:\t\t\t\t\t\t\tcase TIFF_IFD8:\t\t\t\t\t\t\t\t*va_arg(ap, uint64*) =\t\t\t\t\t\t\t\t\t*(uint64 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SLONG8:\t\t\t\t\t\t\t\t*va_arg(ap, int64*) =\t\t\t\t\t\t\t\t\t*(int64 *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_RATIONAL:\t\t\t\t\t\t\tcase TIFF_SRATIONAL:\t\t\t\t\t\t\tcase TIFF_FLOAT:\t\t\t\t\t\t\t\t*va_arg(ap, float*) =\t\t\t\t\t\t\t\t\t*(float *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_DOUBLE:\t\t\t\t\t\t\t\t*va_arg(ap, double*) =\t\t\t\t\t\t\t\t\t*(double *)val;\t\t\t\t\t\t\t\tret_val = 1;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tdefault:\t\t\t\t\t\t\t\tret_val = 0;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t}\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t}\treturn(ret_val);}",
        "label": 1,
        "cve": "cve-2016-10095"
    },
    {
        "code": "static voidcpTags(TIFF* in, TIFF* out){    struct cpTag *p;    for (p = tags; p < &tags[NTAGS]; p++)\tcpTag(in, out, p->tag, p->count, p->type);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intread_strips(TIFF *tif, const tdata_t array, const tsize_t size){\ttstrip_t\tstrip, nstrips;\ttsize_t\t\tstripsize, offset;\ttdata_t\t\tbuf = NULL;\tstripsize = TIFFStripSize(tif);\tif (!stripsize) {\t\tfprintf (stderr, \"Wrong size of strip.\\n\");\t\treturn -1;\t}\tbuf = _TIFFmalloc(stripsize);\tif (!buf) {\t\tfprintf (stderr, \"Can't allocate space for strip buffer.\\n\");\t\treturn -1;\t}\tnstrips = TIFFNumberOfStrips(tif);\tfor (offset = 0, strip = 0;\t     offset < size && strip < nstrips;\t     offset+=stripsize, strip++) {\t\t\t\ttsize_t\tbufsize = size - offset;\t\tif (bufsize > stripsize)\t\t\tbufsize = stripsize;\t\tif (TIFFReadEncodedStrip(tif, strip, buf, -1) != bufsize) {\t\t\tfprintf (stderr, \"Can't read strip %lu.\\n\",\t\t\t\t (unsigned long)strip);\t\t\treturn -1;\t\t}\t\tif (memcmp(buf, (char *)array + offset, bufsize) != 0) {\t\t\tfprintf (stderr, \"Wrong data read for strip %lu.\\n\",\t\t\t\t (unsigned long)strip);\t\t\t_TIFFfree(buf);\t\t\treturn -1;\t\t}        }\t_TIFFfree(buf);\treturn 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static float*setupLuma(float c){    float *v = (float *)_TIFFmalloc(256 * sizeof (float));    int i;    for (i = 0; i < 256; i++)\tv[i] = c * i;    return (v);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tmsize_tmultiply_ms(tmsize_t m1, tmsize_t m2){        if( m1 == 0 || m2 > TIFF_TMSIZE_T_MAX / m1 )            return 0;        return m1 * m2;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size){\t(void) fd; (void) base; (void) size;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFCvtNativeToIEEEFloat(TIFF* tif, u_int n, float* f){\tfloat_t* fp = (float_t*) f;\twhile (n-- > 0) {\t\tNATIVE2IEEEFLOAT(fp);\t\tfp++;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchPerSampleShorts(TIFF* tif, TIFFDirEntry* dir, int* pl){\tint samples = tif->tif_dir.td_samplesperpixel;\tint status = 0;\tif (CheckDirCount(tif, dir, (uint32) samples)) {\t\tuint16 buf[10];\t\tuint16* v = buf;\t\tif (samples > NITEMS(buf))\t\t\tv = (uint16*) _TIFFmalloc(samples * sizeof (uint16));\t\tif (TIFFFetchShortArray(tif, dir, v)) {\t\t\tint i;\t\t\tfor (i = 1; i < samples; i++)\t\t\t\tif (v[i] != v[0]) {\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t\"Cannot handle different per-sample values for field \\\"%s\\\"\",\t\t\t   _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t*pl = v[0];\t\t\tstatus = 1;\t\t}\tbad:\t\tif (v != buf)\t\t\t_TIFFfree((char*) v);\t}\treturn (status);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteDirectoryTagLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value){    static const char module[] = \"TIFFWriteDirectoryTagLongLong8Array\";    uint64* ma;    uint32 mb;    uint32* p;    uint32* q;    int o;        if (dir==NULL)    {        (*ndir)++;        return(1);    }        if( tif->tif_flags&TIFF_BIGTIFF )        return TIFFWriteDirectoryTagCheckedLong8Array(tif,ndir,dir,                                                      tag,count,value);        p = _TIFFmalloc(count*sizeof(uint32));    if (p==NULL)    {        TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");        return(0);    }    for (q=p, ma=value, mb=0; mb<count; ma++, mb++, q++)    {        if (*ma>0xFFFFFFFF)        {            TIFFErrorExt(tif->tif_clientdata,module,                         \"Attempt to write value larger than 0xFFFFFFFF in Classic TIFF file.\");            _TIFFfree(p);            return(0);        }        *q= (uint32)(*ma);    }    o=TIFFWriteDirectoryTagCheckedLongArray(tif,ndir,dir,tag,count,p);    _TIFFfree(p);    return(o);}",
        "label": 1,
        "cve": "cve-2016-3658"
    },
    {
        "code": "intmain(){\tTIFF\t\t*tif;\tsize_t\t\ti;\tunsigned char\tbuf[SPP] = { 0, 127, 255 };\t\ttif = TIFFOpen(filename, \"w\");\tif (!tif) {\t\tfprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename);\t\treturn 1;\t}\tif (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) {\t\tfprintf (stderr, \"Can't set ImageWidth tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) {\t\tfprintf (stderr, \"Can't set ImageLength tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps)) {\t\tfprintf (stderr, \"Can't set BitsPerSample tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, SPP)) {\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip)) {\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, planarconfig)) {\t\tfprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\");\t\tgoto failure;\t}\tif (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric)) {\t\tfprintf (stderr, \"Can't set PhotometricInterpretation tag.\\n\");\t\tgoto failure;\t}\tfor (i = 0; i < NSINGLETAGS; i++) {\t\tif (!TIFFSetField(tif, short_single_tags[i].tag,\t\t\t\t  short_single_tags[i].value)) {\t\t\tfprintf(stderr, \"Can't set tag %lu.\\n\",\t\t\t\t(unsigned long)short_single_tags[i].tag);\t\t\tgoto failure;\t\t}\t}\tfor (i = 0; i < NPAIREDTAGS; i++) {\t\tif (!TIFFSetField(tif, short_paired_tags[i].tag,\t\t\t\t  short_paired_tags[i].values[0],\t\t\t\t  short_paired_tags[i].values[1])) {\t\t\tfprintf(stderr, \"Can't set tag %lu.\\n\",\t\t\t\t(unsigned long)short_paired_tags[i].tag);\t\t\tgoto failure;\t\t}\t}\t\tif (TIFFWriteScanline(tif, buf, 0, 0) == -1) {\t\tfprintf (stderr, \"Can't write image data.\\n\");\t\tgoto failure;\t}\tTIFFClose(tif);\t\ttif = TIFFOpen(filename, \"r\");\tif (!tif) {\t\tfprintf (stderr, \"Can't open test TIFF file %s.\\n\", filename);\t\treturn 1;\t}\tif (CheckLongField(tif, TIFFTAG_IMAGEWIDTH, width) < 0)\t\tgoto failure;\tif (CheckLongField(tif, TIFFTAG_IMAGELENGTH, length) < 0)\t\tgoto failure;\tif (CheckShortField(tif, TIFFTAG_BITSPERSAMPLE, bps) < 0)\t\tgoto failure;\tif (CheckShortField(tif, TIFFTAG_PHOTOMETRIC, photometric) < 0)\t\tgoto failure;\tif (CheckShortField(tif, TIFFTAG_SAMPLESPERPIXEL, SPP) < 0)\t\tgoto failure;\tif (CheckLongField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip) < 0)\t\tgoto failure;\tif (CheckShortField(tif, TIFFTAG_PLANARCONFIG, planarconfig) < 0)\t\tgoto failure;\tfor (i = 0; i < NSINGLETAGS; i++) {\t\tif (CheckShortField(tif, short_single_tags[i].tag,\t\t\t\t    short_single_tags[i].value) < 0)\t\t\tgoto failure;\t}\tfor (i = 0; i < NPAIREDTAGS; i++) {\t\tif (CheckShortPairedField(tif, short_paired_tags[i].tag,\t\t\t\t\t  short_paired_tags[i].values) < 0)\t\t\tgoto failure;\t}\tTIFFClose(tif);\t\tunlink(filename);\treturn 0;failure:\t\tTIFFClose(tif);\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFFlushData(TIFF* tif){\tif ((tif->tif_flags & TIFF_BEENWRITING) == 0)\t\treturn (1);\tif (tif->tif_flags & TIFF_POSTENCODE) {\t\ttif->tif_flags &= ~TIFF_POSTENCODE;\t\tif (!(*tif->tif_postencode)(tif))\t\t\treturn (0);\t}\treturn (TIFFFlushData1(tif));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intprocessCompressOptions(char* opt){\tif (streq(opt, \"none\"))\t\tcompression = COMPRESSION_NONE;\telse if (streq(opt, \"packbits\"))\t\tcompression = COMPRESSION_PACKBITS;\telse if (strneq(opt, \"jpeg\", 4)) {\t\tchar* cp = strchr(opt, ':');                compression = COMPRESSION_JPEG;                while( cp )                {                    if (isdigit((int)cp[1]))\t\t\tquality = atoi(cp+1);                    else if (cp[1] == 'r' )\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;                    else                        usage();                    cp = strchr(cp+1,':');                }\t} else if (strneq(opt, \"lzw\", 3)) {\t\tchar* cp = strchr(opt, ':');\t\tif (cp)\t\t\tpredictor = atoi(cp+1);\t\tcompression = COMPRESSION_LZW;\t} else if (strneq(opt, \"zip\", 3)) {\t\tchar* cp = strchr(opt, ':');\t\tif (cp)\t\t\tpredictor = atoi(cp+1);\t\tcompression = COMPRESSION_DEFLATE;\t} else\t\treturn (0);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static toff_t_tiffSeekProc(thandle_t fd, toff_t off, int whence){\treturn ((toff_t) lseek((int) fd, (off_t) off, whence));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidUsage(){    fprintf(stderr, \"Usage: %s -depth (8 | 4 | 2 | 1) tiff-image\\n\", programName);    exit(0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcpStripToTile(uint8* out, uint8* in,    uint32 rows, uint32 cols, int outskew, int inskew){\twhile (rows-- > 0) {\t\tuint32 j = cols;\t\twhile (j-- > 0)\t\t\t*out++ = *in++;\t\tout += outskew;\t\tin += inskew;\t}}",
        "label": 1,
        "cve": "cve-2016-10093"
    },
    {
        "code": "const uint32\trows_per_strip = 1;int test_packbits(){    TIFF\t    *tif;    int             i;    unsigned char   buf[10] = {0,0,0,0,0,0,0,0,0,0};    int  length = 20;    const char *filename = \"test_packbits.tif\";        tif = TIFFOpen(filename, \"w\");    if (!tif) {        fprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename);        return 1;    }    if (!TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS)) {        fprintf (stderr, \"Can't set Compression tag.\\n\");        goto failure;    }    if (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) {        fprintf (stderr, \"Can't set ImageWidth tag.\\n\");        goto failure;    }    if (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) {        fprintf (stderr, \"Can't set ImageLength tag.\\n\");        goto failure;    }    if (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8)) {        fprintf (stderr, \"Can't set BitsPerSample tag.\\n\");        goto failure;    }    if (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1)) {        fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");        goto failure;    }    if (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip)) {        fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");        goto failure;    }    if (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) {        fprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\");        goto failure;    }    for (i = 0; i < length; i++ )    {        if( !TIFFWriteEncodedStrip( tif, i, buf, 10 ) )        {            fprintf (stderr, \"Can't write image data.\\n\");            goto failure;        }    }    TIFFClose(tif);        tif = TIFFOpen(filename, \"r+\");    if (!tif) {        fprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename);        return 1;    }    buf[3] = 17;    buf[6] = 12;    if( !TIFFWriteEncodedStrip( tif, 6, buf, 10 ) )    {        fprintf (stderr, \"Can't write image data.\\n\");        goto failure;    }    TIFFClose(tif);    unlink(filename);    return 0;  failure:        TIFFClose(tif);        return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcvtRaster(TIFF* tif, uint32* raster, uint32 width, uint32 height){\tuint32 y;\ttstrip_t strip = 0;\ttsize_t cc, acc;\tunsigned char* buf;\tuint32 rwidth = roundup(width, horizSubSampling);\tuint32 rheight = roundup(height, vertSubSampling);\tuint32 nrows = (rowsperstrip > rheight ? rheight : rowsperstrip);        uint32 rnrows = roundup(nrows,vertSubSampling);\tcc = rnrows*rwidth +\t    2*((rnrows*rwidth) / (horizSubSampling*vertSubSampling));\tbuf = (unsigned char*)_TIFFmalloc(cc);\t\tfor (y = height; (int32) y > 0; y -= nrows) {\t\tuint32 nr = (y > nrows ? nrows : y);\t\tcvtStrip(buf, raster + (y-1)*width, nr, width);\t\tnr = roundup(nr, vertSubSampling);\t\tacc = nr*rwidth +\t\t\t2*((nr*rwidth)/(horizSubSampling*vertSubSampling));\t\tif (!TIFFWriteEncodedStrip(tif, strip++, buf, acc)) {\t\t\t_TIFFfree(buf);\t\t\treturn (0);\t\t}\t}\t_TIFFfree(buf);\treturn (1);}",
        "label": 1,
        "cve": "cve-2016-3623"
    },
    {
        "code": "const char*TIFFGetVersion(void){\treturn (TIFFVersion);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int t2p_closeproc(thandle_t handle){ \tT2P *t2p = (T2P*) handle;\treturn fclose(t2p->outputfile);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFSwabDouble(double *dp){\tregister unsigned char* cp = (unsigned char*) dp;\tunsigned char t;\tassert(sizeof(double)==8);\tt = cp[7]; cp[7] = cp[0]; cp[0] = t;\tt = cp[6]; cp[6] = cp[1]; cp[1] = t;\tt = cp[5]; cp[5] = cp[2]; cp[2] = t;\tt = cp[4]; cp[4] = cp[3]; cp[3] = t;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intreverseSamples16bits (uint16 spp, uint16 bps, uint32 width,                       uint8 *ibuff, uint8 *obuff)  {  int      ready_bits = 0;  uint32   col;  uint32   src_byte = 0, high_bit = 0;  uint32   bit_offset = 0;  uint16   match_bits = 0, mask_bits = 0;  uint16   buff1 = 0, buff2 = 0;  uint8    bytebuff = 0;  unsigned char *src;  unsigned char *dst;  tsample_t sample;  if ((ibuff == NULL) || (obuff == NULL))    {    TIFFError(\"reverseSample16bits\",\"Invalid image or work buffer\");    return (1);    }  ready_bits = 0;  mask_bits =  (uint16)-1 >> (16 - bps);  dst = obuff;  for (col = width; col > 0; col--)    {        bit_offset = (col - 1) * bps * spp;    for (sample = 0; sample < spp; sample++)      {      if (sample == 0)        {        src_byte = bit_offset / 8;        high_bit  = bit_offset % 8;        }      else        {        src_byte = (bit_offset + (sample * bps)) / 8;        high_bit  = (bit_offset + (sample * bps)) % 8;        }      src = ibuff + src_byte;      match_bits = mask_bits << (16 - high_bit - bps);       if (little_endian)        buff1 = (src[0] << 8) | src[1];      else        buff1 = (src[1] << 8) | src[0];      buff1 = (buff1 & match_bits) << (high_bit);      if (ready_bits < 8)        {         bytebuff = 0;        buff2 = (buff2 | (buff1 >> ready_bits));        }      else         {        bytebuff = (buff2 >> 8);        *dst++ = bytebuff;        ready_bits -= 8;                buff2 = ((buff2 << 8) | (buff1 >> ready_bits));        }      ready_bits += bps;      }    }  if (ready_bits > 0)    {    bytebuff = (buff2 >> 8);    *dst++ = bytebuff;    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcl_hash(LZWCodecState* sp){\tregister hash_t *hp = &sp->enc_hashtab[HSIZE-1];\tregister long i = HSIZE-8;\tdo {\t\ti -= 8;\t\thp[-7].hash = -1;\t\thp[-6].hash = -1;\t\thp[-5].hash = -1;\t\thp[-4].hash = -1;\t\thp[-3].hash = -1;\t\thp[-2].hash = -1;\t\thp[-1].hash = -1;\t\thp[ 0].hash = -1;\t\thp -= 8;\t} while (i >= 0);\tfor (i += 8; i > 0; i--, hp--)\t\thp->hash = -1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int sindex(char ch,char *string){  char *cp;  for(cp=string;*cp;++cp)    if(ch==*cp)      return (int)(cp-string);\t  return -1;\t\t\t}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voiddump(int fd, uint64 diroff){\tunsigned i, j;\tuint64* visited_diroff = NULL;\tunsigned int count_visited_dir = 0;\t_TIFF_lseek_f(fd, (_TIFF_off_t) 0, 0);\tif (read(fd, (char*) &hdr, sizeof (TIFFHeaderCommon)) != sizeof (TIFFHeaderCommon))\t\tReadError(\"TIFF header\");\tif (hdr.common.tiff_magic != TIFF_BIGENDIAN\t    && hdr.common.tiff_magic != TIFF_LITTLEENDIAN &&#if HOST_BIGENDIAN\t    \t    MDI_BIGENDIAN != hdr.common.tiff_magic#else\t    MDI_LITTLEENDIAN != hdr.common.tiff_magic#endif\t   ) {\t\tFatal(\"Not a TIFF or MDI file, bad magic number %u (%#x)\",\t\t    hdr.common.tiff_magic, hdr.common.tiff_magic);\t}\tif (hdr.common.tiff_magic == TIFF_BIGENDIAN\t    || hdr.common.tiff_magic == MDI_BIGENDIAN)\t\tswabflag = !bigendian;\telse\t\tswabflag = bigendian;\tif (swabflag)\t\tTIFFSwabShort(&hdr.common.tiff_version);\tif (hdr.common.tiff_version==42)\t{\t\tif (read(fd, (char*) &hdr.classic.tiff_diroff, 4) != 4)\t\t\tReadError(\"TIFF header\");\t\tif (swabflag)\t\t\tTIFFSwabLong(&hdr.classic.tiff_diroff);\t\tprintf(\"Magic: %#x <%s-endian> Version: %#x <%s>\\n\",\t\t    hdr.classic.tiff_magic,\t\t    hdr.classic.tiff_magic == TIFF_BIGENDIAN ? \"big\" : \"little\",\t\t    42,\"ClassicTIFF\");\t\tif (diroff == 0)\t\t\tdiroff = hdr.classic.tiff_diroff;\t}\telse if (hdr.common.tiff_version==43)\t{\t\tif (read(fd, (char*) &hdr.big.tiff_offsetsize, 12) != 12)\t\t\tReadError(\"TIFF header\");\t\tif (swabflag)\t\t{\t\t\tTIFFSwabShort(&hdr.big.tiff_offsetsize);\t\t\tTIFFSwabShort(&hdr.big.tiff_unused);\t\t\tTIFFSwabLong8(&hdr.big.tiff_diroff);\t\t}\t\tprintf(\"Magic: %#x <%s-endian> Version: %#x <%s>\\n\",\t\t    hdr.big.tiff_magic,\t\t    hdr.big.tiff_magic == TIFF_BIGENDIAN ? \"big\" : \"little\",\t\t    43,\"BigTIFF\");\t\tprintf(\"OffsetSize: %#x Unused: %#x\\n\",\t\t    hdr.big.tiff_offsetsize,hdr.big.tiff_unused);\t\tif (diroff == 0)\t\t\tdiroff = hdr.big.tiff_diroff;\t\tbigtiff = 1;\t}\telse\t\tFatal(\"Not a TIFF file, bad version number %u (%#x)\",\t\t    hdr.common.tiff_version, hdr.common.tiff_version);\tfor (i = 0; diroff != 0; i++) {\t\tfor(j=0; j<count_visited_dir; j++)\t\t{\t\t    if( visited_diroff[j] == diroff )\t\t    {\t\t\tfree(visited_diroff);\t\t\tFatal(\"Cycle detected in chaining of TIFF directories!\");\t\t    }\t\t}                {                    size_t alloc_size;                    alloc_size=TIFFSafeMultiply(tmsize_t,(count_visited_dir + 1),                                                sizeof(uint64));                    if (alloc_size == 0)                    {                        if (visited_diroff)                            free(visited_diroff);                        visited_diroff = 0;                    }                    else                    {                        visited_diroff = (uint64*) realloc(visited_diroff,alloc_size);                    }                }\t\tif( !visited_diroff )\t\t    Fatal(\"Out of memory\");\t\tvisited_diroff[count_visited_dir] = diroff;\t\tcount_visited_dir ++;\t\tif (i > 0)\t\t\tputchar('\\n');\t\tdiroff = ReadDirectory(fd, i, diroff);\t}\tif( visited_diroff )\t    free(visited_diroff);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tsize_tTIFFFetchData(TIFF* tif, TIFFDirEntry* dir, char* cp){\tint w = TIFFDataWidth(dir->tdir_type);\ttsize_t cc = dir->tdir_count * w;\tif (!isMapped(tif)) {\t\tif (!SeekOK(tif, dir->tdir_offset))\t\t\tgoto bad;\t\tif (!ReadOK(tif, cp, cc))\t\t\tgoto bad;\t} else {\t\tif (dir->tdir_offset + cc > tif->tif_size)\t\t\tgoto bad;\t\t_TIFFmemcpy(cp, tif->tif_base + dir->tdir_offset, cc);\t}\tif (tif->tif_flags & TIFF_SWAB) {\t\tswitch (dir->tdir_type) {\t\tcase TIFF_SHORT:\t\tcase TIFF_SSHORT:\t\t\tTIFFSwabArrayOfShort((uint16*) cp, dir->tdir_count);\t\t\tbreak;\t\tcase TIFF_LONG:\t\tcase TIFF_SLONG:\t\tcase TIFF_FLOAT:\t\t\tTIFFSwabArrayOfLong((uint32*) cp, dir->tdir_count);\t\t\tbreak;\t\tcase TIFF_RATIONAL:\t\tcase TIFF_SRATIONAL:\t\t\tTIFFSwabArrayOfLong((uint32*) cp, 2*dir->tdir_count);\t\t\tbreak;\t\tcase TIFF_DOUBLE:\t\t\tTIFFSwabArrayOfDouble((double*) cp, dir->tdir_count);\t\t\tbreak;\t\t}\t}\treturn (cc);bad:\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error fetching data for field \\\"%s\\\"\",\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\treturn ((tsize_t) 0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int JBIGDecode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s){\tstruct jbg_dec_state decoder;\tint decodeStatus = 0;\tunsigned char* pImage = NULL;\t(void) size, (void) s;\tif (isFillOrder(tif, tif->tif_dir.td_fillorder))\t{\t\tTIFFReverseBits(tif->tif_rawdata, tif->tif_rawdatasize);\t}\tjbg_dec_init(&decoder);#if defined(HAVE_JBG_NEWLEN)\tjbg_newlen(tif->tif_rawdata, (size_t)tif->tif_rawdatasize);\t #endif  \tdecodeStatus = jbg_dec_in(&decoder, (unsigned char*)tif->tif_rawdata,\t\t\t\t  (size_t)tif->tif_rawdatasize, NULL);\tif (JBG_EOK != decodeStatus)\t{\t\t \t\tTIFFErrorExt(tif->tif_clientdata,\t\t\t     \"JBIG\", \"Error (%d) decoding: %s\",\t\t\t     decodeStatus,#if defined(JBG_EN)\t\t\t     jbg_strerror(decodeStatus, JBG_EN)#else\t\t\t     jbg_strerror(decodeStatus)#endif\t\t\t     );\t\tjbg_dec_free(&decoder);\t\treturn 0;\t}\tpImage = jbg_dec_getimage(&decoder, 0);\t_TIFFmemcpy(buffer, pImage, jbg_dec_getsize(&decoder));\tjbg_dec_free(&decoder);\treturn 1;}",
        "label": 1,
        "cve": "CVE-2018-18557"
    },
    {
        "code": "intmain(int argc, char* argv[]){\tTIFF *in, *out;\tuint16 samplesperpixel, bitspersample = 1, shortv;\tfloat floatv;\tchar thing[1024];\tuint32 rowsperstrip = (uint32) -1;\tuint16 fillorder = 0;\tint c;#if !HAVE_DECL_OPTARG\textern int optind;\textern char *optarg;#endif\twhile ((c = getopt(argc, argv, \"c:f:r:t:\")) != -1)\t\tswitch (c) {\t\tcase 'c':\t\t\t\t\tif (!processCompressOptions(optarg))\t\t\t\tusage();\t\t\tbreak;\t\tcase 'f':\t\t\t\t\tif (streq(optarg, \"lsb2msb\"))\t\t\t\tfillorder = FILLORDER_LSB2MSB;\t\t\telse if (streq(optarg, \"msb2lsb\"))\t\t\t\tfillorder = FILLORDER_MSB2LSB;\t\t\telse\t\t\t\tusage();\t\t\tbreak;\t\tcase 'r':\t\t\t\t\trowsperstrip = atoi(optarg);\t\t\tbreak;\t\tcase 't':\t\t\tthreshold = atoi(optarg);\t\t\tif (threshold < 0)\t\t\t\tthreshold = 0;\t\t\telse if (threshold > 255)\t\t\t\tthreshold = 255;\t\t\tbreak;\t\tcase '?':\t\t\tusage();\t\t\t\t\t}\tif (argc - optind < 2)\t\tusage();\tin = TIFFOpen(argv[optind], \"r\");\tif (in == NULL)\t\treturn (-1);\tTIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\tif (samplesperpixel != 1) {\t\tfprintf(stderr, \"%s: Not a b&w image.\\n\", argv[0]);\t\treturn (-1);\t}\tTIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\tif (bitspersample != 8) {\t\tfprintf(stderr,\t\t    \" %s: Sorry, only handle 8-bit samples.\\n\", argv[0]);\t\treturn (-1);\t}\tout = TIFFOpen(argv[optind+1], \"w\");\tif (out == NULL)\t\treturn (-1);\tCopyField(TIFFTAG_IMAGEWIDTH, imagewidth);\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &imagelength);\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, imagelength-1);\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 1);\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 1);\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\tif (fillorder)\t\tTIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\telse\t\tCopyField(TIFFTAG_FILLORDER, shortv);\tsnprintf(thing, sizeof(thing), \"Dithered B&W version of %s\", argv[optind]);\tTIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, thing);\tCopyField(TIFFTAG_PHOTOMETRIC, shortv);\tCopyField(TIFFTAG_ORIENTATION, shortv);\tCopyField(TIFFTAG_XRESOLUTION, floatv);\tCopyField(TIFFTAG_YRESOLUTION, floatv);\tCopyField(TIFFTAG_RESOLUTIONUNIT, shortv);        rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\tswitch (compression) {\tcase COMPRESSION_CCITTFAX3:\t\tTIFFSetField(out, TIFFTAG_GROUP3OPTIONS, group3options);\t\tbreak;\tcase COMPRESSION_LZW:\tcase COMPRESSION_DEFLATE:\t\tif (predictor)\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\t\tbreak;\t}\tfsdither(in, out);\tTIFFClose(in);\tTIFFClose(out);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFFExtendProcTIFFSetTagExtender(TIFFExtendProc extender){\tTIFFExtendProc prev = _TIFFextender;\t_TIFFextender = extender;\treturn (prev);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static inttiffcvt(TIFF* in, TIFF* out){\tuint32 width, height;\t\t\tuint32* raster;\t\t\t\tuint16 shortv;\tfloat floatv;\tchar *stringv;\tuint32 longv;\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width);\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &height);\traster = (uint32*)_TIFFmalloc(width * height * sizeof (uint32));\tif (raster == 0) {\t\tTIFFError(TIFFFileName(in), \"No space for raster buffer\");\t\treturn (0);\t}\tif (!TIFFReadRGBAImage(in, width, height, raster, 0)) {\t\t_TIFFfree(raster);\t\treturn (0);\t}\tCopyField(TIFFTAG_SUBFILETYPE, longv);\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, height);\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\tif (compression == COMPRESSION_JPEG)\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\tCopyField(TIFFTAG_FILLORDER, shortv);\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3);\tCopyField(TIFFTAG_XRESOLUTION, floatv);\tCopyField(TIFFTAG_YRESOLUTION, floatv);\tCopyField(TIFFTAG_RESOLUTIONUNIT, shortv);\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\t{ char buf[2048];\t  char *cp = strrchr(TIFFFileName(in), '/');\t  sprintf(buf, \"YCbCr conversion of %s\", cp ? cp+1 : TIFFFileName(in));\t  TIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, buf);\t}\tTIFFSetField(out, TIFFTAG_SOFTWARE, TIFFGetVersion());\tCopyField(TIFFTAG_DOCUMENTNAME, stringv);\tTIFFSetField(out, TIFFTAG_REFERENCEBLACKWHITE, refBlackWhite);\tTIFFSetField(out, TIFFTAG_YCBCRSUBSAMPLING,\t    horizSubSampling, vertSubSampling);\tTIFFSetField(out, TIFFTAG_YCBCRPOSITIONING, YCBCRPOSITION_CENTERED);\tTIFFSetField(out, TIFFTAG_YCBCRCOEFFICIENTS, ycbcrCoeffs);\trowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\treturn (cvtRaster(out, raster, width, height));}",
        "label": 1,
        "cve": "cve-2009-2347"
    },
    {
        "code": "int mfs_lseek (int fd, int offset, int whence){    int ret;    long test_off;    if (fds[fd] == -1)      {        ret = -1;        errno = EBADF;    }    else if (offset < 0 && whence == SEEK_SET)    {        ret = -1;        errno = EINVAL;    }    else    {        switch (whence)        {            case SEEK_SET:                if (offset > buf_size[fd])                    extend_mem_file (fd, offset);                buf_off[fd] = offset;                ret = offset;                break;            case SEEK_CUR:                test_off = buf_off[fd] + offset;                if (test_off < 0)                {                    ret = -1;                    errno = EINVAL;                }                else                {                    if (test_off > buf_size[fd])                        extend_mem_file (fd, test_off);                    buf_off[fd] = test_off;                    ret = test_off;                }                break;            case SEEK_END:                test_off = buf_size[fd] + offset;                if (test_off < 0)                {                    ret = -1;                    errno = EINVAL;                }                else                {                    if (test_off > buf_size[fd])                        extend_mem_file (fd, test_off);                    buf_off[fd] = test_off;                    ret = test_off;                }                break;            default:                errno = EINVAL;                ret = -1;                break;        }    }    return (ret);}   ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){\tuint16 edge=0;\ttsize_t written=0;\tunsigned char* buffer=NULL;\ttsize_t bufferoffset=0;\tunsigned char* samplebuffer=NULL;\ttsize_t samplebufferoffset=0;\ttsize_t read=0;\tuint16 i=0;\tttile_t tilecount=0;\t\tttile_t septilecount=0;\ttsize_t septilesize=0;#ifdef JPEG_SUPPORT\tunsigned char* jpt;\tfloat* xfloatp;\tuint32 xuint32=0;#endif\t\tif (t2p->t2p_error != T2P_ERR_OK)\t\treturn(0);\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\tif( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\t\t|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)#endif\t)\t){#ifdef CCITT_SUPPORT\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\t\tif(buffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate %lu bytes of memory \"                                        \"for t2p_readwrite_pdf_image_tile, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\t\t\t}\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\t\t\t_TIFFfree(buffer);\t\t\treturn(t2p->tiff_datasize);\t\t}#endif#ifdef ZIP_SUPPORT\t\tif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\t\tif(buffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate %lu bytes of memory \"                                        \"for t2p_readwrite_pdf_image_tile, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\t\t\t}\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\t\t\t_TIFFfree(buffer);\t\t\treturn(t2p->tiff_datasize);\t\t}#endif#ifdef OJPEG_SUPPORT\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG){\t\t\tif(! t2p->pdf_ojpegdata){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"No support for OJPEG image %s with \"                                        \"bad tables\", \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tbuffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\t\tif(buffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate %lu bytes of memory \"                                        \"for t2p_readwrite_pdf_image, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\t\t\tif(edge!=0){\t\t\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\t\t\t\t\tbuffer[7]=\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;\t\t\t\t\tbuffer[8]=\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;\t\t\t\t}\t\t\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\t\t\t\t\tbuffer[9]=\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;\t\t\t\t\tbuffer[10]=\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;\t\t\t\t}\t\t\t}\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\t\t\tbufferoffset+=TIFFReadRawTile(input, \t\t\t\t\ttile, \t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \t\t\t\t\t-1);\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xff;\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xd9;\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\t\t\t_TIFFfree(buffer);\t\t\treturn(bufferoffset);\t\t}#endif#ifdef JPEG_SUPPORT\t\tif(t2p->tiff_compression == COMPRESSION_JPEG){\t\t\tunsigned char table_end[2];\t\t\tuint32 count = 0;\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\t\tif(buffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \"                                        \"for t2p_readwrite_pdf_image_tile, %s\",                                           (TIFF_SIZE_T) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\t\t\t\tif (count >= 4) {                    \t\t\t\t\t_TIFFmemcpy(buffer, jpt, count - 2);\t\t\t\t\tbufferoffset += count - 2;                    \t\t\t\t\ttable_end[0] = buffer[bufferoffset-2];\t\t\t\t\ttable_end[1] = buffer[bufferoffset-1];\t\t\t\t\txuint32 = bufferoffset;                    bufferoffset -= 2;\t\t\t\t\tbufferoffset += TIFFReadRawTile(\t\t\t\t\t\tinput, \t\t\t\t\t\ttile, \t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \t\t\t\t\t\t-1);                                        \t\t\t\t\tbuffer[xuint32-2]=table_end[0];\t\t\t\t\tbuffer[xuint32-1]=table_end[1];\t\t\t\t} else {\t\t\t\t\tbufferoffset += TIFFReadRawTile(\t\t\t\t\t\tinput, \t\t\t\t\t\ttile, \t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \t\t\t\t\t\t-1);\t\t\t\t}\t\t\t}\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\t\t\t_TIFFfree(buffer);\t\t\treturn(bufferoffset);\t\t}#endif\t\t(void)0;\t}\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\tif(buffer==NULL){\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\"Can't allocate %lu bytes of memory for \"                                \"t2p_readwrite_pdf_image_tile, %s\", \t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\tTIFFFileName(input));\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\treturn(0);\t\t}\t\tread = TIFFReadEncodedTile(\t\t\tinput, \t\t\ttile, \t\t\t(tdata_t) &buffer[bufferoffset], \t\t\tt2p->tiff_datasize);\t\tif(read==-1){\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\"Error on decoding tile %u of %s\", \t\t\t\ttile, \t\t\t\tTIFFFileName(input));\t\t\t_TIFFfree(buffer);\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\t\t\treturn(0);\t\t}\t} else {\t\tif(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\t\t\tseptilesize=TIFFTileSize(input);\t\t\tseptilecount=TIFFNumberOfTiles(input);\t\t\t\t\t\ttilecount=septilecount/t2p->tiff_samplesperpixel;\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\t\tif(buffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate %lu bytes of memory \"                                        \"for t2p_readwrite_pdf_image_tile, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\t\tif(samplebuffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate %lu bytes of memory \"                                        \"for t2p_readwrite_pdf_image_tile, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tsamplebufferoffset=0;\t\t\tfor(i=0;i<t2p->tiff_samplesperpixel;i++){\t\t\t\tread = \t\t\t\t\tTIFFReadEncodedTile(input, \t\t\t\t\t\ttile + i*tilecount, \t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \t\t\t\t\t\tseptilesize);\t\t\t\tif(read==-1){\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\t\"Error on decoding tile %u of %s\", \t\t\t\t\t\ttile + i*tilecount, \t\t\t\t\t\tTIFFFileName(input));\t\t\t\t\t\t_TIFFfree(samplebuffer);\t\t\t\t\t\t_TIFFfree(buffer);\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\t\t\t\t\treturn(0);\t\t\t\t}\t\t\t\tsamplebufferoffset+=read;\t\t\t}\t\t\tt2p_sample_planar_separate_to_contig(\t\t\t\tt2p,\t\t\t\t&(buffer[bufferoffset]),\t\t\t\tsamplebuffer, \t\t\t\tsamplebufferoffset); \t\t\tbufferoffset+=samplebufferoffset;\t\t\t_TIFFfree(samplebuffer);\t\t}\t\tif(buffer==NULL){\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\t\t\tif(buffer==NULL){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Can't allocate %lu bytes of memory \"                                        \"for t2p_readwrite_pdf_image_tile, %s\", \t\t\t\t\t(unsigned long) t2p->tiff_datasize, \t\t\t\t\tTIFFFileName(input));\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t\tread = TIFFReadEncodedTile(\t\t\t\tinput, \t\t\t\ttile, \t\t\t\t(tdata_t) &buffer[bufferoffset], \t\t\t\tt2p->tiff_datasize);\t\t\tif(read==-1){\t\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\t\"Error on decoding tile %u of %s\", \t\t\t\t\ttile, \t\t\t\t\tTIFFFileName(input));\t\t\t\t_TIFFfree(buffer);\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\t\t\t\treturn(0);\t\t\t}\t\t}\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\t\t\t\t(tdata_t)buffer, \t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\t\t}\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\t\t\t\t(tdata_t)buffer, \t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\t\t}\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\t\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t\t\"No support for YCbCr to RGB in tile for %s\", \t\t\t\tTIFFFileName(input));\t\t\t_TIFFfree(buffer);\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\t\treturn(0);\t\t}\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\t\t\t\t(tdata_t)buffer, \t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\t\t}\t}\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){\t\tt2p_tile_collapse_left(\t\t\tbuffer, \t\t\tTIFFTileRowSize(input),\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth, \t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\t}\tt2p_disable(output);\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\t\tTIFFSetField(\t\t\toutput, \t\t\tTIFFTAG_IMAGEWIDTH, \t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\t} else {\t\tTIFFSetField(\t\t\toutput, \t\t\tTIFFTAG_IMAGEWIDTH, \t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\t}\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\t\tTIFFSetField(\t\t\toutput, \t\t\tTIFFTAG_IMAGELENGTH, \t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\t\tTIFFSetField(\t\t\toutput, \t\t\tTIFFTAG_ROWSPERSTRIP, \t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\t} else {\t\tTIFFSetField(\t\t\toutput, \t\t\tTIFFTAG_IMAGELENGTH, \t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\t\tTIFFSetField(\t\t\toutput, \t\t\tTIFFTAG_ROWSPERSTRIP, \t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\t}\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\tswitch(t2p->pdf_compression){\tcase T2P_COMPRESS_NONE:\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\t\tbreak;#ifdef CCITT_SUPPORT\tcase T2P_COMPRESS_G4:\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\t\tbreak;#endif#ifdef JPEG_SUPPORT\tcase T2P_COMPRESS_JPEG:\t\tif (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\t\t\tuint16 hor = 0, ver = 0;\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {\t\t\t\tif (hor != 0 && ver != 0) {\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\t\t\t\t}\t\t\t}\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\t\t\t}\t\t}\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); \t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\t\t\t} else {\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\t\t\t}\t\t}\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\t\t\t(void)0;\t\t}\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\t\t\t(void)0;\t\t}\t\tif(t2p->pdf_defaultcompressionquality != 0){\t\t\tTIFFSetField(output, \t\t\t\tTIFFTAG_JPEGQUALITY, \t\t\t\tt2p->pdf_defaultcompressionquality);\t\t}\t\tbreak;#endif#ifdef ZIP_SUPPORT\tcase T2P_COMPRESS_ZIP:\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\t\t\tTIFFSetField(output, \t\t\t\tTIFFTAG_PREDICTOR, \t\t\t\tt2p->pdf_defaultcompressionquality % 100);\t\t}\t\tif(t2p->pdf_defaultcompressionquality/100 != 0){\t\t\tTIFFSetField(output, \t\t\t\tTIFFTAG_ZIPQUALITY, \t\t\t\t(t2p->pdf_defaultcompressionquality / 100));\t\t}\t\tbreak;#endif\tdefault:\t\tbreak;\t}\tt2p_enable(output);\tt2p->outputwritten = 0;\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,\t\t\t\t\t     TIFFStripSize(output)); \tif (buffer != NULL) {\t\t_TIFFfree(buffer);\t\tbuffer = NULL;\t}\tif (bufferoffset == -1) {\t\tTIFFError(TIFF2PDF_MODULE, \t\t\t  \"Error writing encoded tile to output PDF %s\", \t\t\t  TIFFFileName(output));\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\treturn(0);\t}\t\twritten = t2p->outputwritten;\t\treturn(written);}",
        "label": 1,
        "cve": "cve-2016-10094"
    },
    {
        "code": "static intOkToChangeTag(TIFF* tif, ttag_t tag){\tconst TIFFFieldInfo* fip = _TIFFFindFieldInfo(tif, tag, TIFF_ANY);\tif (!fip) {\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\", \"%s: Unknown %stag %u\",\t\t    tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\", tag);\t\treturn (0);\t}\tif (tag != TIFFTAG_IMAGELENGTH && (tif->tif_flags & TIFF_BEENWRITING) &&\t    !fip->field_oktochange) {\t\t\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\",\t\t    \"%s: Cannot modify tag \\\"%s\\\" while writing\",\t\t    tif->tif_name, fip->field_name);\t\treturn (0);\t}\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intCheckShort2Tag(TIFF* tif1, TIFF* tif2, int tag, char* name){\tuint16 v11, v12, v21, v22;\tif (TIFFGetField(tif1, tag, &v11, &v12)) {\t\tif (!TIFFGetField(tif2, tag, &v21, &v22)) {\t\t\tprintf(\"%s tag appears only in %s\\n\",\t\t\t    name, TIFFFileName(tif1));\t\t\treturn (0);\t\t}\t\tif (v11 == v21 && v12 == v22)\t\t\treturn (1);\t\tprintf(\"%s: <%u,%u> <%u,%u>\\n\", name, v11, v12, v21, v22);\t} else if (TIFFGetField(tif2, tag, &v21, &v22))\t\tprintf(\"%s tag appears only in %s\\n\", name, TIFFFileName(tif2));\telse\t\treturn (1);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static floatTIFFFetchRational(TIFF* tif, TIFFDirEntry* dir){\tuint32 l[2];\tfloat v;\treturn (!TIFFFetchData(tif, dir, (char *)l) ||\t    !cvtRational(tif, dir, l[0], l[1], &v) ? 1.0f : v);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intwriteImageSections(TIFF *in, TIFF *out, struct image_data *image,\t\t   struct pagedef *page, struct pageseg *sections,\t\t   struct dump_opts * dump, unsigned char *src_buff,                   unsigned char **sect_buff_ptr)  {  double  hres, vres;  uint32  i, k, width, length, sectsize;  unsigned char *sect_buff = *sect_buff_ptr;  hres = page->hres;  vres = page->vres;  k = page->cols * page->rows;  if ((k < 1) || (k > MAX_SECTIONS))   {   TIFFError(\"writeImageSections\",\t     \"%d Rows and Columns exceed maximum sections\\nIncrease resolution or reduce sections\", k);   return (-1);   }  for (i = 0; i < k; i++)    {    width  = sections[i].x2 - sections[i].x1 + 1;    length = sections[i].y2 - sections[i].y1 + 1;    sectsize = (uint32)\t    ceil((width * image->bps + 7) / (double)8) * image->spp * length;        if (createImageSection(sectsize, sect_buff_ptr))      {      TIFFError(\"writeImageSections\", \"Unable to allocate section buffer\");      exit (-1);      }    sect_buff = *sect_buff_ptr;    if (extractImageSection (image, &sections[i], src_buff, sect_buff))      {      TIFFError(\"writeImageSections\", \"Unable to extract image sections\");      exit (-1);      }      if (writeSingleSection(in, out, image, dump, width, length, hres, vres, sect_buff))      {      TIFFError(\"writeImageSections\", \"Unable to write image section\");      exit (-1);      }    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_tiffCloseProc(thandle_t fd){\treturn (CloseHandle(fd) ? 0 : -1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidUsage(){    fprintf(stderr, \"Usage: %s -depth (8 | 4 | 2) tiff-image\\n\", programName);    exit(0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFprintAsciiTag(FILE* fd, const char* name, const char* value){\tfprintf(fd, \"  %s: \\\"\", name);\t_TIFFprintAscii(fd, value);\tfprintf(fd, \"\\\"\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static inthorDiff8(TIFF* tif, uint8* cp0, tmsize_t cc){\tTIFFPredictorState* sp = PredictorState(tif);\ttmsize_t stride = sp->stride;\tunsigned char* cp = (unsigned char*) cp0;    if((cc%stride)!=0)    {        TIFFErrorExt(tif->tif_clientdata, \"horDiff8\",                     \"%s\", \"(cc%stride)!=0\");        return 0;    }\tif (cc > stride) {\t\tcc -= stride;\t\t\t\tif (stride == 3) {\t\t\tunsigned int r1, g1, b1;\t\t\tunsigned int r2 = cp[0];\t\t\tunsigned int g2 = cp[1];\t\t\tunsigned  int b2 = cp[2];\t\t\tdo {\t\t\t\tr1 = cp[3]; cp[3] = (unsigned char)((r1-r2)&0xff); r2 = r1;\t\t\t\tg1 = cp[4]; cp[4] = (unsigned char)((g1-g2)&0xff); g2 = g1;\t\t\t\tb1 = cp[5]; cp[5] = (unsigned char)((b1-b2)&0xff); b2 = b1;\t\t\t\tcp += 3;\t\t\t} while ((cc -= 3) > 0);\t\t} else if (stride == 4) {\t\t\tunsigned int r1, g1, b1, a1;\t\t\tunsigned int r2 = cp[0];\t\t\tunsigned int g2 = cp[1];\t\t\tunsigned int b2 = cp[2];\t\t\tunsigned int a2 = cp[3];\t\t\tdo {\t\t\t\tr1 = cp[4]; cp[4] = (unsigned char)((r1-r2)&0xff); r2 = r1;\t\t\t\tg1 = cp[5]; cp[5] = (unsigned char)((g1-g2)&0xff); g2 = g1;\t\t\t\tb1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;\t\t\t\ta1 = cp[7]; cp[7] = (unsigned char)((a1-a2)&0xff); a2 = a1;\t\t\t\tcp += 4;\t\t\t} while ((cc -= 4) > 0);\t\t} else {\t\t\tcp += cc - 1;\t\t\tdo {\t\t\t\tREPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)\t\t\t} while ((cc -= stride) > 0);\t\t}\t}\treturn 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(void){\tchar buf[BUFSIZ];\tint i;\tsetbuf(stderr, buf);        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\tfor (i = 0; stuff[i] != NULL; i++)\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\texit(-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff){\tstatic const char module[] = \"TIFFWriteDirectorySec\";\tuint32 ndir;\tTIFFDirEntry* dir;\tuint32 dirsize;\tvoid* dirmem;\tuint32 m;\tif (tif->tif_mode == O_RDONLY)\t\treturn (1);        _TIFFFillStriles( tif );        \t \tif (imagedone)\t{\t\tif (tif->tif_flags & TIFF_POSTENCODE)\t\t{\t\t\ttif->tif_flags &= ~TIFF_POSTENCODE;\t\t\tif (!(*tif->tif_postencode)(tif))\t\t\t{\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\t\t\t\t    \"Error post-encoding before directory write\");\t\t\t\treturn (0);\t\t\t}\t\t}\t\t(*tif->tif_close)(tif);        \t\t \t\tif (tif->tif_rawcc > 0 \t\t    && (tif->tif_flags & TIFF_BEENWRITING) != 0 )\t\t{\t\t    if( !TIFFFlushData1(tif) )                    {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"Error flushing data before directory write\");\t\t\treturn (0);                    }\t\t}\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata)\t\t{\t\t\t_TIFFfree(tif->tif_rawdata);\t\t\ttif->tif_rawdata = NULL;\t\t\ttif->tif_rawcc = 0;\t\t\ttif->tif_rawdatasize = 0;                        tif->tif_rawdataoff = 0;                        tif->tif_rawdataloaded = 0;\t\t}\t\ttif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP);\t}\tdir=NULL;\tdirmem=NULL;\tdirsize=0;\twhile (1)\t{\t\tndir=0;\t\tif (isimage)\t\t{\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGEWIDTH,tif->tif_dir.td_imagewidth))\t\t\t\t\tgoto bad;\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGELENGTH,tif->tif_dir.td_imagelength))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILEWIDTH,tif->tif_dir.td_tilewidth))\t\t\t\t\tgoto bad;\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILELENGTH,tif->tif_dir.td_tilelength))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XRESOLUTION,tif->tif_dir.td_xresolution))\t\t\t\t\tgoto bad;\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YRESOLUTION,tif->tif_dir.td_yresolution))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_POSITION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XPOSITION,tif->tif_dir.td_xposition))\t\t\t\t\tgoto bad;\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YPOSITION,tif->tif_dir.td_yposition))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SUBFILETYPE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_SUBFILETYPE,tif->tif_dir.td_subfiletype))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_BITSPERSAMPLE,tif->tif_dir.td_bitspersample))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_COMPRESSION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_COMPRESSION,tif->tif_dir.td_compression))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PHOTOMETRIC,tif->tif_dir.td_photometric))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_THRESHHOLDING,tif->tif_dir.td_threshholding))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_FILLORDER))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_FILLORDER,tif->tif_dir.td_fillorder))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_ORIENTATION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_ORIENTATION,tif->tif_dir.td_orientation))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_SAMPLESPERPIXEL,tif->tif_dir.td_samplesperpixel))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_ROWSPERSTRIP,tif->tif_dir.td_rowsperstrip))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MINSAMPLEVALUE,tif->tif_dir.td_minsamplevalue))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MAXSAMPLEVALUE,tif->tif_dir.td_maxsamplevalue))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_PLANARCONFIG))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PLANARCONFIG,tif->tif_dir.td_planarconfig))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_RESOLUTIONUNIT,tif->tif_dir.td_resolutionunit))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_PAGENUMBER))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_PAGENUMBER,2,&tif->tif_dir.td_pagenumber[0]))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPBYTECOUNTS))\t\t\t{\t\t\t\tif (!isTiled(tif))\t\t\t\t{\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\t\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\t\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPOFFSETS))\t\t\t{\t\t\t\tif (!isTiled(tif))\t\t\t\t{                                         if (tif->tif_dir.td_stripoffset != NULL &&                        !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))                        goto bad;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\t\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_COLORMAP))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_EXTRASAMPLES))\t\t\t{\t\t\t\tif (tif->tif_dir.td_extrasamples)\t\t\t\t{\t\t\t\t\tuint16 na;\t\t\t\t\tuint16* nb;\t\t\t\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb);\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb))\t\t\t\t\t\tgoto bad;\t\t\t\t}\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDEPTH))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_TILEDEPTH,tif->tif_dir.td_tiledepth))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_HALFTONEHINTS,2,&tif->tif_dir.td_halftonehints[0]))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_YCBCRSUBSAMPLING,2,&tif->tif_dir.td_ycbcrsubsampling[0]))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_YCBCRPOSITIONING,tif->tif_dir.td_ycbcrpositioning))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_REFBLACKWHITE))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,TIFFTAG_REFERENCEBLACKWHITE,6,tif->tif_dir.td_refblackwhite))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagTransferfunction(tif,&ndir,dir))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_INKNAMES))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames))\t\t\t\t\tgoto bad;\t\t\t}\t\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD))\t\t\t{\t\t\t\tif (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir))\t\t\t\t\tgoto bad;\t\t\t}\t\t\t{\t\t\t\tuint32 n;\t\t\t\tfor (n=0; n<tif->tif_nfields; n++) {\t\t\t\t\tconst TIFFField* o;\t\t\t\t\to = tif->tif_fields[n];\t\t\t\t\tif ((o->field_bit>=FIELD_CODEC)&&(TIFFFieldSet(tif,o->field_bit)))\t\t\t\t\t{\t\t\t\t\t\tswitch (o->get_field_type)\t\t\t\t\t\t{\t\t\t\t\t\t\tcase TIFF_SETGET_ASCII:\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tuint32 pa;\t\t\t\t\t\t\t\t\tchar* pb;\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_ASCII);\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE);\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pb);\t\t\t\t\t\t\t\t\tpa=(uint32)(strlen(pb));\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\t\t\t\t\t\t\t\t\t\tgoto bad;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SETGET_UINT16:\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tuint16 p;\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_SHORT);\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p))\t\t\t\t\t\t\t\t\t\tgoto bad;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SETGET_UINT32:\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tuint32 p;\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_LONG);\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p))\t\t\t\t\t\t\t\t\t\tgoto bad;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tcase TIFF_SETGET_C32_UINT8:\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tuint32 pa;\t\t\t\t\t\t\t\t\tvoid* pb;\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_UNDEFINED);\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE2);\t\t\t\t\t\t\t\t\tassert(o->field_passcount==1);\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pa,&pb);\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\t\t\t\t\t\t\t\t\t\tgoto bad;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\tdefault:\t\t\t\t\t\t\t\tassert(0);    \t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\tfor (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++)\t\t{                        uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag;                        uint32 count = tif->tif_dir.td_customValues[m].count;\t\t\tswitch (tif->tif_dir.td_customValues[m].info->field_type)\t\t\t{\t\t\t\tcase TIFF_ASCII:\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_UNDEFINED:\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_BYTE:\t\t\t\t\tif (!TIFFWriteDirectoryTagByteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SBYTE:\t\t\t\t\tif (!TIFFWriteDirectoryTagSbyteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SHORT:\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SSHORT:\t\t\t\t\tif (!TIFFWriteDirectoryTagSshortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_LONG:\t\t\t\t\tif (!TIFFWriteDirectoryTagLongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SLONG:\t\t\t\t\tif (!TIFFWriteDirectoryTagSlongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_LONG8:\t\t\t\t\tif (!TIFFWriteDirectoryTagLong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SLONG8:\t\t\t\t\tif (!TIFFWriteDirectoryTagSlong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_RATIONAL:\t\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SRATIONAL:\t\t\t\t\tif (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_FLOAT:\t\t\t\t\tif (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_DOUBLE:\t\t\t\t\tif (!TIFFWriteDirectoryTagDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_IFD:\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tcase TIFF_IFD8:\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdIfd8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\t\t\t\t\t\tgoto bad;\t\t\t\t\tbreak;\t\t\t\tdefault:\t\t\t\t\tassert(0);    \t\t\t\t\tbreak;\t\t\t}\t\t}\t\tif (dir!=NULL)\t\t\tbreak;\t\tdir=_TIFFmalloc(ndir*sizeof(TIFFDirEntry));\t\tif (dir==NULL)\t\t{\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\t\t\tgoto bad;\t\t}\t\tif (isimage)\t\t{\t\t\tif ((tif->tif_diroff==0)&&(!TIFFLinkDirectory(tif)))\t\t\t\tgoto bad;\t\t}\t\telse\t\t\ttif->tif_diroff=(TIFFSeekFile(tif,0,SEEK_END)+1)&(~((toff_t)1));\t\tif (pdiroff!=NULL)\t\t\t*pdiroff=tif->tif_diroff;\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t\t\tdirsize=2+ndir*12+4;\t\telse\t\t\tdirsize=8+ndir*20+8;\t\ttif->tif_dataoff=tif->tif_diroff+dirsize;\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t\t\ttif->tif_dataoff=(uint32)tif->tif_dataoff;\t\tif ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize))\t\t{\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\");\t\t\tgoto bad;\t\t}\t\tif (tif->tif_dataoff&1)\t\t\ttif->tif_dataoff++;\t\tif (isimage)\t\t\ttif->tif_curdir++;\t}\tif (isimage)\t{\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0))\t\t{\t\t\tuint32 na;\t\t\tTIFFDirEntry* nb;\t\t\tfor (na=0, nb=dir; ; na++, nb++)\t\t\t{\t\t\t\tif( na == ndir )                                {                                    TIFFErrorExt(tif->tif_clientdata,module,                                                 \"Cannot find SubIFD tag\");                                    goto bad;                                }\t\t\t\tif (nb->tdir_tag==TIFFTAG_SUBIFD)\t\t\t\t\tbreak;\t\t\t}\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+2+na*12+8;\t\t\telse\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+8+na*20+12;\t\t}\t}\tdirmem=_TIFFmalloc(dirsize);\tif (dirmem==NULL)\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\t\tgoto bad;\t}\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t{\t\tuint8* n;\t\tuint32 nTmp;\t\tTIFFDirEntry* o;\t\tn=dirmem;\t\t*(uint16*)n=(uint16)ndir;\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabShort((uint16*)n);\t\tn+=2;\t\to=dir;\t\tfor (m=0; m<ndir; m++)\t\t{\t\t\t*(uint16*)n=o->tdir_tag;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabShort((uint16*)n);\t\t\tn+=2;\t\t\t*(uint16*)n=o->tdir_type;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabShort((uint16*)n);\t\t\tn+=2;\t\t\tnTmp = (uint32)o->tdir_count;\t\t\t_TIFFmemcpy(n,&nTmp,4);\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabLong((uint32*)n);\t\t\tn+=4;\t\t\t \t\t\t \t\t\t_TIFFmemcpy(n,&o->tdir_offset,4);\t\t\tn+=4;\t\t\to++;\t\t}\t\tnTmp = (uint32)tif->tif_nextdiroff;\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabLong(&nTmp);\t\t_TIFFmemcpy(n,&nTmp,4);\t}\telse\t{\t\tuint8* n;\t\tTIFFDirEntry* o;\t\tn=dirmem;\t\t*(uint64*)n=ndir;\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabLong8((uint64*)n);\t\tn+=8;\t\to=dir;\t\tfor (m=0; m<ndir; m++)\t\t{\t\t\t*(uint16*)n=o->tdir_tag;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabShort((uint16*)n);\t\t\tn+=2;\t\t\t*(uint16*)n=o->tdir_type;\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabShort((uint16*)n);\t\t\tn+=2;\t\t\t_TIFFmemcpy(n,&o->tdir_count,8);\t\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\t\tTIFFSwabLong8((uint64*)n);\t\t\tn+=8;\t\t\t_TIFFmemcpy(n,&o->tdir_offset,8);\t\t\tn+=8;\t\t\to++;\t\t}\t\t_TIFFmemcpy(n,&tif->tif_nextdiroff,8);\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabLong8((uint64*)n);\t}\t_TIFFfree(dir);\tdir=NULL;\tif (!SeekOK(tif,tif->tif_diroff))\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\t\tgoto bad;\t}\tif (!WriteOK(tif,dirmem,(tmsize_t)dirsize))\t{\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\t\tgoto bad;\t}\t_TIFFfree(dirmem);\tif (imagedone)\t{\t\tTIFFFreeDirectory(tif);\t\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\t\ttif->tif_flags &= ~TIFF_DIRTYSTRIP;\t\t(*tif->tif_cleanup)(tif);\t\t \t\tTIFFCreateDirectory(tif);\t}\treturn(1);bad:\tif (dir!=NULL)\t\t_TIFFfree(dir);\tif (dirmem!=NULL)\t\t_TIFFfree(dirmem);\treturn(0);}",
        "label": 1,
        "cve": "CVE-2018-10963"
    },
    {
        "code": "static toff_t_tiffSizeProc(thandle_t fd){\treturn ((toff_t)GetFileSize(fd, NULL));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFSwabArrayOfLong8(register uint64* lp, tmsize_t n){\tregister unsigned char *cp;\tregister unsigned char t;\tassert(sizeof(uint64)==8);\t\twhile (n-- > 0) {\t\tcp = (unsigned char *)lp;\t\tt = cp[7]; cp[7] = cp[0]; cp[0] = t;\t\tt = cp[6]; cp[6] = cp[1]; cp[1] = t;\t\tt = cp[5]; cp[5] = cp[2]; cp[2] = t;\t\tt = cp[4]; cp[4] = cp[3]; cp[3] = t;\t\tlp++;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intLZWFixupTags(TIFF* tif){\t(void) tif;\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intextractContigSamplesShifted32bits (uint8 *in, uint8 *out, uint32 cols,                                   tsample_t sample, uint16 spp, uint16 bps,  \t\t\t           tsample_t count, uint32 start, uint32 end,\t                           int shift)  {  int    ready_bits = 0, sindex = 0 ;  uint32 col, src_byte, src_bit, bit_offset;  uint32 longbuff1 = 0, longbuff2 = 0;  uint64 maskbits = 0, matchbits = 0;  uint64 buff1 = 0, buff2 = 0, buff3 = 0;  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;  uint8 *src = in;  uint8 *dst = out;  if ((in == NULL) || (out == NULL))    {    TIFFError(\"extractContigSamplesShifted32bits\",\"Invalid input or output buffer\");    return (1);    }  if ((start > end) || (start > cols))    {    TIFFError (\"extractContigSamplesShifted32bits\",                \"Invalid start column value %d ignored\", start);    start = 0;    }  if ((end == 0) || (end > cols))    {    TIFFError (\"extractContigSamplesShifted32bits\",                \"Invalid end column value %d ignored\", end);    end = cols;    }     ready_bits = shift;  maskbits =  (uint64)-1 >> ( 64 - bps);  for (col = start; col < end; col++)    {        bit_offset = col * bps * spp;    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)      {      if (sindex == 0)        {        src_byte = bit_offset / 8;        src_bit  = bit_offset % 8;        }      else        {        src_byte = (bit_offset + (sindex * bps)) / 8;        src_bit  = (bit_offset + (sindex * bps)) % 8;        }      src = in + src_byte;      matchbits = maskbits << (64 - src_bit - bps);       if (little_endian)        {\tlongbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\tlongbuff2 = longbuff1;        }      else        {\tlongbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\tlongbuff2 = longbuff1;\t}      buff3 = ((uint64)longbuff1 << 32) | longbuff2;      if ((col == start) && (sindex == sample))        buff2 = buff3 & ((uint64)-1) << (32 - shift);      buff1 = (buff3 & matchbits) << (src_bit);      if (ready_bits < 32)        {         bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;        buff2 = (buff2 | (buff1 >> ready_bits));        }      else          {        bytebuff1 = (buff2 >> 56);        *dst++ = bytebuff1;        bytebuff2 = (buff2 >> 48);        *dst++ = bytebuff2;        bytebuff3 = (buff2 >> 40);        *dst++ = bytebuff3;        bytebuff4 = (buff2 >> 32);        *dst++ = bytebuff4;        ready_bits -= 32;                buff2 = ((buff2 << 32) | (buff1 >> ready_bits));        }      ready_bits += bps;      }    }  while (ready_bits > 0)    {    bytebuff1 = (buff2 >> 56);    *dst++ = bytebuff1;    buff2 = (buff2 << 8);    ready_bits -= 8;    }  return (0);  } ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(void){\tchar buf[BUFSIZ];\tint i;\tsetbuf(stderr, buf);        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\tfor (i = 0; stuff[i] != NULL; i++)\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\texit(-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidTIFFReverseBits(uint8* cp, tmsize_t n)  {\tfor (; n > 8; n -= 8) {\t\tcp[0] = TIFFBitRevTable[cp[0]];\t\tcp[1] = TIFFBitRevTable[cp[1]];\t\tcp[2] = TIFFBitRevTable[cp[2]];\t\tcp[3] = TIFFBitRevTable[cp[3]];\t\tcp[4] = TIFFBitRevTable[cp[4]];\t\tcp[5] = TIFFBitRevTable[cp[5]];\t\tcp[6] = TIFFBitRevTable[cp[6]];\t\tcp[7] = TIFFBitRevTable[cp[7]];\t\tcp += 8;\t}\twhile (n-- > 0) {\t\t*cp = TIFFBitRevTable[*cp];\t\tcp++;\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*TIFFFdOpen(int fd, const char* name, const char* mode){\tTIFF* tif;\ttif = TIFFClientOpen(name, mode,  ddd\t    (thandle_t) fd,\t    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,\t    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);\tif (tif)\t\ttif->tif_fd = fd;\treturn (tif);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void TIFFModeCCITTFax3(void){}#endif",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void*_TIFFCheckMalloc(TIFF* tif, tmsize_t nmemb, tmsize_t elem_size, const char* what){\treturn _TIFFCheckRealloc(tif, NULL, nmemb, elem_size, what);  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intLZWSetupDecode(TIFF* tif){\tstatic const char module[] = \"LZWSetupDecode\";\tLZWCodecState* sp = DecoderState(tif);\tint code;\tif( sp == NULL )\t{\t\t\t\ttif->tif_data = (uint8*) _TIFFmalloc(sizeof(LZWCodecState));\t\tif (tif->tif_data == NULL)\t\t{\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"No space for LZW state block\");\t\t\treturn (0);\t\t}\t\tDecoderState(tif)->dec_codetab = NULL;\t\tDecoderState(tif)->dec_decode = NULL;\t\t\t\t(void) TIFFPredictorInit(tif);\t\tsp = DecoderState(tif);\t}\tassert(sp != NULL);\tif (sp->dec_codetab == NULL) {\t\tsp->dec_codetab = (code_t*)_TIFFmalloc(CSIZE*sizeof (code_t));\t\tif (sp->dec_codetab == NULL) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t     \"No space for LZW code table\");\t\t\treturn (0);\t\t}\t\t\t\tcode = 255;\t\tdo {\t\t\tsp->dec_codetab[code].value = (unsigned char)code;\t\t\tsp->dec_codetab[code].firstchar = (unsigned char)code;\t\t\tsp->dec_codetab[code].length = 1;\t\t\tsp->dec_codetab[code].next = NULL;\t\t} while (code--);\t\t                 _TIFFmemset(&sp->dec_codetab[CODE_CLEAR], 0,\t\t\t     (CODE_FIRST - CODE_CLEAR) * sizeof (code_t));\t}\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void_TIFFfree(tdata_t p){\tfree(p);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static uint64checkAdd64(uint64 summand1, uint64 summand2, T2P* t2p){\tuint64 bytes = summand1 + summand2;\tif (bytes < summand1) {\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\t\tt2p->t2p_error = T2P_ERR_ERROR;\t\tbytes = 0;\t}\treturn bytes;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidSimpleGammaCorrection(){    register int i;    register double i_gamma = 1.0 / appData.gamma;    for (i = 0; i < colormapSize; i++) {        if (((tfPhotometricInterpretation == PHOTOMETRIC_MINISWHITE)            && (i == colormapSize - 1))            || ((tfPhotometricInterpretation == PHOTOMETRIC_MINISBLACK)            && (i == 0)))            redMap[i] = greenMap[i] = blueMap[i] = 0;        else {            redMap[i] = ROUND((pow(dRed[i] / 65535.0, i_gamma) * 65535.0));            greenMap[i] = ROUND((pow(dGreen[i] / 65535.0, i_gamma) * 65535.0));            blueMap[i] = ROUND((pow(dBlue[i] / 65535.0, i_gamma) * 65535.0));        }    }    free(dRed); free(dGreen); free(dBlue);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intNeXTDecode(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s){\tregister u_char *bp, *op;\tregister tsize_t cc;\tregister int n;\ttidata_t row;\ttsize_t scanline;\t(void) s;\t\tfor (op = buf, cc = occ; cc-- > 0;)\t\t*op++ = 0xff;\tbp = (u_char *)tif->tif_rawcp;\tcc = tif->tif_rawcc;\tscanline = tif->tif_scanlinesize;\tfor (row = buf; (long)occ > 0; occ -= scanline, row += scanline) {\t\tn = *bp++, cc--;\t\tswitch (n) {\t\tcase LITERALROW:\t\t\t\t\t\tif (cc < scanline)\t\t\t\tgoto bad;\t\t\t_TIFFmemcpy(row, bp, scanline);\t\t\tbp += scanline;\t\t\tcc -= scanline;\t\t\tbreak;\t\tcase LITERALSPAN: {\t\t\tint off;\t\t\t\t\t\toff = (bp[0] * 256) + bp[1];\t\t\tn = (bp[2] * 256) + bp[3];\t\t\tif (cc < 4+n)\t\t\t\tgoto bad;\t\t\t_TIFFmemcpy(row+off, bp+4, n);\t\t\tbp += 4+n;\t\t\tcc -= 4+n;\t\t\tbreak;\t\t}\t\tdefault: {\t\t\tregister int npixels = 0, grey;\t\t\tu_long imagewidth = tif->tif_dir.td_imagewidth;\t\t\t\t\t\top = row;\t\t\tfor (;;) {\t\t\t\tgrey = (n>>6) & 0x3;\t\t\t\tn &= 0x3f;\t\t\t\twhile (n-- > 0)\t\t\t\t\tSETPIXEL(op, grey);\t\t\t\tif (npixels >= (int) imagewidth)\t\t\t\t\tbreak;\t\t\t\tif (cc == 0)\t\t\t\t\tgoto bad;\t\t\t\tn = *bp++, cc--;\t\t\t}\t\t\tbreak;\t\t}\t\t}\t}\ttif->tif_rawcp = (tidata_t) bp;\ttif->tif_rawcc = cc;\treturn (1);bad:\tTIFFError(tif->tif_name, \"NeXTDecode: Not enough data for scanline %ld\",\t    (long) tif->tif_row);\treturn (0);}",
        "label": 1,
        "cve": "cve-2004-0803_1"
    },
    {
        "code": "voidTIFFReadSeparateStripData(TIFF* tif){\tunsigned char *buf;\ttsize_t scanline = TIFFScanlineSize(tif);\tbuf = (unsigned char *)_TIFFmalloc(TIFFStripSize(tif));\tif (buf) {\t\tuint32 row, h;\t\tuint32 rowsperstrip = (uint32)-1;\t\ttsample_t s, samplesperpixel;\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\t\tfor (row = 0; row < h; row += rowsperstrip) {\t\t\tfor (s = 0; s < samplesperpixel; s++) {\t\t\t\tuint32 nrow = (row+rowsperstrip > h ?\t\t\t\t    h-row : rowsperstrip);\t\t\t\ttstrip_t strip = TIFFComputeStrip(tif, row, s);\t\t\t\tif (TIFFReadEncodedStrip(tif, strip, buf, nrow*scanline) < 0) {\t\t\t\t\tif (stoponerr)\t\t\t\t\t\tbreak;\t\t\t\t} else if (showdata)\t\t\t\t\tShowStrip(strip, buf, nrow, scanline);\t\t\t}\t\t}\t\t_TIFFfree(buf);\t}}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int_TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c){\treturn (memcmp(p1, p2, (size_t) c));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intPixarLogVSetField(TIFF* tif, uint32 tag, va_list ap){    static const char module[] = \"PixarLogVSetField\";    PixarLogState *sp = (PixarLogState *)tif->tif_data;    int result;    switch (tag) {     case TIFFTAG_PIXARLOGQUALITY:\t\tsp->quality = (int) va_arg(ap, int);\t\tif (tif->tif_mode != O_RDONLY && (sp->state&PLSTATE_INIT)) {\t\t\tif (deflateParams(&sp->stream,\t\t\t    sp->quality, Z_DEFAULT_STRATEGY) != Z_OK) {\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"ZLib error: %s\",\t\t\t\t\tsp->stream.msg ? sp->stream.msg : \"(null)\");\t\t\t\treturn (0);\t\t\t}\t\t}\t\treturn (1);     case TIFFTAG_PIXARLOGDATAFMT:\tsp->user_datafmt = (int) va_arg(ap, int);\t\tswitch (sp->user_datafmt) {\t case PIXARLOGDATAFMT_8BIT:\t case PIXARLOGDATAFMT_8BITABGR:\t    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\t    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\t    break;\t case PIXARLOGDATAFMT_11BITLOG:\t    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);\t    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\t    break;\t case PIXARLOGDATAFMT_12BITPICIO:\t    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);\t    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\t    break;\t case PIXARLOGDATAFMT_16BIT:\t    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);\t    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\t    break;\t case PIXARLOGDATAFMT_FLOAT:\t    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32);\t    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\t    break;\t}\t\ttif->tif_tilesize = isTiled(tif) ? TIFFTileSize(tif) : (tmsize_t)(-1);\ttif->tif_scanlinesize = TIFFScanlineSize(tif);\tresult = 1;\t\t\tbreak;     default:\tresult = (*sp->vsetparent)(tif, tag, ap);    }    return (result);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "const unsigned char*TIFFGetBitRevTable(int reversed){\treturn (reversed ? TIFFBitRevTable : TIFFNoBitRevTable);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFWriteDirectoryTagSubifd(TIFF* tif, uint32* ndir, TIFFDirEntry* dir){\tstatic const char module[] = \"TIFFWriteDirectoryTagSubifd\";\tuint64 m;\tint n;\tif (tif->tif_dir.td_nsubifd==0)\t\treturn(1);\tif (dir==NULL)\t{\t\t(*ndir)++;\t\treturn(1);\t}\tm=tif->tif_dataoff;\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t{\t\tuint32* o;\t\tuint64* pa;\t\tuint32* pb;\t\tuint16 p;\t\to=_TIFFmalloc(tif->tif_dir.td_nsubifd*sizeof(uint32));\t\tif (o==NULL)\t\t{\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\t\t\treturn(0);\t\t}\t\tpa=tif->tif_dir.td_subifd;\t\tpb=o;\t\tfor (p=0; p < tif->tif_dir.td_nsubifd; p++)\t\t{                        assert(pa != 0);\t\t\tassert(*pa <= 0xFFFFFFFFUL);\t\t\t*pb++=(uint32)(*pa++);\t\t}\t\tn=TIFFWriteDirectoryTagCheckedIfdArray(tif,ndir,dir,TIFFTAG_SUBIFD,tif->tif_dir.td_nsubifd,o);\t\t_TIFFfree(o);\t}\telse\t\tn=TIFFWriteDirectoryTagCheckedIfd8Array(tif,ndir,dir,TIFFTAG_SUBIFD,tif->tif_dir.td_nsubifd,tif->tif_dir.td_subifd);\tif (!n)\t\treturn(0);\t\ttif->tif_flags|=TIFF_INSUBIFD;\ttif->tif_nsubifd=tif->tif_dir.td_nsubifd;\tif (tif->tif_dir.td_nsubifd==1)\t\ttif->tif_subifdoff=0;\telse\t\ttif->tif_subifdoff=m;\treturn(1);}",
        "label": 1,
        "cve": "cve-2017-13727"
    },
    {
        "code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedRational(TIFF* tif, TIFFDirEntry* direntry, double* value){\tUInt64Aligned_t m;\tassert(sizeof(double)==8);\tassert(sizeof(uint64)==8);\tassert(sizeof(uint32)==4);\tif (!(tif->tif_flags&TIFF_BIGTIFF))\t{\t\tenum TIFFReadDirEntryErr err;\t\tuint32 offset = direntry->tdir_offset.toff_long;\t\tif (tif->tif_flags&TIFF_SWAB)\t\t\tTIFFSwabLong(&offset);\t\terr=TIFFReadDirEntryData(tif,offset,8,m.i);\t\tif (err!=TIFFReadDirEntryErrOk)\t\t\treturn(err);\t}\telse\t\tm.l = direntry->tdir_offset.toff_long8;\tif (tif->tif_flags&TIFF_SWAB)\t\tTIFFSwabArrayOfLong(m.i,2);\tif (m.i[0]==0)\t\t*value=0.0;\telse\t\t*value=(double)m.i[0]/(double)m.i[1];\treturn(TIFFReadDirEntryErrOk);}",
        "label": 1,
        "cve": "cve-2017-7597-1"
    },
    {
        "code": "static void TIFF_GetSourceSamples( double * padfSamples, unsigned char *pabySrc,                        int nPixelBytes, int nSampleFormat,                        uint32 nXSize, uint32 nYSize,                        int nPixelOffset, int nLineOffset ){    uint32  iXOff, iYOff;    int     iSample;    iSample = 0;    for( iYOff = 0; iYOff < nYSize; iYOff++ )    {        for( iXOff = 0; iXOff < nXSize; iXOff++ )        {            unsigned char *pabyData;            pabyData = pabySrc + iYOff * nLineOffset + iXOff * nPixelOffset;            if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 1 )            {                padfSamples[iSample++] = *pabyData;            }            else if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 2 )            {                padfSamples[iSample++] = ((uint16 *) pabyData)[0];            }            else if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 4 )            {                padfSamples[iSample++] = ((uint32 *) pabyData)[0];            }            else if( nSampleFormat == SAMPLEFORMAT_INT && nPixelBytes == 2 )            {                padfSamples[iSample++] = ((int16 *) pabyData)[0];            }            else if( nSampleFormat == SAMPLEFORMAT_INT && nPixelBytes == 32 )            {                padfSamples[iSample++] = ((int32 *) pabyData)[0];            }            else if( nSampleFormat == SAMPLEFORMAT_IEEEFP && nPixelBytes == 4 )            {                padfSamples[iSample++] = ((float *) pabyData)[0];            }            else if( nSampleFormat == SAMPLEFORMAT_IEEEFP && nPixelBytes == 8 )            {                padfSamples[iSample++] = ((double *) pabyData)[0];            }        }    }} ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidCreateXImage(){    XGCValues gc_values;    GC bitmap_gc;    xOffset = yOffset = 0;    grabX = grabY = -1;    xImage = XCreateImage(xDisplay, xVisual, xImageDepth,        xImageDepth == 1 ? XYBitmap : ZPixmap,  0,        (char *) imageMemory, tfImageWidth, tfImageHeight,         8,  0);        if (xImageDepth == 1)        xImage->bitmap_bit_order = MSBFirst;    if (xImageDepth <= 8)        xImage->byte_order = MSBFirst;        gc_values.function = GXcopy;    gc_values.plane_mask = AllPlanes;    if (tfPhotometricInterpretation == PHOTOMETRIC_MINISBLACK) {        gc_values.foreground = XWhitePixel(xDisplay, xScreen);        gc_values.background = XBlackPixel(xDisplay, xScreen);    } else {        gc_values.foreground = XBlackPixel(xDisplay, xScreen);        gc_values.background = XWhitePixel(xDisplay, xScreen);    }    xWinGc = XCreateGC(xDisplay, XtWindow(shellWidget),        GCFunction | GCPlaneMask | GCForeground | GCBackground, &gc_values);        if (appData.usePixmap == True) {        xImagePixmap = XCreatePixmap(xDisplay, RootWindow(xDisplay, xScreen),            xImage->width, xImage->height, xImageDepth);                if (xImageDepth == 1) {                     gc_values.foreground = 1;               gc_values.background = 0;               bitmap_gc = XCreateGC(xDisplay, xImagePixmap,                GCForeground | GCBackground, &gc_values);            XPutImage(xDisplay, xImagePixmap, bitmap_gc, xImage,                0, 0, 0, 0, xImage->width, xImage->height);        } else            XPutImage(xDisplay, xImagePixmap, xWinGc, xImage,                0, 0, 0, 0, xImage->width, xImage->height);        XDestroyImage(xImage);        free(imageMemory);    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intTIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, long nstrips, uint32** lpp){\tregister uint32* lp;\tint status;        CheckDirCount(tif, dir, (uint32) nstrips);\t\tif (*lpp == NULL &&\t    (*lpp = (uint32 *)CheckMalloc(tif,\t      nstrips * sizeof (uint32), \"for strip array\")) == NULL)\t\treturn (0);\tlp = *lpp;        memset( lp, 0, sizeof(uint32) * nstrips );\tif (dir->tdir_type == (int)TIFF_SHORT) {\t\t\t\tuint16* dp = (uint16*) CheckMalloc(tif,\t\t    dir->tdir_count* sizeof (uint16), \"to fetch strip tag\");\t\tif (dp == NULL)\t\t\treturn (0);\t\tif( (status = TIFFFetchShortArray(tif, dir, dp)) != 0 ) {                    int i;                                        for( i = 0; i < nstrips && i < (int) dir->tdir_count; i++ )                    {                        lp[i] = dp[i];                    }\t\t}\t\t_TIFFfree((char*) dp);        } else if( nstrips != (int) dir->tdir_count ) {                        uint32* dp = (uint32*) CheckMalloc(tif,\t\t    dir->tdir_count* sizeof (uint32), \"to fetch strip tag\");            if (dp == NULL)                return (0);            status = TIFFFetchLongArray(tif, dir, dp);            if( status != 0 ) {                int i;                for( i = 0; i < nstrips && i < (int) dir->tdir_count; i++ )                {                    lp[i] = dp[i];                }            }            _TIFFfree( (char *) dp );\t} else            status = TIFFFetchLongArray(tif, dir, lp);        \treturn (status);}",
        "label": 1,
        "cve": "cve-2004-1307"
    },
    {
        "code": "intmain(int argc, char **argv){\tTIFF\t\t*tif;\tstatic const char *srcfilerel = \"images/quad-tile.jpg.tiff\";\tchar *srcdir = NULL;\tchar srcfile[1024];\tunsigned short h, v;\tint status;\tunsigned char *buffer;\tuint32 *rgba_buffer;\ttsize_t sz, szout;\tunsigned int pixel_status = 0;        (void) argc;        (void) argv;\tif ((srcdir = getenv(\"srcdir\")) == NULL) {\t\tsrcdir = \".\";\t}\tif ((strlen(srcdir) + 1 + strlen(srcfilerel)) >= sizeof(srcfile)) {\t\tfprintf( stderr, \"srcdir too long %s\\n\", srcdir);\t\texit( 1 );\t}\tstrcpy(srcfile,srcdir);\tstrcat(srcfile,\"/\");\tstrcat(srcfile,srcfilerel);\ttif = TIFFOpen(srcfile,\"r\");\tif ( tif == NULL ) {\t\tfprintf( stderr, \"Could not open %s\\n\", srcfile);\t\texit( 1 );\t}\tstatus = TIFFGetField(tif,TIFFTAG_YCBCRSUBSAMPLING, &h, &v);\tif ( status == 0 || h != 2 || v != 2) {\t\tfprintf( stderr, \"Could not retrieve subsampling tag.\\n\" );\t\texit(1);\t}\t\tsz = TIFFTileSize(tif);\tif( sz != 24576) {\t\tfprintf(stderr, \"tiles are %d bytes\\n\", (int)sz);\t\texit(1);\t}\tbuffer = (unsigned char *) malloc(sz);\t\tszout = TIFFReadEncodedTile(tif,9,buffer,sz);\tif (szout != sz) {\t\tfprintf( stderr, \t\t\t \"Did not get expected result code from TIFFReadEncodedTile()(%d instead of %d)\\n\", \t\t\t (int) szout, (int) sz );\t\treturn 1;\t}\tif( check_cluster( 0, buffer, cluster_0 )\t    || check_cluster( 64, buffer, cluster_64 )\t    || check_cluster( 128, buffer, cluster_128 ) ) {\t\texit(1);\t}\tfree(buffer);\t\tTIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\tsz = TIFFTileSize(tif);\tif( sz != 128*128*3) {\t\tfprintf(stderr, \"tiles are %d bytes\\n\", (int)sz);\t\texit(1);\t}\tbuffer = (unsigned char *) malloc(sz);\tszout = TIFFReadEncodedTile(tif,9,buffer,sz);\tif (szout != sz) {\t\tfprintf( stderr, \t\t\t \"Did not get expected result code from TIFFReadEncodedTile()(%d instead of %d)\\n\", \t\t\t (int) szout, (int) sz );\t\treturn 1;\t}\t\tpixel_status |= check_rgb_pixel( 0, 15, 18, 0, 0, 18, 41, buffer );\tpixel_status |= check_rgb_pixel( 64, 0, 0, 0, 0, 0, 2, buffer );\tpixel_status |= check_rgb_pixel( 512, 5, 6, 34, 36, 182, 196, buffer );\tfree( buffer );\tTIFFClose(tif);\t\ttif = TIFFOpen(srcfile,\"r\");\tsz = 128 * 128 * sizeof(uint32);\trgba_buffer = (uint32 *) malloc(sz);\tif (!TIFFReadRGBATile( tif, 1*128, 2*128, rgba_buffer )) {\t\tfprintf( stderr, \"TIFFReadRGBATile() returned failure code.\\n\" );\t\treturn 1;\t}\t\tpixel_status |= check_rgba_pixel( 0, 15, 18, 0, 0, 18, 41, 255, 255,\t\t\t\t\t  rgba_buffer );\tpixel_status |= check_rgba_pixel( 64, 0, 0, 0, 0, 0, 2, 255, 255,\t\t\t\t\t  rgba_buffer );\tpixel_status |= check_rgba_pixel( 512, 5, 6, 34, 36, 182, 196, 255, 255,\t\t\t\t\t  rgba_buffer );\tfree( rgba_buffer );\tTIFFClose(tif);\tif (pixel_status) {\t\texit(1);\t}\texit( 0 );}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFGetField(TIFF* tif, ttag_t tag, ...){\tint status;\tva_list ap;\tva_start(ap, tag);\tstatus = TIFFVGetField(tif, tag, ap);\tva_end(ap);\treturn (status);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFInitPixarLog(TIFF* tif, int scheme){\tstatic const char module[] = \"TIFFInitPixarLog\";\tPixarLogState* sp;\tassert(scheme == COMPRESSION_PIXARLOG);\t\tif (!_TIFFMergeFields(tif, pixarlogFields,\t\t\t      TIFFArrayCount(pixarlogFields))) {\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t     \"Merging PixarLog codec-specific tags failed\");\t\treturn 0;\t}\t\ttif->tif_data = (uint8*) _TIFFmalloc(sizeof (PixarLogState));\tif (tif->tif_data == NULL)\t\tgoto bad;\tsp = (PixarLogState*) tif->tif_data;\t_TIFFmemset(sp, 0, sizeof (*sp));\tsp->stream.data_type = Z_BINARY;\tsp->user_datafmt = PIXARLOGDATAFMT_UNKNOWN;\t\ttif->tif_fixuptags = PixarLogFixupTags; \ttif->tif_setupdecode = PixarLogSetupDecode;\ttif->tif_predecode = PixarLogPreDecode;\ttif->tif_decoderow = PixarLogDecode;\ttif->tif_decodestrip = PixarLogDecode;  \ttif->tif_decodetile = PixarLogDecode;\ttif->tif_setupencode = PixarLogSetupEncode;\ttif->tif_preencode = PixarLogPreEncode;\ttif->tif_postencode = PixarLogPostEncode;\ttif->tif_encoderow = PixarLogEncode;  \ttif->tif_encodestrip = PixarLogEncode;\ttif->tif_encodetile = PixarLogEncode;  \ttif->tif_close = PixarLogClose;\ttif->tif_cleanup = PixarLogCleanup;\t\tsp->vgetparent = tif->tif_tagmethods.vgetfield;\ttif->tif_tagmethods.vgetfield = PixarLogVGetField;   \tsp->vsetparent = tif->tif_tagmethods.vsetfield;\ttif->tif_tagmethods.vsetfield = PixarLogVSetField;   \t\tsp->quality = Z_DEFAULT_COMPRESSION; \tsp->state = 0;\t\t(void) TIFFPredictorInit(tif);\t\tPixarLogMakeTables(sp);\treturn (1);bad:\tTIFFErrorExt(tif->tif_clientdata, module,\t\t     \"No space for PixarLog state block\");\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size){}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidleof(const char* name, uint32 row, int s){\tprintf(\"%s: EOF at scanline %lu\", name, (unsigned long)row);\tif (s >= 0)\t\tprintf(\", sample %d\", s);\tprintf(\"\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "tdir_tTIFFNumberOfDirectories(TIFF* tif){    toff_t nextdir = tif->tif_header.tiff_diroff;    tdir_t n = 0;    while (nextdir != 0 && TIFFAdvanceDirectory(tif, &nextdir, NULL))        n++;    return (n);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int_TIFFNoRowEncode(TIFF* tif, tidata_t pp, tsize_t cc, tsample_t s){\t(void) pp; (void) cc; (void) s;\treturn (TIFFNoEncode(tif, \"scanline\"));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "    { setByteArray((void**) cpp, (void*) cp, n, 1); }void _TIFFsetShortArray(uint16** wpp, uint16* wp, uint32 n)    { setByteArray((void**) wpp, (void*) wp, n, sizeof (uint16)); }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char* argv[]){\tint i, dither = 0;\tuint16 shortv, config, photometric;\tColorbox *box_list, *ptr;\tfloat floatv;\tuint32 longv;\tint c;#if !HAVE_DECL_OPTARG\textern int optind;\textern char* optarg;#endif\tnum_colors = MAX_CMAP_SIZE;\twhile ((c = getopt(argc, argv, \"c:C:r:f\")) != -1)\t\tswitch (c) {\t\tcase 'c':\t\t\t\t\tif (!processCompressOptions(optarg))\t\t\t\tusage();\t\t\tbreak;\t\tcase 'C':\t\t\t\t\tnum_colors = atoi(optarg);\t\t\tif (num_colors > MAX_CMAP_SIZE) {\t\t\t\tfprintf(stderr,\t\t\t\t   \"-c: colormap too big, max %d\\n\",\t\t\t\t   MAX_CMAP_SIZE);\t\t\t\tusage();\t\t\t}\t\t\tbreak;\t\tcase 'f':\t\t\t\t\tdither = 1;\t\t\tbreak;\t\tcase 'r':\t\t\t\t\trowsperstrip = atoi(optarg);\t\t\tbreak;\t\tcase '?':\t\t\tusage();\t\t\t\t\t}\tif (argc - optind != 2)\t\tusage();\tin = TIFFOpen(argv[optind], \"r\");\tif (in == NULL)\t\treturn (-1);\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &imagewidth);\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &imagelength);\tTIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\tTIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\tif (bitspersample != 8 && bitspersample != 16) {\t\tfprintf(stderr, \"%s: Image must have at least 8-bits/sample\\n\",\t\t    argv[optind]);\t\treturn (-3);\t}\tif (!TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric) ||\t    photometric != PHOTOMETRIC_RGB || samplesperpixel < 3) {\t\tfprintf(stderr, \"%s: Image must have RGB data\\n\", argv[optind]);\t\treturn (-4);\t}\tTIFFGetField(in, TIFFTAG_PLANARCONFIG, &config);\tif (config != PLANARCONFIG_CONTIG) {\t\tfprintf(stderr, \"%s: Can only handle contiguous data packing\\n\",\t\t    argv[optind]);\t\treturn (-5);\t}\t\tusedboxes = NULL;\tbox_list = freeboxes = (Colorbox *)_TIFFmalloc(num_colors*sizeof (Colorbox));\tfreeboxes[0].next = &freeboxes[1];\tfreeboxes[0].prev = NULL;\tfor (i = 1; i < num_colors-1; ++i) {\t\tfreeboxes[i].next = &freeboxes[i+1];\t\tfreeboxes[i].prev = &freeboxes[i-1];\t}\tfreeboxes[num_colors-1].next = NULL;\tfreeboxes[num_colors-1].prev = &freeboxes[num_colors-2];\t\tptr = freeboxes;\tfreeboxes = ptr->next;\tif (freeboxes)\t\tfreeboxes->prev = NULL;\tptr->next = usedboxes;\tusedboxes = ptr;\tif (ptr->next)\t\tptr->next->prev = ptr;\tget_histogram(in, ptr);\t\twhile (freeboxes != NULL) {\t\tptr = largest_box();\t\tif (ptr != NULL)\t\t\tsplitbox(ptr);\t\telse\t\t\tfreeboxes = NULL;\t}\t\tfor (i = 0, ptr = usedboxes; ptr != NULL; ++i, ptr = ptr->next) {\t\trm[i] = ((ptr->rmin + ptr->rmax) << COLOR_SHIFT) / 2;\t\tgm[i] = ((ptr->gmin + ptr->gmax) << COLOR_SHIFT) / 2;\t\tbm[i] = ((ptr->bmin + ptr->bmax) << COLOR_SHIFT) / 2;\t}\t\t_TIFFfree(box_list);\tfreeboxes = usedboxes = NULL;\t\t\tColorCells = (C_cell **)_TIFFmalloc(C_LEN*C_LEN*C_LEN*sizeof (C_cell*));\t_TIFFmemset(ColorCells, 0, C_LEN*C_LEN*C_LEN*sizeof (C_cell*));\t\tmap_colortable();\t\tout = TIFFOpen(argv[optind+1], \"w\");\tif (out == NULL)\t\treturn (-2);\tCopyField(TIFFTAG_SUBFILETYPE, longv);\tCopyField(TIFFTAG_IMAGEWIDTH, longv);\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, (short)COLOR_DEPTH);\tif (compression != (uint16)-1) {\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\t\tswitch (compression) {\t\tcase COMPRESSION_LZW:\t\tcase COMPRESSION_DEFLATE:\t\t\tif (predictor != 0)\t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\t\t\tbreak;\t\t}\t} else\t\tCopyField(TIFFTAG_COMPRESSION, compression);\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, (short)PHOTOMETRIC_PALETTE);\tCopyField(TIFFTAG_ORIENTATION, shortv);\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, (short)1);\tCopyField(TIFFTAG_PLANARCONFIG, shortv);\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\t    TIFFDefaultStripSize(out, rowsperstrip));\tCopyField(TIFFTAG_MINSAMPLEVALUE, shortv);\tCopyField(TIFFTAG_MAXSAMPLEVALUE, shortv);\tCopyField(TIFFTAG_RESOLUTIONUNIT, shortv);\tCopyField(TIFFTAG_XRESOLUTION, floatv);\tCopyField(TIFFTAG_YRESOLUTION, floatv);\tCopyField(TIFFTAG_XPOSITION, floatv);\tCopyField(TIFFTAG_YPOSITION, floatv);\tif (dither)\t\tquant_fsdither(in, out);\telse\t\tquant(in, out);\t#define\tSCALE(x)\t(((x)*((1L<<16)-1))/255)\tfor (i = 0; i < MAX_CMAP_SIZE; ++i) {\t\trm[i] = SCALE(rm[i]);\t\tgm[i] = SCALE(gm[i]);\t\tbm[i] = SCALE(bm[i]);\t}\tTIFFSetField(out, TIFFTAG_COLORMAP, rm, gm, bm);\t(void) TIFFClose(out);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void *TIFFGetClientInfo( TIFF *tif, const char *name ){    TIFFClientInfoLink *psLink = tif->tif_clientinfo;    while( psLink != NULL && strcmp(psLink->name,name) != 0 )        psLink = psLink->next;    if( psLink != NULL )        return psLink->data;    else        return NULL;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intSeparateCompare(int reversed, int sample, uint32 row,\t\tunsigned char* cp1, unsigned char* p2){\tuint32 npixels = imagewidth;\tint pixel;\tcp1 += sample;\tfor (pixel = 0; npixels-- > 0; pixel++, cp1 += samplesperpixel, p2++) {\t\tif (*cp1 != *p2) {\t\t\tprintf(\"Scanline %lu, pixel %lu, sample %ld: \",\t\t\t    (long) row, (long) pixel, (long) sample);\t\t\tif (reversed)\t\t\t\tprintf(\"%02x %02x\\n\", *p2, *cp1);\t\t\telse\t\t\t\tprintf(\"%02x %02x\\n\", *cp1, *p2);\t\t\tif (--stopondiff == 0)\t\t\t\texit(1);\t\t}\t}\treturn 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidraster_reshape(int win_w, int win_h){        GLfloat xratio = (GLfloat)win_w/img.width;        GLfloat yratio = (GLfloat)win_h/img.height;        int     ratio = (int)(((xratio > yratio)?xratio:yratio) * 100);        glPixelZoom(xratio, yratio);        glViewport(0, 0, win_w, win_h);        snprintf(title, 1024, \"%s [%u] %d%%\", filelist[fileindex],                (unsigned int) TIFFCurrentDirectory(tif), ratio);        glutSetWindowTitle(title);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intFax4PostEncode(TIFF* tif){\tFax3CodecState *sp = EncoderState(tif);\t\tFax3PutBits(tif, EOL, 12);\tFax3PutBits(tif, EOL, 12);\tif (sp->bit != 8)\t\tFax3FlushBits(tif, sp);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidhorizontalAccumulate8(uint16 *wp, int n, int stride, unsigned char *op,\tunsigned char *ToLinear8){    register unsigned int  cr, cg, cb, ca, mask;    if (n >= stride) {\tmask = CODE_MASK;\tif (stride == 3) {\t    op[0] = ToLinear8[cr = (wp[0] & mask)];\t    op[1] = ToLinear8[cg = (wp[1] & mask)];\t    op[2] = ToLinear8[cb = (wp[2] & mask)];\t    n -= 3;\t    while (n > 0) {\t\tn -= 3;\t\twp += 3;\t\top += 3;\t\top[0] = ToLinear8[(cr += wp[0]) & mask];\t\top[1] = ToLinear8[(cg += wp[1]) & mask];\t\top[2] = ToLinear8[(cb += wp[2]) & mask];\t    }\t} else if (stride == 4) {\t    op[0] = ToLinear8[cr = (wp[0] & mask)];\t    op[1] = ToLinear8[cg = (wp[1] & mask)];\t    op[2] = ToLinear8[cb = (wp[2] & mask)];\t    op[3] = ToLinear8[ca = (wp[3] & mask)];\t    n -= 4;\t    while (n > 0) {\t\tn -= 4;\t\twp += 4;\t\top += 4;\t\top[0] = ToLinear8[(cr += wp[0]) & mask];\t\top[1] = ToLinear8[(cg += wp[1]) & mask];\t\top[2] = ToLinear8[(cb += wp[2]) & mask];\t\top[3] = ToLinear8[(ca += wp[3]) & mask];\t    }\t} else {\t    REPEAT(stride, *op = ToLinear8[*wp&mask]; wp++; op++)\t    n -= stride;\t    while (n > 0) {\t\tREPEAT(stride,\t\t    wp[stride] += *wp; *op = ToLinear8[*wp&mask]; wp++; op++)\t\tn -= stride;\t    }\t}    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intsetExtraSamples(TIFFDirectory* td, va_list ap, uint32* v){\tuint16* va;\tuint32 i;\t*v = va_arg(ap, uint32);\tif ((uint16) *v > td->td_samplesperpixel)\t\treturn (0);\tva = va_arg(ap, uint16*);\tif (*v > 0 && va == NULL)\t\t\t\treturn (0);\tfor (i = 0; i < *v; i++)\t\tif (va[i] > EXTRASAMPLE_UNASSALPHA)\t\t\treturn (0);\ttd->td_extrasamples = (uint16) *v;\t_TIFFsetShortArray(&td->td_sampleinfo, va, td->td_extrasamples);\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "TIFF*TIFFFdOpen(int ifd, const char* name, const char* mode){\tTIFF* tif;\tBOOL fSuppressMap = (mode[1] == 'u' || (mode[1]!=0 && mode[2] == 'u'));\ttif = TIFFClientOpen(name, mode, (thandle_t)ifd,\t\t\t_tiffReadProc, _tiffWriteProc,\t\t\t_tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\t\t\tfSuppressMap ? _tiffDummyMapProc : _tiffMapProc,\t\t\tfSuppressMap ? _tiffDummyUnmapProc : _tiffUnmapProc);\tif (tif)\t\ttif->tif_fd = ifd;\treturn (tif);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcpTags(TIFF* in, TIFF* out){    struct cpTag *p;    for (p = tags; p < &tags[NTAGS]; p++)\tcpTag(in, out, p->tag, p->count, p->type);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "HDIB LoadTIFFinDIB(LPSTR lpFileName)    {    TIFF          *tif;    unsigned long imageLength;     unsigned long imageWidth;     unsigned int  BitsPerSample;    unsigned long LineSize;    unsigned int  SamplePerPixel;    unsigned long RowsPerStrip;      int           PhotometricInterpretation;    long          nrow;\tunsigned long row;    char          *buf;              LPBITMAPINFOHEADER lpDIB;     HDIB          hDIB;    char          *lpBits;    HGLOBAL       hStrip;    int           i,l;    int           Align;     tif = TIFFOpen(lpFileName, \"r\");    if (!tif)        goto TiffOpenError;    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &imageWidth);    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imageLength);      TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);      TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);       TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);    LineSize = TIFFScanlineSize(tif);     SamplePerPixel = (int) (LineSize/imageWidth);        Align = 4 - (LineSize % 4);    if (Align == 4)\tAlign = 0;        hDIB = CreateDIB((DWORD) imageWidth, (DWORD) imageLength, (WORD)(BitsPerSample*SamplePerPixel));    lpDIB  = (LPBITMAPINFOHEADER) GlobalLock(hDIB);    if (!lpDIB)          goto OutOfDIBMemory;    if (lpDIB)       lpBits = FindDIBBits((LPSTR) lpDIB);    \t    if (lpBits)      {        lpBits = FindDIBBits((LPSTR) lpDIB);        lpBits+=((imageWidth*SamplePerPixel)+Align)*(imageLength-1);\t\t        hStrip = GlobalAlloc(GHND,TIFFStripSize(tif));        buf = GlobalLock(hStrip);                   if (!buf)           goto OutOfBufMemory;                        if (PhotometricInterpretation == 3)        {          uint16* red;          uint16* green;          uint16* blue;          int16 i;          LPBITMAPINFO lpbmi;             int   Palette16Bits;                    TIFFGetField(tif, TIFFTAG_COLORMAP, &red, &green, &blue); \t\t            if (checkcmap(1<<BitsPerSample, red, green, blue) == 16)              Palette16Bits = TRUE;          else             Palette16Bits = FALSE;          lpbmi = (LPBITMAPINFO)lpDIB;                                          for (i = (1<<BitsPerSample)-1; i >= 0; i--)             {                          if (Palette16Bits)                {                  lpbmi->bmiColors[i].rgbRed =(BYTE) CVT(red[i]);                  lpbmi->bmiColors[i].rgbGreen = (BYTE) CVT(green[i]);                  lpbmi->bmiColors[i].rgbBlue = (BYTE) CVT(blue[i]);                           }             else                {                  lpbmi->bmiColors[i].rgbRed = (BYTE) red[i];                  lpbmi->bmiColors[i].rgbGreen = (BYTE) green[i];                  lpbmi->bmiColors[i].rgbBlue = (BYTE) blue[i];                        }            }          }        \t\t<=> BGR        for (row = 0; row < imageLength; row += RowsPerStrip)           {                 nrow = (row + RowsPerStrip > imageLength ? imageLength - row :RowsPerStrip);            if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 0),                buf, nrow*LineSize)==-1)                  {                     goto TiffReadError;                  }             else                  {                      for (l = 0; l < nrow; l++)                       {                         if (SamplePerPixel  == 3)                           for (i=0;i< (int) (imageWidth);i++)                              {                               lpBits[i*SamplePerPixel+0]=buf[l*LineSize+i*SamplePerPixel+2];                                lpBits[i*SamplePerPixel+1]=buf[l*LineSize+i*SamplePerPixel+1];                               lpBits[i*SamplePerPixel+2]=buf[l*LineSize+i*SamplePerPixel+0];                              }                         else                           memcpy(lpBits, &buf[(int) (l*LineSize)], (int)imageWidth*SamplePerPixel);                          lpBits-=imageWidth*SamplePerPixel+Align;                      }                 }          }        GlobalUnlock(hStrip);        GlobalFree(hStrip);        GlobalUnlock(hDIB);         TIFFClose(tif);      }    return hDIB;    OutOfBufMemory:    TiffReadError:       GlobalUnlock(hDIB);        GlobalFree(hStrip);    OutOfDIBMemory:       TIFFClose(tif);    TiffOpenError:       return (HANDLE) 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcpStripToTile(uint8* out, uint8* in,    uint32 rows, uint32 cols, int outskew, int inskew){\twhile (rows-- > 0) {\t\tuint32 j = cols;\t\twhile (j-- > 0)\t\t\t*out++ = *in++;\t\tout += outskew;\t\tin += inskew;\t}}",
        "label": 1,
        "cve": "cve-2016-9540"
    },
    {
        "code": "static voidsvRGBContig(TIFF* tif, uint32* ss, int xsize, int ysize){\tregister int x, y;\ttsize_t stripsize = TIFFStripSize(tif);\tunsigned char *strip = (unsigned char *)_TIFFmalloc(stripsize);\tfor (y = 0; y <= ysize; y += rowsperstrip) {\t\tregister unsigned char *pp = strip;\t\tregister uint32 n;\t\tn = rowsperstrip;\t\tif (n > ysize-y+1)\t\t\tn = ysize-y+1;\t\tdo {\t\t\tfor (x = 0; x <= xsize; x++) {\t\t\t\tuint32 v = ss[x];\t\t\t\tpp[0] = v;\t\t\t\tpp[1] = v >> 8;\t\t\t\tpp[2] = v >> 16;\t\t\t\tpp += 3;\t\t\t}\t\t\tss += xsize+1;\t\t} while (--n);\t\tif (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,0),\t\t    strip, stripsize) < 0)\t\t\tbreak;\t}\t_TIFFfree(strip);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_tiffCloseProc(thandle_t fd){\treturn (_lclose(fd));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "T2P* t2p_init(){\tT2P* t2p = (T2P*) _TIFFmalloc(sizeof(T2P));\tif(t2p==NULL){\t\tTIFFError(\t\t\tTIFF2PDF_MODULE, \t\t\t\"Can't allocate %lu bytes of memory for t2p_init\", \t\t\t(unsigned long) sizeof(T2P));\t\treturn( (T2P*) NULL );\t}\t_TIFFmemset(t2p, 0x00, sizeof(T2P));\tt2p->pdf_majorversion=1;\tt2p->pdf_minorversion=1;\tt2p->pdf_defaultxres=300.0;\tt2p->pdf_defaultyres=300.0;\tt2p->pdf_defaultpagewidth=612.0;\tt2p->pdf_defaultpagelength=792.0;\tt2p->pdf_xrefcount=3; \treturn(t2p);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_XTIFFVGetField(TIFF* tif, ttag_t tag, va_list ap){\txtiff *xt = XTIFFDIR(tif);\tXTIFFDirectory* xd = &xt->xtif_dir;\tswitch (tag) {\t\t\tcase TIFFTAG_EXAMPLE_MULTI:\t\t*va_arg(ap, uint16*) = xd->xd_num_multi;\t\t*va_arg(ap, double**) = xd->xd_example_multi;\t\tbreak;\tcase TIFFTAG_EXAMPLE_ASCII:\t\t*va_arg(ap, char**) = xd->xd_example_ascii;\t\tbreak;\tcase TIFFTAG_EXAMPLE_SINGLE:\t\t*va_arg(ap, uint32*) = xd->xd_example_single;\t\tbreak;\tdefault:\t\t\t\treturn (PARENT(xt,vgetfield))(tif,tag,ap);\t\tbreak;\t}\treturn (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tmsize_t t2pReadFile(TIFF *tif, tdata_t data, tmsize_t size){\tthandle_t client = TIFFClientdata(tif);\tTIFFReadWriteProc proc = TIFFGetReadProc(tif);\tif (proc)\t\treturn proc(client, data, size);\treturn -1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidPixarLogCleanup(TIFF* tif){\tPixarLogState* sp = (PixarLogState*) tif->tif_data;\tassert(sp != 0);\t(void)TIFFPredictorCleanup(tif);\ttif->tif_tagmethods.vgetfield = sp->vgetparent;\ttif->tif_tagmethods.vsetfield = sp->vsetparent;\tif (sp->FromLT2) _TIFFfree(sp->FromLT2);\tif (sp->From14) _TIFFfree(sp->From14);\tif (sp->From8) _TIFFfree(sp->From8);\tif (sp->ToLinearF) _TIFFfree(sp->ToLinearF);\tif (sp->ToLinear16) _TIFFfree(sp->ToLinear16);\tif (sp->ToLinear8) _TIFFfree(sp->ToLinear8);\tif (sp->state&PLSTATE_INIT) {\t\tif (tif->tif_mode == O_RDONLY)\t\t\tinflateEnd(&sp->stream);\t\telse\t\t\tdeflateEnd(&sp->stream);\t}\tif (sp->tbuf)\t\t_TIFFfree(sp->tbuf);\t_TIFFfree(sp);\ttif->tif_data = NULL;\t_TIFFSetDefaultCompressionState(tif);}",
        "label": 1,
        "cve": "cve-2016-5316"
    },
    {
        "code": "static tsize_t_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size){\treturn (FSRead((short) fd, (long*) &size, (char*) buf) == noErr ?\t    size : (tsize_t) -1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intstrcasecmp(const char *s1, const char *s2){\tconst unsigned char *us1 = (const unsigned char *)s1,\t\t\t*us2 = (const unsigned char *)s2;\twhile (tolower(*us1) == tolower(*us2++))\t\tif (*us1++ == '\\0')\t\t\treturn (0);\treturn (tolower(*us1) - tolower(*--us2));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidraster_special(int key, int x, int y){        switch (key) {                case GLUT_KEY_PAGE_UP:                              if (TIFFCurrentDirectory(tif) > 0) {                            if (TIFFSetDirectory(tif,                                                 TIFFCurrentDirectory(tif)-1)) {                                    initImage();                                    setWindowSize();                        }                    } else {                            TIFFRGBAImageEnd(&img);                            prevImage();                            initImage();                            setWindowSize();                    }                break;                case GLUT_KEY_PAGE_DOWN:                            if (!TIFFLastDirectory(tif)) {                            if (TIFFReadDirectory(tif)) {                                    initImage();                                    setWindowSize();                            }                    } else {                            TIFFRGBAImageEnd(&img);                            nextImage();                            initImage();                            setWindowSize();                    }                break;                case GLUT_KEY_HOME:                                     if (TIFFSetDirectory(tif, 0)) {                                TIFFRGBAImageEnd(&img);                                initImage();                                setWindowSize();                        }                break;                case GLUT_KEY_END:                                      TIFFRGBAImageEnd(&img);                        while (!TIFFLastDirectory(tif))                                TIFFReadDirectory(tif);                        initImage();                        setWindowSize();                break;        }        glutPostRedisplay();}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFIsCODECConfigured(uint16 scheme){\tconst TIFFCodec* codec = TIFFFindCODEC(scheme);\tif(codec == NULL) {\t\treturn 0;\t}\tif(codec->init == NULL) {\t\treturn 0;\t}\tif(codec->init != NotConfigured){\t\treturn 1;\t}\treturn 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int dump_data (FILE *dumpfile, int format, char *dump_tag, unsigned char *data, uint32 count)  {  int j, k;  uint32 i;  char  dump_array[10];  unsigned char bitset;  if (dumpfile == NULL)    {    TIFFError (\"\", \"Invalid FILE pointer for dump file\");    return (1);    }  if (format == DUMP_TEXT)    {    fprintf (dumpfile,\" %s  \", dump_tag);    for (i = 0; i < count; i++)      {      for (j = 0, k = 7; j < 8; j++, k--)        {\tbitset = (*(data + i)) & (((unsigned char)1 << k)) ? 1 : 0;        sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");        }      dump_array[8] = '\\0';      fprintf (dumpfile,\" %s\", dump_array);      }    fprintf (dumpfile,\"\\n\");    }  else    {    if ((fwrite (data, 1, count, dumpfile)) != count)      {      TIFFError (\"\", \"Unable to write binary data to dump file\");      return (1);      }    }  return (0);  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static uint64 t2p_sizeproc(thandle_t handle) {\t(void) handle;\treturn -1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intisCCITTCompression(TIFF* tif){    uint16 compress;    TIFFGetField(tif, TIFFTAG_COMPRESSION, &compress);    return (compress == COMPRESSION_CCITTFAX3 ||\t    compress == COMPRESSION_CCITTFAX4 ||\t    compress == COMPRESSION_CCITTRLE ||\t    compress == COMPRESSION_CCITTRLEW);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intCheckShortField(TIFF *tif, const ttag_t field, const uint16 value){\tuint16 tmp = 123;\tif (!TIFFGetField(tif, field, &tmp)) {\t\tfprintf (stderr, \"Problem fetching tag %lu.\\n\",\t\t\t (unsigned long) field);\t\treturn -1;\t}\tif (tmp != value) {\t\tfprintf (stderr, \"Wrong SHORT value fetched for tag %lu.\\n\",\t\t\t (unsigned long) field);\t\treturn -1;\t}\treturn 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidsetByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size){\tif (*vpp)\t\t_TIFFfree(*vpp), *vpp = 0;\tif (vp) {\t\ttmsize_t bytes = (tmsize_t)(nmemb * elem_size);\t\tif (elem_size && bytes / elem_size == nmemb)\t\t\t*vpp = (void*) _TIFFmalloc(bytes);\t\tif (*vpp)\t\t\t_TIFFmemcpy(*vpp, vp, bytes);\t}}",
        "label": 1,
        "cve": "cve-2016-5315"
    },
    {
        "code": "intmain(int argc, char* argv[]){\tint c;#if !HAVE_DECL_OPTARG\textern int optind;\textern char* optarg;#endif\twhile ((c = getopt(argc, argv, \"c:p:r:\")) != -1)\t\tswitch (c) {\t\tcase 'b':\t\t\t\t\tphotometric = PHOTOMETRIC_MINISBLACK;\t\t\tbreak;\t\tcase 'c':\t\t\t\t\tif (streq(optarg, \"none\"))\t\t\t\tcompression = COMPRESSION_NONE;\t\t\telse if (streq(optarg, \"packbits\"))\t\t\t\tcompression = COMPRESSION_PACKBITS;\t\t\telse if (strneq(optarg, \"jpeg\", 4)) {\t\t\t\tchar* cp = strchr(optarg, ':');\t\t\t\tif (cp && isdigit(cp[1]))\t\t\t\t\tquality = atoi(cp+1);\t\t\t\tif (cp && strchr(cp, 'r'))\t\t\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;\t\t\t\tcompression = COMPRESSION_JPEG;\t\t\t} else if (strneq(optarg, \"lzw\", 3)) {\t\t\t\tchar* cp = strchr(optarg, ':');\t\t\t\tif (cp)\t\t\t\t\tpredictor = atoi(cp+1);\t\t\t\tcompression = COMPRESSION_LZW;\t\t\t} else\t\t\t\tusage();\t\t\tbreak;\t\tcase 'p':\t\t\t\t\tif (streq(optarg, \"separate\"))\t\t\t\tconfig = PLANARCONFIG_SEPARATE;\t\t\telse if (streq(optarg, \"contig\"))\t\t\t\tconfig = PLANARCONFIG_CONTIG;\t\t\telse\t\t\t\tusage();\t\t\tbreak;\t\tcase 'r':\t\t\t\t\trowsperstrip = atoi(optarg);\t\t\tbreak;\t\tcase '?':\t\t\tusage();\t\t\t\t\t}\tif (argc - optind != 1 && argc - optind != 5)\t\tusage();\txmaxscreen = getgdesc(GD_XPMAX)-1;\tymaxscreen = getgdesc(GD_YPMAX)-1;\tforeground();\tnoport();\twinopen(\"tiffsv\");\tif (argc - optind == 5)\t\ttiffsv(argv[optind],\t\t    atoi(argv[optind+1]), atoi(argv[optind+2]),\t\t    atoi(argv[optind+3]), atoi(argv[optind+4]));\telse\t\ttiffsv(argv[optind], 0, xmaxscreen, 0, ymaxscreen);\treturn (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static tmsize_t t2p_readproc(thandle_t handle, tdata_t data, tmsize_t size) {\t(void) handle, (void) data, (void) size;\treturn -1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intTIFFGetFieldDefaulted(TIFF* tif, uint32 tag, ...){\tint ok;\tva_list ap;\tva_start(ap, tag);\tok =  TIFFVGetFieldDefaulted(tif, tag, ap);\tva_end(ap);\treturn (ok);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "subtract(32)static biasFn *lineSubtractFn (unsigned bits){\tswitch (bits) {\t\tcase  8:  return subtract8;\t\tcase 16:  return subtract16;\t\tcase 32:  return subtract32;\t}\treturn NULL;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intThunderDecode(TIFF* tif, tidata_t op, tsize_t maxpixels){\tregister unsigned char *bp;\tregister tsize_t cc;\tunsigned int lastpixel;\ttsize_t npixels;\tbp = (unsigned char *)tif->tif_rawcp;\tcc = tif->tif_rawcc;\tlastpixel = 0;\tnpixels = 0;\twhile (cc > 0 && npixels < maxpixels) {\t\tint n, delta;\t\tn = *bp++, cc--;\t\tswitch (n & THUNDER_CODE) {\t\tcase THUNDER_RUN:\t\t\t\t\t\t\t\tif (npixels & 1) {\t\t\t\top[0] |= lastpixel;\t\t\t\tlastpixel = *op++; npixels++; n--;\t\t\t} else\t\t\t\tlastpixel |= lastpixel << 4;\t\t\tnpixels += n;\t\t\tif (npixels < maxpixels) {\t\t\t\tfor (; n > 0; n -= 2)\t\t\t\t\t*op++ = (tidataval_t) lastpixel;\t\t\t}\t\t\tif (n == -1)\t\t\t\t*--op &= 0xf0;\t\t\tlastpixel &= 0xf;\t\t\tbreak;\t\tcase THUNDER_2BITDELTAS:\t\t\t\tif ((delta = ((n >> 4) & 3)) != DELTA2_SKIP)\t\t\t\tSETPIXEL(op, lastpixel + twobitdeltas[delta]);\t\t\tif ((delta = ((n >> 2) & 3)) != DELTA2_SKIP)\t\t\t\tSETPIXEL(op, lastpixel + twobitdeltas[delta]);\t\t\tif ((delta = (n & 3)) != DELTA2_SKIP)\t\t\t\tSETPIXEL(op, lastpixel + twobitdeltas[delta]);\t\t\tbreak;\t\tcase THUNDER_3BITDELTAS:\t\t\t\tif ((delta = ((n >> 3) & 7)) != DELTA3_SKIP)\t\t\t\tSETPIXEL(op, lastpixel + threebitdeltas[delta]);\t\t\tif ((delta = (n & 7)) != DELTA3_SKIP)\t\t\t\tSETPIXEL(op, lastpixel + threebitdeltas[delta]);\t\t\tbreak;\t\tcase THUNDER_RAW:\t\t\t\t\tSETPIXEL(op, n);\t\t\tbreak;\t\t}\t}\ttif->tif_rawcp = (tidata_t) bp;\ttif->tif_rawcc = cc;\tif (npixels != maxpixels) {\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\t\t    \"ThunderDecode: %s data at scanline %ld (%lu != %lu)\",\t\t    npixels < maxpixels ? \"Not enough\" : \"Too much\",\t\t    (long) tif->tif_row, (long) npixels, (long) maxpixels);\t\treturn (0);\t}\treturn (1);}",
        "label": 1,
        "cve": "cve-2011-1167"
    },
    {
        "code": "void_TIFFmemcpy(tdata_t d, const tdata_t s, tsize_t c){\tmemcpy(d, s, (size_t) c);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidEstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount){\tregister TIFFDirEntry *dp;\tregister TIFFDirectory *td = &tif->tif_dir;\tuint16 i;\tif (td->td_stripbytecount)\t\t_TIFFfree(td->td_stripbytecount);\ttd->td_stripbytecount = (uint32*)\t    CheckMalloc(tif, td->td_nstrips * sizeof (uint32),\t\t\"for \\\"StripByteCounts\\\" array\");\tif (td->td_compression != COMPRESSION_NONE) {\t\tuint32 space = (uint32)(sizeof (TIFFHeader)\t\t    + sizeof (uint16)\t\t    + (dircount * sizeof (TIFFDirEntry))\t\t    + sizeof (uint32));\t\ttoff_t filesize = TIFFGetFileSize(tif);\t\tuint16 n;\t\t\t\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\t\t\tuint32 cc = dp->tdir_count*TIFFDataWidth(dp->tdir_type);\t\t\tif (cc > sizeof (uint32))\t\t\t\tspace += cc;\t\t}\t\tspace = (filesize - space) / td->td_samplesperpixel;\t\tfor (i = 0; i < td->td_nstrips; i++)\t\t\ttd->td_stripbytecount[i] = space;\t\t \t\ti--;\t\tif (td->td_stripoffset[i] + td->td_stripbytecount[i] > filesize)\t\t\ttd->td_stripbytecount[i] =\t\t\t    filesize - td->td_stripoffset[i];\t} else {\t\tuint32 rowbytes = TIFFScanlineSize(tif);\t\tuint32 rowsperstrip = td->td_imagelength / td->td_nstrips;\t\tfor (i = 0; i < td->td_nstrips; i++)\t\t\ttd->td_stripbytecount[i] = rowbytes*rowsperstrip;\t}\tTIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);\tif (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP))\t\ttd->td_rowsperstrip = td->td_imagelength;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int_TIFFVSetField(TIFF* tif, uint32 tag, va_list ap){\tstatic const char module[] = \"_TIFFVSetField\";\tTIFFDirectory* td = &tif->tif_dir;\tint status = 1;\tuint32 v32, i, v;\tchar* s;\tconst TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY);\tuint32 standard_tag = tag;\t \tif (fip->field_bit == FIELD_CUSTOM) {\t\tstandard_tag = 0;\t}\tswitch (standard_tag) {\tcase TIFFTAG_SUBFILETYPE:\t\ttd->td_subfiletype = (uint32) va_arg(ap, uint32);\t\tbreak;\tcase TIFFTAG_IMAGEWIDTH:\t\ttd->td_imagewidth = (uint32) va_arg(ap, uint32);\t\tbreak;\tcase TIFFTAG_IMAGELENGTH:\t\ttd->td_imagelength = (uint32) va_arg(ap, uint32);\t\tbreak;\tcase TIFFTAG_BITSPERSAMPLE:\t\ttd->td_bitspersample = (uint16) va_arg(ap, uint16_vap);\t\t \t\tif (tif->tif_flags & TIFF_SWAB) {\t\t\tif (td->td_bitspersample == 8)\t\t\t\ttif->tif_postdecode = _TIFFNoPostDecode;\t\t\telse if (td->td_bitspersample == 16)\t\t\t\ttif->tif_postdecode = _TIFFSwab16BitData;\t\t\telse if (td->td_bitspersample == 24)\t\t\t\ttif->tif_postdecode = _TIFFSwab24BitData;\t\t\telse if (td->td_bitspersample == 32)\t\t\t\ttif->tif_postdecode = _TIFFSwab32BitData;\t\t\telse if (td->td_bitspersample == 64)\t\t\t\ttif->tif_postdecode = _TIFFSwab64BitData;\t\t\telse if (td->td_bitspersample == 128)  \t\t\t\ttif->tif_postdecode = _TIFFSwab64BitData;\t\t}\t\tbreak;\tcase TIFFTAG_COMPRESSION:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\t \t\tif (TIFFFieldSet(tif, FIELD_COMPRESSION)) {\t\t\tif ((uint32)td->td_compression == v)\t\t\t\tbreak;\t\t\t(*tif->tif_cleanup)(tif);\t\t\ttif->tif_flags &= ~TIFF_CODERSETUP;\t\t}\t\t \t\tif( (status = TIFFSetCompressionScheme(tif, v)) != 0 )\t\t    td->td_compression = (uint16) v;\t\telse\t\t    status = 0;\t\tbreak;\tcase TIFFTAG_PHOTOMETRIC:\t\ttd->td_photometric = (uint16) va_arg(ap, uint16_vap);\t\tbreak;\tcase TIFFTAG_THRESHHOLDING:\t\ttd->td_threshholding = (uint16) va_arg(ap, uint16_vap);\t\tbreak;\tcase TIFFTAG_FILLORDER:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\tif (v != FILLORDER_LSB2MSB && v != FILLORDER_MSB2LSB)\t\t\tgoto badvalue;\t\ttd->td_fillorder = (uint16) v;\t\tbreak;\tcase TIFFTAG_ORIENTATION:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\tif (v < ORIENTATION_TOPLEFT || ORIENTATION_LEFTBOT < v)\t\t\tgoto badvalue;\t\telse\t\t\ttd->td_orientation = (uint16) v;\t\tbreak;\tcase TIFFTAG_SAMPLESPERPIXEL:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\tif (v == 0)\t\t\tgoto badvalue;\t\ttd->td_samplesperpixel = (uint16) v;\t\tbreak;\tcase TIFFTAG_ROWSPERSTRIP:\t\tv32 = (uint32) va_arg(ap, uint32);\t\tif (v32 == 0)\t\t\tgoto badvalue32;\t\ttd->td_rowsperstrip = v32;\t\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\t\t\ttd->td_tilelength = v32;\t\t\ttd->td_tilewidth = td->td_imagewidth;\t\t}\t\tbreak;\tcase TIFFTAG_MINSAMPLEVALUE:\t\ttd->td_minsamplevalue = (uint16) va_arg(ap, uint16_vap);\t\tbreak;\tcase TIFFTAG_MAXSAMPLEVALUE:\t\ttd->td_maxsamplevalue = (uint16) va_arg(ap, uint16_vap);\t\tbreak;\tcase TIFFTAG_SMINSAMPLEVALUE:\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\t\t\t_TIFFsetDoubleArray(&td->td_sminsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);\t\telse\t\t\tsetDoubleArrayOneValue(&td->td_sminsamplevalue, va_arg(ap, double), td->td_samplesperpixel);\t\tbreak;\tcase TIFFTAG_SMAXSAMPLEVALUE:\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\t\t\t_TIFFsetDoubleArray(&td->td_smaxsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);\t\telse\t\t\tsetDoubleArrayOneValue(&td->td_smaxsamplevalue, va_arg(ap, double), td->td_samplesperpixel);\t\tbreak;\tcase TIFFTAG_XRESOLUTION:\t\ttd->td_xresolution = (float) va_arg(ap, double);\t\tbreak;\tcase TIFFTAG_YRESOLUTION:\t\ttd->td_yresolution = (float) va_arg(ap, double);\t\tbreak;\tcase TIFFTAG_PLANARCONFIG:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\tif (v != PLANARCONFIG_CONTIG && v != PLANARCONFIG_SEPARATE)\t\t\tgoto badvalue;\t\ttd->td_planarconfig = (uint16) v;\t\tbreak;\tcase TIFFTAG_XPOSITION:\t\ttd->td_xposition = (float) va_arg(ap, double);\t\tbreak;\tcase TIFFTAG_YPOSITION:\t\ttd->td_yposition = (float) va_arg(ap, double);\t\tbreak;\tcase TIFFTAG_RESOLUTIONUNIT:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\tif (v < RESUNIT_NONE || RESUNIT_CENTIMETER < v)\t\t\tgoto badvalue;\t\ttd->td_resolutionunit = (uint16) v;\t\tbreak;\tcase TIFFTAG_PAGENUMBER:\t\ttd->td_pagenumber[0] = (uint16) va_arg(ap, uint16_vap);\t\ttd->td_pagenumber[1] = (uint16) va_arg(ap, uint16_vap);\t\tbreak;\tcase TIFFTAG_HALFTONEHINTS:\t\ttd->td_halftonehints[0] = (uint16) va_arg(ap, uint16_vap);\t\ttd->td_halftonehints[1] = (uint16) va_arg(ap, uint16_vap);\t\tbreak;\tcase TIFFTAG_COLORMAP:\t\tv32 = (uint32)(1L<<td->td_bitspersample);\t\t_TIFFsetShortArray(&td->td_colormap[0], va_arg(ap, uint16*), v32);\t\t_TIFFsetShortArray(&td->td_colormap[1], va_arg(ap, uint16*), v32);\t\t_TIFFsetShortArray(&td->td_colormap[2], va_arg(ap, uint16*), v32);\t\tbreak;\tcase TIFFTAG_EXTRASAMPLES:\t\tif (!setExtraSamples(td, ap, &v))\t\t\tgoto badvalue;\t\tbreak;\tcase TIFFTAG_MATTEING:\t\ttd->td_extrasamples =  (((uint16) va_arg(ap, uint16_vap)) != 0);\t\tif (td->td_extrasamples) {\t\t\tuint16 sv = EXTRASAMPLE_ASSOCALPHA;\t\t\t_TIFFsetShortArray(&td->td_sampleinfo, &sv, 1);\t\t}\t\tbreak;\tcase TIFFTAG_TILEWIDTH:\t\tv32 = (uint32) va_arg(ap, uint32);\t\tif (v32 % 16) {\t\t\tif (tif->tif_mode != O_RDONLY)\t\t\t\tgoto badvalue32;\t\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\t\t\t\t\"Nonstandard tile width %d, convert file\", v32);\t\t}\t\ttd->td_tilewidth = v32;\t\ttif->tif_flags |= TIFF_ISTILED;\t\tbreak;\tcase TIFFTAG_TILELENGTH:\t\tv32 = (uint32) va_arg(ap, uint32);\t\tif (v32 % 16) {\t\t\tif (tif->tif_mode != O_RDONLY)\t\t\t\tgoto badvalue32;\t\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\t\t\t    \"Nonstandard tile length %d, convert file\", v32);\t\t}\t\ttd->td_tilelength = v32;\t\ttif->tif_flags |= TIFF_ISTILED;\t\tbreak;\tcase TIFFTAG_TILEDEPTH:\t\tv32 = (uint32) va_arg(ap, uint32);\t\tif (v32 == 0)\t\t\tgoto badvalue32;\t\ttd->td_tiledepth = v32;\t\tbreak;\tcase TIFFTAG_DATATYPE:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\tswitch (v) {\t\tcase DATATYPE_VOID:\tv = SAMPLEFORMAT_VOID;\tbreak;\t\tcase DATATYPE_INT:\tv = SAMPLEFORMAT_INT;\tbreak;\t\tcase DATATYPE_UINT:\tv = SAMPLEFORMAT_UINT;\tbreak;\t\tcase DATATYPE_IEEEFP:\tv = SAMPLEFORMAT_IEEEFP;break;\t\tdefault:\t\tgoto badvalue;\t\t}\t\ttd->td_sampleformat = (uint16) v;\t\tbreak;\tcase TIFFTAG_SAMPLEFORMAT:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\tif (v < SAMPLEFORMAT_UINT || SAMPLEFORMAT_COMPLEXIEEEFP < v)\t\t\tgoto badvalue;\t\ttd->td_sampleformat = (uint16) v;\t\t \t\tif( td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT\t\t    && td->td_bitspersample == 32\t\t    && tif->tif_postdecode == _TIFFSwab32BitData )\t\t    tif->tif_postdecode = _TIFFSwab16BitData;\t\telse if( (td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT\t\t\t  || td->td_sampleformat == SAMPLEFORMAT_COMPLEXIEEEFP)\t\t\t && td->td_bitspersample == 64\t\t\t && tif->tif_postdecode == _TIFFSwab64BitData )\t\t    tif->tif_postdecode = _TIFFSwab32BitData;\t\tbreak;\tcase TIFFTAG_IMAGEDEPTH:\t\ttd->td_imagedepth = (uint32) va_arg(ap, uint32);\t\tbreak;\tcase TIFFTAG_SUBIFD:\t\tif ((tif->tif_flags & TIFF_INSUBIFD) == 0) {\t\t\ttd->td_nsubifd = (uint16) va_arg(ap, uint16_vap);\t\t\t_TIFFsetLong8Array(&td->td_subifd, (uint64*) va_arg(ap, uint64*),\t\t\t    (long) td->td_nsubifd);\t\t} else {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t     \"%s: Sorry, cannot nest SubIFDs\",\t\t\t\t     tif->tif_name);\t\t\tstatus = 0;\t\t}\t\tbreak;\tcase TIFFTAG_YCBCRPOSITIONING:\t\ttd->td_ycbcrpositioning = (uint16) va_arg(ap, uint16_vap);\t\tbreak;\tcase TIFFTAG_YCBCRSUBSAMPLING:\t\ttd->td_ycbcrsubsampling[0] = (uint16) va_arg(ap, uint16_vap);\t\ttd->td_ycbcrsubsampling[1] = (uint16) va_arg(ap, uint16_vap);\t\tbreak;\tcase TIFFTAG_TRANSFERFUNCTION:\t\tv = (td->td_samplesperpixel - td->td_extrasamples) > 1 ? 3 : 1;\t\tfor (i = 0; i < v; i++)\t\t\t_TIFFsetShortArray(&td->td_transferfunction[i],\t\t\t    va_arg(ap, uint16*), 1L<<td->td_bitspersample);\t\tbreak;\tcase TIFFTAG_REFERENCEBLACKWHITE:\t\t \t\t_TIFFsetFloatArray(&td->td_refblackwhite, va_arg(ap, float*), 6);\t\tbreak;\tcase TIFFTAG_INKNAMES:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\ts = va_arg(ap, char*);\t\tv = checkInkNamesString(tif, v, s);\t\tstatus = v > 0;\t\tif( v > 0 ) {\t\t\t_TIFFsetNString(&td->td_inknames, s, v);\t\t\ttd->td_inknameslen = v;\t\t}\t\tbreak;\tcase TIFFTAG_PERSAMPLE:\t\tv = (uint16) va_arg(ap, uint16_vap);\t\tif( v == PERSAMPLE_MULTI )\t\t\ttif->tif_flags |= TIFF_PERSAMPLE;\t\telse\t\t\ttif->tif_flags &= ~TIFF_PERSAMPLE;\t\tbreak;\tdefault: {\t\tTIFFTagValue *tv;\t\tint tv_size, iCustom;\t\t \t\tif(fip == NULL || fip->field_bit != FIELD_CUSTOM) {\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"%s: Invalid %stag \\\"%s\\\" (not supported by codec)\",\t\t\t    tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\",\t\t\t    fip ? fip->field_name : \"Unknown\");\t\t\tstatus = 0;\t\t\tbreak;\t\t}\t\t \t\ttv = NULL;\t\tfor (iCustom = 0; iCustom < td->td_customValueCount; iCustom++) {\t\t\tif (td->td_customValues[iCustom].info->field_tag == tag) {\t\t\t\ttv = td->td_customValues + iCustom;\t\t\t\tif (tv->value != NULL) {\t\t\t\t\t_TIFFfree(tv->value);\t\t\t\t\ttv->value = NULL;\t\t\t\t}\t\t\t\tbreak;\t\t\t}\t\t}\t\t \t\tif(tv == NULL) {\t\t\tTIFFTagValue *new_customValues;\t\t\ttd->td_customValueCount++;\t\t\tnew_customValues = (TIFFTagValue *)\t\t\t    _TIFFrealloc(td->td_customValues,\t\t\t    sizeof(TIFFTagValue) * td->td_customValueCount);\t\t\tif (!new_customValues) {\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t    \"%s: Failed to allocate space for list of custom values\",\t\t\t\t    tif->tif_name);\t\t\t\tstatus = 0;\t\t\t\tgoto end;\t\t\t}\t\t\ttd->td_customValues = new_customValues;\t\t\ttv = td->td_customValues + (td->td_customValueCount - 1);\t\t\ttv->info = fip;\t\t\ttv->value = NULL;\t\t\ttv->count = 0;\t\t}\t\t \t\ttv_size = _TIFFDataSize(fip->field_type);\t\tif (tv_size == 0) {\t\t\tstatus = 0;\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t    \"%s: Bad field type %d for \\\"%s\\\"\",\t\t\t    tif->tif_name, fip->field_type,\t\t\t    fip->field_name);\t\t\tgoto end;\t\t}\t\tif (fip->field_type == TIFF_ASCII)\t\t{\t\t\tuint32 ma;\t\t\tchar* mb;\t\t\tif (fip->field_passcount)\t\t\t{\t\t\t\tassert(fip->field_writecount==TIFF_VARIABLE2);\t\t\t\tma=(uint32)va_arg(ap,uint32);\t\t\t\tmb=(char*)va_arg(ap,char*);\t\t\t}\t\t\telse\t\t\t{\t\t\t\tmb=(char*)va_arg(ap,char*);\t\t\t\tma=(uint32)(strlen(mb)+1);\t\t\t}\t\t\ttv->count=ma;\t\t\tsetByteArray(&tv->value,mb,ma,1);\t\t}\t\telse\t\t{\t\t\tif (fip->field_passcount) {\t\t\t\tif (fip->field_writecount == TIFF_VARIABLE2)\t\t\t\t\ttv->count = (uint32) va_arg(ap, uint32);\t\t\t\telse\t\t\t\t\ttv->count = (int) va_arg(ap, int);\t\t\t} else if (fip->field_writecount == TIFF_VARIABLE\t\t\t   || fip->field_writecount == TIFF_VARIABLE2)\t\t\t\ttv->count = 1;\t\t\telse if (fip->field_writecount == TIFF_SPP)\t\t\t\ttv->count = td->td_samplesperpixel;\t\t\telse\t\t\t\ttv->count = fip->field_writecount;\t\t\tif (tv->count == 0) {\t\t\t\tstatus = 0;\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t\t\t\t     \"%s: Null count for \\\"%s\\\" (type \"\t\t\t\t\t     \"%d, writecount %d, passcount %d)\",\t\t\t\t\t     tif->tif_name,\t\t\t\t\t     fip->field_name,\t\t\t\t\t     fip->field_type,\t\t\t\t\t     fip->field_writecount,\t\t\t\t\t     fip->field_passcount);\t\t\t\tgoto end;\t\t\t}\t\t\ttv->value = _TIFFCheckMalloc(tif, tv->count, tv_size,\t\t\t    \"custom tag binary object\");\t\t\tif (!tv->value) {\t\t\t\tstatus = 0;\t\t\t\tgoto end;\t\t\t}\t\t\tif (fip->field_tag == TIFFTAG_DOTRANGE \t\t\t    && strcmp(fip->field_name,\"DotRange\") == 0) {\t\t\t\t \t\t\t\tuint16 v[2];\t\t\t\tv[0] = (uint16)va_arg(ap, int);\t\t\t\tv[1] = (uint16)va_arg(ap, int);\t\t\t\t_TIFFmemcpy(tv->value, &v, 4);\t\t\t}\t\t\telse if (fip->field_passcount\t\t\t\t  || fip->field_writecount == TIFF_VARIABLE\t\t\t\t  || fip->field_writecount == TIFF_VARIABLE2\t\t\t\t  || fip->field_writecount == TIFF_SPP\t\t\t\t  || tv->count > 1) {\t\t\t\t_TIFFmemcpy(tv->value, va_arg(ap, void *),\t\t\t\t    tv->count * tv_size);\t\t\t} else {\t\t\t\tchar *val = (char *)tv->value;\t\t\t\tassert( tv->count == 1 );\t\t\t\tswitch (fip->field_type) {\t\t\t\tcase TIFF_BYTE:\t\t\t\tcase TIFF_UNDEFINED:\t\t\t\t\t{\t\t\t\t\t\tuint8 v = (uint8)va_arg(ap, int);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SBYTE:\t\t\t\t\t{\t\t\t\t\t\tint8 v = (int8)va_arg(ap, int);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SHORT:\t\t\t\t\t{\t\t\t\t\t\tuint16 v = (uint16)va_arg(ap, int);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SSHORT:\t\t\t\t\t{\t\t\t\t\t\tint16 v = (int16)va_arg(ap, int);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_LONG:\t\t\t\tcase TIFF_IFD:\t\t\t\t\t{\t\t\t\t\t\tuint32 v = va_arg(ap, uint32);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SLONG:\t\t\t\t\t{\t\t\t\t\t\tint32 v = va_arg(ap, int32);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_LONG8:\t\t\t\tcase TIFF_IFD8:\t\t\t\t\t{\t\t\t\t\t\tuint64 v = va_arg(ap, uint64);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_SLONG8:\t\t\t\t\t{\t\t\t\t\t\tint64 v = va_arg(ap, int64);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_RATIONAL:\t\t\t\tcase TIFF_SRATIONAL:\t\t\t\tcase TIFF_FLOAT:\t\t\t\t\t{\t\t\t\t\t\tfloat v = (float)va_arg(ap, double);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tcase TIFF_DOUBLE:\t\t\t\t\t{\t\t\t\t\t\tdouble v = va_arg(ap, double);\t\t\t\t\t\t_TIFFmemcpy(val, &v, tv_size);\t\t\t\t\t}\t\t\t\t\tbreak;\t\t\t\tdefault:\t\t\t\t\t_TIFFmemset(val, 0, tv_size);\t\t\t\t\tstatus = 0;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t}\t}\t}\tif (status) {\t\tconst TIFFField* fip=TIFFFieldWithTag(tif,tag);\t\tif (fip)                \t\t\tTIFFSetFieldBit(tif, fip->field_bit);\t\ttif->tif_flags |= TIFF_DIRTYDIRECT;\t}end:\tva_end(ap);\treturn (status);badvalue:        {\t\tconst TIFFField* fip=TIFFFieldWithTag(tif,tag);\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t     \"%s: Bad value %u for \\\"%s\\\" tag\",\t\t     tif->tif_name, v,\t\t     fip ? fip->field_name : \"Unknown\");\t\tva_end(ap);        }\treturn (0);badvalue32:        {\t\tconst TIFFField* fip=TIFFFieldWithTag(tif,tag);\t\tTIFFErrorExt(tif->tif_clientdata, module,\t\t     \"%s: Bad value %u for \\\"%s\\\" tag\",\t\t     tif->tif_name, v32,\t\t     fip ? fip->field_name : \"Unknown\");\t\tva_end(ap);        }\treturn (0);}",
        "label": 1,
        "cve": "CVE-2018-5360-1"
    },
    {
        "code": "tdata_t_TIFFrealloc(tdata_t p, tsize_t s){\treturn (tdata_t) GlobalReAllocPtr(p, (DWORD) s, GHND);}",
        "label": 0,
        "cve": "none"
    }
]