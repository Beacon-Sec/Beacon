[
    {
        "code": "static intnpasses_from_interlace_type(png_const_structp pp, int interlace_type){   switch (interlace_type)   {   default:      png_error(pp, \"invalid interlace type\");   case PNG_INTERLACE_NONE:      return 1;   case PNG_INTERLACE_ADAM7:      return PNG_INTERLACE_ADAM7_PASSES;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "PNG_FUNCTION(void, (PNGCBAPI error), (png_structp png_ptr, const char *message),   static PNG_NORETURN){   display *d = (display*)png_get_error_ptr(png_ptr);   fprintf(stderr, \"%s(%s): libpng error: %s\\n\", d->file, d->test, message);   display_exit(d);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intimage_transform_png_set_expand_add(image_transform *this,    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth){   UNUSED(bit_depth)   this->next = *that;   *that = this;      return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int perform_one_test(FILE *fp, int nfiles){   int i;   struct timespec before, after;      rewind(fp);   if (mytime(&before))   {      for (i=0; i<nfiles; ++i)      {         if (read_png(fp))         {            if (ferror(fp))            {               perror(\"temporary file\");               fprintf(stderr, \"file %d: error reading PNG data\\n\", i);               return 0;            }         }         else         {            perror(\"temporary file\");            fprintf(stderr, \"file %d: error from libpng\\n\", i);            return 0;         }      }   }   else      return 0;   if (mytime(&after))   {            unsigned long s = after.tv_sec - before.tv_sec;      long ns = after.tv_nsec - before.tv_nsec;      if (ns < 0)      {         --s;         ns += 1000000000;         if (ns < 0)         {            fprintf(stderr, \"timepng: bad clock from kernel\\n\");            return 0;         }      }      printf(\"%lu.%.9ld\\n\", s, ns);      fflush(stdout);      if (ferror(stdout))      {         fprintf(stderr, \"timepng: error writing output\\n\");         return 0;      }            return 1;   }   else      return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void format_default(format_list *pf, int redundant){   if (redundant)   {      int i;            for (i=0; i<FORMAT_SET_COUNT; ++i)         pf->bits[i] = ~(png_uint_32)0;   }   else   {      png_uint_32 f;      for (f=0; f<FORMAT_COUNT; ++f)      {         #        ifdef PNG_FORMAT_BGR_SUPPORTED                        if ((f & PNG_FORMAT_FLAG_COLOR) == 0 &&               (f & PNG_FORMAT_FLAG_BGR) != 0)#        else            if ((f & 0x10U) != 0)#        endif            continue;         #        ifdef PNG_FORMAT_AFIRST_SUPPORTED            if ((f & PNG_FORMAT_FLAG_ALPHA) == 0 &&               (f & PNG_FORMAT_FLAG_AFIRST) != 0)#        else            if ((f & 0x20U) != 0)#        endif            continue;         format_set(pf, f);      }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static size_tsafecat_color_encoding(char *buffer, size_t bufsize, size_t pos,   PNG_CONST color_encoding *e, double encoding_gamma){   if (e != 0)   {      if (encoding_gamma != 0)         pos = safecat(buffer, bufsize, pos, \"(\");      pos = safecat(buffer, bufsize, pos, \"R(\");      pos = safecatd(buffer, bufsize, pos, e->red.X, 4);      pos = safecat(buffer, bufsize, pos, \",\");      pos = safecatd(buffer, bufsize, pos, e->red.Y, 4);      pos = safecat(buffer, bufsize, pos, \",\");      pos = safecatd(buffer, bufsize, pos, e->red.Z, 4);      pos = safecat(buffer, bufsize, pos, \"),G(\");      pos = safecatd(buffer, bufsize, pos, e->green.X, 4);      pos = safecat(buffer, bufsize, pos, \",\");      pos = safecatd(buffer, bufsize, pos, e->green.Y, 4);      pos = safecat(buffer, bufsize, pos, \",\");      pos = safecatd(buffer, bufsize, pos, e->green.Z, 4);      pos = safecat(buffer, bufsize, pos, \"),B(\");      pos = safecatd(buffer, bufsize, pos, e->blue.X, 4);      pos = safecat(buffer, bufsize, pos, \",\");      pos = safecatd(buffer, bufsize, pos, e->blue.Y, 4);      pos = safecat(buffer, bufsize, pos, \",\");      pos = safecatd(buffer, bufsize, pos, e->blue.Z, 4);      pos = safecat(buffer, bufsize, pos, \")\");      if (encoding_gamma != 0)         pos = safecat(buffer, bufsize, pos, \")\");   }   if (encoding_gamma != 0)   {      pos = safecat(buffer, bufsize, pos, \"^\");      pos = safecatd(buffer, bufsize, pos, encoding_gamma, 5);   }   return pos;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_read_set(png_store *ps, png_uint_32 id){   png_store_file *pf = ps->saved;   while (pf != NULL)   {      if (pf->id == id)      {         ps->current = pf;         ps->next = NULL;         store_read_buffer_next(ps);         return;      }      pf = pf->next;   }   {      size_t pos;      char msg[FILE_NAME_SIZE+64];      pos = standard_name_from_id(msg, sizeof msg, 0, id);      pos = safecat(msg, sizeof msg, pos, \": file not found\");      png_error(ps->pread, msg);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidrandom_color(png_colorp color){   static png_uint_32 color_seed[2] = { 0x12345678, 0x9abcdef };   make_random_bytes(color_seed, color, sizeof *color);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidput_uLong(uLong val){   putchar(val >> 24);   putchar(val >> 16);   putchar(val >>  8);   putchar(val >>  0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidchrm_modification_init(chrm_modification *me, png_modifier *pm,   PNG_CONST color_encoding *encoding){   CIE_color white = white_point(encoding);      me->encoding = encoding;      me->wx = fix(chromaticity_x(white));   me->wy = fix(chromaticity_y(white));   me->rx = fix(chromaticity_x(encoding->red));   me->ry = fix(chromaticity_y(encoding->red));   me->gx = fix(chromaticity_x(encoding->green));   me->gy = fix(chromaticity_y(encoding->green));   me->bx = fix(chromaticity_x(encoding->blue));   me->by = fix(chromaticity_y(encoding->blue));   modification_init(&me->this);   me->this.chunk = CHUNK_cHRM;   me->this.modify_fn = chrm_modify;   me->this.add = CHUNK_PLTE;   me->this.next = pm->modifications;   pm->modifications = &me->this;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidparse_color(char *arg, unsigned int *colors){   unsigned int ncolors = 0;   while (*arg && ncolors < 4)   {      char *ep = arg;      unsigned long ul = strtoul(arg, &ep, 0);      if (ul > 65535)      {         fprintf(stderr, \"makepng --color=...'%s': too big\\n\", arg);         exit(1);      }      if (ep == arg)      {         fprintf(stderr, \"makepng --color=...'%s': not a valid color\\n\", arg);         exit(1);      }      if (*ep) ++ep;       arg = ep;      colors[++ncolors] = (unsigned int)ul;    }   if (*arg)   {      fprintf(stderr, \"makepng --color=...'%s': too many values\\n\", arg);      exit(1);   }   *colors = ncolors;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(void){   fprintf(stderr, \"pngimage: no support for png_read/write_image\\n\");   return 77;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_16u16d(double d){   d = closestinteger(d);   return (png_uint_16)d;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intfindb(const png_byte *name){   int i = NINFO;   while (--i >= 0)   {      if (memcmp(chunk_info[i].name, name, 4) == 0)         break;   }   return i;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGCBAPIcount_zero_samples(png_structp png_ptr, png_row_infop row_info, png_bytep data){   png_bytep dp = data;   if (png_ptr == NULL)      return;           if (row_info->color_type == 0 || row_info->color_type == 3)    {       int pos = 0;       png_uint_32 n, nstop;       for (n = 0, nstop=row_info->width; n<nstop; n++)       {          if (row_info->bit_depth == 1)          {             if (((*dp << pos++ ) & 0x80) == 0)                zero_samples++;             if (pos == 8)             {                pos = 0;                dp++;             }          }          if (row_info->bit_depth == 2)          {             if (((*dp << (pos+=2)) & 0xc0) == 0)                zero_samples++;             if (pos == 8)             {                pos = 0;                dp++;             }          }          if (row_info->bit_depth == 4)          {             if (((*dp << (pos+=4)) & 0xf0) == 0)                zero_samples++;             if (pos == 8)             {                pos = 0;                dp++;             }          }          if (row_info->bit_depth == 8)             if (*dp++ == 0)                zero_samples++;          if (row_info->bit_depth == 16)          {             if ((*dp | *(dp+1)) == 0)                zero_samples++;             dp+=2;          }       }    }    else     {       png_uint_32 n, nstop;       int channel;       int color_channels = row_info->channels;       if (row_info->color_type > 3)color_channels--;       for (n = 0, nstop=row_info->width; n<nstop; n++)       {          for (channel = 0; channel < color_channels; channel++)          {             if (row_info->bit_depth == 8)                if (*dp++ == 0)                   zero_samples++;             if (row_info->bit_depth == 16)             {                if ((*dp | *(dp+1)) == 0)                   zero_samples++;                dp+=2;             }          }          if (row_info->color_type > 3)          {             dp++;             if (row_info->bit_depth == 16)                dp++;          }       }    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#include <sys/ioctl.h>int repl_getch( void ){  char ch;  int fd = fileno(stdin);  struct termio old_tty, new_tty;  ioctl(fd, TCGETA, &old_tty);  new_tty = old_tty;  new_tty.c_lflag &= ~(ICANON | ECHO | ISIG);  ioctl(fd, TCSETA, &new_tty);  fread(&ch, 1, sizeof(ch), stdin);  ioctl(fd, TCSETA, &old_tty);  return ch;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidfile_getpos(struct file *file, fpos_t *pos){   if (fgetpos(file->file, pos))   {            perror(file->file_name);      stop(file, READ_ERROR_CODE, \"fgetpos\");   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_rgba16(Pixel *p, png_const_voidp pb){   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);   p->r = pp[0];   p->g = pp[1];   p->b = pp[2];   p->a = pp[3];}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_bgr8(Pixel *p, png_const_voidp pb){   png_const_bytep pp = voidcast(png_const_bytep, pb);   p->r = pp[2];   p->g = pp[1];   p->b = pp[0];   p->a = 255;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGAPIpng_free_data(png_const_structrp png_ptr, png_inforp info_ptr, png_uint_32 mask,    int num){   png_debug(1, \"in png_free_data\");   if (png_ptr == NULL || info_ptr == NULL)      return;#ifdef PNG_TEXT_SUPPORTED       if (info_ptr->text != NULL &&       ((mask & PNG_FREE_TEXT) & info_ptr->free_me) != 0)   {      if (num != -1)      {         png_free(png_ptr, info_ptr->text[num].key);         info_ptr->text[num].key = NULL;      }      else      {         int i;         for (i = 0; i < info_ptr->num_text; i++)            png_free(png_ptr, info_ptr->text[i].key);         png_free(png_ptr, info_ptr->text);         info_ptr->text = NULL;         info_ptr->num_text = 0;         info_ptr->max_text = 0;      }   }#endif#ifdef PNG_tRNS_SUPPORTED       if (((mask & PNG_FREE_TRNS) & info_ptr->free_me) != 0)   {      info_ptr->valid &= ~PNG_INFO_tRNS;      png_free(png_ptr, info_ptr->trans_alpha);      info_ptr->trans_alpha = NULL;      info_ptr->num_trans = 0;   }#endif#ifdef PNG_sCAL_SUPPORTED       if (((mask & PNG_FREE_SCAL) & info_ptr->free_me) != 0)   {      png_free(png_ptr, info_ptr->scal_s_width);      png_free(png_ptr, info_ptr->scal_s_height);      info_ptr->scal_s_width = NULL;      info_ptr->scal_s_height = NULL;      info_ptr->valid &= ~PNG_INFO_sCAL;   }#endif#ifdef PNG_pCAL_SUPPORTED       if (((mask & PNG_FREE_PCAL) & info_ptr->free_me) != 0)   {      png_free(png_ptr, info_ptr->pcal_purpose);      png_free(png_ptr, info_ptr->pcal_units);      info_ptr->pcal_purpose = NULL;      info_ptr->pcal_units = NULL;      if (info_ptr->pcal_params != NULL)         {            int i;            for (i = 0; i < info_ptr->pcal_nparams; i++)               png_free(png_ptr, info_ptr->pcal_params[i]);            png_free(png_ptr, info_ptr->pcal_params);            info_ptr->pcal_params = NULL;         }      info_ptr->valid &= ~PNG_INFO_pCAL;   }#endif#ifdef PNG_iCCP_SUPPORTED       if (((mask & PNG_FREE_ICCP) & info_ptr->free_me) != 0)   {      png_free(png_ptr, info_ptr->iccp_name);      png_free(png_ptr, info_ptr->iccp_profile);      info_ptr->iccp_name = NULL;      info_ptr->iccp_profile = NULL;      info_ptr->valid &= ~PNG_INFO_iCCP;   }#endif#ifdef PNG_sPLT_SUPPORTED       if (info_ptr->splt_palettes != NULL &&       ((mask & PNG_FREE_SPLT) & info_ptr->free_me) != 0)   {      if (num != -1)      {         png_free(png_ptr, info_ptr->splt_palettes[num].name);         png_free(png_ptr, info_ptr->splt_palettes[num].entries);         info_ptr->splt_palettes[num].name = NULL;         info_ptr->splt_palettes[num].entries = NULL;      }      else      {         int i;         for (i = 0; i < info_ptr->splt_palettes_num; i++)         {            png_free(png_ptr, info_ptr->splt_palettes[i].name);            png_free(png_ptr, info_ptr->splt_palettes[i].entries);         }         png_free(png_ptr, info_ptr->splt_palettes);         info_ptr->splt_palettes = NULL;         info_ptr->splt_palettes_num = 0;         info_ptr->valid &= ~PNG_INFO_sPLT;      }   }#endif#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED   if (info_ptr->unknown_chunks != NULL &&       ((mask & PNG_FREE_UNKN) & info_ptr->free_me) != 0)   {      if (num != -1)      {          png_free(png_ptr, info_ptr->unknown_chunks[num].data);          info_ptr->unknown_chunks[num].data = NULL;      }      else      {         int i;         for (i = 0; i < info_ptr->unknown_chunks_num; i++)            png_free(png_ptr, info_ptr->unknown_chunks[i].data);         png_free(png_ptr, info_ptr->unknown_chunks);         info_ptr->unknown_chunks = NULL;         info_ptr->unknown_chunks_num = 0;      }   }#endif#ifdef PNG_eXIf_SUPPORTED       if (((mask & PNG_FREE_EXIF) & info_ptr->free_me) != 0)   {# ifdef PNG_READ_eXIf_SUPPORTED      if (info_ptr->eXIf_buf)      {         png_free(png_ptr, info_ptr->eXIf_buf);         info_ptr->eXIf_buf = NULL;      }# endif      if (info_ptr->exif)      {         png_free(png_ptr, info_ptr->exif);         info_ptr->exif = NULL;      }      info_ptr->valid &= ~PNG_INFO_eXIf;   }#endif#ifdef PNG_hIST_SUPPORTED       if (((mask & PNG_FREE_HIST) & info_ptr->free_me) != 0)   {      png_free(png_ptr, info_ptr->hist);      info_ptr->hist = NULL;      info_ptr->valid &= ~PNG_INFO_hIST;   }#endif       if (((mask & PNG_FREE_PLTE) & info_ptr->free_me) != 0)   {      png_free(png_ptr, info_ptr->palette);      info_ptr->palette = NULL;      info_ptr->valid &= ~PNG_INFO_PLTE;      info_ptr->num_palette = 0;   }#ifdef PNG_INFO_IMAGE_SUPPORTED       if (((mask & PNG_FREE_ROWS) & info_ptr->free_me) != 0)   {      if (info_ptr->row_pointers != NULL)      {         png_uint_32 row;         for (row = 0; row < info_ptr->height; row++)            png_free(png_ptr, info_ptr->row_pointers[row]);         png_free(png_ptr, info_ptr->row_pointers);         info_ptr->row_pointers = NULL;      }      info_ptr->valid &= ~PNG_INFO_IDAT;   }#endif   if (num != -1)      mask &= ~PNG_FREE_MUL;   info_ptr->free_me &= ~mask;}",
        "label": 1,
        "cve": "CVE-2018-14048"
    },
    {
        "code": "static voidtest_one_file(struct display *dp, const char *filename){      dp->operation = \"cache file\";   dp->transforms = 0;   display_cache_file(dp, filename);   update_display(dp);      if (dp->ignored_transforms != 0)   {      read_png(dp, &dp->original_file, \"ignored transforms\",         dp->ignored_transforms);            if (!compare_read(dp, 0))         return;    }#ifdef PNG_WRITE_SUPPORTED      dp->operation = \"write\";   write_png(dp, dp->original_ip, 0);   read_png(dp, &dp->written_file, NULL, 0);   if (!compare_read(dp, 0))      return;#endif      {            unsigned int active = dp->active_transforms;      const int exhaustive = (dp->options & EXHAUSTIVE) != 0;      unsigned int current = first_transform(active);      unsigned int bad_transforms = 0;      unsigned int bad_combo = ~0U;          unsigned int bad_combo_list = 0;       for (;;)      {         read_png(dp, &dp->original_file, \"active transforms\", current);         #ifdef PNG_WRITE_SUPPORTED         if ((current & write_transforms) == current)         {                        dp->operation = \"reversible transforms\";            write_png(dp, dp->read_ip, current);                        read_png(dp, &dp->written_file, NULL, 0);            if (!compare_read(dp, current))            {                              if (is_combo(current))               {                  bad_combo &= current;                  bad_combo_list |= current;               }               else                  bad_transforms |= current;            }         }#endif                  if (exhaustive)          {            unsigned int next = current;            do            {               if (next == read_transforms)                   goto combo;               ++next;            }              while (  (next & read_transforms) <= current                  || (next & active) == 0                   || (next & bad_transforms) != 0                  || skip_transform(dp, next));            assert((next & read_transforms) == next);            current = next;         }         else          {            active &= ~current;            if (active == 0)               goto combo;            current = first_transform(active);         }      }combo:      if (dp->options & FIND_BAD_COMBOS)      {                  if (bad_combo != ~0U)            printf(\"%s[0x%x]: PROBLEM: 0x%x[0x%x] ANTIDOTE: 0x%x\\n\",               dp->filename, active, bad_combo, bad_combo_list,               rw_transforms & ~bad_combo_list);         else            printf(\"%s: no %sbad combos found\\n\", dp->filename,               (dp->options & SKIP_BUGS) ? \"additional \" : \"\");      }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstandard_palette_init(standard_display *dp){   store_palette_entry *palette = store_current_palette(dp->ps, &dp->npalette);      if (dp->npalette > 0)   {      int i = dp->npalette;      memcpy(dp->palette, palette, i * sizeof *palette);            while (--i >= 0)         if (palette[i].alpha < 255)            break;#     ifdef __GNUC__                  if (i >= 0)            dp->is_transparent = 1;         else            dp->is_transparent = 0;#     else         dp->is_transparent = (i >= 0);#     endif   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int PNGCBAPI read_user_chunk_callback(png_struct *png_ptr,   png_unknown_chunkp chunk){   png_uint_32     *my_user_chunk_data;      if (chunk->name[0] == 115 && chunk->name[1] ==  84 &&            chunk->name[2] ==  69 && chunk->name[3] ==  82)             {                  if (chunk->size != 1)            return (-1);          if (chunk->data[0] != 0 && chunk->data[0] != 1)            return (-1);           my_user_chunk_data=(png_uint_32 *) png_get_user_chunk_ptr(png_ptr);         my_user_chunk_data[0]=chunk->data[0]+1;         return (1);      }   if (chunk->name[0] != 118 || chunk->name[1] != 112 ||           chunk->name[2] !=  65 || chunk->name[3] != 103)            return (0);       if (chunk->size != 9)      return (-1);    my_user_chunk_data=(png_uint_32 *) png_get_user_chunk_ptr(png_ptr);   my_user_chunk_data[1]=png_get_uint_31(png_ptr, chunk->data);   my_user_chunk_data[2]=png_get_uint_31(png_ptr, chunk->data + 4);   my_user_chunk_data[3]=(png_uint_32)chunk->data[8];   return (1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidfile_setpos(struct file *file, const fpos_t *pos){   if (fsetpos(file->file, pos))   {      perror(file->file_name);      stop(file, READ_ERROR_CODE, \"fsetpos\");   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intimage_transform_png_set_expand_gray_1_2_4_to_8_add(image_transform *this,    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth){   return image_transform_png_set_expand_add(this, that, colour_type,      bit_depth);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_tRNS_to_alpha_set(PNG_CONST image_transform *this,   transform_display *that, png_structp pp, png_infop pi){   png_set_tRNS_to_alpha(pp);   this->next->set(this->next, that, pp, pi);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": " * read and processed--i.e., we now have enough info to finish initializing */static void rpng2_x_init(void){    ulg i;    ulg rowbytes = rpng2_info.rowbytes;    Trace((stderr, \"beginning rpng2_x_init()\\n\"))    Trace((stderr, \"  rowbytes = %d\\n\", rpng2_info.rowbytes))    Trace((stderr, \"  width  = %ld\\n\", rpng2_info.width))    Trace((stderr, \"  height = %ld\\n\", rpng2_info.height))    rpng2_info.image_data = (uch *)malloc(rowbytes * rpng2_info.height);    if (!rpng2_info.image_data) {        readpng2_cleanup(&rpng2_info);        return;    }    rpng2_info.row_pointers = (uch **)malloc(rpng2_info.height * sizeof(uch *));    if (!rpng2_info.row_pointers) {        free(rpng2_info.image_data);        rpng2_info.image_data = NULL;        readpng2_cleanup(&rpng2_info);        return;    }    for (i = 0;  i < rpng2_info.height;  ++i)        rpng2_info.row_pointers[i] = rpng2_info.image_data + i*rowbytes;        if (rpng2_x_create_window()) {                        readpng2_cleanup(&rpng2_info);        rpng2_x_cleanup();        exit(2);    }    rpng2_info.state = kWindowInit;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void perform_gamma_sbit_tests(png_modifier *pm){   png_byte sbit;      for (sbit=pm->sbitlow; sbit<(1<<READ_BDHI); ++sbit)   {      png_byte colour_type = 0, bit_depth = 0;      unsigned int npalette = 0;      while (next_format(&colour_type, &bit_depth, &npalette, 1))         if ((colour_type & PNG_COLOR_MASK_ALPHA) == 0 &&            ((colour_type == 3 && sbit < 8) ||            (colour_type != 3 && sbit < bit_depth)))      {         unsigned int i;         for (i=0; i<pm->ngamma_tests; ++i)         {            unsigned int j;            for (j=0; j<pm->ngamma_tests; ++j) if (i != j)            {               gamma_transform_test(pm, colour_type, bit_depth, npalette,                  pm->interlace_type, 1/pm->gammas[i], pm->gammas[j],                  sbit, pm->use_input_precision_sbit, 0 );               if (fail(pm))                  return;            }         }      }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intis_bad_combo(int transforms){   unsigned int i;   for (i=0; i<ARRAY_SIZE(known_bad_combos); ++i)   {      int combo = known_bad_combos[i][0];      if ((combo & transforms) == combo &&         (transforms & known_bad_combos[i][1]) == 0)         return 1;   }   return 0; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_bytepstore_image_row(PNG_CONST png_store* ps, png_const_structp pp, int nImage,   png_uint_32 y){   png_size_t coffset = (nImage * ps->image_h + y) * (ps->cb_row + 5) + 2;   if (ps->image == NULL)      png_error(pp, \"no allocated image\");   if (coffset + ps->cb_row + 3 > ps->cb_image)      png_error(pp, \"image too small\");   return ps->image + coffset;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intglobal_end(struct global *global){   int rc;   IDAT_list_end(&global->idat_cache);   rc = global->status_code;   CLEAR(*global);   return rc;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intimage_transform_png_set_palette_to_rgb_add(image_transform *this,    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth){   UNUSED(bit_depth)   this->next = *that;   *that = this;   return colour_type == PNG_COLOR_TYPE_PALETTE;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_sRGB(Pixel *out, const Pixel *in, const Background *back){   (void)back;   out->r = isRGB(in->r);   if (in->g == in->r)   {      out->g = out->r;      if (in->b == in->r)         out->b = out->r;      else         out->b = isRGB(in->b);   }   else   {      out->g = isRGB(in->g);      if (in->b == in->r)         out->b = out->r;      else if (in->b == in->g)         out->b = out->g;      else         out->b = isRGB(in->b);   }   out->a = 255;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidsize_row(png_byte buffer[SIZE_ROWMAX], png_uint_32 bit_width, png_uint_32 y){      y = ((y & 1) << 7) + ((y & 2) << 6) + ((y & 4) << 5) + ((y & 8) << 4);      y ^= 0xA5;   while (bit_width >= 8)      *buffer++ = (png_byte)y++, bit_width -= 8;      if (bit_width > 0)   {      png_uint_32 mask = (1U<<(8-bit_width))-1;      *buffer = (png_byte)((*buffer & mask) | (y & ~mask));   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidpng_read_data(png_structp png_ptr, png_bytep data, png_size_t length){   png_size_t check;      check = (png_size_t)fread(data, (png_size_t)1, length,      (FILE *)png_ptr->io_ptr);   if (check != length)   {      png_error(png_ptr, \"Read Error\");   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intimage_transform_png_set_gray_to_rgb_add(image_transform *this,    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth){   UNUSED(bit_depth)   this->next = *that;   *that = this;   return (colour_type & PNG_COLOR_MASK_COLOR) == 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voiddeinterlace_row(png_bytep buffer, png_const_bytep row,   unsigned int pixel_size, png_uint_32 w, int pass){      png_uint_32 xin, xout, xstep;   xout = PNG_PASS_START_COL(pass);   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);   for (xin=0; xout<w; xout+=xstep)   {      pixel_copy(buffer, xout, row, xin, pixel_size);      ++xin;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#else int main(void){   fprintf(stderr,      \"pngvalid: no low level write support in libpng, all tests skipped\\n\");      return SKIP;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_byteisRGB(int fixed_linear){   return sRGB(fixed_linear / 65535.);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmodification_reset(png_modification *pmm){   if (pmm != NULL)   {      pmm->modified = 0;      pmm->added = 0;      pmm->removed = 0;      modification_reset(pmm->next);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "BOOL PngLoadImage (PTSTR pstrFileName, png_byte **ppbImageData,                   int *piWidth, int *piHeight, int *piChannels, png_color *pBkgColor){    static FILE        *pfFile;    png_byte            pbSig[8];    int                 iBitDepth;    int                 iColorType;    double              dGamma;    png_color_16       *pBackground;    png_uint_32         ulChannels;    png_uint_32         ulRowBytes;    png_byte           *pbImageData = *ppbImageData;    static png_byte   **ppbRowPointers = NULL;    int                 i;        if (!pstrFileName)    {        *ppbImageData = pbImageData = NULL;        return FALSE;    }    if (!(pfFile = fopen(pstrFileName, \"rb\")))    {        *ppbImageData = pbImageData = NULL;        return FALSE;    }        fread(pbSig, 1, 8, pfFile);    if (png_sig_cmp(pbSig, 0, 8))    {        *ppbImageData = pbImageData = NULL;        return FALSE;    }        png_ptr = png_create_read_struct(png_get_libpng_ver(NULL), NULL,      (png_error_ptr)png_cexcept_error, (png_error_ptr)NULL);    if (!png_ptr)    {        *ppbImageData = pbImageData = NULL;        return FALSE;    }    info_ptr = png_create_info_struct(png_ptr);    if (!info_ptr)    {        png_destroy_read_struct(&png_ptr, NULL, NULL);        *ppbImageData = pbImageData = NULL;        return FALSE;    }    Try    {        #ifdef PNG_STDIO_SUPPORTED        png_init_io(png_ptr, pfFile);#else        png_set_read_fn(png_ptr, (png_voidp)pfFile, png_read_data);#endif        png_set_sig_bytes(png_ptr, 8);                png_read_info(png_ptr, info_ptr);                png_get_IHDR(png_ptr, info_ptr, piWidth, piHeight, &iBitDepth,            &iColorType, NULL, NULL, NULL);                #ifdef PNG_READ_16_TO_8_SUPPORTED    if (iBitDepth == 16)#  ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED        png_set_scale_16(png_ptr);#  else        png_set_strip_16(png_ptr);#  endif#endif        if (iColorType == PNG_COLOR_TYPE_PALETTE)            png_set_expand(png_ptr);        if (iBitDepth < 8)            png_set_expand(png_ptr);        if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))            png_set_expand(png_ptr);        if (iColorType == PNG_COLOR_TYPE_GRAY ||            iColorType == PNG_COLOR_TYPE_GRAY_ALPHA)            png_set_gray_to_rgb(png_ptr);                if (png_get_bKGD(png_ptr, info_ptr, &pBackground))        {            png_set_background(png_ptr, pBackground, PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);            pBkgColor->red   = (byte) pBackground->red;            pBkgColor->green = (byte) pBackground->green;            pBkgColor->blue  = (byte) pBackground->blue;        }        else        {            pBkgColor = NULL;        }                if (png_get_gAMA(png_ptr, info_ptr, &dGamma))            png_set_gamma(png_ptr, (double) 2.2, dGamma);                png_read_update_info(png_ptr, info_ptr);                png_get_IHDR(png_ptr, info_ptr, piWidth, piHeight, &iBitDepth,            &iColorType, NULL, NULL, NULL);                ulRowBytes = png_get_rowbytes(png_ptr, info_ptr);        ulChannels = png_get_channels(png_ptr, info_ptr);        *piChannels = ulChannels;                if (pbImageData)        {            free (pbImageData);            pbImageData = NULL;        }        if ((pbImageData = (png_byte *) malloc(ulRowBytes * (*piHeight)                            * sizeof(png_byte))) == NULL)        {            png_error(png_ptr, \"Visual PNG: out of memory\");        }        *ppbImageData = pbImageData;                if ((ppbRowPointers = (png_bytepp) malloc((*piHeight)                            * sizeof(png_bytep))) == NULL)        {            png_error(png_ptr, \"Visual PNG: out of memory\");        }                for (i = 0; i < (*piHeight); i++)            ppbRowPointers[i] = pbImageData + i * ulRowBytes;                png_read_image(png_ptr, ppbRowPointers);                png_read_end(png_ptr, NULL);                free (ppbRowPointers);        ppbRowPointers = NULL;            }    Catch (msg)    {        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);        *ppbImageData = pbImageData = NULL;        if(ppbRowPointers)            free (ppbRowPointers);        fclose(pfFile);        return FALSE;    }    fclose (pfFile);    return TRUE;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "BOOL CALLBACK AboutDlgProc (HWND hDlg, UINT message,                            WPARAM wParam, LPARAM lParam){     switch (message)     {     case WM_INITDIALOG :          ShowWindow (hDlg, SW_HIDE);          CenterAbout (hDlg, GetWindow (hDlg, GW_OWNER));          ShowWindow (hDlg, SW_SHOW);          return TRUE ;     case WM_COMMAND :          switch (LOWORD (wParam))          {          case IDOK :          case IDCANCEL :               EndDialog (hDlg, 0) ;               return TRUE ;          }          break ;     }     return FALSE ;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_g8(Pixel *out, const Pixel *in, const Background *back){   (void)back;   if (in->r == in->g && in->g == in->b)      out->r = out->g = out->b = in->g;   else      out->r = out->g = out->b =         sRGB(YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));   out->a = in->a;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(void){   fprintf(stderr,      \" test ignored: no support to find out about unknown chunks\\n\");      return 77;}intmain(void){   fprintf(stderr,      \" test ignored: no support to modify unknown chunk handling\\n\");      return 77;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intpng_row_in_interlace_pass(png_uint_32 y, int pass){      int x;   y &= 7;   ++pass;   for (x=0; x<8; ++x) if (adam7[y][x] == pass)      return 1;   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidtransform_image_validate(transform_display *dp, png_const_structp pp,   png_infop pi){      PNG_CONST png_store* PNG_CONST ps = dp->this.ps;   PNG_CONST png_byte in_ct = dp->this.colour_type;   PNG_CONST png_byte in_bd = dp->this.bit_depth;   PNG_CONST png_uint_32 w = dp->this.w;   PNG_CONST png_uint_32 h = dp->this.h;   PNG_CONST png_byte out_ct = dp->output_colour_type;   PNG_CONST png_byte out_bd = dp->output_bit_depth;   PNG_CONST png_byte sample_depth = (png_byte)(out_ct ==      PNG_COLOR_TYPE_PALETTE ? 8 : out_bd);   PNG_CONST png_byte red_sBIT = dp->this.red_sBIT;   PNG_CONST png_byte green_sBIT = dp->this.green_sBIT;   PNG_CONST png_byte blue_sBIT = dp->this.blue_sBIT;   PNG_CONST png_byte alpha_sBIT = dp->this.alpha_sBIT;   PNG_CONST int have_tRNS = dp->this.is_transparent;   double digitization_error;   store_palette out_palette;   png_uint_32 y;   UNUSED(pi)      store_image_check(dp->this.ps, pp, 0);      if (out_ct == PNG_COLOR_TYPE_PALETTE)   {            int npalette = (-1);      (void)read_palette(out_palette, &npalette, pp, pi);      if (npalette != dp->this.npalette)         png_error(pp, \"unexpected change in palette size\");      digitization_error = .5;   }   else   {      png_byte in_sample_depth;      memset(out_palette, 0x5e, sizeof out_palette);            if (in_ct == PNG_COLOR_TYPE_PALETTE || in_bd < 16)         in_sample_depth = 8;      else         in_sample_depth = in_bd;      if (sample_depth != 16 || in_sample_depth > 8 ||         !dp->pm->calculations_use_input_precision)         digitization_error = .5;            else         digitization_error = .5 * 257;   }   for (y=0; y<h; ++y)   {      png_const_bytep PNG_CONST pRow = store_image_row(ps, pp, 0, y);      png_uint_32 x;            png_byte std[STANDARD_ROWMAX];      transform_row(pp, std, in_ct, in_bd, y);            for (x=0; x<w; ++x)      {         image_pixel in_pixel, out_pixel;         unsigned int r, g, b, a;                  image_pixel_init(&in_pixel, std, in_ct, in_bd, x, dp->this.palette);         in_pixel.red_sBIT = red_sBIT;         in_pixel.green_sBIT = green_sBIT;         in_pixel.blue_sBIT = blue_sBIT;         in_pixel.alpha_sBIT = alpha_sBIT;         in_pixel.have_tRNS = have_tRNS;                  r = in_pixel.red;         g = in_pixel.green;         b = in_pixel.blue;         a = in_pixel.alpha;         dp->transform_list->mod(dp->transform_list, &in_pixel, pp, dp);                  image_pixel_init(&out_pixel, pRow, out_ct, out_bd, x, out_palette);                  if (in_ct == PNG_COLOR_TYPE_PALETTE &&            out_ct == PNG_COLOR_TYPE_PALETTE)         {            if (in_pixel.palette_index != out_pixel.palette_index)               png_error(pp, \"unexpected transformed palette index\");         }                  if (in_pixel.red != out_pixel.red)            transform_range_check(pp, r, g, b, a, in_pixel.red, in_pixel.redf,               out_pixel.red, sample_depth, in_pixel.rede,               dp->pm->limit + 1./(2*((1U<<in_pixel.red_sBIT)-1)), \"red/gray\",               digitization_error);         if ((out_ct & PNG_COLOR_MASK_COLOR) != 0 &&            in_pixel.green != out_pixel.green)            transform_range_check(pp, r, g, b, a, in_pixel.green,               in_pixel.greenf, out_pixel.green, sample_depth, in_pixel.greene,               dp->pm->limit + 1./(2*((1U<<in_pixel.green_sBIT)-1)), \"green\",               digitization_error);         if ((out_ct & PNG_COLOR_MASK_COLOR) != 0 &&            in_pixel.blue != out_pixel.blue)            transform_range_check(pp, r, g, b, a, in_pixel.blue, in_pixel.bluef,               out_pixel.blue, sample_depth, in_pixel.bluee,               dp->pm->limit + 1./(2*((1U<<in_pixel.blue_sBIT)-1)), \"blue\",               digitization_error);         if ((out_ct & PNG_COLOR_MASK_ALPHA) != 0 &&            in_pixel.alpha != out_pixel.alpha)            transform_range_check(pp, r, g, b, a, in_pixel.alpha,               in_pixel.alphaf, out_pixel.alpha, sample_depth, in_pixel.alphae,               dp->pm->limit + 1./(2*((1U<<in_pixel.alpha_sBIT)-1)), \"alpha\",               digitization_error);      }    }       dp->this.ps->validated = 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidtransform_range_check(png_const_structp pp, unsigned int r, unsigned int g,   unsigned int b, unsigned int a, unsigned int in_digitized, double in,   unsigned int out, png_byte sample_depth, double err, double limit,   PNG_CONST char *name, double digitization_error){      unsigned int max = (1U<<sample_depth)-1;   double in_min = ceil((in-err)*max - digitization_error);   double in_max = floor((in+err)*max + digitization_error);   if (err > limit || !(out >= in_min && out <= in_max))   {      char message[256];      size_t pos;      pos = safecat(message, sizeof message, 0, name);      pos = safecat(message, sizeof message, pos, \" output value error: rgba(\");      pos = safecatn(message, sizeof message, pos, r);      pos = safecat(message, sizeof message, pos, \",\");      pos = safecatn(message, sizeof message, pos, g);      pos = safecat(message, sizeof message, pos, \",\");      pos = safecatn(message, sizeof message, pos, b);      pos = safecat(message, sizeof message, pos, \",\");      pos = safecatn(message, sizeof message, pos, a);      pos = safecat(message, sizeof message, pos, \"): \");      pos = safecatn(message, sizeof message, pos, out);      pos = safecat(message, sizeof message, pos, \" expected: \");      pos = safecatn(message, sizeof message, pos, in_digitized);      pos = safecat(message, sizeof message, pos, \" (\");      pos = safecatd(message, sizeof message, pos, (in-err)*max, 3);      pos = safecat(message, sizeof message, pos, \"..\");      pos = safecatd(message, sizeof message, pos, (in+err)*max, 3);      pos = safecat(message, sizeof message, pos, \")\");      png_error(pp, message);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstandard_info_imp(standard_display *dp, png_structp pp, png_infop pi,    int nImages){      standard_info_part1(dp, pp, pi);      if (dp->use_update_info)   {            int i = dp->use_update_info;      while (i-- > 0)         png_read_update_info(pp, pi);   }   else      png_start_read_image(pp);      standard_info_part2(dp, pp, pi, nImages);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidprint_one(const char *leader, double err){   if (err != -1.)      printf(\" %s %.5f\\n\", leader, err);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static size_tstore_message(png_store *ps, png_const_structp pp, char *buffer, size_t bufsize,   size_t pos, PNG_CONST char *msg){   if (pp != NULL && pp == ps->pread)   {            pos = safecat(buffer, bufsize, pos, \"read: \");      if (ps->current != NULL)      {         pos = safecat(buffer, bufsize, pos, ps->current->name);         pos = safecat(buffer, bufsize, pos, sep);      }   }   else if (pp != NULL && pp == ps->pwrite)   {            pos = safecat(buffer, bufsize, pos, \"write: \");      pos = safecat(buffer, bufsize, pos, ps->wname);      pos = safecat(buffer, bufsize, pos, sep);   }   else   {            pos = safecat(buffer, bufsize, pos, \"pngvalid: \");   }   if (ps->test[0] != 0)   {      pos = safecat(buffer, bufsize, pos, ps->test);      pos = safecat(buffer, bufsize, pos, sep);   }   pos = safecat(buffer, bufsize, pos, msg);   return pos;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_set_end(PNG_CONST image_transform *this,   transform_display *that, png_structp pp, png_infop pi){   UNUSED(this)   UNUSED(that)   UNUSED(pp)   UNUSED(pi)}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static double outerr(PNG_CONST png_modifier *pm, int in_depth, int out_depth){      if (out_depth == 2)      return .73182-.5;   if (out_depth == 4)      return .90644-.5;   if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16)      return pm->maxout16;      else if (out_depth == 16)      return pm->maxout8 * 257;   else      return pm->maxout8;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstandard_check_text(png_const_structp pp, png_const_textp tp,   png_const_charp keyword, png_const_charp text){   char msg[1024];   size_t pos = safecat(msg, sizeof msg, 0, \"text: \");   size_t ok;   pos = safecat(msg, sizeof msg, pos, keyword);   pos = safecat(msg, sizeof msg, pos, \": \");   ok = pos;   if (tp->compression != TEXT_COMPRESSION)   {      char buf[64];      sprintf(buf, \"compression [%d->%d], \", TEXT_COMPRESSION,         tp->compression);      pos = safecat(msg, sizeof msg, pos, buf);   }   if (tp->key == NULL || strcmp(tp->key, keyword) != 0)   {      pos = safecat(msg, sizeof msg, pos, \"keyword \\\"\");      if (tp->key != NULL)      {         pos = safecat(msg, sizeof msg, pos, tp->key);         pos = safecat(msg, sizeof msg, pos, \"\\\", \");      }      else         pos = safecat(msg, sizeof msg, pos, \"null, \");   }   if (tp->text == NULL)      pos = safecat(msg, sizeof msg, pos, \"text lost, \");   else   {      if (tp->text_length != strlen(text))      {         char buf[64];         sprintf(buf, \"text length changed[%lu->%lu], \",            (unsigned long)strlen(text), (unsigned long)tp->text_length);         pos = safecat(msg, sizeof msg, pos, buf);      }      if (strcmp(tp->text, text) != 0)      {         pos = safecat(msg, sizeof msg, pos, \"text becomes \\\"\");         pos = safecat(msg, sizeof msg, pos, tp->text);         pos = safecat(msg, sizeof msg, pos, \"\\\" (was \\\"\");         pos = safecat(msg, sizeof msg, pos, text);         pos = safecat(msg, sizeof msg, pos, \"\\\"), \");      }   }   if (tp->itxt_length != 0)      pos = safecat(msg, sizeof msg, pos, \"iTXt length set, \");   if (tp->lang != NULL)   {      pos = safecat(msg, sizeof msg, pos, \"iTXt language \\\"\");      pos = safecat(msg, sizeof msg, pos, tp->lang);      pos = safecat(msg, sizeof msg, pos, \"\\\", \");   }   if (tp->lang_key != NULL)   {      pos = safecat(msg, sizeof msg, pos, \"iTXt keyword \\\"\");      pos = safecat(msg, sizeof msg, pos, tp->lang_key);      pos = safecat(msg, sizeof msg, pos, \"\\\", \");   }   if (pos > ok)   {      msg[pos-2] = '\\0';       png_error(pp, msg);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_strip_alpha_mod(PNG_CONST image_transform *this,    image_pixel *that, png_const_structp pp,    PNG_CONST transform_display *display){   if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)      that->colour_type = PNG_COLOR_TYPE_GRAY;   else if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)      that->colour_type = PNG_COLOR_TYPE_RGB;   that->have_tRNS = 0;   that->alphaf = 1;   this->next->mod(this->next, that, pp, display);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_freefile(png_store_file **ppf){   if (*ppf != NULL)   {      store_freefile(&(*ppf)->next);      store_freebuffer(&(*ppf)->data);      (*ppf)->datacount = 0;      if ((*ppf)->palette != NULL)      {         free((*ppf)->palette);         (*ppf)->palette = NULL;         (*ppf)->npalette = 0;      }      free(*ppf);      *ppf = NULL;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32formatof(const char *arg){   char *ep;   unsigned long format = strtoul(arg, &ep, 0);   if (ep > arg && *ep == 0 && format < FORMAT_COUNT)      return (png_uint_32)format;   else for (format=0; format < FORMAT_COUNT; ++format)   {      if (strcmp(format_names[format], arg) == 0)         return (png_uint_32)format;   }   fprintf(stderr, \"pngstest: format name '%s' invalid\\n\", arg);   return FORMAT_COUNT;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static inttest_standard(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,    int bdlo, int PNG_CONST bdhi){   for (; bdlo <= bdhi; ++bdlo)   {      int interlace_type;      for (interlace_type = PNG_INTERLACE_NONE;           interlace_type < INTERLACE_LAST; ++interlace_type)      {         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0,            interlace_type, 0, 0, 0), 0, pm->use_update_info);         if (fail(pm))            return 0;      }   }   return 1; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_pixel_setf(image_pixel *this, unsigned int max){   this->redf = this->red / (double)max;   this->greenf = this->green / (double)max;   this->bluef = this->blue / (double)max;   this->alphaf = this->alpha / (double)max;   if (this->red < max)      this->rede = this->redf * DBL_EPSILON;   else      this->rede = 0;   if (this->green < max)      this->greene = this->greenf * DBL_EPSILON;   else      this->greene = 0;   if (this->blue < max)      this->bluee = this->bluef * DBL_EPSILON;   else      this->bluee = 0;   if (this->alpha < max)      this->alphae = this->alphaf * DBL_EPSILON;   else      this->alphae = 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intis_combo(int transforms){   return transforms & (transforms-1); }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_expand_gray_1_2_4_to_8_set(    PNG_CONST image_transform *this, transform_display *that, png_structp pp,    png_infop pi){   png_set_expand_gray_1_2_4_to_8(pp);   this->next->set(this->next, that, pp, pi);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(const char *prog){   fprintf(stderr,      \"%s: usage: %s [-linear|-sRGB] [-gray|-color] component{1,4}\\n\",      prog, prog);   exit(1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmodifier_reset(png_modifier *pm){   store_read_reset(&pm->this);   pm->limit = 4E-3;   pm->pending_len = pm->pending_chunk = 0;   pm->flush = pm->buffer_count = pm->buffer_position = 0;   pm->modifications = NULL;   pm->state = modifier_start;   modifier_encoding_iterate(pm);      pm->test_uses_encoding = 0;   pm->current_gamma = 0;   pm->current_encoding = 0;   pm->encoding_ignored = 0;      pm->bit_depth = pm->colour_type = 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#define png_error png_warningvoid png_warning(png_const_structrp png_ptr, png_const_charp msg){   fprintf(stderr, \"validation: %s\\n\", msg);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_nop6(Pixel *out, const Pixel *in, const Background *back){   (void)back;   if (in->a == 0)      out->r = out->g = out->b = 65535;   else   {      out->r = in->r;      out->g = in->g;      out->b = in->b;   }   out->a = in->a;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPImakepng_warning(png_structp png_ptr, png_const_charp message){   const char **ep = png_get_error_ptr(png_ptr);   const char *name;   if (ep != NULL && *ep != NULL)      name = *ep;   else      name = \"makepng\";  fprintf(stderr, \"%s: warning: %s\\n\", name, message);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_gpre(Pixel *out, const Pixel *in, const Background *back){   (void)back;   if (in->r == in->g && in->g == in->b)      out->r = out->g = out->b = ilineara(in->g, in->a);   else      out->r = out->g = out->b = u16d(in->a * 257 *         YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));   out->a = 257 * in->a;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidclear_text(png_text *text, png_charp keyword){   text->compression = -1;    text->key = keyword;   text->text = NULL;   text->text_length = 0;    text->itxt_length = 0;    text->lang = NULL;   text->lang_key = NULL;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcheck_handling(display *d, int def, png_uint_32 chunks, png_uint_32 known,   png_uint_32 unknown, const char *position, int set_callback){   while (chunks)   {      png_uint_32 flag = chunks & -(png_int_32)chunks;      int i = find_by_flag(flag);      int keep = chunk_info[i].keep;      const char *type;      const char *errorx = NULL;      if (chunk_info[i].unknown)      {         if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT)         {            type = \"UNKNOWN (default)\";            keep = def;         }         else            type = \"UNKNOWN (specified)\";         if (flag & known)            errorx = \"chunk processed\";         else switch (keep)         {            case PNG_HANDLE_CHUNK_AS_DEFAULT:               if (flag & unknown)                  errorx = \"DEFAULT: unknown chunk saved\";               break;            case PNG_HANDLE_CHUNK_NEVER:               if (flag & unknown)                  errorx = \"DISCARD: unknown chunk saved\";               break;            case PNG_HANDLE_CHUNK_IF_SAFE:               if (ancillary(chunk_info[i].name))               {                  if (!(flag & unknown))                     errorx = \"IF-SAFE: unknown ancillary chunk lost\";               }               else if (flag & unknown)                  errorx = \"IF-SAFE: unknown critical chunk saved\";               break;            case PNG_HANDLE_CHUNK_ALWAYS:               if (!(flag & unknown))                  errorx = \"SAVE: unknown chunk lost\";               break;            default:               errorx = \"internal error: bad keep\";               break;         }      }       else       {         type = \"KNOWN\";         if (flag & known)         {                        if (keep != PNG_HANDLE_CHUNK_AS_DEFAULT)               errorx = \"!DEFAULT: known chunk processed\";         }         else  switch (keep)         {            case PNG_HANDLE_CHUNK_AS_DEFAULT:               errorx = \"DEFAULT: known chunk not processed\";               break;            case PNG_HANDLE_CHUNK_NEVER:               if (flag & unknown)                  errorx = \"DISCARD: known chunk saved\";               break;            case PNG_HANDLE_CHUNK_IF_SAFE:               if (ancillary(chunk_info[i].name))               {                  if (!(flag & unknown))                     errorx = \"IF-SAFE: known ancillary chunk lost\";               }               else if (flag & unknown)                  errorx = \"IF-SAFE: known critical chunk saved\";               break;            case PNG_HANDLE_CHUNK_ALWAYS:               if (!(flag & unknown))                  errorx = \"SAVE: known chunk lost\";               break;            default:               errorx = \"internal error: bad keep (2)\";               break;         }      }      if (errorx != NULL)      {         ++(d->error_count);         fprintf(stderr, \"%s(%s%s): %s %s %s: %s\\n\", d->file, d->test,            set_callback ? \",callback\" : \"\",            type, chunk_info[i].name, position, errorx);      }      chunks &= ~flag;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static doubleclosestinteger(double x){   return floor(x + .5);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void readpng2_cleanup(mainprog_info *mainprog_ptr){    png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr;    png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr;    if (png_ptr && info_ptr)        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);    mainprog_ptr->png_ptr = NULL;    mainprog_ptr->info_ptr = NULL;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidnewimage(Image *image){   memset(image, 0, sizeof *image);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidinit_validate_info(validate_info *vi, gamma_display *dp, png_const_structp pp,    int in_depth, int out_depth){   PNG_CONST unsigned int outmax = (1U<<out_depth)-1;   vi->pp = pp;   vi->dp = dp;   if (dp->sbit > 0 && dp->sbit < in_depth)   {      vi->sbit = dp->sbit;      vi->isbit_shift = in_depth - dp->sbit;   }   else   {      vi->sbit = (png_byte)in_depth;      vi->isbit_shift = 0;   }   vi->sbit_max = (1U << vi->sbit)-1;      vi->screen_gamma = dp->screen_gamma;   if (fabs(vi->screen_gamma-1) < PNG_GAMMA_THRESHOLD)      vi->screen_gamma = vi->screen_inverse = 0;   else      vi->screen_inverse = 1/vi->screen_gamma;   vi->use_input_precision = dp->use_input_precision;   vi->outmax = outmax;   vi->maxabs = abserr(dp->pm, in_depth, out_depth);   vi->maxpc = pcerr(dp->pm, in_depth, out_depth);   vi->maxcalc = calcerr(dp->pm, in_depth, out_depth);   vi->maxout = outerr(dp->pm, in_depth, out_depth);   vi->outquant = output_quantization_factor(dp->pm, in_depth, out_depth);   vi->maxout_total = vi->maxout + vi->outquant * .5;   vi->outlog = outlog(dp->pm, in_depth, out_depth);   if ((dp->this.colour_type & PNG_COLOR_MASK_ALPHA) != 0 ||      (dp->this.colour_type == 3 && dp->this.is_transparent))   {      vi->do_background = dp->do_background;      if (vi->do_background != 0)      {         PNG_CONST double bg_inverse = 1/dp->background_gamma;         double r, g, b;                  r = dp->background_color.red; r /= outmax;         g = dp->background_color.green; g /= outmax;         b = dp->background_color.blue; b /= outmax;#     if 0                  if (fabs(bg_inverse-1) >= PNG_GAMMA_THRESHOLD)#     endif         {            r = pow(r, bg_inverse);            g = pow(g, bg_inverse);            b = pow(b, bg_inverse);         }         vi->background_red = r;         vi->background_green = g;         vi->background_blue = b;      }   }   else      vi->do_background = 0;   if (vi->do_background == 0)      vi->background_red = vi->background_green = vi->background_blue = 0;   vi->gamma_correction = 1/(dp->file_gamma*dp->screen_gamma);   if (fabs(vi->gamma_correction-1) < PNG_GAMMA_THRESHOLD)      vi->gamma_correction = 0;   vi->file_inverse = 1/dp->file_gamma;   if (fabs(vi->file_inverse-1) < PNG_GAMMA_THRESHOLD)      vi->file_inverse = 0;   vi->scale16 = dp->scale16;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_expand_set(PNG_CONST image_transform *this,    transform_display *that, png_structp pp, png_infop pi){   png_set_expand(pp);   this->next->set(this->next, that, pp, pi);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intpng_have_neon(png_structp png_ptr){      PNG_UNUSED(png_ptr)   return android_getCpuFamily() == ANDROID_CPU_FAMILY_ARM &&      (android_getCpuFeatures() & ANDROID_CPU_ARM_FEATURE_NEON) != 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "png_uint_32 get_value (FILE *pnm_file, int depth){  static png_uint_32 mask = 0;  png_byte token[16];  unsigned long ul_ret_value;  png_uint_32 ret_value;  int i = 0;  if (mask == 0)    for (i = 0; i < depth; i++)      mask = (mask << 1) | 0x01;  get_token (pnm_file, (char *) token);  sscanf ((const char *) token, \"%lu\", &ul_ret_value);  ret_value = (png_uint_32) ul_ret_value;  ret_value &= mask;  if (depth < 8)    for (i = 0; i < (8 / depth); i++)      ret_value = (ret_value << depth) || ret_value;  return ret_value;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidtype_name(png_uint_32 type, FILE *out){   putc(type_char(type >> 24), out);   putc(type_char(type >> 16), out);   putc(type_char(type >>  8), out);   putc(type_char(type      ), out);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGAPIpng_set_iCCP(png_structp png_ptr, png_infop info_ptr,             png_charp name, int compression_type,             png_charp profile, png_uint_32 proflen){   png_charp new_iccp_name;   png_charp new_iccp_profile;   png_debug1(1, \"in %s storage function\\n\", \"iCCP\");   if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL)      return;   new_iccp_name = (png_charp)png_malloc_warn(png_ptr, png_strlen(name)+1);   if (new_iccp_name == NULL)   {      png_warning(png_ptr, \"Insufficient memory to process iCCP chunk.\");      return;   }   png_strcpy(new_iccp_name, name);   new_iccp_profile = (png_charp)png_malloc_warn(png_ptr, proflen);   if (new_iccp_profile == NULL)   {      png_free (png_ptr, new_iccp_name);      png_warning(png_ptr, \"Insufficient memory to process iCCP profile.\");      return;   }   png_memcpy(new_iccp_profile, profile, (png_size_t)proflen);   png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, 0);   info_ptr->iccp_proflen = proflen;   info_ptr->iccp_name = new_iccp_name;   info_ptr->iccp_profile = new_iccp_profile;      info_ptr->iccp_compression = (png_byte)compression_type;#ifdef PNG_FREE_ME_SUPPORTED   info_ptr->free_me |= PNG_FREE_ICCP;#endif   info_ptr->valid |= PNG_INFO_iCCP;}#endif",
        "label": 1,
        "cve": "cve-2007-5267"
    },
    {
        "code": "static voidgpc_gprq(Pixel *out, const Pixel *in, const Background *back){   (void)back;   if (in->r == in->g && in->g == in->b)      out->r = out->g = out->b = ilineara(in->g, in->a);   else      out->r = out->g = out->b = u16d(in->a * 257 *         YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));   out->a = 65535;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intwrite_one_file(Image *output, Image *image, int convert_to_8bit){   if (image->opts & FAST_WRITE)      image->image.flags |= PNG_IMAGE_FLAG_FAST;   if (image->opts & USE_STDIO)   {      FILE *f = tmpfile();      if (f != NULL)      {         if (png_image_write_to_stdio(&image->image, f, convert_to_8bit,            image->buffer+16, (png_int_32)image->stride, image->colormap))         {            if (fflush(f) == 0)            {               rewind(f);               initimage(output, image->opts, \"tmpfile\", image->stride_extra);               output->input_file = f;               if (!checkopaque(image))                  return 0;            }            else               return logclose(image, f, \"tmpfile\", \": flush: \");         }         else         {            fclose(f);            return logerror(image, \"tmpfile\", \": write failed\", \"\");         }      }      else         return logerror(image, \"tmpfile\", \": open: \", strerror(errno));   }   else   {      static int counter = 0;      char name[32];      sprintf(name, \"%s%d.png\", tmpf, ++counter);      if (png_image_write_to_file(&image->image, name, convert_to_8bit,         image->buffer+16, (png_int_32)image->stride, image->colormap))      {         initimage(output, image->opts, output->tmpfile_name,            image->stride_extra);                  strcpy(output->tmpfile_name, name);         if (!checkopaque(image))            return 0;      }      else         return logerror(image, name, \": write failed\", \"\");   }      if (read_file(output, image->image.format | FORMAT_NO_CHANGE, NULL))   {      png_uint_32 original_format = image->image.format;      if (convert_to_8bit)         original_format &= ~PNG_FORMAT_FLAG_LINEAR;      if ((output->image.format & BASE_FORMATS) !=         (original_format & BASE_FORMATS))         return logerror(image, image->file_name, \": format changed on read: \",            output->file_name);      return compare_two_images(image, output, 0, NULL);   }   else      return logerror(output, output->tmpfile_name,         \": read of new file failed\", \"\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int validation_muldiv(int count, int argc, char **argv){   int tested = 0;   int overflow = 0;   int error = 0;   int error64 = 0;   int passed = 0;   int randbits = 0;   png_uint_32 randbuffer;   png_fixed_point a;   png_int_32 times, div;   while (--argc > 0)      {         fprintf(stderr, \"unknown argument %s\\n\", *++argv);         return 1;      }      randbuffer = RAND_MAX;   while (randbuffer != 0) ++randbits, randbuffer >>= 1;   printf(\"Using random number generator that makes %d bits\\n\", randbits);   for (div=0; div<32; div += randbits)      randbuffer = (randbuffer << randbits) ^ rand();   a = 0;   times = div = 0;   do   {      png_fixed_point result;            long long int fp, fpround;      unsigned long hi, lo;      int ok;            {         long u1, u2;         int n = 0;         if (a < 0) u1 = -a, n = 1; else u1 = a;         if (times < 0) u2 = -times, n = !n; else u2 = times;         png_64bit_product(u1, u2, &hi, &lo);         if (n)         {                        lo = ((~lo) + 1) & 0xffffffff;            hi = ~hi;            if (lo == 0) ++hi;         }      }      fp = a;      fp *= times;      if ((fp & 0xffffffff) != lo || ((fp >> 32) & 0xffffffff) != hi)      {         fprintf(stderr, \"png_64bit_product %d * %d -> %lx|%.8lx not %llx\\n\",            a, times, hi, lo, fp);         ++error64;      }      if (div != 0)      {                  if ((fp < 0) != (div < 0))           fp -= div/2;         else           fp += div/2;         fp /= div;         fpround = fp;                  ok = fpround <= PNG_UINT_31_MAX &&              fpround >= -1-(long long int)PNG_UINT_31_MAX;         if (!ok) ++overflow;      }      else        ok = 0, ++overflow, fpround = fp;      if (verbose)         fprintf(stderr, \"TEST %d * %d / %d -> %lld (%s)\\n\", a, times, div,            fp, ok ? \"ok\" : \"overflow\");      ++tested;      if (png_muldiv(&result, a, times, div) != ok)      {         ++error;         if (ok)             fprintf(stderr, \"%d * %d / %d -> overflow (expected %lld)\\n\", a,                times, div, fp);         else             fprintf(stderr, \"%d * %d / %d -> %d (expected overflow %lld)\\n\", a,                times, div, result, fp);      }      else if (ok && result != fpround)      {         ++error;         fprintf(stderr, \"%d * %d / %d -> %d not %lld\\n\", a, times, div, result,            fp);      }      else         ++passed;                  a += times;      times += div;      div = randbuffer;      randbuffer = (randbuffer << randbits) ^ rand();   }   while (--count > 0);   printf(\"%d tests including %d overflows, %d passed, %d failed (%d 64 bit \"      \"errors)\\n\", tested, overflow, passed, error, error64);   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_b16g(Pixel *out, const Pixel *in, const Background *back){   if (in->a <= 0)      out->r = out->g = out->b = back->ig;   else   {      double a = in->a/65535.;      double a1 = 1-a;      a /= 65535;      out->r = out->g = out->b = sRGB(in->g * a + back->dg * a1);   }   out->a = 255;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_image_free(png_store *ps, png_const_structp pp){   if (ps->image != NULL)   {      png_bytep image = ps->image;      if (image[-1] != 0xed || image[ps->cb_image] != 0xfe)      {         if (pp != NULL)            png_error(pp, \"png_store image overwrite (1)\");         else            store_log(ps, NULL, \"png_store image overwrite (2)\", 1);      }      ps->image = NULL;      ps->cb_image = 0;      --image;      free(image);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidinterlace_row(png_bytep buffer, png_const_bytep imageRow,   unsigned int pixel_size, png_uint_32 w, int pass){   png_uint_32 xin, xout, xstep;      xin = PNG_PASS_START_COL(pass);   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);   for (xout=0; xin<w; xin+=xstep)   {      pixel_copy(buffer, xout, imageRow, xin, pixel_size);      ++xout;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "BOOL png2pnm (FILE *png_file, FILE *pnm_file, FILE *alpha_file,    volatile BOOL raw, BOOL alpha){  png_struct    *png_ptr = NULL;  png_info        *info_ptr = NULL;  png_byte      buf[8];  png_byte      *png_pixels = NULL;  png_byte      **row_pointers = NULL;  png_byte      *pix_ptr = NULL;  png_uint_32   row_bytes;  png_uint_32   width;  png_uint_32   height;  int           bit_depth;  int           channels;  int           color_type;  int           alpha_present;  int           row, col;  int           ret;  int           i;  long          dep_16;    ret = fread (buf, 1, 8, png_file);  if (ret != 8)    return FALSE;  ret = png_sig_cmp (buf, 0, 8);  if (ret)    return FALSE;    png_ptr = png_create_read_struct (png_get_libpng_ver(NULL),    NULL, NULL, NULL);  if (!png_ptr)    return FALSE;     info_ptr = png_create_info_struct (png_ptr);  if (!info_ptr)  {    png_destroy_read_struct (&png_ptr, NULL, NULL);    return FALSE;     }  if (setjmp (png_jmpbuf(png_ptr)))  {    png_destroy_read_struct (&png_ptr, &info_ptr, NULL);    return FALSE;  }    png_init_io (png_ptr, png_file);  png_set_sig_bytes (png_ptr, 8);      png_read_info (png_ptr, info_ptr);    png_get_IHDR (png_ptr, info_ptr,    &width, &height, &bit_depth, &color_type,    NULL, NULL, NULL);      if (color_type == PNG_COLOR_TYPE_PALETTE)    png_set_expand (png_ptr);    if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)    png_set_expand (png_ptr);    if (png_get_valid (png_ptr, info_ptr, PNG_INFO_tRNS))    png_set_expand (png_ptr);#ifdef NJET    if (bit_depth == 16)    png_set_strip_16 (png_ptr);    if (color_type == PNG_COLOR_TYPE_GRAY ||    color_type == PNG_COLOR_TYPE_GRAY_ALPHA)    png_set_gray_to_rgb (png_ptr);    if (png_get_gAMA (png_ptr, info_ptr, &file_gamma))    png_set_gamma (png_ptr, (double) 2.2, file_gamma);#endif    png_read_update_info (png_ptr, info_ptr);    png_get_IHDR (png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,    NULL, NULL, NULL);    if (bit_depth == 16)  {    raw = FALSE;#ifdef __TURBOC__    pnm_file->flags &= ~((unsigned) _F_BIN);#endif  }    if (color_type == PNG_COLOR_TYPE_GRAY)    channels = 1;  else if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)    channels = 2;  else if (color_type == PNG_COLOR_TYPE_RGB)    channels = 3;  else if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)    channels = 4;  else    channels = 0;   alpha_present = (channels - 1) % 2;    if (alpha && !alpha_present)  {    fprintf (stderr, \"PNG2PNM\\n\");    fprintf (stderr, \"Error:  PNG-file doesn't contain alpha channel\\n\");    exit (1);  }    row_bytes = png_get_rowbytes (png_ptr, info_ptr);  if ((png_pixels = (png_byte *)     malloc (row_bytes * height * sizeof (png_byte))) == NULL) {    png_destroy_read_struct (&png_ptr, &info_ptr, NULL);    return FALSE;  }  if ((row_pointers = (png_byte **)     malloc (height * sizeof (png_bytep))) == NULL)  {    png_destroy_read_struct (&png_ptr, &info_ptr, NULL);    free (png_pixels);    png_pixels = NULL;    return FALSE;  }    for (i = 0; i < ((int) height); i++)    row_pointers[i] = png_pixels + i * row_bytes;    png_read_image (png_ptr, row_pointers);    png_read_end (png_ptr, info_ptr);    png_destroy_read_struct (&png_ptr, &info_ptr, (png_infopp) NULL);    if ((color_type == PNG_COLOR_TYPE_GRAY) ||      (color_type == PNG_COLOR_TYPE_GRAY_ALPHA))  {    fprintf (pnm_file, \"%s\\n\", (raw) ? \"P5\" : \"P2\");    fprintf (pnm_file, \"%d %d\\n\", (int) width, (int) height);    fprintf (pnm_file, \"%ld\\n\", ((1L << (int) bit_depth) - 1L));  }  else if ((color_type == PNG_COLOR_TYPE_RGB) ||           (color_type == PNG_COLOR_TYPE_RGB_ALPHA))  {    fprintf (pnm_file, \"%s\\n\", (raw) ? \"P6\" : \"P3\");    fprintf (pnm_file, \"%d %d\\n\", (int) width, (int) height);    fprintf (pnm_file, \"%ld\\n\", ((1L << (int) bit_depth) - 1L));  }    if ((alpha) &&      ((color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||       (color_type == PNG_COLOR_TYPE_RGB_ALPHA)))  {    fprintf (alpha_file, \"%s\\n\", (raw) ? \"P5\" : \"P2\");    fprintf (alpha_file, \"%d %d\\n\", (int) width, (int) height);    fprintf (alpha_file, \"%ld\\n\", ((1L << (int) bit_depth) - 1L));  }    pix_ptr = png_pixels;  for (row = 0; row < (int) height; row++)  {    for (col = 0; col < (int) width; col++)    {      for (i = 0; i < (channels - alpha_present); i++)      {        if (raw)          fputc ((int) *pix_ptr++ , pnm_file);        else          if (bit_depth == 16){            dep_16 = (long) *pix_ptr++;            fprintf (pnm_file, \"%ld \", (dep_16 << 8) + ((long) *pix_ptr++));          }          else            fprintf (pnm_file, \"%ld \", (long) *pix_ptr++);      }      if (alpha_present)      {        if (!alpha)        {          pix_ptr++;           if (bit_depth == 16)            pix_ptr++;        }        else         {          if (raw)            fputc ((int) *pix_ptr++ , alpha_file);          else            if (bit_depth == 16){              dep_16 = (long) *pix_ptr++;              fprintf (alpha_file, \"%ld \", (dep_16 << 8) + (long) *pix_ptr++);            }            else              fprintf (alpha_file, \"%ld \", (long) *pix_ptr++);        }      }       if (!raw)        if (col % 4 == 3)          fprintf (pnm_file, \"\\n\");    }     if (!raw)      if (col % 4 != 0)        fprintf (pnm_file, \"\\n\");  }   if (row_pointers != (unsigned char**) NULL)    free (row_pointers);  if (png_pixels != (unsigned char*) NULL)    free (png_pixels);  return TRUE;} ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmodifier_crc(png_bytep buffer){      uInt datalen = png_get_uint_32(buffer);   uLong crc = crc32(0, buffer+4, datalen+4);      png_save_uint_32(buffer+datalen+8, (png_uint_32)crc);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char **argv){   FILE *fp = stdout;   const char *file_name = NULL;   int color_type = 8;    int bit_depth = 32;    unsigned int colors[5];   unsigned int filters = PNG_ALL_FILTERS;   png_fixed_point gamma = 0;    chunk_insert *head_insert = NULL;   chunk_insert **insert_ptr = &head_insert;   memset(colors, 0, sizeof colors);   while (--argc > 0)   {      char *arg = *++argv;      if (strcmp(arg, \"--sRGB\") == 0)      {         gamma = PNG_DEFAULT_sRGB;         continue;      }      if (strcmp(arg, \"--linear\") == 0)      {         gamma = PNG_FP_1;         continue;      }      if (strcmp(arg, \"--1.8\") == 0)      {         gamma = PNG_GAMMA_MAC_18;         continue;      }      if (strcmp(arg, \"--nofilters\") == 0)      {         filters = PNG_FILTER_NONE;         continue;      }      if (strncmp(arg, \"--color=\", 8) == 0)      {          parse_color(arg+8, colors);          continue;      }      if (argc >= 3 && strcmp(arg, \"--insert\") == 0)      {         png_const_charp what = *++argv;         png_charp param = *++argv;         chunk_insert *new_insert;         argc -= 2;         new_insert = find_insert(what, param);         if (new_insert != NULL)         {            *insert_ptr = new_insert;            insert_ptr = &new_insert->next;         }         continue;      }      if (arg[0] == '-')      {         fprintf(stderr, \"makepng: %s: invalid option\\n\", arg);         exit(1);      }      if (strcmp(arg, \"palette\") == 0)      {         color_type = PNG_COLOR_TYPE_PALETTE;         continue;      }      if (strncmp(arg, \"gray\", 4) == 0)      {         if (arg[4] == 0)         {            color_type = PNG_COLOR_TYPE_GRAY;            continue;         }         else if (strcmp(arg+4, \"a\") == 0 ||            strcmp(arg+4, \"alpha\") == 0 ||            strcmp(arg+4, \"-alpha\") == 0)         {            color_type = PNG_COLOR_TYPE_GRAY_ALPHA;            continue;         }      }      if (strncmp(arg, \"rgb\", 3) == 0)      {         if (arg[3] == 0)         {            color_type = PNG_COLOR_TYPE_RGB;            continue;         }         else if (strcmp(arg+3, \"a\") == 0 ||            strcmp(arg+3, \"alpha\") == 0 ||            strcmp(arg+3, \"-alpha\") == 0)         {            color_type = PNG_COLOR_TYPE_RGB_ALPHA;            continue;         }      }      if (color_type == 8 && isdigit(arg[0]))      {         color_type = atoi(arg);         if (color_type < 0 || color_type > 6 || color_type == 1 ||            color_type == 5)         {            fprintf(stderr, \"makepng: %s: not a valid color type\\n\", arg);            exit(1);         }         continue;      }      if (bit_depth == 32 && isdigit(arg[0]))      {         bit_depth = atoi(arg);         if (bit_depth <= 0 || bit_depth > 16 ||            (bit_depth & -bit_depth) != bit_depth)         {            fprintf(stderr, \"makepng: %s: not a valid bit depth\\n\", arg);            exit(1);         }         continue;      }      if (argc == 1)       {         fp = fopen(arg, \"wb\");         if (fp == NULL)         {            fprintf(stderr, \"%s: %s: could not open\\n\", arg, strerror(errno));            exit(1);         }         file_name = arg;         continue;      }      fprintf(stderr, \"makepng: %s: unknown argument\\n\", arg);      exit(1);   }    if (color_type == 8 || bit_depth == 32)   {      fprintf(stderr, \"usage: makepng [--sRGB|--linear|--1.8] \"         \"[--color=...] color-type bit-depth [file-name]\\n\"         \"  Make a test PNG file, by default writes to stdout.\\n\");      exit(1);   }      {      const unsigned int lim = (color_type == PNG_COLOR_TYPE_PALETTE ? 255U :         (1U<<bit_depth)-1);      unsigned int i;      for (i=1; i<=colors[0]; ++i)         if (colors[i] > lim)         {            fprintf(stderr, \"makepng: --color=...: %u out of range [0..%u]\\n\",               colors[i], lim);            exit(1);         }   }      if (filters == PNG_ALL_FILTERS)   {      if ((color_type & PNG_COLOR_MASK_PALETTE) != 0 || bit_depth < 8)         filters = PNG_FILTER_NONE;      else if (color_type & PNG_COLOR_MASK_COLOR)       {         if (bit_depth == 8)            filters &= ~(PNG_FILTER_NONE | PNG_FILTER_AVG);         else            filters = PNG_FILTER_SUB | PNG_FILTER_PAETH;      }      else          filters &= ~PNG_FILTER_NONE;   }   {      int ret = write_png(&file_name, fp, color_type, bit_depth, gamma,         head_insert, filters, colors);      if (ret != 0 && file_name != NULL)         remove(file_name);      return ret;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#ifdef FEATURE_LOOPstatic void rpng2_x_reload_bg_image(void){    char *dest;    uch r1, r2, g1, g2, b1, b2;    uch r1_inv, r2_inv, g1_inv, g2_inv, b1_inv, b2_inv;    int k, hmax, max;    int xidx, yidx, yidx_max;    int even_odd_vert, even_odd_horiz, even_odd;    int invert_gradient2 = (bg[pat].type & 0x08);    int invert_column;    ulg i, row;    bgscale = (pat == 0)? 8 : bgscale_default;    yidx_max = bgscale - 1;    if ((bg[pat].type & 0x07) == 0) {        uch r1_min  = rgb[bg[pat].rgb1_min].r;        uch g1_min  = rgb[bg[pat].rgb1_min].g;        uch b1_min  = rgb[bg[pat].rgb1_min].b;        uch r2_min  = rgb[bg[pat].rgb2_min].r;        uch g2_min  = rgb[bg[pat].rgb2_min].g;        uch b2_min  = rgb[bg[pat].rgb2_min].b;        int r1_diff = rgb[bg[pat].rgb1_max].r - r1_min;        int g1_diff = rgb[bg[pat].rgb1_max].g - g1_min;        int b1_diff = rgb[bg[pat].rgb1_max].b - b1_min;        int r2_diff = rgb[bg[pat].rgb2_max].r - r2_min;        int g2_diff = rgb[bg[pat].rgb2_max].g - g2_min;        int b2_diff = rgb[bg[pat].rgb2_max].b - b2_min;        for (row = 0;  row < rpng2_info.height;  ++row) {            yidx = (int)(row % bgscale);            even_odd_vert = (int)((row / bgscale) & 1);            r1 = r1_min + (r1_diff * yidx) / yidx_max;            g1 = g1_min + (g1_diff * yidx) / yidx_max;            b1 = b1_min + (b1_diff * yidx) / yidx_max;            r1_inv = r1_min + (r1_diff * (yidx_max-yidx)) / yidx_max;            g1_inv = g1_min + (g1_diff * (yidx_max-yidx)) / yidx_max;            b1_inv = b1_min + (b1_diff * (yidx_max-yidx)) / yidx_max;            r2 = r2_min + (r2_diff * yidx) / yidx_max;            g2 = g2_min + (g2_diff * yidx) / yidx_max;            b2 = b2_min + (b2_diff * yidx) / yidx_max;            r2_inv = r2_min + (r2_diff * (yidx_max-yidx)) / yidx_max;            g2_inv = g2_min + (g2_diff * (yidx_max-yidx)) / yidx_max;            b2_inv = b2_min + (b2_diff * (yidx_max-yidx)) / yidx_max;            dest = (char *)bg_data + row*bg_rowbytes;            for (i = 0;  i < rpng2_info.width;  ++i) {                even_odd_horiz = (int)((i / bgscale) & 1);                even_odd = even_odd_vert ^ even_odd_horiz;                invert_column =                  (even_odd_horiz && (bg[pat].type & 0x10));                if (even_odd == 0) {                            if (invert_column) {                        *dest++ = r1_inv;                        *dest++ = g1_inv;                        *dest++ = b1_inv;                    } else {                        *dest++ = r1;                        *dest++ = g1;                        *dest++ = b1;                    }                } else {                                        if ((invert_column && invert_gradient2) ||                        (!invert_column && !invert_gradient2))                    {                        *dest++ = r2;                               *dest++ = g2;                               *dest++ = b2;                    } else {                        *dest++ = r2_inv;                        *dest++ = g2_inv;                           *dest++ = b2_inv;                    }                }            }        }    } else if ((bg[pat].type & 0x07) == 1) {        hmax = (bgscale-1)/2;           max = 2*hmax;                   r1 = rgb[bg[pat].rgb1_max].r;        g1 = rgb[bg[pat].rgb1_max].g;        b1 = rgb[bg[pat].rgb1_max].b;        r2 = rgb[bg[pat].rgb2_max].r;        g2 = rgb[bg[pat].rgb2_max].g;        b2 = rgb[bg[pat].rgb2_max].b;        for (row = 0;  row < rpng2_info.height;  ++row) {            yidx = (int)(row % bgscale);            if (yidx > hmax)                yidx = bgscale-1 - yidx;            dest = (char *)bg_data + row*bg_rowbytes;            for (i = 0;  i < rpng2_info.width;  ++i) {                xidx = (int)(i % bgscale);                if (xidx > hmax)                    xidx = bgscale-1 - xidx;                k = xidx + yidx;                *dest++ = (k*r1 + (max-k)*r2) / max;                *dest++ = (k*g1 + (max-k)*g2) / max;                *dest++ = (k*b1 + (max-k)*b2) / max;            }        }    } else if ((bg[pat].type & 0x07) == 2) {        uch ch;        int ii, x, y, hw, hh, grayspot;        double freq, rotate, saturate, gray, intensity;        double angle=0.0, aoffset=0.0, maxDist, dist;        double red=0.0, green=0.0, blue=0.0, hue, s, v, f, p, q, t;        hh = (int)(rpng2_info.height / 2);        hw = (int)(rpng2_info.width / 2);                angle = CLIP(angle, 0.0, 360.0);        grayspot = CLIP(bg[pat].bg_gray, 1, (hh + hw));        freq = MAX((double)bg[pat].bg_freq, 0.0);        saturate = (double)bg[pat].bg_bsat * 0.1;        rotate = (double)bg[pat].bg_brot * 0.1;        gray = 0.0;        intensity = 0.0;        maxDist = (double)((hw*hw) + (hh*hh));        for (row = 0;  row < rpng2_info.height;  ++row) {            y = (int)(row - hh);            dest = (char *)bg_data + row*bg_rowbytes;            for (i = 0;  i < rpng2_info.width;  ++i) {                x = (int)(i - hw);                angle = (x == 0)? PI_2 : atan((double)y / (double)x);                gray = (double)MAX(ABS(y), ABS(x)) / grayspot;                gray = MIN(1.0, gray);                dist = (double)((x*x) + (y*y)) / maxDist;                intensity = cos((angle+(rotate*dist*PI)) * freq) *                  gray * saturate;                intensity = (MAX(MIN(intensity,1.0),-1.0) + 1.0) * 0.5;                hue = (angle + PI) * INV_PI_360 + aoffset;                s = gray * ((double)(ABS(x)+ABS(y)) / (double)(hw + hh));                s = MIN(MAX(s,0.0), 1.0);                v = MIN(MAX(intensity,0.0), 1.0);                if (s == 0.0) {                    ch = (uch)(v * 255.0);                    *dest++ = ch;                    *dest++ = ch;                    *dest++ = ch;                } else {                    if ((hue < 0.0) || (hue >= 360.0))                        hue -= (((int)(hue / 360.0)) * 360.0);                    hue /= 60.0;                    ii = (int)hue;                    f = hue - (double)ii;                    p = (1.0 - s) * v;                    q = (1.0 - (s * f)) * v;                    t = (1.0 - (s * (1.0 - f))) * v;                    if      (ii == 0) { red = v; green = t; blue = p; }                    else if (ii == 1) { red = q; green = v; blue = p; }                    else if (ii == 2) { red = p; green = v; blue = t; }                    else if (ii == 3) { red = p; green = q; blue = v; }                    else if (ii == 4) { red = t; green = p; blue = v; }                    else if (ii == 5) { red = v; green = p; blue = q; }                    *dest++ = (uch)(red * 255.0);                    *dest++ = (uch)(green * 255.0);                    *dest++ = (uch)(blue * 255.0);                }            }        }    }} ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGAPIpng_set_write_fn(png_structp png_ptr, png_voidp io_ptr,    png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn){   if (png_ptr == NULL)      return;   png_ptr->io_ptr = io_ptr;   if (write_data_fn != NULL)      png_ptr->write_data_fn = write_data_fn;   else      png_ptr->write_data_fn = png_default_write_data;   png_ptr->write_data_fn = write_data_fn;   if (output_flush_fn != NULL)      png_ptr->output_flush_fn = output_flush_fn;   else      png_ptr->output_flush_fn = png_default_flush;   png_ptr->output_flush_fn = output_flush_fn;      if (png_ptr->read_data_fn != NULL)   {      png_ptr->read_data_fn = NULL;      png_warning(png_ptr,          \"Can't set both read_data_fn and write_data_fn in the\"          \" same structure\");   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32image_transform_add(PNG_CONST image_transform **this, unsigned int max,   png_uint_32 counter, char *name, size_t sizeof_name, size_t *pos,   png_byte colour_type, png_byte bit_depth){   for (;;)    {      png_uint_32 mask;      image_transform *list;            if (counter == 0)       {         image_transform_reset_count();         if (max <= 1)            counter = 1;         else            counter = random_32();      }      else       {         switch (max)         {            case 0:  ++counter; break;            case 1:  counter <<= 1; break;            default: counter = random_32(); break;         }      }            *this = &image_transform_end;      list = image_transform_first;      mask = 1;            while (list != &image_transform_end)      {         if ((counter & mask) != 0 && list->enable &&             (max == 0 || list->local_use < max))         {                        if (list->add(list, this, colour_type, bit_depth) || max == 0)            {                              *pos = safecat(name, sizeof_name, *pos, \" +\");               *pos = safecat(name, sizeof_name, *pos, list->name);            }            else            {                              *this = list->next;               list->next = 0;                              list->local_use = max;            }         }         mask <<= 1;         list = list->list;      }            if (*this != &image_transform_end)         return counter;            if (!image_transform_test_counter(counter, max))         return 0;   }}static png_uint_32image_transform_add(PNG_CONST image_transform **this, unsigned int max,   png_uint_32 counter, char *name, size_t sizeof_name, size_t *pos,   png_byte colour_type, png_byte bit_depth){   for (;;)    {      png_uint_32 mask;      image_transform *list;            if (counter == 0)       {         image_transform_reset_count();         if (max <= 1)            counter = 1;         else            counter = random_32();      }      else       {         switch (max)         {            case 0:  ++counter; break;            case 1:  counter <<= 1; break;            default: counter = random_32(); break;         }      }            *this = &image_transform_end;      list = image_transform_first;      mask = 1;            while (list != &image_transform_end)      {         if ((counter & mask) != 0 && list->enable &&             (max == 0 || list->local_use < max))         {                        if (list->add(list, this, colour_type, bit_depth) || max == 0)            {                              *pos = safecat(name, sizeof_name, *pos, \" +\");               *pos = safecat(name, sizeof_name, *pos, list->name);            }            else            {                              *this = list->next;               list->next = 0;                              list->local_use = max;            }         }         mask <<= 1;         list = list->list;      }            if (*this != &image_transform_end)         return counter;            if (!image_transform_test_counter(counter, max))         return 0;   }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_write_iCCP(png_structp png_ptr, png_charp name, int compression_type,   png_charp profile, int profile_len){#ifdef PNG_USE_LOCAL_ARRAYS   PNG_iCCP;#endif   png_size_t name_len;   png_charp new_name;   compression_state comp;   png_debug(1, \"in png_write_iCCP\\n\");   comp.num_output_ptr = 0;   comp.max_output_ptr = 0;   comp.output_ptr = NULL;   comp.input = NULL;   comp.input_len = 0;   if (name == NULL || (name_len = png_check_keyword(png_ptr, name,      &new_name)) == 0)   {      png_warning(png_ptr, \"Empty keyword in iCCP chunk\");      return;   }   if (compression_type != PNG_COMPRESSION_TYPE_BASE)      png_warning(png_ptr, \"Unknown compression type in iCCP chunk\");   if (profile == NULL)      profile_len = 0;   if (profile_len)       profile_len = png_text_compress(png_ptr, profile, (png_size_t)profile_len,          PNG_COMPRESSION_TYPE_BASE, &comp);      png_write_chunk_start(png_ptr, (png_bytep)png_iCCP,          (png_uint_32)name_len+profile_len+2);   new_name[name_len+1]=0x00;   png_write_chunk_data(png_ptr, (png_bytep)new_name, name_len + 2);   if (profile_len)      png_write_compressed_data_out(png_ptr, &comp);   png_write_chunk_end(png_ptr);   png_free(png_ptr, new_name);}#endif",
        "label": 1,
        "cve": "cve-2006-7244"
    },
    {
        "code": "static voidstore_storenew(png_store *ps){   png_store_buffer *pb;   if (ps->writepos != STORE_BUFFER_SIZE)      png_error(ps->pwrite, \"invalid store call\");   pb = voidcast(png_store_buffer*, malloc(sizeof *pb));   if (pb == NULL)      png_error(ps->pwrite, \"store new: OOM\");   *pb = ps->new;   ps->new.prev = pb;   ps->writepos = 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_size_tpng_inflate(png_structp png_ptr, const png_byte *data, png_size_t size,        png_bytep output, png_size_t output_size){   png_size_t count = 0;   png_ptr->zstream.next_in = (png_bytep)data;    png_ptr->zstream.avail_in = size;   while (1)   {      int ret, avail;            png_ptr->zstream.next_out = png_ptr->zbuf;      png_ptr->zstream.avail_out = png_ptr->zbuf_size;      ret = inflate(&png_ptr->zstream, Z_NO_FLUSH);      avail = png_ptr->zbuf_size - png_ptr->zstream.avail_out;            if ((ret == Z_OK || ret == Z_STREAM_END) && avail > 0)      {         if (output != 0 && output_size > count)         {            int copy = output_size - count;            if (avail < copy) copy = avail;            png_memcpy(output + count, png_ptr->zbuf, copy);         }         count += avail;      }      if (ret == Z_OK)         continue;            png_ptr->zstream.avail_in = 0;      inflateReset(&png_ptr->zstream);      if (ret == Z_STREAM_END)         return count;             {         PNG_CONST char *msg;         if (png_ptr->zstream.msg != 0)            msg = png_ptr->zstream.msg;         else         {#ifdef PNG_STDIO_SUPPORTED            char umsg[52];            switch (ret)            {               case Z_BUF_ERROR:                  msg = \"Buffer error in compressed datastream in %s chunk\";                  break;               case Z_DATA_ERROR:                  msg = \"Data error in compressed datastream in %s chunk\";                  break;               default:                  msg = \"Incomplete compressed datastream in %s chunk\";                  break;            }            png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name);            msg = umsg;#else            msg = \"Damaged compressed datastream in chunk other than IDAT\";#endif         }         png_warning(png_ptr, msg);      }            return 0;   }}",
        "label": 1,
        "cve": "cve-2011-3045"
    },
    {
        "code": "static png_uint_32png_pass_cols(png_uint_32 width, int pass){   png_uint_32 tiles = width>>3;   png_uint_32 cols = 0;   unsigned int x, y;   width &= 7;   ++pass;   for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass)   {      cols += tiles;      if (x < width) ++cols;      break;    }   return cols;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidclear(void *pv, size_t size){   static png_uint_32 clear_seed[2] = { 0x12345678, 0x9abcdef0 };   make_random_bytes(clear_seed, pv, size);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmake_size(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type, int bdlo,    int PNG_CONST bdhi){   for (; bdlo <= bdhi; ++bdlo)   {      png_uint_32 width;      for (width = 1; width <= 16; ++width)      {         png_uint_32 height;         for (height = 1; height <= 16; ++height)         {                        make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_NONE,               width, height, 0);            make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_NONE,               width, height, 1);#        ifdef PNG_WRITE_INTERLACING_SUPPORTED            make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_ADAM7,               width, height, 0);            make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_ADAM7,               width, height, 1);#        endif         }      }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_read_data(png_structrp png_ptr, png_bytep data, png_size_t length){   png_debug1(4, \"reading %d bytes\", (int)length);   if (png_ptr->read_data_fn != NULL)      (*(png_ptr->read_data_fn))(png_ptr, data, length);   else      png_error(png_ptr, \"Call to NULL read function\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intpng_have_neon(png_structp png_ptr){   int fd = open(\"/proc/self/auxv\", O_RDONLY);   Elf32_auxv_t aux;      if (fd == -1)   {      png_warning(png_ptr, \"/proc/self/auxv open failed\");      return 0;   }   while (safe_read(png_ptr, fd, &aux, sizeof aux) == sizeof aux)   {      if (aux.a_type == AT_HWCAP && (aux.a_un.a_val & HWCAP_NEON) != 0)      {         close(fd);         return 1;      }   }   close(fd);   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": " * read and processed--i.e., we now have enough info to finish initializing */static void rpng2_win_init(){    ulg i;    ulg rowbytes = rpng2_info.rowbytes;    Trace((stderr, \"beginning rpng2_win_init()\\n\"))    Trace((stderr, \"  rowbytes = %d\\n\", rpng2_info.rowbytes))    Trace((stderr, \"  width  = %ld\\n\", rpng2_info.width))    Trace((stderr, \"  height = %ld\\n\", rpng2_info.height))    rpng2_info.image_data = (uch *)malloc(rowbytes * rpng2_info.height);    if (!rpng2_info.image_data) {        readpng2_cleanup(&rpng2_info);        return;    }    rpng2_info.row_pointers = (uch **)malloc(rpng2_info.height * sizeof(uch *));    if (!rpng2_info.row_pointers) {        free(rpng2_info.image_data);        rpng2_info.image_data = NULL;        readpng2_cleanup(&rpng2_info);        return;    }    for (i = 0;  i < rpng2_info.height;  ++i)        rpng2_info.row_pointers[i] = rpng2_info.image_data + i*rowbytes;    if (rpng2_win_create_window()) {        readpng2_cleanup(&rpng2_info);        return;    }    rpng2_info.state = kWindowInit;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmake_size_image(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type,    png_byte PNG_CONST bit_depth, int PNG_CONST interlace_type,    png_uint_32 PNG_CONST w, png_uint_32 PNG_CONST h,    int PNG_CONST do_interlace){   context(ps, fault);      check_interlace_type(interlace_type);   Try   {      png_infop pi;      png_structp pp;      unsigned int pixel_size;            char name[FILE_NAME_SIZE];      PNG_CONST png_uint_32 id = FILEID(colour_type, bit_depth, 0,         interlace_type, w, h, do_interlace);      standard_name_from_id(name, sizeof name, 0, id);      pp = set_store_for_write(ps, &pi, name);            if (pp == NULL)         Throw ps;      png_set_IHDR(pp, pi, w, h, bit_depth, colour_type, interlace_type,         PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);#ifdef PNG_TEXT_SUPPORTED      {         static char key[] = \"image name\";          size_t pos;         png_text text;         char copy[FILE_NAME_SIZE];                  text.compression = TEXT_COMPRESSION;         text.key = key;                  pos = safecat(copy, sizeof copy, 0, ps->wname);         text.text = copy;         text.text_length = pos;         text.itxt_length = 0;         text.lang = 0;         text.lang_key = 0;         png_set_text(pp, pi, &text, 1);      }#endif      if (colour_type == 3)          init_standard_palette(ps, pp, pi, 1U << bit_depth, 0);      png_write_info(pp, pi);            pixel_size = bit_size(pp, colour_type, bit_depth);      if (png_get_rowbytes(pp, pi) != ((w * pixel_size) + 7) / 8)         png_error(pp, \"row size incorrect\");      else      {         int npasses = npasses_from_interlace_type(pp, interlace_type);         png_uint_32 y;         int pass;#        ifdef PNG_WRITE_FILTER_SUPPORTED            int nfilter = PNG_FILTER_VALUE_LAST;#        endif         png_byte image[16][SIZE_ROWMAX];                  memset(image, 0xff, sizeof image);         if (!do_interlace && npasses != png_set_interlace_handling(pp))            png_error(pp, \"write: png_set_interlace_handling failed\");                  for (y=0; y<h; ++y)            size_row(image[y], w * pixel_size, y);         for (pass=0; pass<npasses; ++pass)         {                        PNG_CONST png_uint_32 wPass = PNG_PASS_COLS(w, pass);                        for (y=0; y<h; ++y)            {               png_const_bytep row = image[y];               png_byte tempRow[SIZE_ROWMAX];                              if (do_interlace && interlace_type == PNG_INTERLACE_ADAM7)               {                                    if (PNG_ROW_IN_INTERLACE_PASS(y, pass) && wPass > 0)                  {                                          memset(tempRow, 0xff, sizeof tempRow);                     interlace_row(tempRow, row, pixel_size, w, pass);                     row = tempRow;                  }                  else                     continue;               }#           ifdef PNG_WRITE_FILTER_SUPPORTED                              png_set_filter(pp, 0,                  nfilter >= PNG_FILTER_VALUE_LAST ? PNG_ALL_FILTERS : nfilter);               if (nfilter-- == 0)                  nfilter = PNG_FILTER_VALUE_LAST-1;#           endif               png_write_row(pp, row);            }         }      }#ifdef PNG_TEXT_SUPPORTED      {         static char key[] = \"end marker\";         static char comment[] = \"end\";         png_text text;                  text.compression = TEXT_COMPRESSION;         text.key = key;         text.text = comment;         text.text_length = (sizeof comment)-1;         text.itxt_length = 0;         text.lang = 0;         text.lang_key = 0;         png_set_text(pp, pi, &text, 1);      }#endif      png_write_end(pp, pi);            store_storefile(ps, id);      store_write_reset(ps);   }   Catch(fault)   {            store_write_reset(fault);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGAPIpng_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,    png_const_colorp palette, int num_palette){   png_debug1(1, \"in %s storage function\", \"PLTE\");   if (png_ptr == NULL || info_ptr == NULL)      return;   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)   {      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)         png_error(png_ptr, \"Invalid palette length\");      else      {         png_warning(png_ptr, \"Invalid palette length\");         return;      }   }   if ((num_palette > 0 && palette == NULL) ||      (num_palette == 0#        ifdef PNG_MNG_FEATURES_SUPPORTED            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0#        endif      ))   {      png_chunk_report(png_ptr, \"Invalid palette\", PNG_CHUNK_ERROR);      return;   }      png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);      png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));   if (num_palette > 0)      memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color)));   info_ptr->palette = png_ptr->palette;   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;   info_ptr->free_me |= PNG_FREE_PLTE;   info_ptr->valid |= PNG_INFO_PLTE;}",
        "label": 1,
        "cve": "cve-2015-8126_1"
    },
    {
        "code": "static void readpng2_error_handler(png_structp png_ptr, png_const_charp msg){    mainprog_info  *mainprog_ptr;        fprintf(stderr, \"readpng2 libpng error: %s\\n\", msg);    fflush(stderr);    mainprog_ptr = png_get_error_ptr(png_ptr);    if (mainprog_ptr == NULL) {                 fprintf(stderr,          \"readpng2 severe error:  jmpbuf not recoverable; terminating.\\n\");        fflush(stderr);        exit(99);    }        longjmp(mainprog_ptr->jmpbuf, 1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIpngtest_warning(png_structp png_ptr, png_const_charp message){   PNG_CONST char *name = \"UNKNOWN (ERROR!)\";   char *test;   test = png_get_error_ptr(png_ptr);   if (test == NULL)     fprintf(STDERR, \"%s: libpng warning: %s\\n\", name, message);   else     fprintf(STDERR, \"%s: libpng warning: %s\\n\", test, message);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static inttest_one_file(const char *file_name, format_list *formats, png_uint_32 opts,   int stride_extra, int log_pass){   int result;   Image image;   newimage(&image);   initimage(&image, opts, file_name, stride_extra);   result = read_one_file(&image);   if (result)      result = testimage(&image, opts, formats);   freeimage(&image);      fflush(stderr);   if (log_pass)   {      if (result)         printf(\"PASS:\");      else         printf(\"FAIL:\");#     ifndef PNG_SIMPLIFIED_WRITE_SUPPORTED         printf(\" (no write)\");#     endif      print_opts(opts);      printf(\" %s\\n\", file_name);            fflush(stdout);   }   else if (!result)      exit(1);   return result;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intpng_have_neon(png_structp png_ptr){   FILE *f = fopen(\"/proc/cpuinfo\", \"rb\");   if (f != NULL)   {            static const char ch_feature[] = { 70, 69, 65, 84, 85, 82, 69, 83 };      static const char ch_neon[] = { 78, 69, 79, 78 };      enum      {         StartLine, Feature, Colon, StartTag, Neon, HaveNeon, SkipTag, SkipLine      }  state;      int counter;      for (state=StartLine, counter=0;;)      {         int ch = fgetc(f);         if (ch == EOF)         {                        fclose(f);            return 0;         }         switch (state)         {            case StartLine:                              if (ch <= 32)                   break;               counter=0;               state = Feature;                           case Feature:                              if ((ch & ~0x20) == ch_feature[counter])               {                  if (++counter == (sizeof ch_feature))                     state = Colon;                  break;               }                              state = SkipLine;                           case SkipLine:            skipLine:                              if (ch != 10 && ch != 13)                  break;               state = StartLine;               break;            case Colon:                              if (ch == 32 || ch == 9)                  break;               if (ch == 58)                {                  state = StartTag;                  break;               }                              state = SkipLine;               goto skipLine;            case StartTag:                              if (ch == 32 || ch == 9)                  break;               state = Neon;               counter = 0;                           case Neon:                              if ((ch & ~0x20) == ch_neon[counter])               {                  if (++counter == (sizeof ch_neon))                     state = HaveNeon;                  break;               }               state = SkipTag;                           case SkipTag:                              if (ch == 10 || ch == 13)                  state = StartLine;               else if (ch == 32 || ch == 9)                  state = StartTag;               break;            case HaveNeon:                              if (ch == 10 || ch == 13 || ch == 32 || ch == 9)               {                  fclose(f);                  return 1;               }               state = SkipTag;               break;            default:               png_error(png_ptr, \"png_have_neon: internal error (bug)\");         }      }   }#ifdef PNG_WARNINGS_SUPPORTED   else      png_warning(png_ptr, \"/proc/cpuinfo open failed\");#endif   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void usage(){  fprintf (stderr, \"PNM2PNG\\n\");  fprintf (stderr, \"   by Willem van Schaik, 1999\\n\");#ifdef __TURBOC__  fprintf (stderr, \"   for Turbo-C and Borland-C compilers\\n\");#else  fprintf (stderr, \"   for Linux (and Unix) compilers\\n\");#endif  fprintf (stderr, \"Usage:  pnm2png [options] <file>.<pnm> [<file>.png]\\n\");  fprintf (stderr, \"   or:  ... | pnm2png [options]\\n\");  fprintf (stderr, \"Options:\\n\");  fprintf (stderr, \"   -i[nterlace]   write png-file with interlacing on\\n\");  fprintf (stderr,      \"   -a[lpha] <file>.pgm read PNG alpha channel as pgm-file\\n\");  fprintf (stderr, \"   -h | -?  print this help-information\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_structpset_store_for_write(png_store *ps, png_infopp ppi,   PNG_CONST char * volatile name){   anon_context(ps);   Try   {      if (ps->pwrite != NULL)         png_error(ps->pwrite, \"write store already in use\");      store_write_reset(ps);      safecat(ps->wname, sizeof ps->wname, 0, name);      #     ifdef PNG_USER_MEM_SUPPORTED         if (!ps->speed)            ps->pwrite = png_create_write_struct_2(PNG_LIBPNG_VER_STRING,               ps, store_error, store_warning, &ps->write_memory_pool,               store_malloc, store_free);         else#     endif         ps->pwrite = png_create_write_struct(png_get_libpng_ver(NULL),            ps, store_error, store_warning);      png_set_write_fn(ps->pwrite, ps, store_write, store_flush);#     ifdef PNG_SET_OPTION_SUPPORTED         {            int opt;            for (opt=0; opt<ps->noptions; ++opt)               if (png_set_option(ps->pwrite, ps->options[opt].option,                  ps->options[opt].setting) == PNG_OPTION_INVALID)                  png_error(ps->pwrite, \"png option invalid\");         }#     endif      if (ppi != NULL)         *ppi = ps->piwrite = png_create_info_struct(ps->pwrite);   }   Catch_anonymous      return NULL;   return ps->pwrite;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_voidp PNGCBAPIstore_malloc(png_structp ppIn, png_alloc_size_t cb){   png_const_structp pp = ppIn;   store_pool *pool = voidcast(store_pool*, png_get_mem_ptr(pp));   store_memory *new = voidcast(store_memory*, malloc(cb + (sizeof *new) +      (sizeof pool->mark)));   if (new != NULL)   {      if (cb > pool->max)         pool->max = cb;      pool->current += cb;      if (pool->current > pool->limit)         pool->limit = pool->current;      pool->total += cb;      new->size = cb;      memcpy(new->mark, pool->mark, sizeof new->mark);      memcpy((png_byte*)(new+1) + cb, pool->mark, sizeof pool->mark);      new->pool = pool;      new->next = pool->list;      pool->list = new;      ++new;   }   else   {            store_log(pool->store, pp, \"out of memory\", 1 );   }   return new;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "uch  *image_data = NULL;void readpng_version_info(void){    fprintf(stderr, \"   Compiled with libpng %s; using libpng %s.\\n\",      PNG_LIBPNG_VER_STRING, png_libpng_ver);    fprintf(stderr, \"   Compiled with zlib %s; using zlib %s.\\n\",      ZLIB_VERSION, zlib_version);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_@_set(PNG_CONST image_transform *this,    transform_display *that, png_structp pp, png_infop pi){   png_set_@(pp);   this->next->set(this->next, that, pp, pi);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intchrm_modify(png_modifier *pm, png_modification *me, int add){   UNUSED(add)      png_save_uint_32(pm->buffer   , 32);   png_save_uint_32(pm->buffer+ 4, CHUNK_cHRM);   png_save_uint_32(pm->buffer+ 8, ((chrm_modification*)me)->wx);   png_save_uint_32(pm->buffer+12, ((chrm_modification*)me)->wy);   png_save_uint_32(pm->buffer+16, ((chrm_modification*)me)->rx);   png_save_uint_32(pm->buffer+20, ((chrm_modification*)me)->ry);   png_save_uint_32(pm->buffer+24, ((chrm_modification*)me)->gx);   png_save_uint_32(pm->buffer+28, ((chrm_modification*)me)->gy);   png_save_uint_32(pm->buffer+32, ((chrm_modification*)me)->bx);   png_save_uint_32(pm->buffer+36, ((chrm_modification*)me)->by);   return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "png_uint_32 PNGAPIpng_get_PLTE(png_const_structrp png_ptr, png_inforp info_ptr,    png_colorp *palette, int *num_palette){   png_debug1(1, \"in %s retrieval function\", \"PLTE\");   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_PLTE)       && palette != NULL)   {      *palette = info_ptr->palette;      *num_palette = info_ptr->num_palette;      png_debug1(3, \"num_palette = %d\", *num_palette);      return (PNG_INFO_PLTE);   }   return (0);}",
        "label": 1,
        "cve": "cve-2015-8126_2"
    },
    {
        "code": "static intimage_transform_png_set_expand_16_add(image_transform *this,    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth){   UNUSED(colour_type)   this->next = *that;   *that = this;      return bit_depth < 16;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#ifdef DOS_OS2_W32static char *dos_kbd_gets(char *buf, int len){    int ch, count=0;    do {        buf[count++] = ch = getche();    } while (ch != '\\r' && count < len-1);    buf[count--] = '\\0';            if (buf[count] == '\\r')             buf[count] = '\\n';    fprintf(stderr, \"\\n\");          fflush(stderr);    return buf;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidtransform_display_init(transform_display *dp, png_modifier *pm, png_uint_32 id,    PNG_CONST image_transform *transform_list){   memset(dp, 0, sizeof *dp);      standard_display_init(&dp->this, &pm->this, id, 0,      pm->use_update_info);      dp->pm = pm;   dp->transform_list = transform_list;      dp->output_colour_type = 255;    dp->output_bit_depth = 255;  }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void rpng2_x_display_row(ulg row){    uch bg_red   = rpng2_info.bg_red;    uch bg_green = rpng2_info.bg_green;    uch bg_blue  = rpng2_info.bg_blue;    uch *src, *src2=NULL;    char *dest;    uch r, g, b, a;    int ximage_rowbytes = ximage->bytes_per_line;    ulg i, pixel;    static int rows=0, prevpass=(-1);    static ulg firstrow;    Trace((stderr, \"beginning rpng2_x_display_row()\\n\"))    if (rpng2_info.pass != prevpass) {        if (pause_after_pass && rpng2_info.pass > 0) {            XEvent e;            KeySym k;            fprintf(stderr,              \"%s:  end of pass %d of 7; click in image window to continue\\n\",              PROGNAME, prevpass + 1);            do                XNextEvent(display, &e);            while (!QUIT(e,k));        }        fprintf(stderr, \"%s:  pass %d of 7\\r\", PROGNAME, rpng2_info.pass + 1);        fflush(stderr);        prevpass = rpng2_info.pass;    }    if (rows == 0)        firstrow = row;       ++rows;       if (depth == 24 || depth == 32) {        ulg red, green, blue;        int bpp = ximage->bits_per_pixel;        src = rpng2_info.image_data + row*rpng2_info.rowbytes;        if (bg_image)            src2 = bg_data + row*bg_rowbytes;        dest = ximage->data + row*ximage_rowbytes;        if (rpng2_info.channels == 3) {            for (i = rpng2_info.width;  i > 0;  --i) {                red   = *src++;                green = *src++;                blue  = *src++;                pixel = (red   << RShift) |                        (green << GShift) |                        (blue  << BShift);                                if (bpp == 32) {                    *dest++ = (char)((pixel >> 24) & 0xff);                    *dest++ = (char)((pixel >> 16) & 0xff);                    *dest++ = (char)((pixel >>  8) & 0xff);                    *dest++ = (char)( pixel        & 0xff);                } else {                                                            *dest++ = (char)((pixel >> 16) & 0xff);                    *dest++ = (char)((pixel >>  8) & 0xff);                    *dest++ = (char)( pixel        & 0xff);                }            }        } else  {            for (i = rpng2_info.width;  i > 0;  --i) {                r = *src++;                g = *src++;                b = *src++;                a = *src++;                if (bg_image) {                    bg_red   = *src2++;                    bg_green = *src2++;                    bg_blue  = *src2++;                }                if (a == 255) {                    red   = r;                    green = g;                    blue  = b;                } else if (a == 0) {                    red   = bg_red;                    green = bg_green;                    blue  = bg_blue;                } else {                                        alpha_composite(red,   r, a, bg_red);                    alpha_composite(green, g, a, bg_green);                    alpha_composite(blue,  b, a, bg_blue);                }                pixel = (red   << RShift) |                        (green << GShift) |                        (blue  << BShift);                                if (bpp == 32) {                    *dest++ = (char)((pixel >> 24) & 0xff);                    *dest++ = (char)((pixel >> 16) & 0xff);                    *dest++ = (char)((pixel >>  8) & 0xff);                    *dest++ = (char)( pixel        & 0xff);                } else {                                                            *dest++ = (char)((pixel >> 16) & 0xff);                    *dest++ = (char)((pixel >>  8) & 0xff);                    *dest++ = (char)( pixel        & 0xff);                }            }        }    } else if (depth == 16) {        ush red, green, blue;        src = rpng2_info.row_pointers[row];        if (bg_image)            src2 = bg_data + row*bg_rowbytes;        dest = ximage->data + row*ximage_rowbytes;        if (rpng2_info.channels == 3) {            for (i = rpng2_info.width;  i > 0;  --i) {                red   = ((ush)(*src) << 8);                ++src;                green = ((ush)(*src) << 8);                ++src;                blue  = ((ush)(*src) << 8);                ++src;                pixel = ((red   >> RShift) & RMask) |                        ((green >> GShift) & GMask) |                        ((blue  >> BShift) & BMask);                                *dest++ = (char)((pixel >>  8) & 0xff);                *dest++ = (char)( pixel        & 0xff);            }        } else  {            for (i = rpng2_info.width;  i > 0;  --i) {                r = *src++;                g = *src++;                b = *src++;                a = *src++;                if (bg_image) {                    bg_red   = *src2++;                    bg_green = *src2++;                    bg_blue  = *src2++;                }                if (a == 255) {                    red   = ((ush)r << 8);                    green = ((ush)g << 8);                    blue  = ((ush)b << 8);                } else if (a == 0) {                    red   = ((ush)bg_red   << 8);                    green = ((ush)bg_green << 8);                    blue  = ((ush)bg_blue  << 8);                } else {                                        alpha_composite(r, r, a, bg_red);                    alpha_composite(g, g, a, bg_green);                    alpha_composite(b, b, a, bg_blue);                    red   = ((ush)r << 8);                    green = ((ush)g << 8);                    blue  = ((ush)b << 8);                }                pixel = ((red   >> RShift) & RMask) |                        ((green >> GShift) & GMask) |                        ((blue  >> BShift) & BMask);                                *dest++ = (char)((pixel >>  8) & 0xff);                *dest++ = (char)( pixel        & 0xff);            }        }    } else  {            }    if (demo_timing && (row - firstrow >= 16 || row >= rpng2_info.height-2)) {        XPutImage(display, window, gc, ximage, 0, (int)firstrow, 0,          (int)firstrow, rpng2_info.width, row - firstrow + 1);        XFlush(display);        rows = 0;        usleep(usleep_duration);    } else    if (!demo_timing && ((rows & 0xf) == 0 || row >= rpng2_info.height-2)) {        XPutImage(display, window, gc, ximage, 0, (int)firstrow, 0,          (int)firstrow, rpng2_info.width, row - firstrow + 1);        XFlush(display);        rows = 0;    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmake_random_bytes(png_uint_32* seed, void* pv, size_t size){   png_uint_32 u0 = seed[0], u1 = seed[1];   png_bytep bytes = png_voidcast(png_bytep, pv);      size_t i;   for (i=0; i<size; ++i)   {            png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;      u1 <<= 8;      u1 |= u0 >> 24;      u0 <<= 8;      u0 |= u;      *bytes++ = (png_byte)u;   }   seed[0] = u0;   seed[1] = u1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGAPIpng_set_unknown_chunks(png_structp png_ptr,   png_infop info_ptr, png_const_unknown_chunkp unknowns, int num_unknowns){   png_unknown_chunkp np;   int i;   if (png_ptr == NULL || info_ptr == NULL || num_unknowns == 0)      return;   np = (png_unknown_chunkp)png_malloc_warn(png_ptr,       (png_size_t)(info_ptr->unknown_chunks_num + num_unknowns) *       png_sizeof(png_unknown_chunk));   if (np == NULL)   {      png_warning(png_ptr,          \"Out of memory while processing unknown chunk\");      return;   }   png_memcpy(np, info_ptr->unknown_chunks,       (png_size_t)info_ptr->unknown_chunks_num *       png_sizeof(png_unknown_chunk));   png_free(png_ptr, info_ptr->unknown_chunks);   info_ptr->unknown_chunks = NULL;   for (i = 0; i < num_unknowns; i++)   {      png_unknown_chunkp to = np + info_ptr->unknown_chunks_num + i;      png_const_unknown_chunkp from = unknowns + i;      png_memcpy(to->name, from->name, png_sizeof(from->name));      to->name[png_sizeof(to->name)-1] = '\\0';      to->size = from->size;            to->location = (png_byte)(png_ptr->mode & 0xff);      if (from->size == 0)         to->data=NULL;      else      {         to->data = (png_bytep)png_malloc_warn(png_ptr,             (png_size_t)from->size);         if (to->data == NULL)         {            png_warning(png_ptr,                \"Out of memory while processing unknown chunk\");            to->size = 0;         }         else            png_memcpy(to->data, from->data, from->size);      }   }   info_ptr->unknown_chunks = np;   info_ptr->unknown_chunks_num += num_unknowns;   info_ptr->free_me |= PNG_FREE_UNKN;}",
        "label": 1,
        "cve": "cve-2013-7353"
    },
    {
        "code": "static void PNGCBAPIprogressive_row(png_structp ppIn, png_bytep new_row, png_uint_32 y, int pass){   png_const_structp pp = ppIn;   PNG_CONST standard_display *dp = voidcast(standard_display*,      png_get_progressive_ptr(pp));      if (new_row != NULL)   {      png_bytep row;            if (dp->do_interlace && dp->interlace_type == PNG_INTERLACE_ADAM7)      {#ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED                  if (y != png_get_current_row_number(pp))            png_error(pp, \"png_get_current_row_number is broken\");         if (pass != png_get_current_pass_number(pp))            png_error(pp, \"png_get_current_pass_number is broken\");#endif         y = PNG_ROW_FROM_PASS_ROW(y, pass);      }            if (y >= dp->h)         png_error(pp, \"invalid y to progressive row callback\");      row = store_image_row(dp->ps, pp, 0, y);#ifdef PNG_READ_INTERLACING_SUPPORTED            if (dp->do_interlace)      {         if (dp->interlace_type == PNG_INTERLACE_ADAM7)            deinterlace_row(row, new_row, dp->pixel_size, dp->w, pass);         else            row_copy(row, new_row, dp->pixel_size * dp->w);      }      else         png_progressive_combine_row(pp, row, new_row);#endif    }#ifdef PNG_READ_INTERLACING_SUPPORTED   else if (dp->interlace_type == PNG_INTERLACE_ADAM7 &&       PNG_ROW_IN_INTERLACE_PASS(y, pass) &&       PNG_PASS_COLS(dp->w, pass) > 0)      png_error(pp, \"missing row in progressive de-interlacing\");#endif }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidbuffer_destroy_list(struct buffer_list *list){   if (list != NULL)   {      struct buffer_list *next = list->next;      DELETE(list);      buffer_destroy_list(next);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidpixel_copy(png_bytep toBuffer, png_uint_32 toIndex,   png_const_bytep fromBuffer, png_uint_32 fromIndex, unsigned int pixelSize){      toIndex *= pixelSize;   fromIndex *= pixelSize;   if (pixelSize < 8)    {            unsigned int destMask = ((1U<<pixelSize)-1) << (8-pixelSize-(toIndex&7));            unsigned int destByte = toBuffer[toIndex >> 3] & ~destMask;      unsigned int sourceByte = fromBuffer[fromIndex >> 3];            fromIndex &= 7;      if (fromIndex > 0) sourceByte <<= fromIndex;      if ((toIndex & 7) > 0) sourceByte >>= toIndex & 7;      toBuffer[toIndex >> 3] = (png_byte)(destByte | (sourceByte & destMask));   }   else       memmove(toBuffer+(toIndex>>3), fromBuffer+(fromIndex>>3), pixelSize>>3);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_cb16(Pixel *out, const Pixel *in, const Background *back){   if (in->a <= 0)   {      out->r = back->ir;      out->g = back->ig;      out->b = back->ib;   }   else if (in->a >= 65535)   {      out->r = isRGB(in->r);      out->g = isRGB(in->g);      out->b = isRGB(in->b);   }   else   {      double a = in->a / 65535.;      double a1 = 1-a;      a /= 65535;      out->r = sRGB(in->r * a + back->dr * a1);      out->g = sRGB(in->g * a + back->dg * a1);      out->b = sRGB(in->b * a + back->db * a1);   }   out->a = 255;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_lin(Pixel *out, const Pixel *in, const Background *back){   (void)back;   out->r = ilinear(in->r);   if (in->g == in->r)   {      out->g = out->r;      if (in->b == in->r)         out->b = out->r;      else         out->b = ilinear(in->b);   }   else   {      out->g = ilinear(in->g);      if (in->b == in->r)         out->b = out->r;      else if (in->b == in->g)         out->b = out->g;      else         out->b = ilinear(in->b);   }   out->a = 65535;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_read_IDAT_data(png_structrp png_ptr, png_bytep output,   png_alloc_size_t avail_out){      png_ptr->zstream.next_out = output;   png_ptr->zstream.avail_out = 0;    if (output == NULL)      avail_out = 0;   do   {      int ret;      png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];      if (png_ptr->zstream.avail_in == 0)      {         uInt avail_in;         png_bytep buffer;         while (png_ptr->idat_size == 0)         {            png_crc_finish(png_ptr, 0);            png_ptr->idat_size = png_read_chunk_header(png_ptr);                        if (png_ptr->chunk_name != png_IDAT)               png_error(png_ptr, \"Not enough image data\");         }         avail_in = png_ptr->IDAT_read_size;         if (avail_in > png_ptr->idat_size)            avail_in = (uInt)png_ptr->idat_size;                  buffer = png_read_buffer(png_ptr, avail_in, 0);         png_crc_read(png_ptr, buffer, avail_in);         png_ptr->idat_size -= avail_in;         png_ptr->zstream.next_in = buffer;         png_ptr->zstream.avail_in = avail_in;      }            if (output != NULL)       {         uInt out = ZLIB_IO_MAX;         if (out > avail_out)            out = (uInt)avail_out;         avail_out -= out;         png_ptr->zstream.avail_out = out;      }      else       {         png_ptr->zstream.next_out = tmpbuf;         png_ptr->zstream.avail_out = (sizeof tmpbuf);      }            ret = inflate(&png_ptr->zstream, Z_NO_FLUSH);            if (output != NULL)         avail_out += png_ptr->zstream.avail_out;      else          avail_out += (sizeof tmpbuf) - png_ptr->zstream.avail_out;      png_ptr->zstream.avail_out = 0;      if (ret == Z_STREAM_END)      {                  png_ptr->zstream.next_out = NULL;         png_ptr->mode |= PNG_AFTER_IDAT;         png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;         if (png_ptr->zstream.avail_in > 0 || png_ptr->idat_size > 0)            png_chunk_benign_error(png_ptr, \"Extra compressed data\");         break;      }      if (ret != Z_OK)      {         png_zstream_error(png_ptr, ret);         if (output != NULL)            png_chunk_error(png_ptr, png_ptr->zstream.msg);         else          {            png_chunk_benign_error(png_ptr, png_ptr->zstream.msg);            return;         }      }   } while (avail_out > 0);   if (avail_out > 0)   {            if (output != NULL)         png_error(png_ptr, \"Not enough image data\");      else          png_chunk_benign_error(png_ptr, \"Too much image data\");   }}",
        "label": 1,
        "cve": "cve-2015-0973"
    },
    {
        "code": "static intextract_one_file(const char *filename){   int result = 0;   FILE *fp = fopen(filename, \"rb\");   if (fp != NULL)   {      png_uint_32 proflen = 0;      png_bytep profile = extract(fp, &proflen);      if (profile != NULL && profile != no_profile)      {         size_t len;         char *output;         {            const char *ep = strrchr(filename, '.');            if (ep != NULL)               len = ep-filename;            else               len = strlen(filename);         }         output = malloc(len + 5);         if (output != NULL)         {            FILE *of;            memcpy(output, filename, len);            strcpy(output+len, \".icc\");            of = fopen(output, \"wb\");            if (of != NULL)            {               if (fwrite(profile, proflen, 1, of) == 1 &&                  fflush(of) == 0 &&                  fclose(of) == 0)               {                  if (verbose)                     printf(\"%s -> %s\\n\", filename, output);                                    result = 1;               }               else               {                  fprintf(stderr, \"%s: error writing profile\\n\", output);                  if (remove(output))                     fprintf(stderr, \"%s: could not remove file\\n\", output);               }            }            else               fprintf(stderr, \"%s: failed to open output file\\n\", output);            free(output);         }         else            fprintf(stderr, \"%s: OOM allocating string!\\n\", filename);         free(profile);      }      else if (verbose && profile == no_profile)\tprintf(\"%s has no profile\\n\", filename);   }   else      fprintf(stderr, \"%s: could not open file\\n\", filename);   return result;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#include \"../../png.h\"int main(int argc, const char **argv){   int result = 1;   if (argc == 3)   {      png_image image;            memset(&image, 0, sizeof image);      image.version = PNG_IMAGE_VERSION;      if (png_image_begin_read_from_file(&image, argv[1]))      {         png_bytep buffer;                  image.format = PNG_FORMAT_RGBA;         buffer = malloc(PNG_IMAGE_SIZE(image));         if (buffer != NULL)         {            if (png_image_finish_read(&image, NULL, buffer,               0, NULL))            {               if (png_image_write_to_file(&image, argv[2],                  0, buffer, 0,                  NULL))                  result = 0;               else                  fprintf(stderr, \"pngtopng: write %s: %s\\n\", argv[2],                      image.message);               free(buffer);            }            else            {               fprintf(stderr, \"pngtopng: read %s: %s\\n\", argv[1],                   image.message);                              png_image_free(&image);            }         }         else            fprintf(stderr, \"pngtopng: out of memory: %lu bytes\\n\",               (unsigned long)PNG_IMAGE_SIZE(image));      }      else                  fprintf(stderr, \"pngtopng: %s: %s\\n\", argv[1], image.message);   }   else            fprintf(stderr, \"pngtopng: usage: pngtopng input-file output-file\\n\");   return result;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_expand_16_mod(PNG_CONST image_transform *this,    image_pixel *that, png_const_structp pp,    PNG_CONST transform_display *display){      if (that->colour_type == PNG_COLOR_TYPE_PALETTE)      image_pixel_convert_PLTE(that);   if (that->have_tRNS)      image_pixel_add_alpha(that, &display->this);   if (that->bit_depth < 16)      that->sample_depth = that->bit_depth = 16;   this->next->mod(this->next, that, pp, display);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "FILE *saved_infile;void readpng_version_info(){    fprintf(stderr, \"   Compiled without libpng, zlib or PBMPLUS/NetPBM.\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void readpng2_error_handler(png_structp png_ptr, png_const_charp msg);void readpng2_version_info(void){    fprintf(stderr, \"   Compiled with libpng %s; using libpng %s\\n\",      PNG_LIBPNG_VER_STRING, png_libpng_ver);    fprintf(stderr, \"   and with zlib %s; using zlib %s.\\n\",      ZLIB_VERSION, zlib_version);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_pre(Pixel *out, const Pixel *in, const Background *back){   (void)back;   out->r = ilineara(in->r, in->a);   if (in->g == in->r)   {      out->g = out->r;      if (in->b == in->r)         out->b = out->r;      else         out->b = ilineara(in->b, in->a);   }   else   {      out->g = ilineara(in->g, in->a);      if (in->b == in->r)         out->b = out->r;      else if (in->b == in->g)         out->b = out->g;      else         out->b = ilineara(in->b, in->a);   }   out->a = in->a * 257;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGAPIpng_set_sPLT(png_structp png_ptr,             png_infop info_ptr, png_sPLT_tp entries, int nentries){    png_sPLT_tp np;    int i;    np = (png_sPLT_tp)png_malloc_warn(png_ptr,        (info_ptr->splt_palettes_num + nentries) * png_sizeof(png_sPLT_t));    if (np == NULL)    {      png_warning(png_ptr, \"No memory for sPLT palettes.\");      return;    }    png_memcpy(np, info_ptr->splt_palettes,           info_ptr->splt_palettes_num * png_sizeof(png_sPLT_t));    png_free(png_ptr, info_ptr->splt_palettes);    info_ptr->splt_palettes=NULL;    for (i = 0; i < nentries; i++)    {        png_sPLT_tp to = np + info_ptr->splt_palettes_num + i;        png_sPLT_tp from = entries + i;        to->name = (png_charp)png_malloc(png_ptr,            png_strlen(from->name) + 1);                png_strcpy(to->name, from->name);        to->entries = (png_sPLT_entryp)png_malloc(png_ptr,            from->nentries * png_sizeof(png_sPLT_t));                png_memcpy(to->entries, from->entries,            from->nentries * png_sizeof(png_sPLT_t));        to->nentries = from->nentries;        to->depth = from->depth;    }    info_ptr->splt_palettes = np;    info_ptr->splt_palettes_num += nentries;    info_ptr->valid |= PNG_INFO_sPLT;#ifdef PNG_FREE_ME_SUPPORTED    info_ptr->free_me |= PNG_FREE_SPLT;#endif}#endif ",
        "label": 1,
        "cve": "cve-2006-5793"
    },
    {
        "code": "static intcheck16(png_const_bytep bp, int b){   int i = 16;   do      if (*bp != b) return 1;   while (--i);   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmake_random_bytes(png_uint_32* seed, void* pv, size_t size){   png_uint_32 u0 = seed[0], u1 = seed[1];   png_bytep bytes = voidcast(png_bytep, pv);      size_t i;   for (i=0; i<size; ++i)   {            png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;      u1 <<= 8;      u1 |= u0 >> 24;      u0 <<= 8;      u0 |= u;      *bytes++ = (png_byte)u;   }   seed[0] = u0;   seed[1] = u1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidallocate(struct file *file, int allocate_idat){   struct control *control = png_voidcast(struct control*, file->alloc_ptr);   if (allocate_idat)   {      assert(file->idat == NULL);      IDAT_init(&control->idat, file);   }   else    {      assert(file->chunk == NULL);      chunk_init(&control->chunk, file);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_strip_16_mod(PNG_CONST image_transform *this,    image_pixel *that, png_const_structp pp,    PNG_CONST transform_display *display){   if (that->bit_depth == 16)   {      that->sample_depth = that->bit_depth = 8;      if (that->red_sBIT > 8) that->red_sBIT = 8;      if (that->green_sBIT > 8) that->green_sBIT = 8;      if (that->blue_sBIT > 8) that->blue_sBIT = 8;      if (that->alpha_sBIT > 8) that->alpha_sBIT = 8;      #     ifdef PNG_READ_ACCURATE_SCALE_SUPPORTED#        if PNG_LIBPNG_VER >= 10504#           error PNG_READ_ACCURATE_SCALE should not be set#        endif                  {            PNG_CONST double d = (255-128.5)/65535;            that->rede += d;            that->greene += d;            that->bluee += d;            that->alphae += d;         }#     endif   }   this->next->mod(this->next, that, pp, display);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "unsigned longcomponent(const char *prog, const char *arg, int issRGB){   char *ep;   unsigned long c = strtoul(arg, &ep, 0);   if (ep <= arg || *ep || c > 65535 || (issRGB && c > 255))   {      fprintf(stderr, \"%s: %s: invalid component value (%lu)\\n\", prog, arg, c);      usage(prog);   }   return c;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_write_data(png_structp png_ptr, png_const_bytep data, png_size_t length){      if (png_ptr->write_data_fn != NULL )      (*(png_ptr->write_data_fn))(png_ptr, (png_bytep)data, length);   else      png_error(png_ptr, \"Call to NULL write function\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidusage(const char *prog){      size_t i;   static const char *usage_string[] = {\"  Tests, optimizes and optionally fixes the zlib header in PNG files.\",\"  Optionally, when fixing, strips ancilliary chunks from the file.\",0,\"OPTIONS\",\"  OPERATION\",\"      By default files are just checked for readability with a summary of the\",\"      of zlib issues founds for each compressed chunk and the IDAT stream in\",\"      the file.\",\"    --optimize (-o):\",\"      Find the smallest deflate window size for the compressed data.\",\"    --strip=[none|crc|unsafe|unused|transform|color|all]:\",\"        none (default):   Retain all chunks.\",\"        crc:    Remove chunks with a bad CRC.\",\"        unsafe: Remove chunks that may be unsafe to retain if the image data\",\"                is modified.  This is set automatically if --max is given but\",\"                may be cancelled by a later --strip=none.\",\"        unused: Remove chunks not used by libpng when decoding an image.\",\"                This retains any chunks that might be used by libpng image\",\"                transformations.\",\"        transform: unused+bKGD.\",\"        color:  transform+iCCP and cHRM.\",\"        all:    color+gAMA and sRGB.\",\"      Only ancillary chunks are ever removed.  In addition the tRNS and sBIT\",\"      chunks are never removed as they affect exact interpretation of the\",\"      image pixel values.  The following known chunks are treated specially\",\"      by the above options:\",\"        gAMA, sRGB [all]: These specify the gamma encoding used for the pixel\",\"            values.\",\"        cHRM, iCCP [color]: These specify how colors are encoded.  iCCP also\",\"            specifies the exact encoding of a pixel value however in practice\",\"            most programs will ignore it.\",\"        bKGD [transform]: This is used by libpng transforms.\"\"    --max=<number>:\",\"      Use IDAT chunks sized <number>.  If no number is given the the IDAT\",\"      chunks will be the maximum size permitted; 2^31-1 bytes.  If the option\",\"      is omitted the original chunk sizes will not be changed.  When the\",\"      option is given --strip=unsafe is set automatically, this may be\",\"      cancelled if you know that all unknown unsafe-to-copy chunks really are\",\"      safe to copy across an IDAT size change.  This is true of all chunks\",\"      that have ever been formally proposed as PNG extensions.\",\"  MESSAGES\",\"      By default the program only outputs summaries for each file.\",\"    --quiet (-q):\",\"      Do not output the summaries except for files which cannot be read. With\",\"      two --quiets these are not output either.\",\"    --errors (-e):\",\"      Output errors from libpng and the program (except too-far-back).\",\"    --warnings (-w):\",\"      Output warnings from libpng.\",\"  OUTPUT\",\"      By default nothing is written.\",\"    --out=<file>:\",\"      Write the optimized/corrected version of the next PNG to <file>.  This\",\"      overrides the following two options\",\"    --suffix=<suffix>:\",\"      Set --out=<name><suffix> for all following files unless overridden on\",\"      a per-file basis by explicit --out.\",\"    --prefix=<prefix>:\",\"      Set --out=<prefix><name> for all the following files unless overridden\",\"      on a per-file basis by explicit --out.\",\"      These two options can be used together to produce a suffix and prefix.\",\"  INTERNAL OPTIONS\",#if 0 #ifdef PNG_MAXIMUM_INFLATE_WINDOW\"    --test:\",\"      Test the PNG_MAXIMUM_INFLATE_WINDOW option.  Setting this disables\",\"      output as this would produce a broken file.\",#endif#endif0,\"EXIT CODES\",\"  *** SUBJECT TO CHANGE ***\",\"  The program exit code is value in the range 0..127 holding a bit mask of\",\"  the following codes.  Notice that the results for each file are combined\",\"  together - check one file at a time to get a meaningful error code!\",\"    0x01: The zlib too-far-back error existed in at least one chunk.\",\"    0x02: At least once chunk had a CRC error.\",\"    0x04: A chunk length was incorrect.\",\"    0x08: The file was truncated.\",\"  Errors less than 16 are potentially recoverable, for a single file if the\",\"  exit code is less than 16 the file could be read (with corrections if a\",\"  non-zero code is returned).\",\"    0x10: The file could not be read, even with corrections.\",\"    0x20: The output file could not be written.\",\"    0x40: An unexpected, potentially internal, error occured.\",\"  If the command line arguments are incorrect the program exits with exit\",\"  255.  Some older operating systems only support 7-bit exit codes, on those\",\"  systems it is suggested that this program is first tested by supplying\",\"  invalid arguments.\",0,\"DESCRIPTION\",\"  \" PROGRAM_NAME \":\",\"  checks each PNG file on the command line for errors.  By default errors are\",\"  not output and the program just returns an exit code and prints a summary.\",\"  With the --quiet (-q) option the summaries are suppressed too and the\",\"  program only outputs unexpected errors (internal errors and file open\",\"  errors).\",\"  Various known problems in PNG files are fixed while the file is being read\",\"  The exit code says what problems were fixed.  In particular the zlib error:\",0,\"        \\\"invalid distance too far back\\\"\",0,\"  caused by an incorrect optimization of a zlib stream is fixed in any\",\"  compressed chunk in which it is encountered.  An integrity problem of the\",\"  PNG stream caused by a bug in libpng which wrote an incorrect chunk length\",\"  is also fixed.  Chunk CRC errors are automatically fixed up.\",0,\"  Setting one of the \\\"OUTPUT\\\" options causes the possibly modified file to\",\"  be written to a new file.\",0,\"  Notice that some PNG files with the zlib optimization problem can still be\",\"  read by libpng under some circumstances.  This program will still detect\",\"  and, if requested, correct the error.\",0,\"  The program will reliably process all files on the command line unless\",\"  either an invalid argument causes the usage message (this message) to be\",\"  produced or the program crashes.\",0,\"  The summary lines describe issues encountered with the zlib compressed\",\"  stream of a chunk.  They have the following format, which is SUBJECT TO\",\"  CHANGE in the future:\",0,\"     chunk reason comp-level p1 p2 p3 p4 file\",0,\"  p1 through p4 vary according to the 'reason'.  There are always 8 space\",\"  separated fields.  Reasons specific formats are:\",0,\"     chunk ERR status code read-errno write-errno message file\",\"     chunk SKP comp-level file-bits zlib-rc compressed message file\",\"     chunk ??? comp-level file-bits ok-bits compressed uncompress file\",0,\"  The various fields are\",0,\"$1 chunk:      The chunk type of a chunk in the file or 'HEAD' if a problem\",\"               is reported by libpng at the start of the IDAT stream.\",\"$2 reason:     One of:\",\"          CHK: A zlib header checksum was detected and fixed.\",\"          TFB: The zlib too far back error was detected and fixed.\",\"          OK : No errors were detected in the zlib stream and optimization\",\"               was not requested, or was not possible.\",\"          OPT: The zlib stream window bits value could be improved (and was).\",\"          SKP: The chunk was skipped because of a zlib issue (zlib-rc) with\",\"               explanation 'message'\",\"          ERR: The read of the file was aborted.  The parameters explain why.\",\"$3 status:     For 'ERR' the accumulate status code from 'EXIT CODES' above.\",\"               This is printed as a 2 digit hexadecimal value\",\"   comp-level: The recorded compression level (FLEVEL) of a zlib stream\",\"               expressed as a string {supfast,stdfast,default,maximum}\",\"$4 code:       The file exit code; where stop was called, as a fairly terse\",\"               string {warning,libpng,zlib,invalid,read,write,unexpected}.\",\"   file-bits:  The zlib window bits recorded in the file.\",\"$5 read-errno: A system errno value from a read translated by strerror(3).\",\"   zlib-rc:    A zlib return code as a string (see zlib.h).\",\"   ok-bits:    The smallest zlib window bits value that works.\",\"$6 write-errno:A system errno value from a write translated by strerror(3).\",\"   compressed: The count of compressed bytes in the zlib stream, when the\",\"               reason is 'SKP'; this is a count of the bytes read from the\",\"               stream when the fatal error was encountered.\",\"$7 message:    An error message (spaces replaced by _, as in all parameters),\",\"   uncompress: The count of bytes from uncompressing the zlib stream; this\",\"               may not be the same as the number of bytes in the image.\",\"$8 file:       The name of the file (this may contain spaces).\",};   fprintf(stderr, \"Usage: %s {[options] png-file}\\n\", prog);   for (i=0; i < (sizeof usage_string)/(sizeof usage_string[0]); ++i)   {      if (usage_string[i] != 0)         fputs(usage_string[i], stderr);      fputc('\\n', stderr);   }   exit(255);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32png_row_from_pass_row(png_uint_32 yIn, int pass){      switch (pass)   {case 0: return yIn * 8;case 1: return yIn * 8;case 2: return yIn * 8 + 4;case 3: return yIn * 4;case 4: return yIn * 4 + 2;case 5: return yIn * 2;case 6: return yIn * 2 + 1;default: break;   }   return 0xff; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static size_t safecat(char *buffer, size_t bufsize, size_t pos,   PNG_CONST char *cat){   while (pos < bufsize && cat != NULL && *cat != 0)      buffer[pos++] = *cat++;   if (pos >= bufsize)      pos = bufsize-1;   buffer[pos] = 0;   return pos;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_g16(Pixel *out, const Pixel *in, const Background *back){   (void)back;   out->r = out->g = out->b = u16d(YfromRGBint(in->r, in->g, in->b));   out->a = 65535;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intfind_by_flag(png_uint_32 flag){   int i = NINFO;   while (--i >= 0) if (chunk_info[i].flag == flag) return i;   fprintf(stderr, \"pngunknown: internal error\\n\");   exit(4);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int writepng_encode_image(mainprog_info *mainprog_ptr){    png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr;    png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr;        if (setjmp(mainprog_ptr->jmpbuf)) {        png_destroy_write_struct(&png_ptr, &info_ptr);        mainprog_ptr->png_ptr = NULL;        mainprog_ptr->info_ptr = NULL;        return 2;    }        png_write_image(png_ptr, mainprog_ptr->row_pointers);        png_write_end(png_ptr, NULL);    return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIpngtest_flush(png_structp png_ptr){      PNG_UNUSED(png_ptr)   }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidbuffer_start_write(struct buffer *buffer){   buffer->last = &buffer->first;   buffer->end_count = 0;   buffer->current = NULL;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_handle_sPLT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length){   png_bytep chunkdata;   png_bytep entry_start;   png_sPLT_t new_palette;#ifdef PNG_NO_POINTER_INDEXING   png_sPLT_entryp pp;#endif   int data_length, entry_size, i;   png_uint_32 skip = 0;   png_size_t slength;   png_debug(1, \"in png_handle_sPLT\\n\");   if (!(png_ptr->mode & PNG_HAVE_IHDR))      png_error(png_ptr, \"Missing IHDR before sPLT\");   else if (png_ptr->mode & PNG_HAVE_IDAT)   {      png_warning(png_ptr, \"Invalid sPLT after IDAT\");      png_crc_finish(png_ptr, length);      return;   }#ifdef PNG_MAX_MALLOC_64K   if (length > (png_uint_32)65535L)   {      png_warning(png_ptr, \"sPLT chunk too large to fit in memory\");      skip = length - (png_uint_32)65535L;      length = (png_uint_32)65535L;   }#endif   chunkdata = (png_bytep)png_malloc(png_ptr, length + 1);   slength = (png_size_t)length;   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);   if (png_crc_finish(png_ptr, skip))   {      png_free(png_ptr, chunkdata);      return;   }   chunkdata[slength] = 0x00;   for (entry_start = chunkdata; *entry_start; entry_start++)       ;   ++entry_start;      if (entry_start > chunkdata + slength - 2)   {      png_free(png_ptr, chunkdata);      png_warning(png_ptr, \"malformed sPLT chunk\");      return;   }   new_palette.depth = *entry_start++;   entry_size = (new_palette.depth == 8 ? 6 : 10);   data_length = (slength - (entry_start - chunkdata));      if (data_length % entry_size)   {      png_free(png_ptr, chunkdata);      png_warning(png_ptr, \"sPLT chunk has bad length\");      return;   }   new_palette.nentries = (png_int_32) ( data_length / entry_size);   if ((png_uint_32) new_palette.nentries > (png_uint_32) (PNG_SIZE_MAX /       png_sizeof(png_sPLT_entry)))   {       png_warning(png_ptr, \"sPLT chunk too long\");       return;   }   new_palette.entries = (png_sPLT_entryp)png_malloc_warn(       png_ptr, new_palette.nentries * png_sizeof(png_sPLT_entry));   if (new_palette.entries == NULL)   {       png_warning(png_ptr, \"sPLT chunk requires too much memory\");       return;   }#ifndef PNG_NO_POINTER_INDEXING   for (i = 0; i < new_palette.nentries; i++)   {      png_sPLT_entryp pp = new_palette.entries + i;      if (new_palette.depth == 8)      {          pp->red = *entry_start++;          pp->green = *entry_start++;          pp->blue = *entry_start++;          pp->alpha = *entry_start++;      }      else      {          pp->red   = png_get_uint_16(entry_start); entry_start += 2;          pp->green = png_get_uint_16(entry_start); entry_start += 2;          pp->blue  = png_get_uint_16(entry_start); entry_start += 2;          pp->alpha = png_get_uint_16(entry_start); entry_start += 2;      }      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;   }#else   pp = new_palette.entries;   for (i = 0; i < new_palette.nentries; i++)   {      if (new_palette.depth == 8)      {          pp[i].red   = *entry_start++;          pp[i].green = *entry_start++;          pp[i].blue  = *entry_start++;          pp[i].alpha = *entry_start++;      }      else      {          pp[i].red   = png_get_uint_16(entry_start); entry_start += 2;          pp[i].green = png_get_uint_16(entry_start); entry_start += 2;          pp[i].blue  = png_get_uint_16(entry_start); entry_start += 2;          pp[i].alpha = png_get_uint_16(entry_start); entry_start += 2;      }      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;   }#endif      new_palette.name = (png_charp)chunkdata;   png_set_sPLT(png_ptr, info_ptr, &new_palette, 1);   png_free(png_ptr, chunkdata);   png_free(png_ptr, new_palette.entries);}#endif ",
        "label": 1,
        "cve": "cve-2004-0599-1"
    },
    {
        "code": "static voidperform_one_test(FILE *fp, int argc, const char **argv,   png_uint_32 *default_flags, display *d, int set_callback){   int def;   png_uint_32 flags[2][4];   rewind(fp);   clear_keep();   memcpy(flags[0], default_flags, sizeof flags[0]);   def = check(fp, argc, argv, flags[1], d, set_callback);      check_error(d, (flags[0][0]|flags[0][2]) & (flags[0][1]|flags[0][3]),      \"chunk handled inconsistently in count tests\");   check_error(d, (flags[1][0]|flags[1][2]) & (flags[1][1]|flags[1][3]),      \"chunk handled inconsistently in option tests\");      {      png_uint_32 test;      test = flags[1][0] & ~flags[0][0];      check_error(d, test, \"new known chunk before IDAT\");      test = flags[1][1] & ~(flags[0][0] | flags[0][1]);      check_error(d, test, \"new unknown chunk before IDAT\");      test = flags[1][2] & ~flags[0][2];      check_error(d, test, \"new known chunk after IDAT\");      test = flags[1][3] & ~(flags[0][2] | flags[0][3]);      check_error(d, test, \"new unknown chunk after IDAT\");   }      check_handling(d, def, flags[0][0] | flags[0][1], flags[1][0], flags[1][1],      \"before IDAT\", set_callback);   check_handling(d, def, flags[0][2] | flags[0][3], flags[1][2], flags[1][3],      \"after IDAT\", set_callback);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidinsert_hIST(png_structp png_ptr, png_infop info_ptr, int nparams, png_charpp params){   int i;   png_uint_16 freq[256];      memset(freq, 0, sizeof freq);   for (i=0; i<nparams; ++i)   {      char *endptr = NULL;      unsigned long int l = strtoul(params[i], &endptr, 0);      if (params[i][0] && *endptr == 0 && l <= 65535)         freq[i] = (png_uint_16)l;      else      {         fprintf(stderr, \"hIST[%d]: %s: invalid frequency\\n\", i, params[i]);         exit(1);      }   }   png_set_hIST(png_ptr, info_ptr, freq);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void rpng2_win_cleanup(){    if (bg_image && bg_data) {        free(bg_data);        bg_data = NULL;    }    if (rpng2_info.image_data) {        free(rpng2_info.image_data);        rpng2_info.image_data = NULL;    }    if (rpng2_info.row_pointers) {        free(rpng2_info.row_pointers);        rpng2_info.row_pointers = NULL;    }    if (dib) {        free(dib);        dib = NULL;    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void initimage(Image *image, png_uint_32 opts, const char *file_name,   int stride_extra){   freeimage(image);   memset(&image->image, 0, sizeof image->image);   image->opts = opts;   image->file_name = file_name;   image->stride_extra = stride_extra;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_structpset_store_for_read(png_store *ps, png_infopp ppi, png_uint_32 id,   PNG_CONST char *name){      safecat(ps->test, sizeof ps->test, 0, name);   if (ps->pread != NULL)      png_error(ps->pread, \"read store already in use\");   store_read_reset(ps);   #  ifdef PNG_USER_MEM_SUPPORTED      if (!ps->speed)         ps->pread = png_create_read_struct_2(PNG_LIBPNG_VER_STRING, ps,             store_error, store_warning, &ps->read_memory_pool, store_malloc,             store_free);      else#  endif   ps->pread = png_create_read_struct(PNG_LIBPNG_VER_STRING, ps, store_error,      store_warning);   if (ps->pread == NULL)   {      struct exception_context *the_exception_context = &ps->exception_context;      store_log(ps, NULL, \"png_create_read_struct returned NULL (unexpected)\",         1 );      Throw ps;   }#  ifdef PNG_SET_OPTION_SUPPORTED      {         int opt;         for (opt=0; opt<ps->noptions; ++opt)            if (png_set_option(ps->pread, ps->options[opt].option,               ps->options[opt].setting) == PNG_OPTION_INVALID)                  png_error(ps->pread, \"png option invalid\");      }#  endif   store_read_set(ps, id);   if (ppi != NULL)      *ppi = ps->piread = png_create_info_struct(ps->pread);   return ps->pread;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidsBIT_error_fn(png_structp pp, png_infop pi){   png_byte bit_depth;   png_color_8 bad;   if (png_get_color_type(pp, pi) == PNG_COLOR_TYPE_PALETTE)      bit_depth = 8;   else      bit_depth = png_get_bit_depth(pp, pi);      bad.red = bad.green = bad.blue = bad.gray = bad.alpha =      (png_byte)(bit_depth+1);   png_set_sBIT(pp, pi, &bad);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int readpng2_init(mainprog_info *mainprog_ptr){    png_structp  png_ptr;           png_infop  info_ptr;        png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,      readpng2_error_handler, NULL);    if (!png_ptr)        return 4;       info_ptr = png_create_info_struct(png_ptr);    if (!info_ptr) {        png_destroy_read_struct(&png_ptr, NULL, NULL);        return 4;       }            if (setjmp(mainprog_ptr->jmpbuf)) {        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);        return 2;    }#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED        {                static PNG_CONST png_byte chunks_to_process[] = {            98,  75,  71,  68, '\\0',             103,  65,  77,  65, '\\0',             115,  82,  71,  66, '\\0',             };              png_set_keep_unknown_chunks(png_ptr, -1 ,          NULL, -1);              png_set_keep_unknown_chunks(png_ptr,          0 , chunks_to_process,          sizeof(chunks_to_process)/5);    }#endif         png_set_progressive_read_fn(png_ptr, mainprog_ptr,      readpng2_info_callback, readpng2_row_callback, readpng2_end_callback);        mainprog_ptr->png_ptr = png_ptr;    mainprog_ptr->info_ptr = info_ptr;        return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_bytecomponent_loc(png_byte loc[4], png_uint_32 format){      png_byte channels;   if (format & PNG_FORMAT_FLAG_COLOR)   {      channels = 3;      loc[2] = 1;#     ifdef PNG_FORMAT_BGR_SUPPORTED         if (format & PNG_FORMAT_FLAG_BGR)         {            loc[1] = 2;            loc[3] = 0;         }         else#     endif      {         loc[1] = 0;         loc[3] = 2;      }   }   else   {      channels = 1;      loc[1] = loc[2] = loc[3] = 0;   }   if (format & PNG_FORMAT_FLAG_ALPHA)   {#     ifdef PNG_FORMAT_AFIRST_SUPPORTED         if (format & PNG_FORMAT_FLAG_AFIRST)         {            loc[0] = 0;            ++loc[1];            ++loc[2];            ++loc[3];         }         else#     endif         loc[0] = channels;      ++channels;   }   else      loc[0] = 4;    return channels;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "doublesRGB(unsigned int i){   return fsRGB(i);}doublefinvsRGB(unsigned int i){   return 65535 * linear_from_sRGB(i/255.);}png_uint_16invsRGB(unsigned int i){   unsigned int x = nearbyint(finvsRGB(i));   if (x > 65535)   {      fprintf(stderr, \"invsRGB(%u) overflows to %u\\n\", i, x);      exit(1);   }   return (png_uint_16)x;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static size_tstore_read_buffer_size(png_store *ps){      if (ps->next != &ps->current->data)      return STORE_BUFFER_SIZE;   return ps->current->datacount;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "png_voidpPNGCBAPI png_debug_malloc(png_structp png_ptr, png_alloc_size_t size){      if (size == 0)      return (NULL);      {            memory_infop pinfo;      png_set_mem_fn(png_ptr, NULL, NULL, NULL);      pinfo = (memory_infop)png_malloc(png_ptr,         png_sizeof(*pinfo));      pinfo->size = size;      current_allocation += size;      total_allocation += size;      num_allocations ++;      if (current_allocation > maximum_allocation)         maximum_allocation = current_allocation;      pinfo->pointer = png_malloc(png_ptr, size);            png_set_mem_fn(png_ptr,          NULL, png_debug_malloc, png_debug_free);      if (size != 0 && pinfo->pointer == NULL)      {         current_allocation -= size;         total_allocation -= size;         png_error(png_ptr,           \"out of memory in pngtest->png_debug_malloc\");      }      pinfo->next = pinformation;      pinformation = pinfo;            png_memset(pinfo->pointer, 0xdd, pinfo->size);      if (verbose)         printf(\"png_malloc %lu bytes at %p\\n\", (unsigned long)size,            pinfo->pointer);      return (png_voidp)(pinfo->pointer);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidglobal_init(struct global *global)   {   CLEAR(*global);      global->errors        = 0;   global->warnings      = 0;   global->quiet         = 0;   global->verbose       = 0;   global->idat_max      = 0;            global->optimize_zlib = 0;   global->skip          = SKIP_NONE;   global->status_code   = 0;   IDAT_list_init(&global->idat_cache);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_g8(Pixel *p, png_const_voidp pb){   png_const_bytep pp = voidcast(png_const_bytep, pb);   p->r = p->g = p->b = pp[0];   p->a = 255;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intimage_transform_png_set_strip_16_add(image_transform *this,    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth){   UNUSED(colour_type)   this->next = *that;   *that = this;   return bit_depth > 8;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_pixel_init(image_pixel *this, png_const_bytep row, png_byte colour_type,    png_byte bit_depth, png_uint_32 x, store_palette palette){   PNG_CONST png_byte sample_depth = (png_byte)(colour_type ==      PNG_COLOR_TYPE_PALETTE ? 8 : bit_depth);   PNG_CONST unsigned int max = (1U<<sample_depth)-1;      this->palette_index = this->red = this->green = this->blue =      sample(row, colour_type, bit_depth, x, 0);   this->alpha = max;   this->red_sBIT = this->green_sBIT = this->blue_sBIT = this->alpha_sBIT =      sample_depth;      if (colour_type == 3)    {            if (palette != 0)      {         PNG_CONST unsigned int i = this->palette_index;         this->red = palette[i].red;         this->green = palette[i].green;         this->blue = palette[i].blue;         this->alpha = palette[i].alpha;      }   }   else    {      unsigned int i = 0;      if (colour_type & 2)      {         this->green = sample(row, colour_type, bit_depth, x, 1);         this->blue = sample(row, colour_type, bit_depth, x, 2);         i = 2;      }      if (colour_type & 4)         this->alpha = sample(row, colour_type, bit_depth, x, ++i);   }      image_pixel_setf(this, max);      this->colour_type = colour_type;   this->bit_depth = bit_depth;   this->sample_depth = sample_depth;   this->have_tRNS = 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static const char *strcode(int code){   switch (code)   {      case LIBPNG_WARNING_CODE:   return \"warning\";      case LIBPNG_ERROR_CODE:     return \"libpng\";      case ZLIB_ERROR_CODE:       return \"zlib\";      case INVALID_ERROR_CODE:    return \"invalid\";      case READ_ERROR_CODE:       return \"read\";      case WRITE_ERROR_CODE:      return \"write\";      case UNEXPECTED_ERROR_CODE: return \"unexpected\";      default:                    return \"INVALID\";   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int have_gc = FALSE;int main(int argc, char **argv){#ifdef sgi    char tmpline[80];#endif    char *p, *bgstr = NULL;    int rc, alen, flen;    int error = 0;    int timing = FALSE;    int have_bg = FALSE;#ifdef FEATURE_LOOP    int loop = FALSE;    long loop_interval = -1;            #endif    double LUT_exponent;                    double CRT_exponent = 2.2;              double default_display_exponent;        XEvent e;    KeySym k;        displayname = (char *)NULL;    filename = (char *)NULL;    memset(&rpng2_info, 0, sizeof(mainprog_info));    #if defined(NeXT)        LUT_exponent = 1.0 / 2.2;    #elif defined(sgi)    LUT_exponent = 1.0 / 1.7;        infile = fopen(\"/etc/config/system.glGammaVal\", \"r\");    if (infile) {        double sgi_gamma;        fgets(tmpline, 80, infile);        fclose(infile);        sgi_gamma = atof(tmpline);        if (sgi_gamma > 0.0)            LUT_exponent = 1.0 / sgi_gamma;    }#elif defined(Macintosh)    LUT_exponent = 1.8 / 2.61;    #else    LUT_exponent = 1.0;   #endif        default_display_exponent = LUT_exponent * CRT_exponent;        if ((p = getenv(\"SCREEN_GAMMA\")) != NULL)        rpng2_info.display_exponent = atof(p);    else        rpng2_info.display_exponent = default_display_exponent;        while (*++argv && !error) {        if (!strncmp(*argv, \"-display\", 2)) {            if (!*++argv)                ++error;            else                displayname = *argv;        } else if (!strncmp(*argv, \"-gamma\", 2)) {            if (!*++argv)                ++error;            else {                rpng2_info.display_exponent = atof(*argv);                if (rpng2_info.display_exponent <= 0.0)                    ++error;            }        } else if (!strncmp(*argv, \"-bgcolor\", 4)) {            if (!*++argv)                ++error;            else {                bgstr = *argv;                if (strlen(bgstr) != 7 || bgstr[0] != '#')                    ++error;                else {                    have_bg = TRUE;                    bg_image = FALSE;                }            }        } else if (!strncmp(*argv, \"-bgpat\", 4)) {            if (!*++argv)                ++error;            else {                pat = atoi(*argv);                if (pat >= 0 && pat < num_bgpat) {                    bg_image = TRUE;                    have_bg = FALSE;                } else                    ++error;            }        } else if (!strncmp(*argv, \"-usleep\", 2)) {            if (!*++argv)                ++error;            else {                usleep_duration = (ulg)atol(*argv);                demo_timing = TRUE;            }        } else if (!strncmp(*argv, \"-pause\", 2)) {            pause_after_pass = TRUE;        } else if (!strncmp(*argv, \"-timing\", 2)) {            timing = TRUE;#ifdef FEATURE_LOOP        } else if (!strncmp(*argv, \"-loop\", 2)) {            loop = TRUE;            if (!argv[1] || !is_number(argv[1]))                loop_interval = 2;            else {                ++argv;                loop_interval = atol(*argv);                if (loop_interval < 0)                    loop_interval = 2;                else if (loop_interval > 100000)                       loop_interval = 100000;            }#endif        } else {            if (**argv != '-') {                filename = *argv;                if (argv[1])                       ++error;            } else                ++error;           }    }    if (!filename)        ++error;        if (error) {        fprintf(stderr, \"\\n%s %s:  %s\\n\\n\", PROGNAME, VERSION, appname);        readpng2_version_info();        fprintf(stderr, \"\\n\"          \"Usage:  %s [-display xdpy] [-gamma exp] [-bgcolor bg | -bgpat pat]\\n\"#ifdef FEATURE_LOOP          \"        %*s [-usleep dur | -timing] [-pause] [-loop [sec]] file.png\\n\\n\"#else          \"        %*s [-usleep dur | -timing] [-pause] file.png\\n\\n\"#endif          \"    xdpy\\tname of the target X display (e.g., ``hostname:0'')\\n\"          \"    exp \\ttransfer-function exponent (``gamma'') of the display\\n\"          \"\\t\\t  system in floating-point format (e.g., ``%.1f''); equal\\n\"          \"\\t\\t  to the product of the lookup-table exponent (varies)\\n\"          \"\\t\\t  and the CRT exponent (usually 2.2); must be positive\\n\"          \"    bg  \\tdesired background color in 7-character hex RGB format\\n\"          \"\\t\\t  (e.g., ``#ff7700'' for orange:  same as HTML colors);\\n\"          \"\\t\\t  used with transparent images; overrides -bgpat\\n\"          \"    pat \\tdesired background pattern number (0-%d); used with\\n\"          \"\\t\\t  transparent images; overrides -bgcolor\\n\"#ifdef FEATURE_LOOP          \"    -loop\\tloops through background images after initial display\\n\"          \"\\t\\t  is complete (depends on -bgpat)\\n\"          \"    sec \\tseconds to display each background image (default = 2)\\n\"#endif          \"    dur \\tduration in microseconds to wait after displaying each\\n\"          \"\\t\\t  row (for demo purposes)\\n\"          \"    -timing\\tenables delay for every block read, to simulate modem\\n\"          \"\\t\\t  download of image (~36 Kbps)\\n\"          \"    -pause\\tpauses after displaying each pass until mouse clicked\\n\"          \"\\nPress Q, Esc or mouse button 1 (within image window, after image\\n\"          \"is displayed) to quit.\\n\"          \"\\n\", PROGNAME,          (int)strlen(PROGNAME), \" \", default_display_exponent, num_bgpat-1);        exit(1);    }    if (!(infile = fopen(filename, \"rb\"))) {        fprintf(stderr, PROGNAME \":  can't open PNG file [%s]\\n\", filename);        ++error;    } else {        incount = fread(inbuf, 1, INBUFSIZE, infile);        if (incount < 8 || !readpng2_check_sig(inbuf, 8)) {            fprintf(stderr, PROGNAME              \":  [%s] is not a PNG file: incorrect signature\\n\",              filename);            ++error;        } else if ((rc = readpng2_init(&rpng2_info)) != 0) {            switch (rc) {                case 2:                    fprintf(stderr, PROGNAME                      \":  [%s] has bad IHDR (libpng longjmp)\\n\", filename);                    break;                case 4:                    fprintf(stderr, PROGNAME \":  insufficient memory\\n\");                    break;                default:                    fprintf(stderr, PROGNAME                      \":  unknown readpng2_init() error\\n\");                    break;            }            ++error;        } else {            Trace((stderr, \"about to call XOpenDisplay()\\n\"))            display = XOpenDisplay(displayname);            if (!display) {                readpng2_cleanup(&rpng2_info);                fprintf(stderr, PROGNAME \":  can't open X display [%s]\\n\",                  displayname? displayname : \"default\");                ++error;            }        }        if (error)            fclose(infile);    }    if (error) {        fprintf(stderr, PROGNAME \":  aborting.\\n\");        exit(2);    }        alen = strlen(appname);    flen = strlen(filename);    if (alen + flen + 3 > 1023)        sprintf(titlebar, \"%s:  ...%s\", appname, filename+(alen+flen+6-1023));    else        sprintf(titlebar, \"%s:  %s\", appname, filename);        if (have_bg) {        unsigned r, g, b;           sscanf(bgstr+1, \"%2x%2x%2x\", &r, &g, &b);        rpng2_info.bg_red   = (uch)r;        rpng2_info.bg_green = (uch)g;        rpng2_info.bg_blue  = (uch)b;    } else        rpng2_info.need_bgcolor = TRUE;    rpng2_info.state = kPreInit;    rpng2_info.mainprog_init = rpng2_x_init;    rpng2_info.mainprog_display_row = rpng2_x_display_row;    rpng2_info.mainprog_finish_display = rpng2_x_finish_display;        for (;;) {        Trace((stderr, \"about to call readpng2_decode_data()\\n\"))        if (readpng2_decode_data(&rpng2_info, inbuf, incount))            ++error;        Trace((stderr, \"done with readpng2_decode_data()\\n\"))        if (error || incount != INBUFSIZE || rpng2_info.state == kDone) {            if (rpng2_info.state == kDone) {                Trace((stderr, \"done decoding PNG image\\n\"))            } else if (ferror(infile)) {                fprintf(stderr, PROGNAME                  \":  error while reading PNG image file\\n\");                exit(3);            } else if (feof(infile)) {                fprintf(stderr, PROGNAME \":  end of file reached \"                  \"(unexpectedly) while reading PNG image file\\n\");                exit(3);            } else  {                            }            break;        }        if (timing)            sleep(1);        incount = fread(inbuf, 1, INBUFSIZE, infile);    }        fclose(infile);    Trace((stderr, \"about to call readpng2_cleanup()\\n\"))    readpng2_cleanup(&rpng2_info);    if (error) {        fprintf(stderr, PROGNAME \":  libpng error while decoding PNG image\\n\");        exit(3);    }#ifdef FEATURE_LOOP    if (loop && bg_image) {        Trace((stderr, \"entering -loop loop (FEATURE_LOOP)\\n\"))        for (;;) {            int i, use_sleep;            struct timeval now, then;                        if (gettimeofday(&then, NULL) == 0) {                then.tv_sec += loop_interval;                use_sleep = FALSE;            } else                use_sleep = TRUE;                                    if (XCheckMaskEvent(display, KeyPressMask | ButtonPressMask, &e))                if (QUIT(e,k))                    break;                        if (++pat >= num_bgpat)                pat = 0;            rpng2_x_reload_bg_image();                        if (use_sleep || gettimeofday(&now, NULL) != 0) {                for (i = loop_interval;  i > 0;  --i) {                    sleep(1);                                        if (XCheckMaskEvent(display, KeyPressMask | ButtonPressMask,                        &e) && QUIT(e,k))                        break;                }            } else {                                if (now.tv_sec < then.tv_sec ||                    (now.tv_sec == then.tv_sec && now.tv_usec < then.tv_usec))                {                    int quit = FALSE;                    long seconds_to_go = then.tv_sec - now.tv_sec;                    long usleep_usec;                                        while (seconds_to_go-- > 1) {                        int seconds_done = 0;                        for (i = seconds_to_go;  i > 0 && !quit;  --i) {                            sleep(1);                                                        if (XCheckMaskEvent(display, KeyPressMask |                                ButtonPressMask, &e) && QUIT(e,k))                                quit = TRUE;                            if (++seconds_done > 1000)                                break;                           }                        if (quit)                            break;                                                if (gettimeofday(&now, NULL) == 0) {                            if (now.tv_sec >= then.tv_sec)                                break;                            seconds_to_go = then.tv_sec - now.tv_sec;                        } else                            ++seconds_to_go;                      }                    if (quit)                        break;                                           if (gettimeofday(&now, NULL) == 0) {                        usleep_usec = 1000000L*(then.tv_sec - now.tv_sec) +                          then.tv_usec - now.tv_usec;                        if (usleep_usec > 0)                            usleep((ulg)usleep_usec);                    }                }            }                        rpng2_x_redisplay_image (0, 0, rpng2_info.width, rpng2_info.height);        }    } else #endif         if (rpng2_info.state >= kWindowInit) {        Trace((stderr, \"entering final wait-for-quit-event loop\\n\"))        do {            XNextEvent(display, &e);            if (e.type == Expose) {                XExposeEvent *ex = (XExposeEvent *)&e;                rpng2_x_redisplay_image (ex->x, ex->y, ex->width, ex->height);            }        } while (!QUIT(e,k));    } else {        fprintf(stderr, PROGNAME \":  init callback never called:  probable \"          \"libpng error while decoding PNG metadata\\n\");        exit(4);    }        Trace((stderr, \"about to call rpng2_x_cleanup()\\n\"))    rpng2_x_cleanup();    return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intimage_transform_png_set_@_add(image_transform *this,    PNG_CONST image_transform **that, char *name, size_t sizeof_name,    size_t *pos, png_byte colour_type, png_byte bit_depth){   this->next = *that;   *that = this;   *pos = safecat(name, sizeof_name, *pos, \" +@\");   return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static size_t safecatn(char *buffer, size_t bufsize, size_t pos, int n){   char number[64];   sprintf(number, \"%d\", n);   return safecat(buffer, bufsize, pos, number);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static HWND global_hwnd;int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, PSTR cmd, int showmode){    char *args[1024];                     char *p, *q, **argv = args;    int argc = 0;    int rc, alen, flen;    int error = 0;    int have_bg = FALSE;    double LUT_exponent;                  double CRT_exponent = 2.2;            double default_display_exponent;      MSG msg;    filename = (char *)NULL;#ifndef __CYGWIN__        AllocConsole();    freopen(\"CONOUT$\", \"a\", stderr);    freopen(\"CONOUT$\", \"a\", stdout);#endif    #if defined(NeXT)    LUT_exponent = 1.0 / 2.2;    #elif defined(sgi)    LUT_exponent = 1.0 / 1.7;        infile = fopen(\"/etc/config/system.glGammaVal\", \"r\");    if (infile) {        double sgi_gamma;        fgets(tmpline, 80, infile);        fclose(infile);        sgi_gamma = atof(tmpline);        if (sgi_gamma > 0.0)            LUT_exponent = 1.0 / sgi_gamma;    }#elif defined(Macintosh)    LUT_exponent = 1.8 / 2.61;    #else    LUT_exponent = 1.0;   #endif        default_display_exponent = LUT_exponent * CRT_exponent;        if ((p = getenv(\"SCREEN_GAMMA\")) != NULL)        display_exponent = atof(p);    else        display_exponent = default_display_exponent;        argv[argc++] = PROGNAME;    p = cmd;    for (;;) {        if (*p == ' ')            while (*++p == ' ')                ;                if (*p == '\\0')            break;            argv[argc++] = q = p;        while (*q && *q != ' ')            ++q;                if (*q == '\\0')            break;            *q = '\\0';            p = q + 1;    }    argv[argc] = NULL;           while (*++argv && !error) {        if (!strncmp(*argv, \"-gamma\", 2)) {            if (!*++argv)                ++error;            else {                display_exponent = atof(*argv);                if (display_exponent <= 0.0)                    ++error;            }        } else if (!strncmp(*argv, \"-bgcolor\", 2)) {            if (!*++argv)                ++error;            else {                bgstr = *argv;                if (strlen(bgstr) != 7 || bgstr[0] != '#')                    ++error;                else                    have_bg = TRUE;            }        } else {            if (**argv != '-') {                filename = *argv;                if (argv[1])                       ++error;            } else                ++error;           }    }    if (!filename)        ++error;        if (error) {#ifndef __CYGWIN__        int ch;#endif        fprintf(stderr, \"\\n%s %s:  %s\\n\\n\", PROGNAME, VERSION, appname);        readpng_version_info();        fprintf(stderr, \"\\n\"          \"Usage:  %s [-gamma exp] [-bgcolor bg] file.png\\n\"          \"    exp \\ttransfer-function exponent (``gamma'') of the display\\n\"          \"\\t\\t  system in floating-point format (e.g., ``%.1f''); equal\\n\"          \"\\t\\t  to the product of the lookup-table exponent (varies)\\n\"          \"\\t\\t  and the CRT exponent (usually 2.2); must be positive\\n\"          \"    bg  \\tdesired background color in 7-character hex RGB format\\n\"          \"\\t\\t  (e.g., ``#ff7700'' for orange:  same as HTML colors);\\n\"          \"\\t\\t  used with transparent images\\n\"          \"\\nPress Q, Esc or mouse button 1 after image is displayed to quit.\\n\"#ifndef __CYGWIN__          \"Press Q or Esc to quit this usage screen.\\n\"#endif          \"\\n\", PROGNAME, default_display_exponent);#ifndef __CYGWIN__        do            ch = _getch();        while (ch != 'q' && ch != 'Q' && ch != 0x1B);#endif        exit(1);    }    if (!(infile = fopen(filename, \"rb\"))) {        fprintf(stderr, PROGNAME \":  can't open PNG file [%s]\\n\", filename);        ++error;    } else {        if ((rc = readpng_init(infile, &image_width, &image_height)) != 0) {            switch (rc) {                case 1:                    fprintf(stderr, PROGNAME                      \":  [%s] is not a PNG file: incorrect signature\\n\",                      filename);                    break;                case 2:                    fprintf(stderr, PROGNAME                      \":  [%s] has bad IHDR (libpng longjmp)\\n\", filename);                    break;                case 4:                    fprintf(stderr, PROGNAME \":  insufficient memory\\n\");                    break;                default:                    fprintf(stderr, PROGNAME                      \":  unknown readpng_init() error\\n\");                    break;            }            ++error;        }        if (error)            fclose(infile);    }    if (error) {#ifndef __CYGWIN__        int ch;#endif        fprintf(stderr, PROGNAME \":  aborting.\\n\");#ifndef __CYGWIN__        do            ch = _getch();        while (ch != 'q' && ch != 'Q' && ch != 0x1B);#endif        exit(2);    } else {        fprintf(stderr, \"\\n%s %s:  %s\\n\", PROGNAME, VERSION, appname);#ifndef __CYGWIN__        fprintf(stderr,          \"\\n   [console window:  closing this window will terminate %s]\\n\\n\",          PROGNAME);#endif    }        alen = strlen(appname);    flen = strlen(filename);    if (alen + flen + 3 > 1023)        sprintf(titlebar, \"%s:  ...%s\", appname, filename+(alen+flen+6-1023));    else        sprintf(titlebar, \"%s:  %s\", appname, filename);        if (have_bg) {        unsigned r, g, b;           sscanf(bgstr+1, \"%2x%2x%2x\", &r, &g, &b);        bg_red   = (uch)r;        bg_green = (uch)g;        bg_blue  = (uch)b;    } else if (readpng_get_bgcolor(&bg_red, &bg_green, &bg_blue) > 1) {        readpng_cleanup(TRUE);        fprintf(stderr, PROGNAME          \":  libpng error while checking for background color\\n\");        exit(2);    }        if (rpng_win_create_window(hInst, showmode))        exit(2);        Trace((stderr, \"calling readpng_get_image()\\n\"))    image_data = readpng_get_image(display_exponent, &image_channels,      &image_rowbytes);    Trace((stderr, \"done with readpng_get_image()\\n\"))        readpng_cleanup(FALSE);    fclose(infile);    if (!image_data) {        fprintf(stderr, PROGNAME \":  unable to decode PNG image\\n\");        exit(3);    }        Trace((stderr, \"calling rpng_win_display_image()\\n\"))    if (rpng_win_display_image()) {        free(image_data);        exit(4);    }    Trace((stderr, \"done with rpng_win_display_image()\\n\"))        printf(#ifndef __CYGWIN__      \"Done.  Press Q, Esc or mouse button 1 (within image window) to quit.\\n\"#else      \"Done.  Press mouse button 1 (within image window) to quit.\\n\"#endif    );    fflush(stdout);    while (GetMessage(&msg, NULL, 0, 0)) {        TranslateMessage(&msg);        DispatchMessage(&msg);    }        rpng_win_cleanup();    return msg.wParam;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_handle_sCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length){   png_charp buffer, ep;#ifdef PNG_FLOATING_POINT_SUPPORTED   double width, height;   png_charp vp;#else#ifdef PNG_FIXED_POINT_SUPPORTED   png_charp swidth, sheight;#endif#endif   png_size_t slength;   png_debug(1, \"in png_handle_sCAL\\n\");   if (!(png_ptr->mode & PNG_HAVE_IHDR))      png_error(png_ptr, \"Missing IHDR before sCAL\");   else if (png_ptr->mode & PNG_HAVE_IDAT)   {      png_warning(png_ptr, \"Invalid sCAL after IDAT\");      png_crc_finish(png_ptr, length);      return;   }   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL))   {      png_warning(png_ptr, \"Duplicate sCAL chunk\");      png_crc_finish(png_ptr, length);      return;   }   png_debug1(2, \"Allocating and reading sCAL chunk data (%lu bytes)\\n\",      length + 1);   buffer = (png_charp)png_malloc_warn(png_ptr, length + 1);   if (buffer == NULL)     {       png_warning(png_ptr, \"Out of memory while processing sCAL chunk\");       return;     }   slength = (png_size_t)length;   png_crc_read(png_ptr, (png_bytep)buffer, slength);   if (png_crc_finish(png_ptr, 0))   {      png_free(png_ptr, buffer);      return;   }   buffer[slength] = 0x00;    ep = buffer + 1;        #ifdef PNG_FLOATING_POINT_SUPPORTED   width = strtod(ep, &vp);   if (*vp)   {       png_warning(png_ptr, \"malformed width string in sCAL chunk\");       return;   }#else#ifdef PNG_FIXED_POINT_SUPPORTED   swidth = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1);   if (swidth == NULL)     {       png_warning(png_ptr, \"Out of memory while processing sCAL chunk width\");       return;     }   png_memcpy(swidth, ep, (png_size_t)png_strlen(ep));#endif#endif   for (ep = buffer; *ep; ep++)       ;   ep++;#ifdef PNG_FLOATING_POINT_SUPPORTED   height = strtod(ep, &vp);   if (*vp)   {       png_warning(png_ptr, \"malformed height string in sCAL chunk\");       return;   }#else#ifdef PNG_FIXED_POINT_SUPPORTED   sheight = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1);   if (swidth == NULL)     {       png_warning(png_ptr, \"Out of memory while processing sCAL chunk height\");       return;     }   png_memcpy(sheight, ep, (png_size_t)png_strlen(ep));#endif#endif   if (buffer + slength < ep#ifdef PNG_FLOATING_POINT_SUPPORTED      || width <= 0. || height <= 0.#endif      )   {      png_warning(png_ptr, \"Invalid sCAL data\");      png_free(png_ptr, buffer);#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)      png_free(png_ptr, swidth);      png_free(png_ptr, sheight);#endif      return;   }#ifdef PNG_FLOATING_POINT_SUPPORTED   png_set_sCAL(png_ptr, info_ptr, buffer[0], width, height);#else#ifdef PNG_FIXED_POINT_SUPPORTED   png_set_sCAL_s(png_ptr, info_ptr, buffer[0], swidth, sheight);#endif#endif   png_free(png_ptr, buffer);#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)   png_free(png_ptr, swidth);   png_free(png_ptr, sheight);#endif}#endif",
        "label": 1,
        "cve": "cve-2007-5269-2"
    },
    {
        "code": "static voidgpc_sG(Pixel *out, const Pixel *in, const Background *back){   (void)back;   out->r = out->g = out->b = sRGB(YfromRGBint(in->r, in->g, in->b)/65535);   out->a = 255;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#ifdef DO_16BITstatic void perform_gamma_scale16_tests(png_modifier *pm){#  ifndef PNG_MAX_GAMMA_8#     define PNG_MAX_GAMMA_8 11#  endif#  define SBIT_16_TO_8 PNG_MAX_GAMMA_8      unsigned int i, j;   for (i=0; i<pm->ngamma_tests; ++i)   {      for (j=0; j<pm->ngamma_tests; ++j)      {         if (i != j &&             fabs(pm->gammas[j]/pm->gammas[i]-1) >= PNG_GAMMA_THRESHOLD)         {            gamma_transform_test(pm, 0, 16, 0, pm->interlace_type,               1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,               pm->use_input_precision_16to8, 1 );            if (fail(pm))               return;            gamma_transform_test(pm, 2, 16, 0, pm->interlace_type,               1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,               pm->use_input_precision_16to8, 1 );            if (fail(pm))               return;            gamma_transform_test(pm, 4, 16, 0, pm->interlace_type,               1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,               pm->use_input_precision_16to8, 1 );            if (fail(pm))               return;            gamma_transform_test(pm, 6, 16, 0, pm->interlace_type,               1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,               pm->use_input_precision_16to8, 1 );            if (fail(pm))               return;         }      }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32 png_log8bit(unsigned x){   if (x > 0)      return (png_uint_32)floor(.5-log(x/255.)*L2INV);   return 0xffffffff;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intfirst_transform(int transforms){   return transforms & -transforms; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void writepng_error_handler(png_structp png_ptr, png_const_charp msg){    mainprog_info  *mainprog_ptr;        fprintf(stderr, \"writepng libpng error: %s\\n\", msg);    fflush(stderr);    mainprog_ptr = png_get_error_ptr(png_ptr);    if (mainprog_ptr == NULL) {                 fprintf(stderr,          \"writepng severe error:  jmpbuf not recoverable; terminating.\\n\");        fflush(stderr);        exit(99);    }        longjmp(mainprog_ptr->jmpbuf, 1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_rgb_to_gray_ini(PNG_CONST image_transform *this,    transform_display *that){   png_modifier *pm = that->pm;   PNG_CONST color_encoding *e = pm->current_encoding;   UNUSED(this)      pm->test_uses_encoding = 1;      if (e != 0)   {            PNG_CONST double whiteY = e->red.Y + e->green.Y + e->blue.Y;      data.red_coefficient = e->red.Y;      data.green_coefficient = e->green.Y;      data.blue_coefficient = e->blue.Y;      if (whiteY != 1)      {         data.red_coefficient /= whiteY;         data.green_coefficient /= whiteY;         data.blue_coefficient /= whiteY;      }   }   else   {            data.red_coefficient = 6968 / 32768.;      data.green_coefficient = 23434 / 32768.;      data.blue_coefficient = 2366 / 32768.;   }   data.gamma = pm->current_gamma;      if (data.gamma == 0)      data.gamma = 1;      if (pm->test_exhaustive)   {            data.coefficients_overridden = !data.coefficients_overridden;      pm->repeat = data.coefficients_overridden != 0;   }   else      data.coefficients_overridden = random_choice();   if (data.coefficients_overridden)   {            png_uint_32 ru;      double total;      RANDOMIZE(ru);      data.green_coefficient = total = (ru & 0xffff) / 65535.;      ru >>= 16;      data.red_coefficient = (1 - total) * (ru & 0xffff) / 65535.;      total += data.red_coefficient;      data.blue_coefficient = 1 - total;#     ifdef PNG_FLOATING_POINT_SUPPORTED         data.red_to_set = data.red_coefficient;         data.green_to_set = data.green_coefficient;#     else         data.red_to_set = fix(data.red_coefficient);         data.green_to_set = fix(data.green_coefficient);#     endif            pm->encoding_ignored = 1;   }   else   {      data.red_to_set = -1;      data.green_to_set = -1;   }      if (data.gamma != 1)    {      if (that->this.bit_depth == 16 || pm->assume_16_bit_calculations)      {                  that->pm->limit +=#        if PNG_MAX_GAMMA_8 < 14               pow((that->this.bit_depth == 16 ?                  8. : 6. + (1<<(15-PNG_MAX_GAMMA_8)))/65535, data.gamma);#        else               pow((that->this.bit_depth == 16 ?                  8. : 8. + (1<<(15-PNG_MAX_GAMMA_8)))/65535, data.gamma);#        endif      }      else      {                  that->pm->limit +=#        if DIGITIZE             pow(1.1 /255, data.gamma);#        else             pow(1.0 /255, data.gamma);#        endif      }   }   else   {            if (that->this.bit_depth != 16 && !pm->assume_16_bit_calculations)         that->pm->limit += 4E-3;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_palette_to_rgb_mod(PNG_CONST image_transform *this,    image_pixel *that, png_const_structp pp,    PNG_CONST transform_display *display){   if (that->colour_type == PNG_COLOR_TYPE_PALETTE)      image_pixel_convert_PLTE(that);   this->next->mod(this->next, that, pp, display);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32 png_exp(png_uint_32 x){   return (png_uint_32)floor(.5 + exp(x * -LN2) * 0xffffffffU);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intone_file(struct global *global, const char *file_name, const char *out_name){   int rc;   struct control control;   if (global->verbose)      fprintf(stderr, \"FILE %s -> %s\\n\", file_name,         out_name ? out_name : \"<none>\");      rc = control_init(&control, global, file_name, out_name);   if (rc == 0)      rc = read_png(&control);   rc |= control_end(&control);   return rc;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_A(Pixel *out, const Pixel *in, const Background *back){   (void)back;   out->r = in->r;   out->g = in->g;   out->b = in->b;   out->a = 65535;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voiddisplay_clean_write(struct display *dp){      if (dp->write_pp != NULL)         png_destroy_write_struct(&dp->write_pp, NULL);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int mytime(struct timespec *t){      if (!clock_gettime(CLOCK_PROCESS_CPUTIME_ID, t))      return 1;   perror(\"CLOCK_PROCESS_CPUTIME_ID\");   fprintf(stderr, \"timepng: could not get the time\\n\");   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_handle_tRNS(png_structp png_ptr, png_infop info_ptr, png_uint_32 length){   png_byte readbuf[PNG_MAX_PALETTE_LENGTH];   png_debug(1, \"in png_handle_tRNS\\n\");   if (!(png_ptr->mode & PNG_HAVE_IHDR))      png_error(png_ptr, \"Missing IHDR before tRNS\");   else if (png_ptr->mode & PNG_HAVE_IDAT)   {      png_warning(png_ptr, \"Invalid tRNS after IDAT\");      png_crc_finish(png_ptr, length);      return;   }   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))   {      png_warning(png_ptr, \"Duplicate tRNS chunk\");      png_crc_finish(png_ptr, length);      return;   }   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)   {      png_byte buf[2];      if (length != 2)      {         png_warning(png_ptr, \"Incorrect tRNS chunk length\");         png_crc_finish(png_ptr, length);         return;      }      png_crc_read(png_ptr, buf, 2);      png_ptr->num_trans = 1;      png_ptr->trans_values.gray = png_get_uint_16(buf);   }   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)   {      png_byte buf[6];      if (length != 6)      {         png_warning(png_ptr, \"Incorrect tRNS chunk length\");         png_crc_finish(png_ptr, length);         return;      }      png_crc_read(png_ptr, buf, (png_size_t)length);      png_ptr->num_trans = 1;      png_ptr->trans_values.red = png_get_uint_16(buf);      png_ptr->trans_values.green = png_get_uint_16(buf + 2);      png_ptr->trans_values.blue = png_get_uint_16(buf + 4);   }   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)   {      if (!(png_ptr->mode & PNG_HAVE_PLTE))      {                  png_warning(png_ptr, \"Missing PLTE before tRNS\");      }      if (length > (png_uint_32)png_ptr->num_palette ||          length > PNG_MAX_PALETTE_LENGTH)      {         png_warning(png_ptr, \"Incorrect tRNS chunk length\");         png_crc_finish(png_ptr, length);         return;      }      if (length == 0)      {         png_warning(png_ptr, \"Zero length tRNS chunk\");         png_crc_finish(png_ptr, length);         return;      }      png_crc_read(png_ptr, readbuf, (png_size_t)length);      png_ptr->num_trans = (png_uint_16)length;   }   else   {      png_warning(png_ptr, \"tRNS chunk not allowed with alpha channel\");      png_crc_finish(png_ptr, length);      return;   }   if (png_crc_finish(png_ptr, 0))      return;   png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,      &(png_ptr->trans_values));}#endif",
        "label": 1,
        "cve": "cve-2007-2445"
    },
    {
        "code": "static void perform_gamma_transform_tests(png_modifier *pm){   png_byte colour_type = 0;   png_byte bit_depth = 0;   unsigned int palette_number = 0;   while (next_format(&colour_type, &bit_depth, &palette_number, 1))   {      unsigned int i, j;      for (i=0; i<pm->ngamma_tests; ++i) for (j=0; j<pm->ngamma_tests; ++j)         if (i != j)         {            gamma_transform_test(pm, colour_type, bit_depth, palette_number,               pm->interlace_type, 1/pm->gammas[i], pm->gammas[j], 0,               pm->use_input_precision, 0 );            if (fail(pm))               return;         }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_argb8(Pixel *p, png_const_voidp pb){   png_const_bytep pp = voidcast(png_const_bytep, pb);   p->r = pp[1];   p->g = pp[2];   p->b = pp[3];   p->a = pp[0];}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgamma_image_validate(gamma_display *dp, png_const_structp pp,   png_infop pi){      PNG_CONST png_store* PNG_CONST ps = dp->this.ps;   PNG_CONST png_byte in_ct = dp->this.colour_type;   PNG_CONST png_byte in_bd = dp->this.bit_depth;   PNG_CONST png_uint_32 w = dp->this.w;   PNG_CONST png_uint_32 h = dp->this.h;   PNG_CONST size_t cbRow = dp->this.cbRow;   PNG_CONST png_byte out_ct = png_get_color_type(pp, pi);   PNG_CONST png_byte out_bd = png_get_bit_depth(pp, pi);      PNG_CONST unsigned int samples_per_pixel = (out_ct & 2U) ? 3U : 1U;   int processing;   png_uint_32 y;   PNG_CONST store_palette_entry *in_palette = dp->this.palette;   PNG_CONST int in_is_transparent = dp->this.is_transparent;   int out_npalette = -1;   int out_is_transparent = 0;    store_palette out_palette;   validate_info vi;      store_image_check(dp->this.ps, pp, 0);      init_validate_info(&vi, dp, pp, in_ct==3?8:in_bd, out_ct==3?8:out_bd);   processing = (vi.gamma_correction > 0 && !dp->threshold_test)      || in_bd != out_bd || in_ct != out_ct || vi.do_background;      if (in_ct == 3 && out_ct == 3)      processing = 0;   if (processing && out_ct == 3)      out_is_transparent = read_palette(out_palette, &out_npalette, pp, pi);   for (y=0; y<h; ++y)   {      png_const_bytep pRow = store_image_row(ps, pp, 0, y);      png_byte std[STANDARD_ROWMAX];      transform_row(pp, std, in_ct, in_bd, y);      if (processing)      {         unsigned int x;         for (x=0; x<w; ++x)         {            double alpha = 1;                         PNG_CONST unsigned int in_index =               in_ct == 3 ? sample(std, 3, in_bd, x, 0) : 256;            PNG_CONST unsigned int out_index =               out_ct == 3 ? sample(std, 3, out_bd, x, 0) : 256;                        if ((in_ct & PNG_COLOR_MASK_ALPHA) != 0 || (in_ct == 3 &&               in_is_transparent))            {               PNG_CONST unsigned int input_alpha = in_ct == 3 ?                  dp->this.palette[in_index].alpha :                  sample(std, in_ct, in_bd, x, samples_per_pixel);               unsigned int output_alpha = 65536 ;               if (out_ct == 3)               {                  if (out_is_transparent)                     output_alpha = out_palette[out_index].alpha;               }               else if ((out_ct & PNG_COLOR_MASK_ALPHA) != 0)                  output_alpha = sample(pRow, out_ct, out_bd, x,                     samples_per_pixel);               if (output_alpha != 65536)                  alpha = gamma_component_validate(\"alpha\", &vi, input_alpha,                     output_alpha, -1, 0);               else                {                                    alpha = input_alpha >> vi.isbit_shift;                  alpha /= vi.sbit_max;               }            }                        if ((in_ct & PNG_COLOR_MASK_COLOR) == 0)                (void)gamma_component_validate(\"gray\", &vi,                  sample(std, in_ct, in_bd, x, 0),                  sample(pRow, out_ct, out_bd, x, 0), alpha,                  vi.background_red);            else             {               (void)gamma_component_validate(\"red\", &vi,                  in_ct == 3 ? in_palette[in_index].red :                     sample(std, in_ct, in_bd, x, 0),                  out_ct == 3 ? out_palette[out_index].red :                     sample(pRow, out_ct, out_bd, x, 0),                  alpha, vi.background_red);               (void)gamma_component_validate(\"green\", &vi,                  in_ct == 3 ? in_palette[in_index].green :                     sample(std, in_ct, in_bd, x, 1),                  out_ct == 3 ? out_palette[out_index].green :                     sample(pRow, out_ct, out_bd, x, 1),                  alpha, vi.background_green);               (void)gamma_component_validate(\"blue\", &vi,                  in_ct == 3 ? in_palette[in_index].blue :                     sample(std, in_ct, in_bd, x, 2),                  out_ct == 3 ? out_palette[out_index].blue :                     sample(pRow, out_ct, out_bd, x, 2),                  alpha, vi.background_blue);            }         }      }      else if (memcmp(std, pRow, cbRow) != 0)      {         char msg[64];                  sprintf(msg, \"gamma: below threshold row %lu changed\",            (unsigned long)y);         png_error(pp, msg);      }   }    dp->this.ps->validated = 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int is_number(char *p){    while (*p) {        if (!isdigit(*p))            return FALSE;        ++p;    }    return TRUE;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidrandomize(void *pv, size_t size){   static png_uint_32 random_seed[2] = {0x56789abc, 0xd};   make_random_bytes(random_seed, pv, size);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIpngtest_error(png_structp png_ptr, png_const_charp message){   pngtest_warning(png_ptr, message);   }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_noop(Pixel *out, const Pixel *in, const Background *back){   (void)back;   out->r = in->r;   out->g = in->g;   out->b = in->b;   out->a = in->a;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgama_modification_init(gama_modification *me, png_modifier *pm, double gammad){   double g;   modification_init(&me->this);   me->this.chunk = CHUNK_gAMA;   me->this.modify_fn = gama_modify;   me->this.add = CHUNK_PLTE;   g = fix(gammad);   me->gamma = (png_fixed_point)g;   me->this.next = pm->modifications;   pm->modifications = &me->this;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_image_check(PNG_CONST png_store* ps, png_const_structp pp, int iImage){   png_const_bytep image = ps->image;   if (image[-1] != 0xed || image[ps->cb_image] != 0xfe)      png_error(pp, \"image overwrite\");   else   {      png_size_t cbRow = ps->cb_row;      png_uint_32 rows = ps->image_h;      image += iImage * (cbRow+5) * ps->image_h;      image += 2;       while (rows-- > 0)      {         if (image[-2] != 190 || image[-1] != 239)            png_error(pp, \"row start overwritten\");         if (image[cbRow] != 222 || image[cbRow+1] != 173 ||            image[cbRow+2] != 17)            png_error(pp, \"row end overwritten\");         image += cbRow+5;      }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_write_reset(png_store *ps){   if (ps->pwrite != NULL)   {      anon_context(ps);      Try         png_destroy_write_struct(&ps->pwrite, &ps->piwrite);      Catch_anonymous      {               }      ps->pwrite = NULL;      ps->piwrite = NULL;   }   #  ifdef PNG_USER_MEM_SUPPORTED      store_pool_delete(ps, &ps->write_memory_pool);#  endif   store_freenew(ps);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_bckc(Pixel *out, const Pixel *in, const Background *back){   if (in->a <= 0)   {      out->r = back->ir;      out->g = back->ig;      out->b = back->ib;   }   else if (in->a >= 255)   {      out->r = in->r;      out->g = in->g;      out->b = in->b;   }   else   {      double a = in->a / 255.;      out->r = sRGB(sRGB_to_d[in->r] * a + back->dr * (1-a));      out->g = sRGB(sRGB_to_d[in->g] * a + back->dg * (1-a));      out->b = sRGB(sRGB_to_d[in->b] * a + back->db * (1-a));   }   out->a = 255;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIstore_error(png_structp ppIn, png_const_charp message) {   png_const_structp pp = ppIn;   png_store *ps = voidcast(png_store*, png_get_error_ptr(pp));   if (!ps->expect_error)      store_log(ps, pp, message, 1 );      {      struct exception_context *the_exception_context = &ps->exception_context;      Throw ps;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidinit_display(display *d, const char *program){   memset(d, 0, sizeof *d);   d->png_ptr = NULL;   d->info_ptr = d->end_ptr = NULL;   d->error_count = d->warning_count = 0;   d->program = program;   d->file = program;   d->test = init;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_16ilineara_g22(int fixed_srgb, int alpha){   return u16d((257 * alpha) * g22_to_d[fixed_srgb]);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_memory_free(png_const_structp pp, store_pool *pool, store_memory *memory){      if (memory->pool != pool)      store_pool_error(pool->store, pp, \"memory corrupted (pool)\");   else if (memcmp(memory->mark, pool->mark, sizeof memory->mark) != 0)      store_pool_error(pool->store, pp, \"memory corrupted (start)\");      else   {      png_alloc_size_t cb = memory->size;      if (cb > pool->max)         store_pool_error(pool->store, pp, \"memory corrupted (size)\");      else if (memcmp((png_bytep)(memory+1)+cb, pool->mark, sizeof pool->mark)         != 0)         store_pool_error(pool->store, pp, \"memory corrupted (end)\");            else         {         pool->current -= cb;         free(memory);         }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void rpng2_x_finish_display(void){    Trace((stderr, \"beginning rpng2_x_finish_display()\\n\"))        rpng2_info.state = kDone;    printf(      \"Done.  Press Q, Esc or mouse button 1 (within image window) to quit.\\n\");    fflush(stdout);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(void){   fprintf(stderr,      \"pngfix needs libpng with a zlib >=1.2.4 (not 0x%x)\\n\",      ZLIB_VERNUM);   return 77;}intmain(void){   fprintf(stderr, \"pngfix does not work without read support\\n\");   return 77;}intmain(void){   fprintf(stderr, \"pngfix does not work without setjmp support\\n\");   return 77;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidinsert_iCCP(png_structp png_ptr, png_infop info_ptr, int nparams,   png_charpp params){   png_bytep profile = NULL;   png_uint_32 proflen = 0;   int result;   check_param_count(nparams, 2);   switch (params[1][0])   {      case '<':         {            png_size_t filelen = load_file(params[1]+1, &profile);            if (filelen > 0xfffffffc)             {               fprintf(stderr, \"%s: file too long (%lu) for an ICC profile\\n\",                  params[1]+1, (unsigned long)filelen);               exit(1);            }            proflen = (png_uint_32)filelen;         }         break;      case '0': case '1': case '2': case '3': case '4':      case '5': case '6': case '7': case '8': case '9':         {            png_size_t fake_len = load_fake(params[1], &profile);            if (fake_len > 0)             {               if (fake_len > 0xffffffff)                {                  fprintf(stderr,                     \"%s: fake data too long (%lu) for an ICC profile\\n\",                     params[1], (unsigned long)fake_len);                  exit(1);               }               proflen = (png_uint_32)(fake_len & ~3U);                              png_save_uint_32(profile, proflen);               break;            }         }      default:         fprintf(stderr, \"--insert iCCP \\\"%s\\\": unrecognized\\n\", params[1]);         fprintf(stderr, \"  use '<' to read a file: \\\"<filename\\\"\\n\");         exit(1);   }   result = 1;   if (proflen & 3)   {      fprintf(stderr,         \"makepng: --insert iCCP %s: profile length made a multiple of 4\\n\",         params[1]);            while (proflen & 3)         profile[proflen++] = 0;   }   if (profile != NULL && proflen > 3)   {      png_uint_32 prof_header = png_get_uint_32(profile);      if (prof_header != proflen)      {         fprintf(stderr, \"--insert iCCP %s: profile length field wrong:\\n\",            params[1]);         fprintf(stderr, \"  actual %lu, recorded value %lu (corrected)\\n\",            (unsigned long)proflen, (unsigned long)prof_header);         png_save_uint_32(profile, proflen);      }   }   if (result && profile != NULL && proflen >=4)      png_set_iCCP(png_ptr, info_ptr, params[0], PNG_COMPRESSION_TYPE_BASE,         profile, proflen);   if (profile)      free(profile);   if (!result)      exit(1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void png_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp    error_message){   int iout = 0, iin = 0;   while (iin < 4)   {      int c = png_ptr->chunk_name[iin++];      if (isnonalpha(c))      {         buffer[iout++] = PNG_LITERAL_LEFT_SQUARE_BRACKET;         buffer[iout++] = png_digit[(c & 0xf0) >> 4];         buffer[iout++] = png_digit[c & 0x0f];         buffer[iout++] = PNG_LITERAL_RIGHT_SQUARE_BRACKET;      }      else      {         buffer[iout++] = (png_byte)c;      }   }   if (error_message == NULL)      buffer[iout] = '\\0';   else   {      buffer[iout++] = ':';      buffer[iout++] = ' ';      png_memcpy(buffer + iout, error_message, PNG_MAX_ERROR_TEXT);      buffer[iout + PNG_MAX_ERROR_TEXT - 1] = '\\0';   }}#endif ",
        "label": 1,
        "cve": "cve-2011-2501"
    },
    {
        "code": "#else int main(void){   fprintf(stderr, \"pngstest: no read support in libpng, test skipped\\n\");      return 77;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static doublegamma_component_validate(PNG_CONST char *name, PNG_CONST validate_info *vi,    PNG_CONST unsigned int id, PNG_CONST unsigned int od,    PNG_CONST double alpha ,    PNG_CONST double background ){   PNG_CONST unsigned int isbit = id >> vi->isbit_shift;   PNG_CONST unsigned int sbit_max = vi->sbit_max;   PNG_CONST unsigned int outmax = vi->outmax;   PNG_CONST int do_background = vi->do_background;   double i;      i = isbit; i /= sbit_max;      if (alpha == 1  || !do_background#ifdef PNG_READ_ALPHA_MODE_SUPPORTED      || do_background == ALPHA_MODE_OFFSET + PNG_ALPHA_PNG#endif      || (alpha < 0 #ifdef PNG_READ_ALPHA_MODE_SUPPORTED      && do_background != ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN#endif      ))   {            double encoded_sample = i;      double encoded_error;            if (alpha >= 0 && vi->gamma_correction > 0)         encoded_sample = pow(encoded_sample, vi->gamma_correction);      encoded_sample *= outmax;      encoded_error = fabs(od-encoded_sample);      if (encoded_error > vi->dp->maxerrout)         vi->dp->maxerrout = encoded_error;      if (encoded_error < vi->maxout_total && encoded_error < vi->outlog)         return i;   }         {      double input_sample = i;       double output, error, encoded_sample, encoded_error;      double es_lo, es_hi;      int compose = 0;                 int output_is_encoded;           int log_max_error = 1;           png_const_charp pass = 0;              if (alpha >= 0)      {         int tcompose;         if (vi->file_inverse > 0)            input_sample = pow(input_sample, vi->file_inverse);                  tcompose = 0;         input_sample = gamma_component_compose(do_background, input_sample,            alpha, background, &tcompose);         if (tcompose)            compose = 1;      }            output = od;      output /= outmax;      output_is_encoded = vi->screen_gamma > 0;      if (alpha < 0)       {#ifdef PNG_READ_ALPHA_MODE_SUPPORTED         if (do_background != ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN)#endif         {                        output_is_encoded = 0;            log_max_error = 0;         }      }#ifdef PNG_READ_ALPHA_MODE_SUPPORTED      else       {         if (do_background == ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED &&            alpha < 1)          {            if (alpha > 0) log_max_error = 0;            output_is_encoded = 0;         }      }#endif      if (output_is_encoded)         output = pow(output, vi->screen_gamma);            encoded_sample = input_sample;      if (output_is_encoded)         encoded_sample = pow(encoded_sample, vi->screen_inverse);      encoded_sample *= outmax;      encoded_error = fabs(od-encoded_sample);            if (log_max_error && encoded_error > vi->dp->maxerrout)         vi->dp->maxerrout = encoded_error;      if (encoded_error < vi->maxout_total)      {         if (encoded_error < vi->outlog)            return i;                  pass = \"less than maxout:\\n\";      }                  error = fabs(input_sample-output);      if (log_max_error && error > vi->dp->maxerrabs)         vi->dp->maxerrabs = error;            if (log_max_error && input_sample > .5)      {         double percentage_error = error/input_sample;         if (percentage_error > vi->dp->maxerrpc)            vi->dp->maxerrpc = percentage_error;      }            {         double tmp = input_sample * vi->maxpc;         if (tmp < vi->maxabs) tmp = vi->maxabs;                  if (compose && tmp < vi->maxcalc) tmp = vi->maxcalc;                  es_lo = encoded_sample - vi->maxout;         if (es_lo > 0 && input_sample-tmp > 0)         {            double low_value = input_sample-tmp;            if (output_is_encoded)               low_value = pow(low_value, vi->screen_inverse);            low_value *= outmax;            if (low_value < es_lo) es_lo = low_value;                        es_lo = ceil(es_lo / vi->outquant - .5) * vi->outquant;         }         else            es_lo = 0;         es_hi = encoded_sample + vi->maxout;         if (es_hi < outmax && input_sample+tmp < 1)         {            double high_value = input_sample+tmp;            if (output_is_encoded)               high_value = pow(high_value, vi->screen_inverse);            high_value *= outmax;            if (high_value > es_hi) es_hi = high_value;            es_hi = floor(es_hi / vi->outquant + .5) * vi->outquant;         }         else            es_hi = outmax;      }            if (od >= es_lo && od <= es_hi)      {                  if (encoded_error < vi->outlog)            return i;         if (pass == 0)            pass = \"within digitization limits:\\n\";      }      {                  double is_lo, is_hi;                  if (pass == 0 && vi->use_input_precision && vi->dp->sbit)         {            #           if PNG_LIBPNG_VER < 10700#              define SBIT_ERROR .5#           else#              define SBIT_ERROR 1.#           endif            double tmp = (isbit - SBIT_ERROR)/sbit_max;            if (tmp <= 0)               tmp = 0;            else if (alpha >= 0 && vi->file_inverse > 0 && tmp < 1)               tmp = pow(tmp, vi->file_inverse);            tmp = gamma_component_compose(do_background, tmp, alpha, background,               NULL);            if (output_is_encoded && tmp > 0 && tmp < 1)               tmp = pow(tmp, vi->screen_inverse);            is_lo = ceil(outmax * tmp - vi->maxout_total);            if (is_lo < 0)               is_lo = 0;            tmp = (isbit + SBIT_ERROR)/sbit_max;            if (tmp >= 1)               tmp = 1;            else if (alpha >= 0 && vi->file_inverse > 0 && tmp < 1)               tmp = pow(tmp, vi->file_inverse);            tmp = gamma_component_compose(do_background, tmp, alpha, background,               NULL);            if (output_is_encoded && tmp > 0 && tmp < 1)               tmp = pow(tmp, vi->screen_inverse);            is_hi = floor(outmax * tmp + vi->maxout_total);            if (is_hi > outmax)               is_hi = outmax;            if (!(od < is_lo || od > is_hi))            {               if (encoded_error < vi->outlog)                  return i;               pass = \"within input precision limits:\\n\";            }            #           ifndef PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED#              if PNG_LIBPNG_VER < 10504                                    if (pass == 0 && alpha < 0 && vi->scale16 && vi->sbit > 8 &&                     vi->sbit + vi->isbit_shift == 16)                  {                     tmp = ((id >> 8) - .5)/255;                     if (tmp > 0)                     {                        is_lo = ceil(outmax * tmp - vi->maxout_total);                        if (is_lo < 0) is_lo = 0;                     }                     else                        is_lo = 0;                     tmp = ((id >> 8) + .5)/255;                     if (tmp < 1)                     {                        is_hi = floor(outmax * tmp + vi->maxout_total);                        if (is_hi > outmax) is_hi = outmax;                     }                     else                        is_hi = outmax;                     if (!(od < is_lo || od > is_hi))                     {                        if (encoded_error < vi->outlog)                           return i;                        pass = \"within 8 bit limits:\\n\";                     }                  }#              endif#           endif         }         else             is_lo = es_lo, is_hi = es_hi;                  {            size_t pos = 0;                        int precision = (outmax >= 1000 ? 6 : 3);            int use_input=1, use_background=0, do_compose=0;            char msg[256];            if (pass != 0)               pos = safecat(msg, sizeof msg, pos, \"\\n\\t\");                        switch (do_background)            {#           ifdef PNG_READ_BACKGROUND_SUPPORTED               case PNG_BACKGROUND_GAMMA_SCREEN:               case PNG_BACKGROUND_GAMMA_FILE:               case PNG_BACKGROUND_GAMMA_UNIQUE:                  use_background = (alpha >= 0 && alpha < 1);                  #           endif#           ifdef PNG_READ_ALPHA_MODE_SUPPORTED               case ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD:               case ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN:               case ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED:#           endif                do_compose = (alpha > 0 && alpha < 1);               use_input = (alpha != 0);               break;            default:               break;            }                        if (compose != do_compose)               png_error(vi->pp, \"internal error (compose)\");                        pos = safecat(msg, sizeof msg, pos, name);            pos = safecat(msg, sizeof msg, pos, \"(\");            pos = safecatn(msg, sizeof msg, pos, id);            if (use_input || pass != 0)            {               if (isbit != id)               {                                    pos = safecat(msg, sizeof msg, pos, \", sbit(\");                  pos = safecatn(msg, sizeof msg, pos, vi->sbit);                  pos = safecat(msg, sizeof msg, pos, \"): \");                  pos = safecatn(msg, sizeof msg, pos, isbit);               }               pos = safecat(msg, sizeof msg, pos, \"/\");                              pos = safecatn(msg, sizeof msg, pos, vi->sbit_max);            }            pos = safecat(msg, sizeof msg, pos, \")\");                        if (compose || pass != 0)            {                              if (use_input || pass != 0)               {                  if (vi->file_inverse > 0)                  {                     pos = safecat(msg, sizeof msg, pos, \"^\");                     pos = safecatd(msg, sizeof msg, pos, vi->file_inverse, 2);                  }                  else                     pos = safecat(msg, sizeof msg, pos, \"[linear]\");                  pos = safecat(msg, sizeof msg, pos, \"*(alpha)\");                  pos = safecatd(msg, sizeof msg, pos, alpha, precision);               }                              if (use_background)               {                  pos = safecat(msg, sizeof msg, pos, use_input ? \"+\" : \" \");                  pos = safecat(msg, sizeof msg, pos, \"(background)\");                  pos = safecatd(msg, sizeof msg, pos, background, precision);                  pos = safecat(msg, sizeof msg, pos, \"*\");                  pos = safecatd(msg, sizeof msg, pos, 1-alpha, precision);               }            }                        if (compose || alpha < 0 || pass != 0)            {               pos = safecat(msg, sizeof msg, pos,                  pass != 0 ? \" =\\n\\t\" : \" = \");               pos = safecatd(msg, sizeof msg, pos, input_sample, precision);               pos = safecat(msg, sizeof msg, pos, \" (libpng: \");               pos = safecatd(msg, sizeof msg, pos, output, precision);               pos = safecat(msg, sizeof msg, pos, \")\");                              if (output_is_encoded)               {                  pos = safecat(msg, sizeof msg, pos, \" ^\");                  pos = safecatd(msg, sizeof msg, pos, vi->screen_inverse, 2);                  pos = safecat(msg, sizeof msg, pos, \"(to screen) =\");               }               else                  pos = safecat(msg, sizeof msg, pos, \" [screen is linear] =\");            }            if ((!compose && alpha >= 0) || pass != 0)            {               if (pass != 0)                   pos = safecat(msg, sizeof msg, pos, \"\\n\\t[overall:\");                              if (vi->gamma_correction > 0)               {                  pos = safecat(msg, sizeof msg, pos, \" ^\");                  pos = safecatd(msg, sizeof msg, pos, vi->gamma_correction, 2);                  pos = safecat(msg, sizeof msg, pos, \"(gamma correction) =\");               }               else                  pos = safecat(msg, sizeof msg, pos,                     \" [no gamma correction] =\");               if (pass != 0)                  pos = safecat(msg, sizeof msg, pos, \"]\");            }                        pos = safecat(msg, sizeof msg, pos, pass != 0 ? \"\\n\\t\" : \" \");            pos = safecatd(msg, sizeof msg, pos, is_lo, 1);            pos = safecat(msg, sizeof msg, pos, \" < \");            pos = safecatd(msg, sizeof msg, pos, encoded_sample, 1);            pos = safecat(msg, sizeof msg, pos, \" (libpng: \");            pos = safecatn(msg, sizeof msg, pos, od);            pos = safecat(msg, sizeof msg, pos, \")\");            pos = safecat(msg, sizeof msg, pos, \"/\");            pos = safecatn(msg, sizeof msg, pos, outmax);            pos = safecat(msg, sizeof msg, pos, \" < \");            pos = safecatd(msg, sizeof msg, pos, is_hi, 1);            if (pass == 0)             {#              ifdef PNG_WARNINGS_SUPPORTED                  png_warning(vi->pp, msg);#              else                  store_warning(vi->pp, msg);#              endif            }            else                store_verbose(&vi->dp->pm->this, vi->pp, pass, msg);         }      }   }   return i;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidinternal_error(png_store *ps, png_const_charp message){   store_log(ps, NULL, message, 1 );      {      struct exception_context *the_exception_context = &ps->exception_context;      Throw ps;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam,        LPARAM lParam){    static HINSTANCE          hInstance ;    static HDC                hdc;    static PAINTSTRUCT        ps;    static HMENU              hMenu;    static BITMAPFILEHEADER  *pbmfh;    static BITMAPINFOHEADER  *pbmih;    static BYTE              *pbImage;    static int                cxWinSize, cyWinSize;    static int                cxImgSize, cyImgSize;    static int                cImgChannels;    static png_color          bkgColor = {127, 127, 127};    static BOOL               bStretched = TRUE;    static BYTE              *pDib = NULL;    static BYTE              *pDiData = NULL;    static TCHAR              szImgPathName [MAX_PATH];    static TCHAR              szTitleName [MAX_PATH];    static TCHAR             *pPngFileList = NULL;    static int                iPngFileCount;    static int                iPngFileIndex;    BOOL                      bOk;    switch (message)    {    case WM_CREATE:        hInstance = ((LPCREATESTRUCT) lParam)->hInstance ;        PngFileInitialize (hwnd);        strcpy (szImgPathName, \"\");                if (szCmdFileName[0] != '\\0')        {            strcpy (szImgPathName, szCmdFileName);                                    BuildPngList (szImgPathName, &pPngFileList, &iPngFileCount,                          &iPngFileIndex);                        if (!LoadImageFile (hwnd, szImgPathName,                &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))                return 0;                        InvalidateRect (hwnd, NULL, TRUE);                        DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,                pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);        }        return 0;    case WM_SIZE:        cxWinSize = LOWORD (lParam);        cyWinSize = HIWORD (lParam);                InvalidateRect (hwnd, NULL, TRUE);                DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,            pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);        return 0;    case WM_INITMENUPOPUP:        hMenu = GetMenu (hwnd);        if (pbImage)            EnableMenuItem (hMenu, IDM_FILE_SAVE, MF_ENABLED);        else            EnableMenuItem (hMenu, IDM_FILE_SAVE, MF_GRAYED);        return 0;    case WM_COMMAND:        hMenu = GetMenu (hwnd);        switch (LOWORD (wParam))        {        case IDM_FILE_OPEN:                        if (!PngFileOpenDlg (hwnd, szImgPathName, szTitleName))                return 0;                                    BuildPngList (szImgPathName, &pPngFileList, &iPngFileCount,                          &iPngFileIndex);                        if (!LoadImageFile (hwnd, szImgPathName,                &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))                return 0;                        InvalidateRect (hwnd, NULL, TRUE);                        DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,                pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);            return 0;        case IDM_FILE_SAVE:                        if (!PngFileSaveDlg (hwnd, szImgPathName, szTitleName))                return 0;                        SetCursor (LoadCursor (NULL, IDC_WAIT));            ShowCursor (TRUE);            bOk = PngSaveImage (szImgPathName, pDiData, cxWinSize, cyWinSize,                  bkgColor);            ShowCursor (FALSE);            SetCursor (LoadCursor (NULL, IDC_ARROW));            if (!bOk)                MessageBox (hwnd, TEXT (\"Error in saving the PNG image\"),                szProgName, MB_ICONEXCLAMATION | MB_OK);            return 0;        case IDM_FILE_NEXT:                        if (SearchPngList (pPngFileList, iPngFileCount, &iPngFileIndex,                NULL, szImgPathName))            {                if (strcmp (szImgPathName, \"\") == 0)                    return 0;                                if (!LoadImageFile (hwnd, szImgPathName, &pbImage,                        &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))                    return 0;                                InvalidateRect (hwnd, NULL, TRUE);                                DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,                    pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);            }            return 0;        case IDM_FILE_PREVIOUS:                        if (SearchPngList (pPngFileList, iPngFileCount, &iPngFileIndex,                szImgPathName, NULL))            {                if (strcmp (szImgPathName, \"\") == 0)                    return 0;                                if (!LoadImageFile (hwnd, szImgPathName, &pbImage, &cxImgSize,                    &cyImgSize, &cImgChannels, &bkgColor))                    return 0;                                InvalidateRect (hwnd, NULL, TRUE);                                DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,                    pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);            }            return 0;        case IDM_FILE_EXIT:                                    if (pDib != NULL)            {                free (pDib);                pDib = NULL;            }                        if (pPngFileList != NULL)            {                free (pPngFileList);                pPngFileList = NULL;            }                        exit (0);            return 0;        case IDM_OPTIONS_STRETCH:            bStretched = !bStretched;            if (bStretched)                CheckMenuItem (hMenu, IDM_OPTIONS_STRETCH, MF_CHECKED);            else                CheckMenuItem (hMenu, IDM_OPTIONS_STRETCH, MF_UNCHECKED);                        InvalidateRect (hwnd, NULL, TRUE);                        DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,                pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);            return 0;        case IDM_HELP_ABOUT:            DialogBox (hInstance, TEXT (\"AboutBox\"), hwnd, AboutDlgProc) ;            return 0;        }         break;    case WM_PAINT:        hdc = BeginPaint (hwnd, &ps);        if (pDib)            SetDIBitsToDevice (hdc, 0, 0, cxWinSize, cyWinSize, 0, 0,                0, cyWinSize, pDiData, (BITMAPINFO *) pDib, DIB_RGB_COLORS);        EndPaint (hwnd, &ps);        return 0;    case WM_DESTROY:        if (pbmfh)        {            free (pbmfh);            pbmfh = NULL;        }        PostQuitMessage (0);        return 0;    }    return DefWindowProc (hwnd, message, wParam, lParam);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidfreeimage(Image *image){   freebuffer(image);   png_image_free(&image->image);   if (image->input_file != NULL)   {      fclose(image->input_file);      image->input_file = NULL;   }   if (image->input_memory != NULL)   {      free(image->input_memory);      image->input_memory = NULL;      image->input_memory_size = 0;   }   if (image->tmpfile_name[0] != 0 && (image->opts & KEEP_TMPFILES) == 0)   {      remove(image->tmpfile_name);      image->tmpfile_name[0] = 0;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidperform_one_test_safe(FILE *fp, int argc, const char **argv,   png_uint_32 *default_flags, display *d, const char *test){   if (setjmp(d->error_return) == 0)   {      d->test = test; #     ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED         perform_one_test(fp, argc, argv, default_flags, d, 0);#     endif#     ifdef PNG_READ_USER_CHUNKS_SUPPORTED         perform_one_test(fp, argc, argv, default_flags, d, 1);#     endif      d->test = init;    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static size_tsafecat_current_encoding(char *buffer, size_t bufsize, size_t pos,   PNG_CONST png_modifier *pm){   pos = safecat_color_encoding(buffer, bufsize, pos, pm->current_encoding,      pm->current_gamma);   if (pm->encoding_ignored)      pos = safecat(buffer, bufsize, pos, \"[overridden]\");   return pos;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "uch *readpng_get_image(double display_exponent, int *pChannels, ulg *pRowbytes){    double  gamma;    png_uint_32  i, rowbytes;    png_bytepp  row_pointers = NULL;        if (setjmp(png_jmpbuf(png_ptr))) {        free(image_data);        image_data = NULL;        free(row_pointers);        row_pointers = NULL;        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);        return NULL;    }        if (color_type == PNG_COLOR_TYPE_PALETTE)        png_set_expand(png_ptr);    if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)        png_set_expand(png_ptr);    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))        png_set_expand(png_ptr);#ifdef PNG_READ_16_TO_8_SUPPORTED    if (bit_depth == 16)#  ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED        png_set_scale_16(png_ptr);#  else        png_set_strip_16(png_ptr);#  endif#endif    if (color_type == PNG_COLOR_TYPE_GRAY ||        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)        png_set_gray_to_rgb(png_ptr);        if (png_get_gAMA(png_ptr, info_ptr, &gamma))        png_set_gamma(png_ptr, display_exponent, gamma);        png_read_update_info(png_ptr, info_ptr);    *pRowbytes = rowbytes = png_get_rowbytes(png_ptr, info_ptr);    *pChannels = (int)png_get_channels(png_ptr, info_ptr);    if ((image_data = (uch *)malloc(rowbytes*height)) == NULL) {        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);        return NULL;    }    if ((row_pointers = (png_bytepp)malloc(height*sizeof(png_bytep))) == NULL) {        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);        free(image_data);        image_data = NULL;        return NULL;    }    Trace((stderr, \"readpng_get_image:  channels = %d, rowbytes = %ld, height = %ld\\n\",        *pChannels, rowbytes, height));        for (i = 0;  i < height;  ++i)        row_pointers[i] = image_data + i*rowbytes;        png_read_image(png_ptr, row_pointers);        free(row_pointers);    row_pointers = NULL;    png_read_end(png_ptr, NULL);    return image_data;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_ensure_image(png_store *ps, png_const_structp pp, int nImages,   png_size_t cbRow, png_uint_32 cRows){   png_size_t cb = nImages * cRows * (cbRow + 5);   if (ps->cb_image < cb)   {      png_bytep image;      store_image_free(ps, pp);            image = voidcast(png_bytep, malloc(cb+2));      if (image == NULL)      {                  if (pp == NULL)            return;         png_error(pp, \"OOM allocating image buffer\");      }            ++image;      image[-1] = 0xed;      image[cb] = 0xfe;      ps->image = image;      ps->cb_image = cb;   }      ps->cb_row = cbRow;   ps->image_h = cRows;      memset(ps->image, 178, cb);      while (--nImages >= 0)   {      png_uint_32 y;      for (y=0; y<cRows; ++y)      {         png_bytep row = store_image_row(ps, pp, nImages, y);                  row[-2] = 190;         row[-1] = 239;         row[cbRow] = 222;         row[cbRow+1] = 173;         row[cbRow+2] = 17;      }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidsequential_row(standard_display *dp, png_structp pp, png_infop pi,    PNG_CONST int iImage, PNG_CONST int iDisplay){   PNG_CONST int         npasses = dp->npasses;   PNG_CONST int         do_interlace = dp->do_interlace &&      dp->interlace_type == PNG_INTERLACE_ADAM7;   PNG_CONST png_uint_32 height = standard_height(pp, dp->id);   PNG_CONST png_uint_32 width = standard_width(pp, dp->id);   PNG_CONST png_store*  ps = dp->ps;   int pass;   for (pass=0; pass<npasses; ++pass)   {      png_uint_32 y;      png_uint_32 wPass = PNG_PASS_COLS(width, pass);      for (y=0; y<height; ++y)      {         if (do_interlace)         {                        if (wPass > 0 && PNG_ROW_IN_INTERLACE_PASS(y, pass))            {                              png_byte row[STANDARD_ROWMAX], display[STANDARD_ROWMAX];                              memset(row, 0xc5, sizeof row);               memset(display, 0x5c, sizeof display);               png_read_row(pp, row, display);               if (iImage >= 0)                  deinterlace_row(store_image_row(ps, pp, iImage, y), row,                     dp->pixel_size, dp->w, pass);               if (iDisplay >= 0)                  deinterlace_row(store_image_row(ps, pp, iDisplay, y), display,                     dp->pixel_size, dp->w, pass);            }         }         else            png_read_row(pp,               iImage >= 0 ? store_image_row(ps, pp, iImage, y) : NULL,               iDisplay >= 0 ? store_image_row(ps, pp, iDisplay, y) : NULL);      }   }      png_read_end(pp, pi);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmodifier_current_encoding(PNG_CONST png_modifier *pm, color_encoding *ce){   if (pm->current_encoding != 0)      *ce = *pm->current_encoding;   else      memset(ce, 0, sizeof *ce);   ce->gamma = pm->current_gamma;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int rpng2_x_create_window(void){    ulg bg_red   = rpng2_info.bg_red;    ulg bg_green = rpng2_info.bg_green;    ulg bg_blue  = rpng2_info.bg_blue;    ulg bg_pixel = 0L;    ulg attrmask;    int need_colormap = FALSE;    int screen, pad;    uch *xdata;    Window root;    XEvent e;    XGCValues gcvalues;    XSetWindowAttributes attr;    XTextProperty windowName, *pWindowName = &windowName;    XTextProperty iconName, *pIconName = &iconName;    XVisualInfo visual_info;    XSizeHints *size_hints;    XWMHints *wm_hints;    XClassHint *class_hints;    Trace((stderr, \"beginning rpng2_x_create_window()\\n\"))    screen = DefaultScreen(display);    depth = DisplayPlanes(display, screen);    root = RootWindow(display, screen);#ifdef DEBUG    XSynchronize(display, True);#endif    if (depth != 16 && depth != 24 && depth != 32) {        int visuals_matched = 0;        Trace((stderr, \"default depth is %d:  checking other visuals\\n\",          depth))                visual_info.screen = screen;        visual_info.depth = 24;        visual_list = XGetVisualInfo(display,          VisualScreenMask | VisualDepthMask, &visual_info, &visuals_matched);        if (visuals_matched == 0) {            fprintf(stderr, \"default screen depth %d not supported, and no\"              \" 24-bit visuals found\\n\", depth);            return 2;        }        Trace((stderr, \"XGetVisualInfo() returned %d 24-bit visuals\\n\",          visuals_matched))        visual = visual_list[0].visual;        depth = visual_list[0].depth;        have_nondefault_visual = TRUE;        need_colormap = TRUE;    } else {        XMatchVisualInfo(display, screen, depth, TrueColor, &visual_info);        visual = visual_info.visual;    }    RMask = visual->red_mask;    GMask = visual->green_mask;    BMask = visual->blue_mask;    if (depth == 8 || need_colormap) {        colormap = XCreateColormap(display, root, visual, AllocNone);        if (!colormap) {            fprintf(stderr, \"XCreateColormap() failed\\n\");            return 2;        }        have_colormap = TRUE;        if (depth == 8)            bg_image = FALSE;       }    if (depth == 15 || depth == 16) {        RShift = 15 - rpng2_x_msb(RMask);            GShift = 15 - rpng2_x_msb(GMask);        BShift = 15 - rpng2_x_msb(BMask);    } else if (depth > 16) {        RShift = rpng2_x_msb(RMask) - 7;             GShift = rpng2_x_msb(GMask) - 7;        BShift = rpng2_x_msb(BMask) - 7;    }    if (depth >= 15 && (RShift < 0 || GShift < 0 || BShift < 0)) {        fprintf(stderr, \"rpng2 internal logic error:  negative X shift(s)!\\n\");        return 2;    }    attr.backing_store = Always;    attr.event_mask = ExposureMask | KeyPressMask | ButtonPressMask;    attrmask = CWBackingStore | CWEventMask;    if (have_nondefault_visual) {        attr.colormap = colormap;        attr.background_pixel = 0;        attr.border_pixel = 1;        attrmask |= CWColormap | CWBackPixel | CWBorderPixel;    }    window = XCreateWindow(display, root, 0, 0, rpng2_info.width,      rpng2_info.height, 0, depth, InputOutput, visual, attrmask, &attr);    if (window == None) {        fprintf(stderr, \"XCreateWindow() failed\\n\");        return 2;    } else        have_window = TRUE;    if (depth == 8)        XSetWindowColormap(display, window, colormap);    if (!XStringListToTextProperty(&window_name, 1, pWindowName))        pWindowName = NULL;    if (!XStringListToTextProperty(&icon_name, 1, pIconName))        pIconName = NULL;        if ((size_hints = XAllocSizeHints()) != NULL) {                size_hints->flags = PMinSize | PMaxSize;        size_hints->min_width = size_hints->max_width = (int)rpng2_info.width;        size_hints->min_height = size_hints->max_height =          (int)rpng2_info.height;    }    if ((wm_hints = XAllocWMHints()) != NULL) {        wm_hints->initial_state = NormalState;        wm_hints->input = True;             wm_hints->flags = StateHint | InputHint   ;    }    if ((class_hints = XAllocClassHint()) != NULL) {        class_hints->res_name = res_name;        class_hints->res_class = res_class;    }    XSetWMProperties(display, window, pWindowName, pIconName, NULL, 0,      size_hints, wm_hints, class_hints);        if (pWindowName)       XFree(pWindowName->value);    if (pIconName)       XFree(pIconName->value);    if (size_hints)        XFree(size_hints);    if (wm_hints)       XFree(wm_hints);    if (class_hints)       XFree(class_hints);    XMapWindow(display, window);    gc = XCreateGC(display, window, 0, &gcvalues);    have_gc = TRUE;    if (depth == 24 || depth == 32) {        xdata = (uch *)malloc(4*rpng2_info.width*rpng2_info.height);        pad = 32;    } else if (depth == 16) {        xdata = (uch *)malloc(2*rpng2_info.width*rpng2_info.height);        pad = 16;    } else  {        xdata = (uch *)malloc(rpng2_info.width*rpng2_info.height);        pad = 8;    }    if (!xdata) {        fprintf(stderr, PROGNAME \":  unable to allocate image memory\\n\");        return 4;    }    ximage = XCreateImage(display, visual, depth, ZPixmap, 0,      (char *)xdata, rpng2_info.width, rpng2_info.height, pad, 0);    if (!ximage) {        fprintf(stderr, PROGNAME \":  XCreateImage() failed\\n\");        free(xdata);        return 3;    }        ximage->byte_order = MSBFirst;    if (bg_image)        rpng2_x_load_bg_image();        if (!bg_image) {        if (depth == 24 || depth == 32) {            bg_pixel = (bg_red   << RShift) |                       (bg_green << GShift) |                       (bg_blue  << BShift);        } else if (depth == 16) {            bg_pixel = (((bg_red   << 8) >> RShift) & RMask) |                       (((bg_green << 8) >> GShift) & GMask) |                       (((bg_blue  << 8) >> BShift) & BMask);        } else  {                    }        XSetForeground(display, gc, bg_pixel);        XFillRectangle(display, window, gc, 0, 0, rpng2_info.width,          rpng2_info.height);    }    do        XNextEvent(display, &e);    while (e.type != Expose || e.xexpose.count);    XFlush(display);    return 0;} ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_do_expand_palette(png_row_infop row_info, png_bytep row,   png_const_colorp palette, png_const_bytep trans_alpha, int num_trans){   int shift, value;   png_bytep sp, dp;   png_uint_32 i;   png_uint_32 row_width=row_info->width;   png_debug(1, \"in png_do_expand_palette\");   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)   {      if (row_info->bit_depth < 8)      {         switch (row_info->bit_depth)         {            case 1:            {               sp = row + (png_size_t)((row_width - 1) >> 3);               dp = row + (png_size_t)row_width - 1;               shift = 7 - (int)((row_width + 7) & 0x07);               for (i = 0; i < row_width; i++)               {                  if ((*sp >> shift) & 0x01)                     *dp = 1;                  else                     *dp = 0;                  if (shift == 7)                  {                     shift = 0;                     sp--;                  }                  else                     shift++;                  dp--;               }               break;            }            case 2:            {               sp = row + (png_size_t)((row_width - 1) >> 2);               dp = row + (png_size_t)row_width - 1;               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);               for (i = 0; i < row_width; i++)               {                  value = (*sp >> shift) & 0x03;                  *dp = (png_byte)value;                  if (shift == 6)                  {                     shift = 0;                     sp--;                  }                  else                     shift += 2;                  dp--;               }               break;            }            case 4:            {               sp = row + (png_size_t)((row_width - 1) >> 1);               dp = row + (png_size_t)row_width - 1;               shift = (int)((row_width & 0x01) << 2);               for (i = 0; i < row_width; i++)               {                  value = (*sp >> shift) & 0x0f;                  *dp = (png_byte)value;                  if (shift == 4)                  {                     shift = 0;                     sp--;                  }                  else                     shift += 4;                  dp--;               }               break;            }            default:               break;         }         row_info->bit_depth = 8;         row_info->pixel_depth = 8;         row_info->rowbytes = row_width;      }      if (row_info->bit_depth == 8)      {         {            if (num_trans > 0)            {               sp = row + (png_size_t)row_width - 1;               dp = row + (png_size_t)(row_width << 2) - 1;               for (i = 0; i < row_width; i++)               {                  if ((int)(*sp) >= num_trans)                     *dp-- = 0xff;                  else                     *dp-- = trans_alpha[*sp];                  *dp-- = palette[*sp].blue;                  *dp-- = palette[*sp].green;                  *dp-- = palette[*sp].red;                  sp--;               }               row_info->bit_depth = 8;               row_info->pixel_depth = 32;               row_info->rowbytes = row_width * 4;               row_info->color_type = 6;               row_info->channels = 4;            }            else            {               sp = row + (png_size_t)row_width - 1;               dp = row + (png_size_t)(row_width * 3) - 1;               for (i = 0; i < row_width; i++)               {                  *dp-- = palette[*sp].blue;                  *dp-- = palette[*sp].green;                  *dp-- = palette[*sp].red;                  sp--;               }               row_info->bit_depth = 8;               row_info->pixel_depth = 24;               row_info->rowbytes = row_width * 3;               row_info->color_type = 2;               row_info->channels = 3;            }         }      }   }}",
        "label": 1,
        "cve": "cve-2013-6954"
    },
    {
        "code": "static voidgp_ga8(Pixel *p, png_const_voidp pb){   png_const_bytep pp = voidcast(png_const_bytep, pb);   p->r = p->g = p->b = pp[0];   p->a = pp[1];}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int readpng_init(FILE *infile, ulg *pWidth, ulg *pHeight){    static uch ppmline[256];    int maxval;    saved_infile = infile;    fgets(ppmline, 256, infile);    if (ppmline[0] != 'P' || ppmline[1] != '6') {        fprintf(stderr, \"ERROR:  not a PPM file\\n\");        return 1;    }        if (ppmline[1] == '6') {        color_type = 2;        channels = 3;    } else if (ppmline[1] == '8') {        color_type = 6;        channels = 4;    } else  {        color_type = 0;        channels = 1;    }    do {        fgets(ppmline, 256, infile);    } while (ppmline[0] == '#');    sscanf(ppmline, \"%lu %lu\", &width, &height);    do {        fgets(ppmline, 256, infile);    } while (ppmline[0] == '#');    sscanf(ppmline, \"%d\", &maxval);    if (maxval != 255) {        fprintf(stderr, \"ERROR:  maxval = %d\\n\", maxval);        return 2;    }    bit_depth = 8;    *pWidth = width;    *pHeight = height;    return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intprocess_iTXt(struct file *file){      struct chunk *chunk = file->chunk;   png_uint_32 length;   png_uint_32 index = 0;   assert(chunk != NULL && file->idat == NULL);   length = chunk->chunk_length;   setpos(chunk);   while (length >= 5)   {      --length;      ++index;      if (reread_byte(file) == 0)       {         --length;         ++index;         if (reread_byte(file) == 0)             return 1;          --length;         ++index;         (void)reread_byte(file);                   while (length >= 9)         {            --length;            ++index;            if (reread_byte(file) == 0)             {                              while (length >= 8)               {                  --length;                  ++index;                  if (reread_byte(file) == 0)                      return zlib_check(file, index);               }            }         }                  break;      }   }   log_error(file, INVALID_ERROR_CODE, \"iTXt chunk length\");   return 0; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcheckbuffer(Image *image, const char *arg){   if (check16(image->buffer, 95))   {      fflush(stdout);      fprintf(stderr, \"%s: overwrite at start of image buffer\\n\", arg);      exit(1);   }   if (check16(image->buffer+16+image->allocsize, 95))   {      fflush(stdout);      fprintf(stderr, \"%s: overwrite at end of image buffer\\n\", arg);      exit(1);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_expand_mod(PNG_CONST image_transform *this,    image_pixel *that, png_const_structp pp,    PNG_CONST transform_display *display){      if (that->colour_type == PNG_COLOR_TYPE_PALETTE)      image_pixel_convert_PLTE(that);   else if (that->bit_depth < 8)       that->sample_depth = that->bit_depth = 8;   if (that->have_tRNS)      image_pixel_add_alpha(that, &display->this);   this->next->mod(this->next, that, pp, display);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intread_byte(struct file *file){   int ch = getc(file->file);   if (ch >= 0 && ch <= 255)   {      ++(file->read_count);      return ch;   }   else if (ch != EOF)   {      file->status_code |= INTERNAL_ERROR;      file->read_errno = ERANGE;             emit_error(file, UNEXPECTED_ERROR_CODE, \"file read\");   }#  ifdef EINTR      else if (errno == EINTR)       {         errno = 0;         return read_byte(file);      }#  endif   else   {            if (ferror(file->file))         file->read_errno = errno;      else if (feof(file->file))         file->read_errno = 0;       else          file->read_errno = EDOM;   }      file->status_code |= TRUNCATED;   return EOF;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIstandard_end(png_structp ppIn, png_infop pi){   png_const_structp pp = ppIn;   standard_display *dp = voidcast(standard_display*,      png_get_progressive_ptr(pp));   UNUSED(pi)      standard_text_validate(dp, pp, pi,      PNG_LIBPNG_VER >= 10518);   standard_image_validate(dp, pp, 0, -1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static store_palette_entry *store_write_palette(png_store *ps, int npalette){   if (ps->pwrite == NULL)      store_log(ps, NULL, \"attempt to write palette without write stream\", 1);   if (ps->palette != NULL)      png_error(ps->pwrite, \"multiple store_write_palette calls\");      if (npalette > 0)   {      ps->palette = voidcast(store_palette_entry*, malloc(npalette *         sizeof *ps->palette));      if (ps->palette == NULL)         png_error(ps->pwrite, \"store new palette: OOM\");      ps->npalette = npalette;   }   return ps->palette;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intlogpixel(const Transform *transform, png_uint_32 x, png_uint_32 y,   const Pixel *in, const Pixel *calc, const Pixel *out, const char *reason){   const png_uint_32 in_format = transform->in_image->image.format;   const png_uint_32 out_format = transform->out_image->image.format;   png_uint_32 back_format = out_format & ~PNG_FORMAT_FLAG_ALPHA;   const char *via_linear = \"\";   char pixel_in[64], pixel_calc[64], pixel_out[64], pixel_loc[64];   char background_info[100];   print_pixel(pixel_in, in, in_format);   print_pixel(pixel_calc, calc, out_format);   print_pixel(pixel_out, out, out_format);   if (transform->is_palette)      sprintf(pixel_loc, \"palette: %lu\", (unsigned long)y);   else      sprintf(pixel_loc, \"%lu,%lu\", (unsigned long)x, (unsigned long)y);   if (transform->from_linear != NULL)   {      via_linear = \" (via linear)\";            back_format |= PNG_FORMAT_FLAG_LINEAR;   }   if (transform->background != NULL)   {      Pixel back;      char pixel_back[64];      back.r = transform->background->ir;      back.g = transform->background->ig;      back.b = transform->background->ib;      back.a = -1;       print_pixel(pixel_back, &back, back_format);      sprintf(background_info, \" on background %s\", pixel_back);   }   else      background_info[0] = 0;   if (transform->in_image->file_name != transform->out_image->file_name)   {      char error_buffer[512];      sprintf(error_buffer,         \"(%s) %s error%s:\\n %s%s ->\\n       %s\\n  not: %s.\\n\"         \"Use --preserve and examine: \", pixel_loc, reason, via_linear,         pixel_in, background_info, pixel_out, pixel_calc);      return logerror(transform->in_image, transform->in_image->file_name,         error_buffer, transform->out_image->file_name);   }   else   {      char error_buffer[512];      sprintf(error_buffer,         \"(%s) %s error%s:\\n %s%s ->\\n       %s\\n  not: %s.\\n\"         \" The error happened when reading the original file with this format.\",         pixel_loc, reason, via_linear, pixel_in, background_info, pixel_out,         pixel_calc);      return logerror(transform->in_image, transform->in_image->file_name,         error_buffer, \"\");   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidpng_handle_sBIT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length){   png_size_t truelen;   png_byte buf[4];   png_debug(1, \"in png_handle_sBIT\\n\");   buf[0] = buf[1] = buf[2] = buf[3] = 0;   if (!(png_ptr->mode & PNG_HAVE_IHDR))      png_error(png_ptr, \"Missing IHDR before sBIT\");   else if (png_ptr->mode & PNG_HAVE_IDAT)   {      png_warning(png_ptr, \"Invalid sBIT after IDAT\");      png_crc_finish(png_ptr, length);      return;   }   else if (png_ptr->mode & PNG_HAVE_PLTE)   {            png_warning(png_ptr, \"Out of place sBIT chunk\");   }   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_sBIT)   {      png_warning(png_ptr, \"Duplicate sBIT chunk\");      png_crc_finish(png_ptr, length);      return;   }   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)      truelen = 3;   else      truelen = (png_size_t)png_ptr->channels;   if (length != truelen)   {      png_warning(png_ptr, \"Incorrect sBIT chunk length\");      png_crc_finish(png_ptr, length);      return;   }   png_crc_read(png_ptr, buf, truelen);   if (png_crc_finish(png_ptr, 0))      return;   if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)   {      png_ptr->sig_bit.red = buf[0];      png_ptr->sig_bit.green = buf[1];      png_ptr->sig_bit.blue = buf[2];      png_ptr->sig_bit.alpha = buf[3];   }   else   {      png_ptr->sig_bit.gray = buf[0];      png_ptr->sig_bit.alpha = buf[1];   }   png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));}#endif",
        "label": 1,
        "cve": "cve-2004-0597-2"
    },
    {
        "code": "static voidstandard_palette_validate(standard_display *dp, png_const_structp pp,   png_infop pi){   int npalette;   store_palette palette;   if (read_palette(palette, &npalette, pp, pi) != dp->is_transparent)      png_error(pp, \"validate: palette transparency changed\");   if (npalette != dp->npalette)   {      size_t pos = 0;      char msg[64];      pos = safecat(msg, sizeof msg, pos, \"validate: palette size changed: \");      pos = safecatn(msg, sizeof msg, pos, dp->npalette);      pos = safecat(msg, sizeof msg, pos, \" -> \");      pos = safecatn(msg, sizeof msg, pos, npalette);      png_error(pp, msg);   }   {      int i = npalette;       while (--i >= 0)         if (palette[i].red != dp->palette[i].red ||            palette[i].green != dp->palette[i].green ||            palette[i].blue != dp->palette[i].blue ||            palette[i].alpha != dp->palette[i].alpha)            png_error(pp, \"validate: PLTE or tRNS chunk changed\");   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIwarning_handler(png_structp png_ptr, png_const_charp message){   struct file *file = get_control(png_ptr);   if (file->global->warnings)      emit_error(file, LIBPNG_WARNING_CODE, message);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidfreebuffer(Image *image){   if (image->buffer) free(image->buffer);   image->buffer = NULL;   image->bufsize = 0;   image->allocsize = 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#endif int validation_gamma(int argc, char **argv){   double gamma[9] = { 2.2, 1.8, 1.52, 1.45, 1., 1/1.45, 1/1.52, 1/1.8, 1/2.2 };   double maxerr;   int i, silent=0, onlygamma=0;      while (--argc > 0)      if (strcmp(*++argv, \"-s\") == 0)         silent = 1;      else if (strcmp(*argv, \"-g\") == 0)         onlygamma = 1;      else      {         fprintf(stderr, \"unknown argument %s\\n\", *argv);         return 1;      }   if (!onlygamma)   {            maxerr = 0;      for (i=0; i<256; ++i)      {         double correct = -log(i/255.)/log(2.)*65536;         double error = png_log8bit(i) - correct;         if (i != 0 && fabs(error) > maxerr)            maxerr = fabs(error);         if (i == 0 && png_log8bit(i) != 0xffffffff ||             i != 0 && png_log8bit(i) != floor(correct+.5))         {            fprintf(stderr, \"8 bit log error: %d: got %u, expected %f\\n\",               i, png_log8bit(i), correct);         }      }      if (!silent)         printf(\"maximum 8 bit log error = %f\\n\", maxerr);      maxerr = 0;      for (i=0; i<65536; ++i)      {         double correct = -log(i/65535.)/log(2.)*65536;         double error = png_log16bit(i) - correct;         if (i != 0 && fabs(error) > maxerr)            maxerr = fabs(error);         if (i == 0 && png_log16bit(i) != 0xffffffff ||             i != 0 && png_log16bit(i) != floor(correct+.5))         {            if (error > .68)             {               fprintf(stderr, \"16 bit log error: %d: got %u, expected %f\"                  \" error: %f\\n\", i, png_log16bit(i), correct, error);            }         }      }      if (!silent)         printf(\"maximum 16 bit log error = %f\\n\", maxerr);            maxerr = 0;      for (i=0; i<=0xfffff; ++i)      {         double correct = exp(-i/65536. * log(2.)) * (65536. * 65536);         double error = png_exp(i) - correct;         if (fabs(error) > maxerr)            maxerr = fabs(error);         if (fabs(error) > 1883)          {            fprintf(stderr, \"32 bit exp error: %d: got %u, expected %f\"                  \" error: %f\\n\", i, png_exp(i), correct, error);         }      }      if (!silent)         printf(\"maximum 32 bit exp error = %f\\n\", maxerr);      maxerr = 0;      for (i=0; i<=0xfffff; ++i)      {         double correct = exp(-i/65536. * log(2.)) * 255;         double error = png_exp8bit(i) - correct;         if (fabs(error) > maxerr)            maxerr = fabs(error);         if (fabs(error) > .50002)          {            fprintf(stderr, \"8 bit exp error: %d: got %u, expected %f\"                  \" error: %f\\n\", i, png_exp8bit(i), correct, error);         }      }      if (!silent)         printf(\"maximum 8 bit exp error = %f\\n\", maxerr);      maxerr = 0;      for (i=0; i<=0xfffff; ++i)      {         double correct = exp(-i/65536. * log(2.)) * 65535;         double error = png_exp16bit(i) - correct;         if (fabs(error) > maxerr)            maxerr = fabs(error);         if (fabs(error) > .524)          {            fprintf(stderr, \"16 bit exp error: %d: got %u, expected %f\"                  \" error: %f\\n\", i, png_exp16bit(i), correct, error);         }      }      if (!silent)         printf(\"maximum 16 bit exp error = %f\\n\", maxerr);   }       for (i=0; i<9; ++i)   {      unsigned j;      double g = gamma[i];      png_fixed_point gfp = floor(g * PNG_FP_1 + .5);      if (!silent)         printf(\"Test gamma %f\\n\", g);      maxerr = 0;      for (j=0; j<256; ++j)      {         double correct = pow(j/255., g) * 255;         png_byte out = png_gamma_8bit_correct(j, gfp);         double error = out - correct;         if (fabs(error) > maxerr)            maxerr = fabs(error);         if (out != floor(correct+.5))         {            fprintf(stderr, \"8bit %d ^ %f: got %d expected %f error %f\\n\",               j, g, out, correct, error);         }      }      if (!silent)         printf(\"gamma %f: maximum 8 bit error %f\\n\", g, maxerr);      maxerr = 0;      for (j=0; j<65536; ++j)      {         double correct = pow(j/65535., g) * 65535;         png_uint_16 out = png_gamma_16bit_correct(j, gfp);         double error = out - correct;         if (fabs(error) > maxerr)            maxerr = fabs(error);         if (fabs(error) > 1.62)         {            fprintf(stderr, \"16bit %d ^ %f: got %d expected %f error %f\\n\",               j, g, out, correct, error);         }      }      if (!silent)         printf(\"gamma %f: maximum 16 bit error %f\\n\", g, maxerr);   }   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_verbose(png_store *ps, png_const_structp pp, png_const_charp prefix,   png_const_charp message){   char buffer[512];   if (prefix)      fputs(prefix, stderr);   (void)store_message(ps, pp, buffer, sizeof buffer, 0, message);   fputs(buffer, stderr);   fputc('\\n', stderr);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intread_one_file(Image *image){   if (!(image->opts & READ_FILE) || (image->opts & USE_STDIO))   {            FILE *f = fopen(image->file_name, \"rb\");      if (f != NULL)      {         if (image->opts & READ_FILE)            image->input_file = f;         else          {            if (fseek(f, 0, SEEK_END) == 0)            {               long int cb = ftell(f);               if (cb > 0 && (unsigned long int)cb < (size_t)~(size_t)0)               {                  png_bytep b = voidcast(png_bytep, malloc((size_t)cb));                  if (b != NULL)                  {                     rewind(f);                     if (fread(b, (size_t)cb, 1, f) == 1)                     {                        fclose(f);                        image->input_memory_size = cb;                        image->input_memory = b;                     }                     else                     {                        free(b);                        return logclose(image, f, image->file_name,                           \": read failed: \");                     }                  }                  else                     return logclose(image, f, image->file_name,                        \": out of memory: \");               }               else if (cb == 0)                  return logclose(image, f, image->file_name,                     \": zero length: \");               else                  return logclose(image, f, image->file_name,                     \": tell failed: \");            }            else               return logclose(image, f, image->file_name, \": seek failed: \");         }      }      else         return logerror(image, image->file_name, \": open failed: \",            strerror(errno));   }   return read_file(image, FORMAT_NO_CHANGE, NULL);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#include <sys/ioctl.h>int repl_getch( void ){  char ch;  int fd = fileno(stdin);  struct termio old_tty, new_tty;  ioctl(fd, TCGETA, &old_tty);  new_tty = old_tty;  new_tty.c_lflag &= ~(ICANON | ECHO | ISIG);  ioctl(fd, TCSETA, &new_tty);  fread(&ch, 1, sizeof(ch), stdin);  ioctl(fd, TCSETA, &old_tty);  return ch;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIdisplay_warning(png_structp pp, png_const_charp warning){   display_log(get_dp(pp), LIBPNG_WARNING, \"%s\", warning);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void gamma_threshold_test(png_modifier *pm, png_byte colour_type,    png_byte bit_depth, int interlace_type, double file_gamma,    double screen_gamma){   size_t pos = 0;   char name[64];   pos = safecat(name, sizeof name, pos, \"threshold \");   pos = safecatd(name, sizeof name, pos, file_gamma, 3);   pos = safecat(name, sizeof name, pos, \"/\");   pos = safecatd(name, sizeof name, pos, screen_gamma, 3);   (void)gamma_test(pm, colour_type, bit_depth, 0, interlace_type,      file_gamma, screen_gamma, 0, 1, name,      0 ,      0 , 0 , 0 , 0 ,      0 );}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void readpng2_row_callback(png_structp png_ptr, png_bytep new_row,                                  png_uint_32 row_num, int pass){    mainprog_info  *mainprog_ptr;        if (!new_row)        return;        mainprog_ptr = png_get_progressive_ptr(png_ptr);        mainprog_ptr->pass = pass;        png_progressive_combine_row(png_ptr, mainprog_ptr->row_pointers[row_num],      new_row);        (*mainprog_ptr->mainprog_display_row)(row_num);        return;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidtransform_row(png_const_structp pp, png_byte buffer[TRANSFORM_ROWMAX],   png_byte colour_type, png_byte bit_depth, png_uint_32 y){   png_uint_32 v = y << 7;   png_uint_32 i = 0;   switch (bit_size(pp, colour_type, bit_depth))   {      case 1:         while (i<128/8) buffer[i] = (png_byte)(v & 0xff), v += 17, ++i;         return;      case 2:         while (i<128/4) buffer[i] = (png_byte)(v & 0xff), v += 33, ++i;         return;      case 4:         while (i<128/2) buffer[i] = (png_byte)(v & 0xff), v += 65, ++i;         return;      case 8:                  while (i<128) buffer[i] = (png_byte)(v & 0xff), ++v, ++i;         return;      case 16:                  while (i<128)         {            buffer[2*i] = (png_byte)((v>>8) & 0xff);            buffer[2*i+1] = (png_byte)(v & 0xff);            ++v;            ++i;         }         return;      case 24:                  while (i<128)         {                        buffer[3*i+0] = (png_byte)((v >> 8) & 0xff);            buffer[3*i+1] = (png_byte)(v & 0xff);            buffer[3*i+2] = (png_byte)(((v >> 8) ^ v) & 0xff);            ++v;            ++i;         }         return;      case 32:                  while (i<128)         {            buffer[4*i+0] = (png_byte)((v >> 8) & 0xff);            buffer[4*i+1] = (png_byte)(v & 0xff);            buffer[4*i+2] = (png_byte)((v >> 8) & 0xff);            buffer[4*i+3] = (png_byte)(v & 0xff);            ++v;            ++i;         }         return;      case 48:                  while (i<128)         {            png_uint_32 t = v++;            buffer[6*i+0] = (png_byte)((t >> 8) & 0xff);            buffer[6*i+1] = (png_byte)(t & 0xff);            t *= 257;            buffer[6*i+2] = (png_byte)((t >> 8) & 0xff);            buffer[6*i+3] = (png_byte)(t & 0xff);            t *= 17;            buffer[6*i+4] = (png_byte)((t >> 8) & 0xff);            buffer[6*i+5] = (png_byte)(t & 0xff);            ++i;         }         return;      case 64:                  while (i<128)         {            png_uint_32 t = v++;            buffer[8*i+0] = (png_byte)((t >> 8) & 0xff);            buffer[8*i+1] = (png_byte)(t & 0xff);            buffer[8*i+4] = (png_byte)((t >> 8) & 0xff);            buffer[8*i+5] = (png_byte)(t & 0xff);            t *= 257;            buffer[8*i+2] = (png_byte)((t >> 8) & 0xff);            buffer[8*i+3] = (png_byte)(t & 0xff);            buffer[8*i+6] = (png_byte)((t >> 8) & 0xff);            buffer[8*i+7] = (png_byte)(t & 0xff);            ++i;         }         return;      default:         break;   }   png_error(pp, \"internal error\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int verbose = 0;int validation_ascii_to_fp(int count, int argc, char **argv){   int    showall = 0;   double max_error=2;         double max_error_abs=17;    double max = 0;   double max_abs = 0;   double test = 0;    int    precision = 5;   int    nonfinite = 0;   int    finite = 0;   int    ok = 0;   int    failcount = 0;   int    minorarith = 0;   while (--argc > 0)      if (strcmp(*++argv, \"-a\") == 0)         showall = 1;      else if (strcmp(*argv, \"-e\") == 0 && argc > 0)      {         --argc;         max_error = atof(*++argv);      }      else if (strcmp(*argv, \"-E\") == 0 && argc > 0)      {         --argc;         max_error_abs = atof(*++argv);      }      else      {         fprintf(stderr, \"unknown argument %s\\n\", *argv);         return 1;      }   do   {      png_size_t index;      int state, failed = 0;      char buffer[64];      if (isfinite(test))         ++finite;      else         ++nonfinite;      if (verbose)         fprintf(stderr, \"%.*g %d\\n\", DBL_DIG, test, precision);            memset(buffer, 71, sizeof buffer);      png_ascii_from_fp(0, buffer, precision+10, test, precision);            if (buffer[precision+7] != 71)      {         fprintf(stderr, \"%g[%d] -> '%s'[%lu] buffer overflow\\n\", test,            precision, buffer, (unsigned long)strlen(buffer));         failed = 1;      }            state = 0;      index = 0;      if (!isfinite(test))      {                  if (test >= 0 && strcmp(buffer, \"inf\") ||             test <  0 && strcmp(buffer, \"-inf\"))         {            fprintf(stderr, \"%g[%d] -> '%s' but expected 'inf'\\n\", test,               precision, buffer);            failed = 1;         }      }      else if (!png_check_fp_number(buffer, precision+10, &state, &index) ||          buffer[index] != 0)      {         fprintf(stderr, \"%g[%d] -> '%s' but has bad format ('%c')\\n\", test,         precision, buffer, buffer[index]);         failed = 1;      }      else if (PNG_FP_IS_NEGATIVE(state) && !(test < 0))      {         fprintf(stderr, \"%g[%d] -> '%s' but negative value not so reported\\n\",            test, precision, buffer);         failed = 1;         assert(!PNG_FP_IS_ZERO(state));         assert(!PNG_FP_IS_POSITIVE(state));      }      else if (PNG_FP_IS_ZERO(state) && !(test == 0))      {         fprintf(stderr, \"%g[%d] -> '%s' but zero value not so reported\\n\",            test, precision, buffer);         failed = 1;         assert(!PNG_FP_IS_NEGATIVE(state));         assert(!PNG_FP_IS_POSITIVE(state));      }      else if (PNG_FP_IS_POSITIVE(state) && !(test > 0))      {         fprintf(stderr, \"%g[%d] -> '%s' but postive value not so reported\\n\",            test, precision, buffer);         failed = 1;         assert(!PNG_FP_IS_NEGATIVE(state));         assert(!PNG_FP_IS_ZERO(state));      }      else      {                  double out = atof(buffer);         double change = fabs((out - test)/test);         double allow = .5/pow(10,            (precision >= DBL_DIG) ? DBL_DIG-1 : precision-1);                  if (change >= allow && (isfinite(out) ||             fabs(test/DBL_MAX) <= 1-allow))         {            double percent = (precision >= DBL_DIG) ? max_error_abs : max_error;            double allowp = (change-allow)*100/allow;            if (precision >= DBL_DIG)            {               if (max_abs < allowp) max_abs = allowp;            }            else            {               if (max < allowp) max = allowp;            }            if (showall || allowp >= percent)            {               fprintf(stderr,                  \"%.*g[%d] -> '%s' -> %.*g number changed (%g > %g (%d%%))\\n\",                  DBL_DIG, test, precision, buffer, DBL_DIG, out, change, allow,                  (int)round(allowp));               failed = 1;            }            else               ++minorarith;         }      }      if (failed)         ++failcount;      else         ++ok;skip:            precision = rand();      if (precision & 1) test = -test;      precision >>= 1;            if (test == 0 || !isfinite(test))         test = precision+1;      else      {                  int exponent = precision % (DBL_MAX_EXP - DBL_MIN_EXP) + DBL_MIN_EXP;         int tmp;         test = frexp(test * rand(), &tmp);         test = ldexp(test, exponent);         precision >>= 8;       }            precision = (precision & 0x1f) + 1;   }   while (--count);   printf(\"Tested %d finite values, %d non-finite, %d OK (%d failed) %d minor \"      \"arithmetic errors\\n\", finite, nonfinite, ok, failcount, minorarith);   printf(\" Error with >=%d digit precision %.2f%%\\n\", DBL_DIG, max_abs);   printf(\" Error with < %d digit precision %.2f%%\\n\", DBL_DIG, max);   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intfile_end(struct file *file){   int rc;      if (file->idat != NULL)      IDAT_end(&file->idat);   if (file->chunk != NULL)      chunk_end(&file->chunk);   rc = file->status_code;   if (file->file != NULL)      (void)fclose(file->file);   if (file->out != NULL)   {            if (ferror(file->out) | fflush(file->out) | fclose(file->out))      {         perror(file->out_name);         emit_error(file, READ_ERROR_CODE, \"output write error\");         rc |= WRITE_ERROR;      }   }      file->global->status_code |= rc;   CLEAR(*file);   return rc; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int main(int argc, char **argv){   int err = 0;   printf(\"/* adler32, crc32, MD5[16], intent, date, length, file-name */\\n\");   if (argc > 1)   {      int i;      for (i=1; i<argc; ++i)      {         FILE *ip = fopen(argv[i], \"rb\");         if (ip == NULL || !read_one_file(ip, argv[i]))         {            err = 1;            perror(argv[i]);            fprintf(stderr, \"%s: read error\\n\", argv[i]);            printf(\"/* ERROR: %s */\\n\", argv[i]);         }         (void)fclose(ip);      }   }   else   {      if (!read_one_file(stdin, \"-\"))      {         err = 1;         perror(\"stdin\");         fprintf(stderr, \"stdin: read error\\n\");         printf(\"/* ERROR: stdin */\\n\");      }   }   return err;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIstore_free(png_structp ppIn, png_voidp memory){   png_const_structp pp = ppIn;   store_pool *pool = voidcast(store_pool*, png_get_mem_ptr(pp));   store_memory *this = voidcast(store_memory*, memory), **test;      if (pp != pool->store->pread && pp != pool->store->pwrite)      pp = NULL;      --this;   for (test = &pool->list; *test != this; test = &(*test)->next)   {      if (*test == NULL)      {         store_pool_error(pool->store, pp, \"bad pointer to free\");         return;      }   }      *test = this->next;   this->next = NULL;   store_memory_free(pp, pool, this);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length){   png_textp text_ptr;   png_charp key;   png_charp text;   png_uint_32 skip = 0;   png_size_t slength;   int ret;   png_debug(1, \"in png_handle_tEXt\\n\");   if (!(png_ptr->mode & PNG_HAVE_IHDR))      png_error(png_ptr, \"Missing IHDR before tEXt\");   if (png_ptr->mode & PNG_HAVE_IDAT)      png_ptr->mode |= PNG_AFTER_IDAT;#ifdef PNG_MAX_MALLOC_64K   if (length > (png_uint_32)65535L)   {      png_warning(png_ptr, \"tEXt chunk too large to fit in memory\");      skip = length - (png_uint_32)65535L;      length = (png_uint_32)65535L;   }#endif   key = (png_charp)png_malloc_warn(png_ptr, length + 1);   if (key == NULL)   {     png_warning(png_ptr, \"No memory to process text chunk.\");     return;   }   slength = (png_size_t)length;   png_crc_read(png_ptr, (png_bytep)key, slength);   if (png_crc_finish(png_ptr, skip))   {      png_free(png_ptr, key);      return;   }   key[slength] = 0x00;   for (text = key; *text; text++)       ;   if (text != key + slength)      text++;   text_ptr = (png_textp)png_malloc_warn(png_ptr,      (png_uint_32)png_sizeof(png_text));   if (text_ptr == NULL)   {     png_warning(png_ptr, \"Not enough memory to process text chunk.\");     png_free(png_ptr, key);     return;   }   text_ptr->compression = PNG_TEXT_COMPRESSION_NONE;   text_ptr->key = key;#ifdef PNG_iTXt_SUPPORTED   text_ptr->lang = NULL;   text_ptr->lang_key = NULL;   text_ptr->itxt_length = 0;#endif   text_ptr->text = text;   text_ptr->text_length = png_strlen(text);   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);   png_free(png_ptr, key);   png_free(png_ptr, text_ptr);   if (ret)     png_warning(png_ptr, \"Insufficient memory to process text chunk.\");}#endif",
        "label": 1,
        "cve": "cve-2008-6218"
    },
    {
        "code": "BOOL DisplayImage (HWND hwnd, BYTE **ppDib,        BYTE **ppDiData, int cxWinSize, int cyWinSize,        BYTE *pbImage, int cxImgSize, int cyImgSize, int cImgChannels,        BOOL bStretched){    BYTE                       *pDib = *ppDib;    BYTE                       *pDiData = *ppDiData;        BITMAPINFOHEADER           *pbmih;    WORD                        wDIRowBytes;    png_color                   bkgBlack = {0, 0, 0};    png_color                   bkgGray  = {127, 127, 127};    png_color                   bkgWhite = {255, 255, 255};        wDIRowBytes = (WORD) ((3 * cxWinSize + 3L) >> 2) << 2;    if (pDib)    {        free (pDib);        pDib = NULL;    }    if (!(pDib = (BYTE *) malloc (sizeof(BITMAPINFOHEADER) +        wDIRowBytes * cyWinSize)))    {        MessageBox (hwnd, TEXT (\"Error in displaying the PNG image\"),            szProgName, MB_ICONEXCLAMATION | MB_OK);        *ppDib = pDib = NULL;        return FALSE;    }    *ppDib = pDib;    memset (pDib, 0, sizeof(BITMAPINFOHEADER));        pbmih = (BITMAPINFOHEADER *) pDib;    pbmih->biSize = sizeof(BITMAPINFOHEADER);    pbmih->biWidth = cxWinSize;    pbmih->biHeight = -((long) cyWinSize);    pbmih->biPlanes = 1;    pbmih->biBitCount = 24;    pbmih->biCompression = 0;    pDiData = pDib + sizeof(BITMAPINFOHEADER);    *ppDiData = pDiData;        InitBitmap (pDiData, cxWinSize, cyWinSize);        if (pbImage)    {        FillBitmap (            pDiData, cxWinSize, cyWinSize,            pbImage, cxImgSize, cyImgSize, cImgChannels,            bStretched);    }    return TRUE;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_log(png_store* ps, png_const_structp pp, png_const_charp message,   int is_error){      if (is_error ? (ps->nerrors)++ == 0 :       (ps->nwarnings)++ == 0 && ps->nerrors == 0)      store_message(ps, pp, ps->error, sizeof ps->error, 0, message);   if (ps->verbose)      store_verbose(ps, pp, is_error ? \"error: \" : \"warning: \", message);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidbuffer_read(struct display *dp, struct buffer *bp, png_bytep data,   png_size_t size){   struct buffer_list *last = bp->current;   size_t read_count = bp->read_count;   while (size > 0)   {      size_t avail;      if (last == NULL ||         (last == bp->last && read_count >= bp->end_count))      {         display_log(dp, USER_ERROR, \"file truncated (%lu bytes)\",            (unsigned long)size);                  break;      }      else if (read_count >= sizeof last->buffer)      {                  last = last->next;         read_count = 0;         bp->current = last;                   if (last == NULL)         {            display_log(dp, INTERNAL_ERROR, \"damaged buffer list\");                        break;         }      }      avail = (sizeof last->buffer) - read_count;      if (avail > size)         avail = size;      memcpy(data, last->buffer + read_count, avail);      read_count += avail;      size -= avail;      data += avail;   }   bp->read_count = read_count;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstandard_test(png_store* PNG_CONST psIn, png_uint_32 PNG_CONST id,   int do_interlace, int use_update_info){   standard_display d;   context(psIn, fault);      standard_display_init(&d, psIn, id, do_interlace, use_update_info);      Try   {      png_structp pp;      png_infop pi;            pp = set_store_for_read(d.ps, &pi, d.id,         d.do_interlace ?  (d.ps->progressive ?            \"pngvalid progressive deinterlacer\" :            \"pngvalid sequential deinterlacer\") : (d.ps->progressive ?               \"progressive reader\" : \"sequential reader\"));            standard_palette_init(&d);            if (d.ps->progressive)      {         png_set_progressive_read_fn(pp, &d, standard_info, progressive_row,            standard_end);                  store_progressive_read(d.ps, pp, pi);      }      else      {                  png_set_read_fn(pp, d.ps, store_read);                  png_read_info(pp, pi);                  standard_info_imp(&d, pp, pi, 2 );                  {            sequential_row(&d, pp, pi, 0, 1);                        if (!d.speed)            {               standard_text_validate(&d, pp, pi, 1);               standard_image_validate(&d, pp, 0, 1);            }            else               d.ps->validated = 1;         }      }            if (!d.ps->validated)         png_error(pp, \"image read failed silently\");         }   Catch(fault)      d.ps = fault;       store_read_reset(d.ps);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void writepng_error_handler(png_structp png_ptr, png_const_charp msg);void writepng_version_info(void){  fprintf(stderr, \"   Compiled with libpng %s; using libpng %s.\\n\",    PNG_LIBPNG_VER_STRING, png_libpng_ver);  fprintf(stderr, \"   Compiled with zlib %s; using zlib %s.\\n\",    ZLIB_VERSION, zlib_version);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32png_pass_start_col(int pass){   int x, y;   ++pass;   for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass)      return x;   return 0xf;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static unsigned intbit_size(png_const_structp pp, png_byte colour_type, png_byte bit_depth){   switch (colour_type)   {      default: png_error(pp, \"invalid color type\");      case 0:  return bit_depth;      case 2:  return 3*bit_depth;      case 3:  return bit_depth;      case 4:  return 2*bit_depth;      case 6:  return 4*bit_depth;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "png_charp png_decompress_chunk(png_structp png_ptr, int comp_type,                              png_charp chunkdata, png_size_t chunklength,                              png_size_t prefix_size, png_size_t *newlength){   static char msg[] = \"Error decoding compressed text\";   png_charp text;   png_size_t text_size;   if (comp_type == PNG_COMPRESSION_TYPE_BASE)   {      int ret = Z_OK;      png_ptr->zstream.next_in = (png_bytep)(chunkdata + prefix_size);      png_ptr->zstream.avail_in = (uInt)(chunklength - prefix_size);      png_ptr->zstream.next_out = png_ptr->zbuf;      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;      text_size = 0;      text = NULL;      while (png_ptr->zstream.avail_in)      {         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);         if (ret != Z_OK && ret != Z_STREAM_END)         {            if (png_ptr->zstream.msg != NULL)               png_warning(png_ptr, png_ptr->zstream.msg);            else               png_warning(png_ptr, msg);            inflateReset(&png_ptr->zstream);            png_ptr->zstream.avail_in = 0;            if (text ==  NULL)            {               text_size = prefix_size + png_sizeof(msg) + 1;               text = (png_charp)png_malloc_warn(png_ptr, text_size);               if (text ==  NULL)                 {                    png_free(png_ptr,chunkdata);                    png_error(png_ptr,\"Not enough memory to decompress chunk\");                 }               png_memcpy(text, chunkdata, prefix_size);            }            text[text_size - 1] = 0x00;                        text_size = (png_size_t)(chunklength - (text - chunkdata) - 1);            text_size = png_sizeof(msg) > text_size ? text_size :               png_sizeof(msg);            png_memcpy(text + prefix_size, msg, text_size + 1);            break;         }         if (!png_ptr->zstream.avail_out || ret == Z_STREAM_END)         {            if (text == NULL)            {               text_size = prefix_size +                   png_ptr->zbuf_size - png_ptr->zstream.avail_out;               text = (png_charp)png_malloc_warn(png_ptr, text_size + 1);               if (text ==  NULL)                 {                    png_free(png_ptr,chunkdata);                    png_error(png_ptr,\"Not enough memory to decompress chunk.\");                 }               png_memcpy(text + prefix_size, png_ptr->zbuf,                    text_size - prefix_size);               png_memcpy(text, chunkdata, prefix_size);               *(text + text_size) = 0x00;            }            else            {               png_charp tmp;               tmp = text;               text = (png_charp)png_malloc_warn(png_ptr,                  (png_uint_32)(text_size +                  png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1));               if (text == NULL)               {                  png_free(png_ptr, tmp);                  png_free(png_ptr, chunkdata);                  png_error(png_ptr,\"Not enough memory to decompress chunk..\");               }               png_memcpy(text, tmp, text_size);               png_free(png_ptr, tmp);               png_memcpy(text + text_size, png_ptr->zbuf,                  (png_ptr->zbuf_size - png_ptr->zstream.avail_out));               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;               *(text + text_size) = 0x00;            }            if (ret == Z_STREAM_END)               break;            else            {               png_ptr->zstream.next_out = png_ptr->zbuf;               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;            }         }      }      if (ret != Z_STREAM_END)      {#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)         char umsg[50];         if (ret == Z_BUF_ERROR)            sprintf(umsg,\"Buffer error in compressed datastream in %s chunk\",                png_ptr->chunk_name);         else if (ret == Z_DATA_ERROR)            sprintf(umsg,\"Data error in compressed datastream in %s chunk\",                png_ptr->chunk_name);         else            sprintf(umsg,\"Incomplete compressed datastream in %s chunk\",                png_ptr->chunk_name);         png_warning(png_ptr, umsg);#else         png_warning(png_ptr,            \"Incomplete compressed datastream in chunk other than IDAT\");#endif         text_size=prefix_size;         if (text ==  NULL)         {            text = (png_charp)png_malloc_warn(png_ptr, text_size+1);            if (text == NULL)              {                png_free(png_ptr, chunkdata);                png_error(png_ptr,\"Not enough memory for text.\");              }            png_memcpy(text, chunkdata, prefix_size);         }         *(text + text_size) = 0x00;      }      inflateReset(&png_ptr->zstream);      png_ptr->zstream.avail_in = 0;      png_free(png_ptr, chunkdata);      chunkdata = text;      *newlength=text_size;   }   else    {#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)      char umsg[50];      sprintf(umsg, \"Unknown zTXt compression type %d\", comp_type);      png_warning(png_ptr, umsg);#else      png_warning(png_ptr, \"Unknown zTXt compression type\");#endif      *(chunkdata + prefix_size) = 0x00;      *newlength=prefix_size;   }   return chunkdata;}",
        "label": 1,
        "cve": "cve-2006-3334"
    },
    {
        "code": "static intfind(const char *name){   int i = NINFO;   while (--i >= 0)   {      if (memcmp(chunk_info[i].name, name, 4) == 0)         break;   }   return i;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_unpg(Pixel *out, const Pixel *in, const Background *back){   (void)back;   if (in->a <= 128)   {      out->r = out->g = out->b = 255;      out->a = 0;   }   else   {      out->r = out->g = out->b = sRGB((double)in->g / in->a);      out->a = u8d(in->a / 257.);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidperform_error_test(png_modifier *pm){#ifdef PNG_WARNINGS_SUPPORTED       safecat(pm->this.test, sizeof pm->this.test, 0, \"error test\");   if (!make_errors(pm, 0, 0, WRITE_BDHI))      return;   if (!make_errors(pm, 2, 3, WRITE_BDHI))      return;   if (!make_errors(pm, 3, 0, 3))      return;   if (!make_errors(pm, 4, 3, WRITE_BDHI))      return;   if (!make_errors(pm, 6, 3, WRITE_BDHI))      return;#else   UNUSED(pm)#endif}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_16 png_exp16bit(png_uint_32 log){   return (png_uint_16)floor(.5 + exp(log * -LN2) * 65535);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "BOOL PngSaveImage (PTSTR pstrFileName, png_byte *pDiData,                   int iWidth, int iHeight, png_color bkgColor){    const int           ciBitDepth = 8;    const int           ciChannels = 3;    static FILE        *pfFile;    png_uint_32         ulRowBytes;    static png_byte   **ppbRowPointers = NULL;    int                 i;        if (!pstrFileName)        return FALSE;    if (!(pfFile = fopen(pstrFileName, \"wb\")))        return FALSE;        png_ptr = png_create_write_struct(png_get_libpng_ver(NULL), NULL,      (png_error_ptr)png_cexcept_error, (png_error_ptr)NULL);    if (!png_ptr)    {        fclose(pfFile);        return FALSE;    }    info_ptr = png_create_info_struct(png_ptr);    if (!info_ptr) {        fclose(pfFile);        png_destroy_write_struct(&png_ptr, (png_infopp) NULL);        return FALSE;    }    Try    {        #ifdef PNG_STDIO_SUPPORTED        png_init_io(png_ptr, pfFile);#else        png_set_write_fn(png_ptr, (png_voidp)pfFile, png_write_data, png_flush);#endif                png_set_IHDR(png_ptr, info_ptr, iWidth, iHeight, ciBitDepth,            PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE,            PNG_FILTER_TYPE_BASE);                png_write_info(png_ptr, info_ptr);                png_set_bgr(png_ptr);                ulRowBytes = iWidth * ciChannels;                if ((ppbRowPointers = (png_bytepp) malloc(iHeight * sizeof(png_bytep))) == NULL)            Throw \"Visualpng: Out of memory\";                for (i = 0; i < iHeight; i++)            ppbRowPointers[i] = pDiData + i * (((ulRowBytes + 3) >> 2) << 2);                png_write_image (png_ptr, ppbRowPointers);                png_write_end(png_ptr, info_ptr);                free (ppbRowPointers);        ppbRowPointers = NULL;                png_destroy_write_struct(&png_ptr, (png_infopp) NULL);            }    Catch (msg)    {        png_destroy_write_struct(&png_ptr, (png_infopp) NULL);        if(ppbRowPointers)            free (ppbRowPointers);        fclose(pfFile);        return FALSE;    }    fclose (pfFile);    return TRUE;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIpngtest_read_data(png_structp png_ptr, png_bytep data, png_size_t length){   png_size_t check = 0;   png_voidp io_ptr;      io_ptr = png_get_io_ptr(png_ptr);   if (io_ptr != NULL)   {      check = fread(data, 1, length, (png_FILE_p)io_ptr);   }   if (check != length)   {      png_error(png_ptr, \"Read Error\");   }#ifdef PNG_IO_STATE_SUPPORTED   pngtest_check_io_state(png_ptr, length, PNG_IO_READING);#endif}static void PNGCBAPIpngtest_read_data(png_structp png_ptr, png_bytep data, png_size_t length){   png_size_t check;   png_byte *n_data;   png_FILE_p io_ptr;      n_data = (png_byte *)CVT_PTR_NOCHECK(data);   io_ptr = (png_FILE_p)CVT_PTR(png_get_io_ptr(png_ptr));   if ((png_bytep)n_data == data)   {      check = fread(n_data, 1, length, io_ptr);   }   else   {      png_byte buf[NEAR_BUF_SIZE];      png_size_t read, remaining, err;      check = 0;      remaining = length;      do      {         read = MIN(NEAR_BUF_SIZE, remaining);         err = fread(buf, 1, 1, io_ptr);         png_memcpy(data, buf, read);          if (err != read)            break;         else            check += err;         data += read;         remaining -= read;      }      while (remaining != 0);   }   if (check != length)      png_error(png_ptr, \"Read Error\");#ifdef PNG_IO_STATE_SUPPORTED   pngtest_check_io_state(png_ptr, length, PNG_IO_READING);#endif}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_gray_to_rgb_mod(PNG_CONST image_transform *this,    image_pixel *that, png_const_structp pp,    PNG_CONST transform_display *display){      if ((that->colour_type & PNG_COLOR_MASK_COLOR) == 0 && that->have_tRNS)      image_pixel_add_alpha(that, &display->this);      if (that->colour_type == PNG_COLOR_TYPE_GRAY)   {            if (that->bit_depth < 8)         that->sample_depth = that->bit_depth = 8;            that->colour_type = PNG_COLOR_TYPE_RGB;   }   else if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)      that->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;   this->next->mod(this->next, that, pp, display);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidperform_transform_test(png_modifier *pm){   png_byte colour_type = 0;   png_byte bit_depth = 0;   unsigned int palette_number = 0;   while (next_format(&colour_type, &bit_depth, &palette_number, 0))   {      png_uint_32 counter = 0;      size_t base_pos;      char name[64];      base_pos = safecat(name, sizeof name, 0, \"transform:\");      for (;;)      {         size_t pos = base_pos;         PNG_CONST image_transform *list = 0;                  counter = image_transform_add(&list, 1, counter,            name, sizeof name, &pos, colour_type, bit_depth);         if (counter == 0)            break;                  do         {            pm->repeat = 0;            transform_test(pm, FILEID(colour_type, bit_depth, palette_number,               pm->interlace_type, 0, 0, 0), list, name);            if (fail(pm))               return;         }         while (pm->repeat);      }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_rgb8(Pixel *p, png_const_voidp pb){   png_const_bytep pp = voidcast(png_const_bytep, pb);   p->r = pp[0];   p->g = pp[1];   p->b = pp[2];   p->a = 255;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static doublechromaticity_y(CIE_color c){   return c.Y / (c.X + c.Y + c.Z);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidput_chunk(const unsigned char *chunk, uInt length){   uLong crc;   put_uLong(length-4);    fwrite(chunk, length, 1, stdout);   crc = crc32(0, Z_NULL, 0);   put_uLong(crc32(crc, chunk, length));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_pool_delete(png_store *ps, store_pool *pool){   if (pool->list != NULL)   {      fprintf(stderr, \"%s: %s %s: memory lost (list follows):\\n\", ps->test,         pool == &ps->read_memory_pool ? \"read\" : \"write\",         pool == &ps->read_memory_pool ? (ps->current != NULL ?            ps->current->name : \"unknown file\") : ps->wname);      ++ps->nerrors;      do      {         store_memory *next = pool->list;         pool->list = next->next;         next->next = NULL;         fprintf(stderr, \"\\t%lu bytes @ %p\\n\",             (unsigned long)next->size, (PNG_CONST void*)(next+1));                  store_memory_free(NULL, pool, next);      }      while (pool->list != NULL);   }      if (pool->max > pool->max_max) pool->max_max = pool->max;   pool->max = 0;   if (pool->current != 0)       fprintf(stderr, \"%s: %s %s: memory counter mismatch (internal error)\\n\",         ps->test, pool == &ps->read_memory_pool ? \"read\" : \"write\",         pool == &ps->read_memory_pool ? (ps->current != NULL ?            ps->current->name : \"unknown file\") : ps->wname);   pool->current = 0;   if (pool->limit > pool->max_limit)      pool->max_limit = pool->limit;   pool->limit = 0;   if (pool->total > pool->max_total)      pool->max_total = pool->total;   pool->total = 0;      store_pool_mark(pool->mark);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,                    PSTR szCmdLine, int iCmdShow){    HACCEL   hAccel;    HWND     hwnd;    MSG      msg;    WNDCLASS wndclass;    int ixBorders, iyBorders;    wndclass.style         = CS_HREDRAW | CS_VREDRAW;    wndclass.lpfnWndProc   = WndProc;    wndclass.cbClsExtra    = 0;    wndclass.cbWndExtra    = 0;    wndclass.hInstance     = hInstance;    wndclass.hIcon         = LoadIcon (hInstance, szIconName) ;    wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW);    wndclass.hbrBackground = NULL;     wndclass.lpszMenuName  = szProgName;    wndclass.lpszClassName = szProgName;    if (!RegisterClass (&wndclass))    {        MessageBox (NULL, TEXT (\"Error: this program requires Windows NT!\"),            szProgName, MB_ICONERROR);        return 0;    }        if ((szCmdLine != NULL) && (*szCmdLine != '\\0'))        if (szCmdLine[0] == '\"')            strncpy (szCmdFileName, szCmdLine + 1, strlen(szCmdLine) - 2);        else            strcpy (szCmdFileName, szCmdLine);    else        strcpy (szCmdFileName, \"\");        ixBorders = 2 * (GetSystemMetrics (SM_CXBORDER) +                     GetSystemMetrics (SM_CXDLGFRAME));    iyBorders = 2 * (GetSystemMetrics (SM_CYBORDER) +                     GetSystemMetrics (SM_CYDLGFRAME)) +                     GetSystemMetrics (SM_CYCAPTION) +                     GetSystemMetrics (SM_CYMENUSIZE) +                     1;     hwnd = CreateWindow (szProgName, szAppName,        WS_OVERLAPPEDWINDOW,        CW_USEDEFAULT, CW_USEDEFAULT,        512 + 2 * MARGIN + ixBorders, 384 + 2 * MARGIN + iyBorders,        NULL, NULL, hInstance, NULL);    ShowWindow (hwnd, iCmdShow);    UpdateWindow (hwnd);    hAccel = LoadAccelerators (hInstance, szProgName);    while (GetMessage (&msg, NULL, 0, 0))    {        if (!TranslateAccelerator (hwnd, hAccel, &msg))        {            TranslateMessage (&msg);            DispatchMessage (&msg);        }    }    return msg.wParam;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void writepng_cleanup(mainprog_info *mainprog_ptr){    png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr;    png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr;    if (png_ptr && info_ptr)        png_destroy_write_struct(&png_ptr, &info_ptr);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intmodifier_color_encoding_is_set(PNG_CONST png_modifier *pm){   return pm->current_gamma != 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char **argv){   int i;   int extracted = 0;   for (i=1; i<argc; ++i)   {      if (strcmp(argv[i], \"-q\") == 0)         verbose = 0;      else if (extract_one_file(argv[i]))         extracted = 1;   }      return extracted == 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidperform_formatting_test(png_store *volatile ps){#ifdef PNG_TIME_RFC1123_SUPPORTED      context(ps, fault);   Try   {      png_const_charp correct = \"29 Aug 2079 13:53:60 +0000\";      png_const_charp result;#     if PNG_LIBPNG_VER >= 10600         char timestring[29];#     endif      png_structp pp;      png_time pt;      pp = set_store_for_write(ps, NULL, \"libpng formatting test\");      if (pp == NULL)         Throw ps;            pt.year = 2079;      pt.month = 8;      pt.day = 29;      pt.hour = 13;      pt.minute = 53;      pt.second = 60; #     if PNG_LIBPNG_VER < 10600         result = png_convert_to_rfc1123(pp, &pt);#     else         if (png_convert_to_rfc1123_buffer(timestring, &pt))            result = timestring;         else            result = NULL;#     endif      if (result == NULL)         png_error(pp, \"png_convert_to_rfc1123 failed\");      if (strcmp(result, correct) != 0)      {         size_t pos = 0;         char msg[128];         pos = safecat(msg, sizeof msg, pos, \"png_convert_to_rfc1123(\");         pos = safecat(msg, sizeof msg, pos, correct);         pos = safecat(msg, sizeof msg, pos, \") returned: '\");         pos = safecat(msg, sizeof msg, pos, result);         pos = safecat(msg, sizeof msg, pos, \"'\");         png_error(pp, msg);      }      store_write_reset(ps);   }   Catch(fault)   {      store_write_reset(fault);   }#else   UNUSED(ps)#endif}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_g16(Pixel *p, png_const_voidp pb){   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);   p->r = p->g = p->b = pp[0];   p->a = 65535;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_reset_count(void){   image_transform *next = image_transform_first;   int count = 0;   while (next != &image_transform_end)   {      next->local_use = 0;      next->next = 0;      next = next->list;      ++count;   }      if (count > 32) abort();}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#define png_fixed_error png_fixed_warningvoid png_fixed_warning(png_const_structrp png_ptr, png_const_charp msg){   fprintf(stderr, \"overflow in: %s\\n\", msg);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_handle_iCCP(png_structp png_ptr, png_infop info_ptr, png_uint_32 length){   png_charp chunkdata;   png_byte compression_type;   png_bytep pC;   png_charp profile;   png_uint_32 skip = 0;   png_uint_32 profile_size, profile_length;   png_size_t slength, prefix_length, data_length;   png_debug(1, \"in png_handle_iCCP\\n\");   if (!(png_ptr->mode & PNG_HAVE_IHDR))      png_error(png_ptr, \"Missing IHDR before iCCP\");   else if (png_ptr->mode & PNG_HAVE_IDAT)   {      png_warning(png_ptr, \"Invalid iCCP after IDAT\");      png_crc_finish(png_ptr, length);      return;   }   else if (png_ptr->mode & PNG_HAVE_PLTE)            png_warning(png_ptr, \"Out of place iCCP chunk\");   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP))   {      png_warning(png_ptr, \"Duplicate iCCP chunk\");      png_crc_finish(png_ptr, length);      return;   }#ifdef PNG_MAX_MALLOC_64K   if (length > (png_uint_32)65535L)   {      png_warning(png_ptr, \"iCCP chunk too large to fit in memory\");      skip = length - (png_uint_32)65535L;      length = (png_uint_32)65535L;   }#endif   chunkdata = (png_charp)png_malloc(png_ptr, length + 1);   slength = (png_size_t)length;   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);   if (png_crc_finish(png_ptr, skip))   {      png_free(png_ptr, chunkdata);      return;   }   chunkdata[slength] = 0x00;   for (profile = chunkdata; *profile; profile++)       ;   ++profile;      if ( profile >= chunkdata + slength - 1)   {      png_free(png_ptr, chunkdata);      png_warning(png_ptr, \"Malformed iCCP chunk\");      return;   }      compression_type = *profile++;   if (compression_type)   {      png_warning(png_ptr, \"Ignoring nonzero compression type in iCCP chunk\");      compression_type=0x00;     }   prefix_length = profile - chunkdata;   chunkdata = png_decompress_chunk(png_ptr, compression_type, chunkdata,                                    slength, prefix_length, &data_length);   profile_length = data_length - prefix_length;   if ( prefix_length > data_length || profile_length < 4)   {      png_free(png_ptr, chunkdata);      png_warning(png_ptr, \"Profile size field missing from iCCP chunk\");      return;   }      pC = (png_bytep)(chunkdata+prefix_length);   profile_size = ((*(pC  ))<<24) |                  ((*(pC+1))<<16) |                  ((*(pC+2))<< 8) |                  ((*(pC+3))    );   if(profile_size < profile_length)      profile_length = profile_size;   if(profile_size > profile_length)   {      png_free(png_ptr, chunkdata);      png_warning(png_ptr, \"Ignoring truncated iCCP profile.\");      return;   }   png_set_iCCP(png_ptr, info_ptr, chunkdata, compression_type,                chunkdata + prefix_length, profile_length);   png_free(png_ptr, chunkdata);}#endif",
        "label": 1,
        "cve": "cve-2004-0598"
    },
    {
        "code": "static png_uint_32standard_rowsize(png_const_structp pp, png_uint_32 id){   png_uint_32 width = standard_width(pp, id);      width *= bit_size(pp, COL_FROM_ID(id), DEPTH_FROM_ID(id));   return (width + 7) / 8;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static size_tload_file(png_const_charp name, png_bytepp result){   FILE *fp = tmpfile();   if (fp != NULL)   {      FILE *ip = fopen(name, \"rb\");      if (ip != NULL)      {         size_t total = 0;         int ch;         for (;;)         {            ch = getc(ip);            if (ch == EOF) break;            putc(ch, fp);            ++total;         }         if (ferror(ip))         {            perror(name);            fprintf(stderr, \"%s: read error\\n\", name);            (void)fclose(ip);         }         else         {            (void)fclose(ip);            if (ferror(fp))            {               perror(\"temporary file\");               fprintf(stderr, \"temporary file write error\\n\");            }            else            {               rewind(fp);               if (total > 0)               {                                    png_bytep data = malloc((total+3)&~3);                  if (data != NULL)                  {                     size_t new_size = 0;                     for (;;)                     {                        ch = getc(fp);                        if (ch == EOF) break;                        data[new_size++] = (png_byte)ch;                     }                     if (ferror(fp) || new_size != total)                     {                        perror(\"temporary file\");                        fprintf(stderr, \"temporary file read error\\n\");                        free(data);                     }                     else                     {                        (void)fclose(fp);                        *result = data;                        return total;                     }                  }                  else                     fprintf(stderr, \"%s: out of memory loading file\\n\", name);               }               else                  fprintf(stderr, \"%s: empty file\\n\", name);            }         }      }      else      {         perror(name);         fprintf(stderr, \"%s: open failed\\n\", name);      }      fclose(fp);   }   else      fprintf(stderr, \"makepng: %s: could not open temporary file\\n\", name);   exit(1);   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidperform_size_test(png_modifier *pm){      if (!test_size(pm, 0, 0, READ_BDHI))      return;   if (!test_size(pm, 2, 3, READ_BDHI))      return;   #if 0   if (!test_size(pm, 3, 0, 3))      return;#endif   if (!test_size(pm, 4, 3, READ_BDHI))      return;   if (!test_size(pm, 6, 3, READ_BDHI))      return;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGAPIpng_set_iCCP(png_structp png_ptr, png_infop info_ptr,             png_charp name, int compression_type,             png_charp profile, png_uint_32 proflen){   png_charp new_iccp_name;   png_charp new_iccp_profile;   png_debug1(1, \"in %s storage function\\n\", \"iCCP\");   if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL)      return;   new_iccp_name = (png_charp)png_malloc_warn(png_ptr, png_strlen(name)+1);   if (new_iccp_name == NULL)   {      png_warning(png_ptr, \"Insufficient memory to process iCCP chunk.\");      return;   }   png_strcpy(new_iccp_name, name);   new_iccp_profile = (png_charp)png_malloc_warn(png_ptr, proflen);   if (new_iccp_profile == NULL)   {      png_free (png_ptr, new_iccp_name);      png_warning(png_ptr, \"Insufficient memory to process iCCP profile.\");      return;   }   png_memcpy(new_iccp_profile, profile, (png_size_t)proflen);   png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, 0);   info_ptr->iccp_proflen = proflen;   info_ptr->iccp_name = new_iccp_name;   info_ptr->iccp_profile = new_iccp_profile;      info_ptr->iccp_compression = (png_byte)compression_type;#ifdef PNG_FREE_ME_SUPPORTED   info_ptr->free_me |= PNG_FREE_ICCP;#endif   info_ptr->valid |= PNG_INFO_iCCP;}#endif",
        "label": 1,
        "cve": "cve-2007-5266"
    },
    {
        "code": "static intdisplay_rc(const display *d, int strict){   return d->error_count + (strict ? d->warning_count : 0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmodifier_read_imp(png_modifier *pm, png_bytep pb, png_size_t st){   while (st > 0)   {      size_t cb;      png_uint_32 len, chunk;      png_modification *mod;      if (pm->buffer_position >= pm->buffer_count) switch (pm->state)      {         static png_byte sign[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };         case modifier_start:            store_read_imp(&pm->this, pm->buffer, 8);             pm->buffer_count = 8;            pm->buffer_position = 0;            if (memcmp(pm->buffer, sign, 8) != 0)               png_error(pm->this.pread, \"invalid PNG file signature\");            pm->state = modifier_signature;            break;         case modifier_signature:            store_read_imp(&pm->this, pm->buffer, 13+12);             pm->buffer_count = 13+12;            pm->buffer_position = 0;            if (png_get_uint_32(pm->buffer) != 13 ||                png_get_uint_32(pm->buffer+4) != CHUNK_IHDR)               png_error(pm->this.pread, \"invalid IHDR\");                        mod = pm->modifications;            while (mod != NULL)            {               if (mod->chunk == CHUNK_IHDR && mod->modify_fn &&                   (*mod->modify_fn)(pm, mod, 0))                  {                  mod->modified = 1;                  modifier_setbuffer(pm);                  }                              mod = mod->next;            }                        pm->bit_depth = pm->buffer[8+8];            pm->colour_type = pm->buffer[8+8+1];            pm->state = modifier_IHDR;            pm->flush = 0;            break;         case modifier_IHDR:         default:                        if ((cb = pm->flush) > 0)            {               if (cb > st) cb = st;               pm->flush -= cb;               store_read_imp(&pm->this, pb, cb);               pb += cb;               st -= cb;               if (st == 0) return;            }                        if (pm->pending_chunk != 0)            {               png_save_uint_32(pm->buffer, pm->pending_len);               png_save_uint_32(pm->buffer+4, pm->pending_chunk);               pm->pending_len = 0;               pm->pending_chunk = 0;            }            else               store_read_imp(&pm->this, pm->buffer, 8);            pm->buffer_count = 8;            pm->buffer_position = 0;                        len = png_get_uint_32(pm->buffer);            chunk = png_get_uint_32(pm->buffer+4);                        if (chunk == CHUNK_PLTE || chunk == CHUNK_IDAT ||                chunk == CHUNK_IEND)            {               mod = pm->modifications;               while (mod != NULL)               {                  if ((mod->add == chunk ||                      (mod->add == CHUNK_PLTE && chunk == CHUNK_IDAT)) &&                      mod->modify_fn != NULL && !mod->modified && !mod->added)                  {                                          mod->added = 1;                     if ((*mod->modify_fn)(pm, mod, 1 ))                     {                                                if (pm->buffer_count > 0)                           modifier_setbuffer(pm);                        else                           {                           pm->buffer_position = 0;                           mod->removed = 1;                           }                                                pm->pending_len = len;                        pm->pending_chunk = chunk;                        break;                      }                  }                  mod = mod->next;               }                              if (mod != NULL)                  break;             }                        if (len+12 <= sizeof pm->buffer)            {               store_read_imp(&pm->this, pm->buffer+pm->buffer_count,                   len+12-pm->buffer_count);               pm->buffer_count = len+12;                              mod = pm->modifications;               while (mod != NULL)               {                  if (mod->chunk == chunk)                  {                     if (mod->modify_fn == NULL)                     {                                                pm->buffer_count = pm->buffer_position = 0;                        mod->removed = 1;                        break;                      }                     else if ((*mod->modify_fn)(pm, mod, 0))                     {                        mod->modified = 1;                                                if (pm->buffer_count == 0)                        {                           pm->buffer_position = 0;                           break;                        }                        modifier_setbuffer(pm);                     }                  }                  mod = mod->next;               }            }            else               pm->flush = len+12 - pm->buffer_count;                         break;      }            cb = pm->buffer_count - pm->buffer_position;      if (cb > st)         cb = st;      memcpy(pb, pm->buffer + pm->buffer_position, cb);      st -= cb;      pb += cb;      pm->buffer_position += cb;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "png_charp PNGAPIpng_convert_to_rfc1123(png_structp png_ptr, png_timep ptime){   static PNG_CONST char short_months[12][4] =        {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",         \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};   if (png_ptr == NULL)      return (NULL);   if (png_ptr->time_buffer == NULL)   {      png_ptr->time_buffer = (png_charp)png_malloc(png_ptr, (png_uint_32)(29*         png_sizeof(char)));   }#ifdef USE_FAR_KEYWORD   {      char near_time_buf[29];      png_snprintf6(near_time_buf, 29, \"%d %s %d %02d:%02d:%02d +0000\",          ptime->day % 32, short_months[(ptime->month - 1) % 12],          ptime->year, ptime->hour % 24, ptime->minute % 60,          ptime->second % 61);      png_memcpy(png_ptr->time_buffer, near_time_buf,          29*png_sizeof(char));   }#else   png_snprintf6(png_ptr->time_buffer, 29, \"%d %s %d %02d:%02d:%02d +0000\",       ptime->day % 32, short_months[(ptime->month - 1) % 12],       ptime->year, ptime->hour % 24, ptime->minute % 60,       ptime->second % 61);#endif   return ((png_charp)png_ptr->time_buffer);}#endif ",
        "label": 1,
        "cve": "cve-2015-7981"
    },
    {
        "code": "BOOL BuildPngList (PTSTR pstrPathName, TCHAR **ppFileList, int *pFileCount,     int *pFileIndex){    static TCHAR              szImgPathName [MAX_PATH];    static TCHAR              szImgFileName [MAX_PATH];    static TCHAR              szImgFindName [MAX_PATH];    WIN32_FIND_DATA           finddata;    HANDLE                    hFind;    static TCHAR              szTmp [MAX_PATH];    BOOL                      bOk;    int                       i, ii;    int                       j, jj;        if (*ppFileList != NULL)    {        free (*ppFileList);        *ppFileList = NULL;    }        strcpy (szImgPathName, pstrPathName);    strcpy (szImgFileName, strrchr (pstrPathName, '\\\\') + 1);    strcpy (szImgFindName, szImgPathName);    *(strrchr (szImgFindName, '\\\\') + 1) = '\\0';    strcat (szImgFindName, \"*.png\");        *pFileCount = 0;    hFind = FindFirstFile(szImgFindName, &finddata);    bOk = (hFind != (HANDLE) -1);    while (bOk)    {        *pFileCount += 1;        bOk = FindNextFile(hFind, &finddata);    }    FindClose(hFind);        *ppFileList = (TCHAR *) malloc (*pFileCount * MAX_PATH);        hFind = FindFirstFile(szImgFindName, &finddata);    bOk = (hFind != (HANDLE) -1);    i = 0;    ii = 0;    while (bOk)    {        strcpy (*ppFileList + ii, szImgPathName);        strcpy (strrchr(*ppFileList + ii, '\\\\') + 1, finddata.cFileName);        if (strcmp(pstrPathName, *ppFileList + ii) == 0)            *pFileIndex = i;        ii += MAX_PATH;        i++;        bOk = FindNextFile(hFind, &finddata);    }    FindClose(hFind);        for (i = 0; i < *pFileCount - 1; i++)    {        ii = i * MAX_PATH;        for (j = i+1; j < *pFileCount; j++)        {            jj = j * MAX_PATH;            if (strcmp (*ppFileList + ii, *ppFileList + jj) > 0)            {                strcpy (szTmp, *ppFileList + jj);                strcpy (*ppFileList + jj, *ppFileList + ii);                strcpy (*ppFileList + ii, szTmp);                                if (*pFileIndex == i)                    *pFileIndex = j;                else                    if (*pFileIndex == j)                        *pFileIndex = i;            }        }    }    return TRUE;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intmake_errors(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,    int bdlo, int PNG_CONST bdhi){   for (; bdlo <= bdhi; ++bdlo)   {      int interlace_type;      for (interlace_type = PNG_INTERLACE_NONE;           interlace_type < INTERLACE_LAST; ++interlace_type)      {         unsigned int test;         char name[FILE_NAME_SIZE];         standard_name(name, sizeof name, 0, colour_type, 1<<bdlo, 0,            interlace_type, 0, 0, 0);         for (test=0; test<ARRAY_SIZE(error_test); ++test)         {            make_error(&pm->this, colour_type, DEPTH(bdlo), interlace_type,               test, name);            if (fail(pm))               return 0;         }      }   }   return 1; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidperform_gamma_composition_tests(png_modifier *pm, int do_background,   int expand_16){   png_byte colour_type = 0;   png_byte bit_depth = 0;   unsigned int palette_number = 0;      while (next_format(&colour_type, &bit_depth, &palette_number, 1))      if ((colour_type & PNG_COLOR_MASK_ALPHA) != 0)   {      unsigned int i, j;            for (i=0; i<pm->ngamma_tests; ++i) for (j=0; j<pm->ngamma_tests; ++j)      {         gamma_composition_test(pm, colour_type, bit_depth, palette_number,            pm->interlace_type, 1/pm->gammas[i], pm->gammas[j],            pm->use_input_precision, do_background, expand_16);         if (fail(pm))            return;      }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_freebuffer(png_store_buffer* psb){   if (psb->prev)   {      store_freebuffer(psb->prev);      free(psb->prev);      psb->prev = NULL;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int main(int argc, char **argv){   int ok = 0;   FILE *fp = tmpfile();   if (fp != NULL)   {      int err = 0;      int nfiles = 0;      if (argc > 1)      {         int i;         for (i=1; i<argc; ++i)         {            if (add_one_file(fp, argv[i]))               ++nfiles;            else            {               err = 1;               break;            }         }      }      else      {         char filename[FILENAME_MAX+1];         while (fgets(filename, FILENAME_MAX+1, stdin))         {            size_t len = strlen(filename);            if (filename[len-1] == '\\n')            {               filename[len-1] = 0;               if (add_one_file(fp, filename))                  ++nfiles;               else               {                  err = 1;                  break;               }            }            else            {               fprintf(stderr, \"timepng: truncated file name ...%s\\n\",                  filename+len-32);               err = 1;               break;            }         }         if (ferror(stdin))         {            fprintf(stderr, \"timepng: stdin: read error\\n\");            err = 1;         }      }      if (!err)      {         if (nfiles > 0)            ok = perform_one_test(fp, nfiles);         else            fprintf(stderr, \"usage: timepng {files} or ls files | timepng\\n\");      }      (void)fclose(fp);   }   else      fprintf(stderr, \"timepng: could not open temporary file\\n\");      return ok == 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#endifstatic int format_isset(format_list *pf, png_uint_32 format){   return format < FORMAT_COUNT &&      (pf->bits[format >> 5] & (((png_uint_32)1) << (format & 31))) != 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intbuffer_from_file(struct buffer *buffer, FILE *fp){   struct buffer_list *last = &buffer->first;   size_t count = 0;   for (;;)   {      size_t r = fread(last->buffer+count, 1,         (sizeof last->buffer)-count, fp);      if (r > 0)      {         count += r;         if (count >= sizeof last->buffer)         {            assert(count == sizeof last->buffer);            count = 0;            if (last->next == NULL)            {               last = buffer_extend(last);               if (last == NULL)                  return MEMORY;            }            else               last = last->next;         }      }      else       {         if (feof(fp))         {            buffer->last = last;            buffer->end_count = count;            return 0;          }                  return errno == 0 ? ERANGE : errno;      }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intancillaryb(const png_byte *name){   return PNG_CHUNK_ANCILLARY(PNG_U32(name[0], name[1], name[2], name[3]));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_push_read_zTXt(png_structp png_ptr, png_infop info_ptr){   if (png_ptr->buffer_size && png_ptr->current_text_left)   {      png_size_t text_size;      if (png_ptr->buffer_size < (png_uint_32)png_ptr->current_text_left)         text_size = png_ptr->buffer_size;      else         text_size = png_ptr->current_text_left;      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);      png_ptr->current_text_left -= text_size;      png_ptr->current_text_ptr += text_size;   }   if (!(png_ptr->current_text_left))   {      png_textp text_ptr;      png_charp text;      png_charp key;      int ret;      png_size_t text_size, key_size;      if (png_ptr->buffer_size < 4)      {         png_push_save_buffer(png_ptr);         return;      }      png_push_crc_finish(png_ptr);      key = png_ptr->current_text;      for (text = key; *text; text++)          ;            if (text >= key + png_ptr->current_text_size)      {         png_ptr->current_text = NULL;         png_free(png_ptr, key);         return;      }      text++;      if (*text != PNG_TEXT_COMPRESSION_zTXt)       {         png_ptr->current_text = NULL;         png_free(png_ptr, key);         return;      }      text++;      png_ptr->zstream.next_in = (png_bytep)text;      png_ptr->zstream.avail_in = (uInt)(png_ptr->current_text_size -          (text - key));      png_ptr->zstream.next_out = png_ptr->zbuf;      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;      key_size = text - key;      text_size = 0;      text = NULL;      ret = Z_STREAM_END;      while (png_ptr->zstream.avail_in)      {         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);         if (ret != Z_OK && ret != Z_STREAM_END)         {            inflateReset(&png_ptr->zstream);            png_ptr->zstream.avail_in = 0;            png_ptr->current_text = NULL;            png_free(png_ptr, key);            png_free(png_ptr, text);            return;         }         if (!(png_ptr->zstream.avail_out) || ret == Z_STREAM_END)         {            if (text == NULL)            {               text = (png_charp)png_malloc(png_ptr,                   (png_ptr->zbuf_size                   - png_ptr->zstream.avail_out + key_size + 1));               png_memcpy(text + key_size, png_ptr->zbuf,                   png_ptr->zbuf_size - png_ptr->zstream.avail_out);               png_memcpy(text, key, key_size);               text_size = key_size + png_ptr->zbuf_size -                   png_ptr->zstream.avail_out;               *(text + text_size) = '\\0';            }            else            {               png_charp tmp;               tmp = text;               text = (png_charp)png_malloc(png_ptr, text_size +                   (png_ptr->zbuf_size                   - png_ptr->zstream.avail_out + 1));               png_memcpy(text, tmp, text_size);               png_free(png_ptr, tmp);               png_memcpy(text + text_size, png_ptr->zbuf,                   png_ptr->zbuf_size - png_ptr->zstream.avail_out);               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;               *(text + text_size) = '\\0';            }            if (ret != Z_STREAM_END)            {               png_ptr->zstream.next_out = png_ptr->zbuf;               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;            }         }         else         {            break;         }         if (ret == Z_STREAM_END)            break;      }      inflateReset(&png_ptr->zstream);      png_ptr->zstream.avail_in = 0;      if (ret != Z_STREAM_END)      {         png_ptr->current_text = NULL;         png_free(png_ptr, key);         png_free(png_ptr, text);         return;      }      png_ptr->current_text = NULL;      png_free(png_ptr, key);      key = text;      text += key_size;      text_ptr = (png_textp)png_malloc(png_ptr,          png_sizeof(png_text));      text_ptr->compression = PNG_TEXT_COMPRESSION_zTXt;      text_ptr->key = key;      text_ptr->itxt_length = 0;      text_ptr->lang = NULL;      text_ptr->lang_key = NULL;      text_ptr->text = text;      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);      png_free(png_ptr, key);      png_free(png_ptr, text_ptr);      if (ret)         png_warning(png_ptr, \"Insufficient memory to store text chunk\");   }}#endif",
        "label": 1,
        "cve": "cve-2012-3425"
    },
    {
        "code": "static intcontrol_end(struct control *control){   return file_end(&control->file);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_freenew(png_store *ps){   store_freebuffer(&ps->new);   ps->writepos = 0;   if (ps->palette != NULL)   {      free(ps->palette);      ps->palette = NULL;      ps->npalette = 0;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidperform_gamma_threshold_tests(png_modifier *pm){   png_byte colour_type = 0;   png_byte bit_depth = 0;   unsigned int palette_number = 0;      while (next_format(&colour_type, &bit_depth, &palette_number, 1))      if (palette_number == 0)   {      double test_gamma = 1.0;      while (test_gamma >= .4)      {                  gamma_threshold_test(pm, colour_type, bit_depth, pm->interlace_type,            test_gamma, 1/test_gamma);         test_gamma *= .95;      }            gamma_threshold_test(pm, colour_type, bit_depth, pm->interlace_type,          .45455, 2.2);      if (fail(pm))         return;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPImakepng_error(png_structp png_ptr, png_const_charp message){   makepng_warning(png_ptr, message);   png_longjmp(png_ptr, 1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int rpng_win_create_window(HINSTANCE hInst, int showmode){    uch *dest;    int extra_width, extra_height;    ulg i, j;    WNDCLASSEX wndclass;    wimage_rowbytes = ((3*image_width + 3L) >> 2) << 2;    if (!(dib = (uch *)malloc(sizeof(BITMAPINFOHEADER) +                              wimage_rowbytes*image_height)))    {        return 4;       }    memset(dib, 0, sizeof(BITMAPINFOHEADER));    bmih = (BITMAPINFOHEADER *)dib;    bmih->biSize = sizeof(BITMAPINFOHEADER);    bmih->biWidth = image_width;    bmih->biHeight = -((long)image_height);    bmih->biPlanes = 1;    bmih->biBitCount = 24;    bmih->biCompression = 0;    wimage_data = dib + sizeof(BITMAPINFOHEADER);    for (j = 0;  j < image_height;  ++j) {        dest = wimage_data + j*wimage_rowbytes;        for (i = image_width;  i > 0;  --i) {            *dest++ = bg_blue;            *dest++ = bg_green;            *dest++ = bg_red;        }    }    memset(&wndclass, 0, sizeof(wndclass));    wndclass.cbSize = sizeof(wndclass);    wndclass.style = CS_HREDRAW | CS_VREDRAW;    wndclass.lpfnWndProc = rpng_win_wndproc;    wndclass.hInstance = hInst;    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);    wndclass.hbrBackground = (HBRUSH)GetStockObject(DKGRAY_BRUSH);    wndclass.lpszMenuName = NULL;    wndclass.lpszClassName = progname;    wndclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);    RegisterClassEx(&wndclass);    extra_width  = 2*(GetSystemMetrics(SM_CXBORDER) +                      GetSystemMetrics(SM_CXDLGFRAME));    extra_height = 2*(GetSystemMetrics(SM_CYBORDER) +                      GetSystemMetrics(SM_CYDLGFRAME)) +                      GetSystemMetrics(SM_CYCAPTION);    global_hwnd = CreateWindow(progname, titlebar, WS_OVERLAPPEDWINDOW,      CW_USEDEFAULT, CW_USEDEFAULT, image_width+extra_width,      image_height+extra_height, NULL, NULL, hInst, NULL);    ShowWindow(global_hwnd, showmode);    UpdateWindow(global_hwnd);    return 0;} ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmodifier_encoding_iterate(png_modifier *pm){   if (!pm->repeat &&       pm->test_uses_encoding)    {      if (pm->test_exhaustive)      {         if (++pm->encoding_counter >= modifier_total_encodings(pm))            pm->encoding_counter = 0;       }      else      {                  if (pm->encoding_counter == 0)            pm->encoding_counter = random_mod(modifier_total_encodings(pm)-1)+1;         else            pm->encoding_counter = 0;      }      if (pm->encoding_counter > 0)         pm->repeat = 1;   }   else if (!pm->repeat)      pm->encoding_counter = 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidbuffer_destroy(struct buffer *buffer){   struct buffer_list *list = buffer->first.next;   buffer_init(buffer);   buffer_destroy_list(list);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGCBAPIwrite_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass){   if (png_ptr == NULL || row_number > PNG_UINT_31_MAX || pass > 7)      return;   fprintf(stdout, \"w\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcheck_error(display *d, png_uint_32 flags, const char *message){   while (flags)   {      png_uint_32 flag = flags & -(png_int_32)flags;      int i = find_by_flag(flag);      fprintf(stderr, \"%s(%s): chunk %s: %s\\n\", d->file, d->test,         chunk_info[i].name, message);      ++(d->error_count);      flags &= ~flag;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidpng_write_data(png_structp png_ptr, png_bytep data, png_size_t length){   png_uint_32 check;   check = fwrite(data, 1, length, (FILE *)(png_ptr->io_ptr));   if (check != length)   {      png_error(png_ptr, \"Write Error\");   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void usage(){  fprintf (stderr, \"PNG2PNM\\n\");  fprintf (stderr, \"   by Willem van Schaik, 1999\\n\");#ifdef __TURBOC__  fprintf (stderr, \"   for Turbo-C and Borland-C compilers\\n\");#else  fprintf (stderr, \"   for Linux (and Unix) compilers\\n\");#endif  fprintf (stderr, \"Usage:  png2pnm [options] <file>.png [<file>.pnm]\\n\");  fprintf (stderr, \"   or:  ... | png2pnm [options]\\n\");  fprintf (stderr, \"Options:\\n\");  fprintf (stderr,     \"   -r[aw]   write pnm-file in binary format (P4/P5/P6) (default)\\n\");  fprintf (stderr, \"   -n[oraw] write pnm-file in ascii format (P1/P2/P3)\\n\");  fprintf (stderr,     \"   -a[lpha] <file>.pgm write PNG alpha channel as pgm-file\\n\");  fprintf (stderr, \"   -h | -?  print this help-information\\n\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intimage_transform_png_set_rgb_to_gray_add(image_transform *this,    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth){   UNUSED(bit_depth)   this->next = *that;   *that = this;   return (colour_type & PNG_COLOR_MASK_COLOR) != 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_sGp(Pixel *out, const Pixel *in, const Background *back){   (void)back;   if (in->a <= 128)   {      out->r = out->g = out->b = 255;      out->a = 0;   }   else   {      out->r = out->g = out->b = sRGB(YfromRGBint(in->r, in->g, in->b)/in->a);      out->a = u8d(in->a / 257.);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static doublegamma_component_compose(int do_background, double input_sample, double alpha,   double background, int *compose){   switch (do_background)   {#ifdef PNG_READ_BACKGROUND_SUPPORTED      case PNG_BACKGROUND_GAMMA_SCREEN:      case PNG_BACKGROUND_GAMMA_FILE:      case PNG_BACKGROUND_GAMMA_UNIQUE:                  if (alpha < 1)         {            if (alpha > 0)            {               input_sample = input_sample * alpha + background * (1-alpha);               if (compose != NULL)                  *compose = 1;            }            else               input_sample = background;         }         break;#endif#ifdef PNG_READ_ALPHA_MODE_SUPPORTED      case ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD:      case ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN:               case ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED:                  if (alpha < 1)         {            if (alpha > 0)            {               input_sample *= alpha;               if (compose != NULL)                  *compose = 1;            }            else               input_sample = 0;         }         break;#endif      default:                  UNUSED(alpha)         UNUSED(background)         UNUSED(compose)         break;   }   return input_sample;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int add_one_file(FILE *fp, char *name){   FILE *ip = fopen(name, \"rb\");   if (ip != NULL)   {      int ch;      for (;;)      {         ch = getc(ip);         if (ch == EOF) break;         putc(ch, fp);      }      if (ferror(ip))      {         perror(name);         fprintf(stderr, \"%s: read error\\n\", name);         return 0;      }      (void)fclose(ip);      if (ferror(fp))      {         perror(\"temporary file\");         fprintf(stderr, \"temporary file write error\\n\");         return 0;      }   }   else   {      perror(name);      fprintf(stderr, \"%s: open failed\\n\", name);      return 0;   }   return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidnormalize_color_encoding(color_encoding *encoding){   PNG_CONST double whiteY = encoding->red.Y + encoding->green.Y +      encoding->blue.Y;   if (whiteY != 1)   {      encoding->red.X /= whiteY;      encoding->red.Y /= whiteY;      encoding->red.Z /= whiteY;      encoding->green.X /= whiteY;      encoding->green.Y /= whiteY;      encoding->green.Z /= whiteY;      encoding->blue.X /= whiteY;      encoding->blue.Y /= whiteY;      encoding->blue.Z /= whiteY;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static unsigned intcomponent(png_const_bytep row, png_uint_32 x, unsigned int c,   unsigned int bit_depth, unsigned int channels){      png_uint_32 bit_offset_hi = bit_depth * ((x >> 6) * channels);   png_uint_32 bit_offset_lo = bit_depth * ((x & 0x3f) * channels + c);   row = (png_const_bytep)(((PNG_CONST png_byte (*)[8])row) + bit_offset_hi);   row += bit_offset_lo >> 3;   bit_offset_lo &= 0x07;      switch (bit_depth)   {      case 1: return (row[0] >> (7-bit_offset_lo)) & 0x01;      case 2: return (row[0] >> (6-bit_offset_lo)) & 0x03;      case 4: return (row[0] >> (4-bit_offset_lo)) & 0x0f;      case 8: return row[0];      case 16: return (row[0] << 8) + row[1];      default:                  fprintf(stderr, \"pngpixel: invalid bit depth %u\\n\", bit_depth);         exit(1);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_pixel_convert_PLTE(image_pixel *this){   if (this->colour_type == PNG_COLOR_TYPE_PALETTE)   {      if (this->have_tRNS)      {         this->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;         this->have_tRNS = 0;      }      else         this->colour_type = PNG_COLOR_TYPE_RGB;            this->bit_depth = 8;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "BOOL FillBitmap (        BYTE *pDiData, int cxWinSize, int cyWinSize,        BYTE *pbImage, int cxImgSize, int cyImgSize, int cImgChannels,        BOOL bStretched){    BYTE *pStretchedImage;    BYTE *pImg;    BYTE *src, *dst;    BYTE r, g, b, a;    const int cDIChannels = 3;    WORD wImgRowBytes;    WORD wDIRowBytes;    int cxNewSize, cyNewSize;    int cxImgPos, cyImgPos;    int xImg, yImg;    int xWin, yWin;    int xOld, yOld;    int xNew, yNew;    if (bStretched)    {        cxNewSize = cxWinSize - 2 * MARGIN;        cyNewSize = cyWinSize - 2 * MARGIN;                        if ((cyNewSize * cxImgSize) > (cyImgSize * cxNewSize))        {            cyNewSize = cxNewSize * cyImgSize / cxImgSize;            cxImgPos = MARGIN;            cyImgPos = (cyWinSize - cyNewSize) / 2;        }        else        {            cxNewSize = cyNewSize * cxImgSize / cyImgSize;            cyImgPos = MARGIN;            cxImgPos = (cxWinSize - cxNewSize) / 2;        }        pStretchedImage = malloc (cImgChannels * cxNewSize * cyNewSize);        pImg = pStretchedImage;        for (yNew = 0; yNew < cyNewSize; yNew++)        {            yOld = yNew * cyImgSize / cyNewSize;            for (xNew = 0; xNew < cxNewSize; xNew++)            {                xOld = xNew * cxImgSize / cxNewSize;                r = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld) + 0);                g = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld) + 1);                b = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld) + 2);                *pImg++ = r;                *pImg++ = g;                *pImg++ = b;                if (cImgChannels == 4)                {                    a = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld)                        + 3);                    *pImg++ = a;                }            }        }                wImgRowBytes = cImgChannels * cxNewSize;        wDIRowBytes = (WORD) ((cDIChannels * cxWinSize + 3L) >> 2) << 2;                for (yImg = 0, yWin = cyImgPos; yImg < cyNewSize; yImg++, yWin++)        {            if (yWin >= cyWinSize - cyImgPos)                break;            src = pStretchedImage + yImg * wImgRowBytes;            dst = pDiData + yWin * wDIRowBytes + cxImgPos * cDIChannels;            for (xImg = 0, xWin = cxImgPos; xImg < cxNewSize; xImg++, xWin++)            {                if (xWin >= cxWinSize - cxImgPos)                    break;                r = *src++;                g = *src++;                b = *src++;                *dst++ = b;                 *dst++ = g;                *dst++ = r;                if (cImgChannels == 4)                {                    a = *src++;                }            }        }                if (pStretchedImage != NULL)        {            free (pStretchedImage);            pStretchedImage = NULL;        }    }        else    {                cxImgPos = (cxWinSize - cxImgSize) / 2;        cyImgPos = (cyWinSize - cyImgSize) / 2;                if (cxImgPos < MARGIN)            cxImgPos = MARGIN;        if (cyImgPos < MARGIN)            cyImgPos = MARGIN;                wImgRowBytes = cImgChannels * cxImgSize;        wDIRowBytes = (WORD) ((cDIChannels * cxWinSize + 3L) >> 2) << 2;                for (yImg = 0, yWin = cyImgPos; yImg < cyImgSize; yImg++, yWin++)        {            if (yWin >= cyWinSize - MARGIN)                break;            src = pbImage + yImg * wImgRowBytes;            dst = pDiData + yWin * wDIRowBytes + cxImgPos * cDIChannels;            for (xImg = 0, xWin = cxImgPos; xImg < cxImgSize; xImg++, xWin++)            {                if (xWin >= cxWinSize - MARGIN)                    break;                r = *src++;                g = *src++;                b = *src++;                *dst++ = b;                 *dst++ = g;                *dst++ = r;                if (cImgChannels == 4)                {                    a = *src++;                }            }        }    }    return TRUE;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_expand_16_set(PNG_CONST image_transform *this,    transform_display *that, png_structp pp, png_infop pi){   png_set_expand_16(pp);   this->next->set(this->next, that, pp, pi);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcompare_two_images(Image *a, Image *b, int via_linear,   png_const_colorp background){   ptrdiff_t stridea = a->stride;   ptrdiff_t strideb = b->stride;   png_const_bytep rowa = a->buffer+16;   png_const_bytep rowb = b->buffer+16;   const png_uint_32 width = a->image.width;   const png_uint_32 height = a->image.height;   const png_uint_32 formata = a->image.format;   const png_uint_32 formatb = b->image.format;   const unsigned int a_sample = PNG_IMAGE_SAMPLE_SIZE(formata);   const unsigned int b_sample = PNG_IMAGE_SAMPLE_SIZE(formatb);   int alpha_added, alpha_removed;   int bchannels;   int btoa[4];   png_uint_32 y;   Transform tr;      if (width != b->image.width || height != b->image.height)      return logerror(a, a->file_name, \": width x height changed: \",         b->file_name);      transform_from_formats(&tr, a, b, background, via_linear);      if (!(formata & PNG_FORMAT_FLAG_COLORMAP) &&      (formata & PNG_FORMAT_FLAG_LINEAR))      stridea *= 2;   if (!(formatb & PNG_FORMAT_FLAG_COLORMAP) &&      (formatb & PNG_FORMAT_FLAG_LINEAR))      strideb *= 2;   if (stridea < 0) rowa += (height-1) * (-stridea);   if (strideb < 0) rowb += (height-1) * (-strideb);      if (formata & formatb & PNG_FORMAT_FLAG_COLORMAP)   {            png_const_bytep ppa, ppb;      int match;      png_byte in_use[256], amax = 0, bmax = 0;      memset(in_use, 0, sizeof in_use);      ppa = rowa;      ppb = rowb;            for (y=0, match=1; y<height && match; ++y, ppa += stridea, ppb += strideb)      {         png_uint_32 x;         for (x=0; x<width; ++x)         {            png_byte bval = ppb[x];            png_byte aval = ppa[x];            if (bval > bmax)               bmax = bval;            if (bval != aval)               match = 0;            in_use[aval] = 1;            if (aval > amax)               amax = aval;         }      }            if (match)      {                  png_const_bytep a_cmap = (png_const_bytep)a->colormap;         png_const_bytep b_cmap = (png_const_bytep)b->colormap;         int result = 1;                   tr.is_palette = 1;         for (y=0; y<256; ++y, a_cmap += a_sample, b_cmap += b_sample)            if (in_use[y])         {                        if (y >= a->image.colormap_entries)            {               if ((a->opts & ACCUMULATE) == 0)               {                  char pindex[9];                  sprintf(pindex, \"%lu[%lu]\", (unsigned long)y,                     (unsigned long)a->image.colormap_entries);                  logerror(a, a->file_name, \": bad pixel index: \", pindex);               }               result = 0;            }            else if (y >= b->image.colormap_entries)            {               if ((a->opts & ACCUMULATE) == 0)                  {                  char pindex[9];                  sprintf(pindex, \"%lu[%lu]\", (unsigned long)y,                     (unsigned long)b->image.colormap_entries);                  logerror(b, b->file_name, \": bad pixel index: \", pindex);                  }               result = 0;            }                        else if (!cmppixel(&tr, a_cmap, b_cmap, 0, y))               result = 0;         }                  if (a->opts & ACCUMULATE)         {            tr.error_ptr[0] = tr.error[0];            tr.error_ptr[1] = tr.error[1];            tr.error_ptr[2] = tr.error[2];            tr.error_ptr[3] = tr.error[3];            result = 1;          }         return result;      }            else if ((a->opts & ACCUMULATE) == 0)      {                  if (amax >= a->image.colormap_entries)         {            char pindex[9];            sprintf(pindex, \"%d[%lu]\", amax,               (unsigned long)a->image.colormap_entries);            return logerror(a, a->file_name, \": bad pixel index: \", pindex);         }         else if (bmax >= b->image.colormap_entries)         {            char pindex[9];            sprintf(pindex, \"%d[%lu]\", bmax,               (unsigned long)b->image.colormap_entries);            return logerror(b, b->file_name, \": bad pixel index: \", pindex);         }      }   }      if (!(((formata ^ formatb) & PNG_FORMAT_FLAG_LINEAR) |      (formata & (formatb ^ PNG_FORMAT_FLAG_COLOR) & PNG_FORMAT_FLAG_COLOR)))   {            const png_uint_32 alpha_changed = (formata ^ formatb) &         PNG_FORMAT_FLAG_ALPHA;            alpha_removed = (formata & alpha_changed) != 0;            alpha_added = (formatb & alpha_changed) != 0;            {         int i;         png_byte aloc[4];         png_byte bloc[4];                  (void)component_loc(aloc, formata);         bchannels = component_loc(bloc, formatb);                  for (i=0; i<4; ++i) if (bloc[i] < 4)            btoa[bloc[i]] = aloc[i];          if (alpha_added)            alpha_added = bloc[0];          else            alpha_added = 4;          if (alpha_removed)            alpha_removed = aloc[0];          else            alpha_removed = 4;      }   }   else   {            bchannels = 0;      alpha_removed = alpha_added = 4;      btoa[3] = btoa[2] = btoa[1] = btoa[0] = 4;    }   for (y=0; y<height; ++y, rowa += stridea, rowb += strideb)   {      png_const_bytep ppa, ppb;      png_uint_32 x;      for (x=0, ppa=rowa, ppb=rowb; x<width; ++x)      {         png_const_bytep psa, psb;         if (formata & PNG_FORMAT_FLAG_COLORMAP)            psa = (png_const_bytep)a->colormap + a_sample * *ppa++;         else            psa = ppa, ppa += a_sample;         if (formatb & PNG_FORMAT_FLAG_COLORMAP)            psb = (png_const_bytep)b->colormap + b_sample * *ppb++;         else            psb = ppb, ppb += b_sample;                  if (bchannels)         {                        if (formatb & PNG_FORMAT_FLAG_LINEAR)             {               png_const_uint_16p pua = aligncastconst(png_const_uint_16p, psa);               png_const_uint_16p pub = aligncastconst(png_const_uint_16p, psb);               switch (bchannels)               {                  case 4:                     if (pua[btoa[3]] != pub[3]) break;                  case 3:                     if (pua[btoa[2]] != pub[2]) break;                  case 2:                     if (pua[btoa[1]] != pub[1]) break;                  case 1:                     if (pua[btoa[0]] != pub[0]) break;                     if (alpha_added != 4 && pub[alpha_added] != 65535) break;                     continue;                   default:                     break;                }            }            else if (alpha_removed == 4 || psa[alpha_removed] == 255)            {               switch (bchannels)               {                  case 4:                     if (psa[btoa[3]] != psb[3]) break;                  case 3:                     if (psa[btoa[2]] != psb[2]) break;                  case 2:                     if (psa[btoa[1]] != psb[1]) break;                  case 1:                     if (psa[btoa[0]] != psb[0]) break;                     if (alpha_added != 4 && psb[alpha_added] != 255) break;                     continue;                   default:                     break;                }            }         }                  if (!cmppixel(&tr, psa, psb, x, y) && (a->opts & KEEP_GOING) == 0)            return 0;       }   }      if (a->opts & ACCUMULATE)   {      tr.error_ptr[0] = tr.error[0];      tr.error_ptr[1] = tr.error[1];      tr.error_ptr[2] = tr.error[2];      tr.error_ptr[3] = tr.error[3];   }   return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void readpng_cleanup(int free_image_data){    if (free_image_data && image_data) {        free(image_data);        image_data = NULL;    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#ifdef PNG_READ_GAMMA_SUPPORTEDstatic double abserr(PNG_CONST png_modifier *pm, int in_depth, int out_depth){      if (pm->assume_16_bit_calculations ||      (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)      return pm->maxabs16;   else      return pm->maxabs8;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void (*get_pixel(png_uint_32 format))(Pixel *p, png_const_voidp pb){      if (format & PNG_FORMAT_FLAG_LINEAR)   {      if (format & PNG_FORMAT_FLAG_COLOR)      {#        ifdef PNG_FORMAT_BGR_SUPPORTED            if (format & PNG_FORMAT_FLAG_BGR)            {               if (format & PNG_FORMAT_FLAG_ALPHA)               {#                 ifdef PNG_FORMAT_AFIRST_SUPPORTED                     if (format & PNG_FORMAT_FLAG_AFIRST)                        return gp_abgr16;                     else#                 endif                     return gp_bgra16;               }               else                  return gp_bgr16;            }            else#        endif         {            if (format & PNG_FORMAT_FLAG_ALPHA)            {#              ifdef PNG_FORMAT_AFIRST_SUPPORTED                  if (format & PNG_FORMAT_FLAG_AFIRST)                     return gp_argb16;                  else#              endif                  return gp_rgba16;            }            else               return gp_rgb16;         }      }      else      {         if (format & PNG_FORMAT_FLAG_ALPHA)         {#           ifdef PNG_FORMAT_AFIRST_SUPPORTED               if (format & PNG_FORMAT_FLAG_AFIRST)                  return gp_ag16;               else#           endif               return gp_ga16;         }         else            return gp_g16;      }   }   else   {      if (format & PNG_FORMAT_FLAG_COLOR)      {#        ifdef PNG_FORMAT_BGR_SUPPORTED            if (format & PNG_FORMAT_FLAG_BGR)            {               if (format & PNG_FORMAT_FLAG_ALPHA)               {#                 ifdef PNG_FORMAT_AFIRST_SUPPORTED                     if (format & PNG_FORMAT_FLAG_AFIRST)                        return gp_abgr8;                     else#                 endif                     return gp_bgra8;               }               else                  return gp_bgr8;            }            else#        endif         {            if (format & PNG_FORMAT_FLAG_ALPHA)            {#              ifdef PNG_FORMAT_AFIRST_SUPPORTED                  if (format & PNG_FORMAT_FLAG_AFIRST)                     return gp_argb8;                  else#              endif                  return gp_rgba8;            }            else               return gp_rgb8;         }      }      else      {         if (format & PNG_FORMAT_FLAG_ALPHA)         {#           ifdef PNG_FORMAT_AFIRST_SUPPORTED               if (format & PNG_FORMAT_FLAG_AFIRST)                  return gp_ag8;               else#           endif               return gp_ga8;         }         else            return gp_g8;      }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_bytesRGB(double linear ){   return u8d(255 * sRGB_from_linear(linear));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_push_read_chunk(png_structrp png_ptr, png_inforp info_ptr){   png_uint_32 chunk_name;#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED   int keep; #endif      if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))   {      png_byte chunk_length[4];      png_byte chunk_tag[4];      if (png_ptr->buffer_size < 8)      {         png_push_save_buffer(png_ptr);         return;      }      png_push_fill_buffer(png_ptr, chunk_length, 4);      png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);      png_reset_crc(png_ptr);      png_crc_read(png_ptr, chunk_tag, 4);      png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(chunk_tag);      png_check_chunk_name(png_ptr, png_ptr->chunk_name);      png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;   }   chunk_name = png_ptr->chunk_name;   if (chunk_name == png_IDAT)   {      if (png_ptr->mode & PNG_AFTER_IDAT)         png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;            if (!(png_ptr->mode & PNG_HAVE_IHDR))         png_error(png_ptr, \"Missing IHDR before IDAT\");      else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&          !(png_ptr->mode & PNG_HAVE_PLTE))         png_error(png_ptr, \"Missing PLTE before IDAT\");      png_ptr->mode |= PNG_HAVE_IDAT;      if (!(png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))         if (png_ptr->push_length == 0)            return;      if (png_ptr->mode & PNG_AFTER_IDAT)         png_benign_error(png_ptr, \"Too many IDATs found\");   }   if (chunk_name == png_IHDR)   {      if (png_ptr->push_length != 13)         png_error(png_ptr, \"Invalid IHDR length\");      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_IHDR(png_ptr, info_ptr, png_ptr->push_length);   }   else if (chunk_name == png_IEND)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_IEND(png_ptr, info_ptr, png_ptr->push_length);      png_ptr->process_mode = PNG_READ_DONE_MODE;      png_push_have_end(png_ptr, info_ptr);   }#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED   else if ((keep = png_chunk_unknown_handling(png_ptr, chunk_name)) != 0)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length, keep);      if (chunk_name == png_PLTE)         png_ptr->mode |= PNG_HAVE_PLTE;   }#endif   else if (chunk_name == png_PLTE)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_PLTE(png_ptr, info_ptr, png_ptr->push_length);   }   else if (chunk_name == png_IDAT)   {      png_ptr->idat_size = png_ptr->push_length;      png_ptr->process_mode = PNG_READ_IDAT_MODE;      png_push_have_info(png_ptr, info_ptr);      png_ptr->zstream.avail_out =          (uInt) PNG_ROWBYTES(png_ptr->pixel_depth,          png_ptr->iwidth) + 1;      png_ptr->zstream.next_out = png_ptr->row_buf;      return;   }#ifdef PNG_READ_gAMA_SUPPORTED   else if (png_ptr->chunk_name == png_gAMA)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_gAMA(png_ptr, info_ptr, png_ptr->push_length);   }#endif#ifdef PNG_READ_sBIT_SUPPORTED   else if (png_ptr->chunk_name == png_sBIT)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_sBIT(png_ptr, info_ptr, png_ptr->push_length);   }#endif#ifdef PNG_READ_cHRM_SUPPORTED   else if (png_ptr->chunk_name == png_cHRM)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_cHRM(png_ptr, info_ptr, png_ptr->push_length);   }#endif#ifdef PNG_READ_sRGB_SUPPORTED   else if (chunk_name == png_sRGB)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_sRGB(png_ptr, info_ptr, png_ptr->push_length);   }#endif#ifdef PNG_READ_iCCP_SUPPORTED   else if (png_ptr->chunk_name == png_iCCP)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_iCCP(png_ptr, info_ptr, png_ptr->push_length);   }#endif#ifdef PNG_READ_sPLT_SUPPORTED   else if (chunk_name == png_sPLT)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_sPLT(png_ptr, info_ptr, png_ptr->push_length);   }#endif#ifdef PNG_READ_tRNS_SUPPORTED   else if (chunk_name == png_tRNS)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_tRNS(png_ptr, info_ptr, png_ptr->push_length);   }#endif#ifdef PNG_READ_bKGD_SUPPORTED   else if (chunk_name == png_bKGD)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_bKGD(png_ptr, info_ptr, png_ptr->push_length);   }#endif#ifdef PNG_READ_hIST_SUPPORTED   else if (chunk_name == png_hIST)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_hIST(png_ptr, info_ptr, png_ptr->push_length);   }#endif#ifdef PNG_READ_pHYs_SUPPORTED   else if (chunk_name == png_pHYs)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_pHYs(png_ptr, info_ptr, png_ptr->push_length);   }#endif#ifdef PNG_READ_oFFs_SUPPORTED   else if (chunk_name == png_oFFs)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_oFFs(png_ptr, info_ptr, png_ptr->push_length);   }#endif#ifdef PNG_READ_pCAL_SUPPORTED   else if (chunk_name == png_pCAL)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_pCAL(png_ptr, info_ptr, png_ptr->push_length);   }#endif#ifdef PNG_READ_sCAL_SUPPORTED   else if (chunk_name == png_sCAL)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_sCAL(png_ptr, info_ptr, png_ptr->push_length);   }#endif#ifdef PNG_READ_tIME_SUPPORTED   else if (chunk_name == png_tIME)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_tIME(png_ptr, info_ptr, png_ptr->push_length);   }#endif#ifdef PNG_READ_tEXt_SUPPORTED   else if (chunk_name == png_tEXt)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);   }#endif#ifdef PNG_READ_zTXt_SUPPORTED   else if (chunk_name == png_zTXt)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);   }#endif#ifdef PNG_READ_iTXt_SUPPORTED   else if (chunk_name == png_iTXt)   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);   }#endif   else   {      if (png_ptr->push_length + 4 > png_ptr->buffer_size)      {         png_push_save_buffer(png_ptr);         return;      }      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length,         PNG_HANDLE_CHUNK_AS_DEFAULT);   }   png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;}",
        "label": 1,
        "cve": "cve-2014-0333"
    },
    {
        "code": "static int check_all_characters(checkfp_command *co, checkfp_control c){   int ch;   if (c.cnumber+4 < sizeof co->number) for (ch=0; ch<256; ++ch)   {      if (!check_one_character(co, c, ch))         return 0;   }   return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidbuffer_start_read(struct buffer *buffer){   buffer->current = &buffer->first;   buffer->read_count = 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "doublefsRGB(double l){   return sRGB_from_linear(l/max_input);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_fixed_pointfix(double d){   d = floor(d * PNG_FP_1 + .5);   return (png_fixed_point)d;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static size_tstandard_name_from_id(char *buffer, size_t bufsize, size_t pos, png_uint_32 id){   return standard_name(buffer, bufsize, pos, COL_FROM_ID(id),      DEPTH_FROM_ID(id), PALETTE_FROM_ID(id), INTERLACE_FROM_ID(id),      WIDTH_FROM_ID(id), HEIGHT_FROM_ID(id), DO_INTERLACE_FROM_ID(id));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int format_set(format_list *pf, png_uint_32 format){   if (format < FORMAT_COUNT)      return pf->bits[format >> 5] |= ((png_uint_32)1) << (format & 31);   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_abgr16(Pixel *p, png_const_voidp pb){   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);   p->r = pp[3];   p->g = pp[2];   p->b = pp[1];   p->a = pp[0];}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidsbit_modification_init(sbit_modification *me, png_modifier *pm, png_byte sbit){   modification_init(&me->this);   me->this.chunk = CHUNK_sBIT;   me->this.modify_fn = sbit_modify;   me->this.add = CHUNK_PLTE;   me->sbit = sbit;   me->this.next = pm->modifications;   pm->modifications = &me->this;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static doublechromaticity_x(CIE_color c){   return c.X / (c.X + c.Y + c.Z);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_expand_gray_1_2_4_to_8_mod(    PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp,    PNG_CONST transform_display *display){   image_transform_png_set_expand_mod(this, that, pp, display);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstandard_display_init(standard_display *dp, png_store* ps, png_uint_32 id,   int do_interlace, int use_update_info){   memset(dp, 0, sizeof *dp);   dp->ps = ps;   dp->colour_type = COL_FROM_ID(id);   dp->bit_depth = DEPTH_FROM_ID(id);   if (dp->bit_depth < 1 || dp->bit_depth > 16)      internal_error(ps, \"internal: bad bit depth\");   if (dp->colour_type == 3)      dp->red_sBIT = dp->blue_sBIT = dp->green_sBIT = dp->alpha_sBIT = 8;   else      dp->red_sBIT = dp->blue_sBIT = dp->green_sBIT = dp->alpha_sBIT =         dp->bit_depth;   dp->interlace_type = INTERLACE_FROM_ID(id);   check_interlace_type(dp->interlace_type);   dp->id = id;      dp->w = 0;   dp->h = 0;   dp->npasses = 0;   dp->pixel_size = 0;   dp->bit_width = 0;   dp->cbRow = 0;   dp->do_interlace = do_interlace;   dp->is_transparent = 0;   dp->speed = ps->speed;   dp->use_update_info = use_update_info;   dp->npalette = 0;      memset(&dp->transparent, 0, sizeof dp->transparent);      memset(dp->palette, 0xff, sizeof dp->palette);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIerror_handler(png_structp png_ptr, png_const_charp message){   stop(get_control(png_ptr),  LIBPNG_ERROR_CODE, message);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstandard_row_validate(standard_display *dp, png_const_structp pp,   int iImage, int iDisplay, png_uint_32 y){   int where;   png_byte std[STANDARD_ROWMAX];      memset(std, 178, sizeof std);   standard_row(pp, std, dp->id, y);      if (iImage >= 0 &&      (where = pixel_cmp(std, store_image_row(dp->ps, pp, iImage, y),            dp->bit_width)) != 0)   {      char msg[64];      sprintf(msg, \"PNG image row[%lu][%d] changed from %.2x to %.2x\",         (unsigned long)y, where-1, std[where-1],         store_image_row(dp->ps, pp, iImage, y)[where-1]);      png_error(pp, msg);   }#if PNG_LIBPNG_VER < 10506   #endif   if (iDisplay >= 0 &&      (where = pixel_cmp(std, store_image_row(dp->ps, pp, iDisplay, y),         dp->bit_width)) != 0)   {      char msg[64];      sprintf(msg, \"display  row[%lu][%d] changed from %.2x to %.2x\",         (unsigned long)y, where-1, std[where-1],         store_image_row(dp->ps, pp, iDisplay, y)[where-1]);      png_error(pp, msg);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intnext_format(png_bytep colour_type, png_bytep bit_depth,   unsigned int* palette_number, int no_low_depth_gray){   if (*bit_depth == 0)   {      *colour_type = 0;      if (no_low_depth_gray)         *bit_depth = 8;      else         *bit_depth = 1;      *palette_number = 0;      return 1;   }   if (*colour_type == 3)   {            if (++*palette_number < PALETTE_COUNT(*bit_depth))         return 1;      *palette_number = 0;   }   *bit_depth = (png_byte)(*bit_depth << 1);      if (*bit_depth <= 8#ifdef DO_16BIT         || (*colour_type != 3 && *bit_depth <= 16)#endif      )      return 1;      switch (*colour_type)   {      case 0:         *colour_type = 2;         *bit_depth = 8;         return 1;      case 2:         *colour_type = 3;         *bit_depth = 1;         return 1;      case 3:         *colour_type = 4;         *bit_depth = 8;         return 1;      case 4:         *colour_type = 6;         *bit_depth = 8;         return 1;      default:         return 0;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmake_four_random_bytes(png_uint_32* seed, png_bytep bytes){   make_random_bytes(seed, bytes, 4);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#endifstatic int format_is_initial(format_list *pf){   int i;   for (i=0; i<FORMAT_SET_COUNT; ++i)      if (pf->bits[i] != 0)         return 0;   return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int main(int argc, char *argv[]){  FILE *fp_rd = stdin;  FILE *fp_al = NULL;  FILE *fp_wr = stdout;  BOOL interlace = FALSE;  BOOL alpha = FALSE;  int argi;  for (argi = 1; argi < argc; argi++)  {    if (argv[argi][0] == '-')    {      switch (argv[argi][1])      {        case 'i':          interlace = TRUE;          break;        case 'a':          alpha = TRUE;          argi++;          if ((fp_al = fopen (argv[argi], \"rb\")) == NULL)          {            fprintf (stderr, \"PNM2PNG\\n\");            fprintf (stderr, \"Error:  alpha-channel file %s does not exist\\n\",               argv[argi]);            exit (1);          }          break;        case 'h':        case '?':          usage();          exit(0);          break;        default:          fprintf (stderr, \"PNM2PNG\\n\");          fprintf (stderr, \"Error:  unknown option %s\\n\", argv[argi]);          usage();          exit(1);          break;      }     }    else if (fp_rd == stdin)    {      if ((fp_rd = fopen (argv[argi], \"rb\")) == NULL)      {        fprintf (stderr, \"PNM2PNG\\n\");        fprintf (stderr, \"Error:  file %s does not exist\\n\", argv[argi]);        exit (1);      }    }    else if (fp_wr == stdout)    {      if ((fp_wr = fopen (argv[argi], \"wb\")) == NULL)      {        fprintf (stderr, \"PNM2PNG\\n\");        fprintf (stderr, \"Error:  can not create PNG-file %s\\n\", argv[argi]);        exit (1);      }    }    else    {      fprintf (stderr, \"PNM2PNG\\n\");      fprintf (stderr, \"Error:  too many parameters\\n\");      usage();      exit (1);    }  } #ifdef __TURBOC__    if (fp_rd == stdin)  {    setmode (STDIN, O_BINARY);  }  if (fp_wr == stdout)  {    setmode (STDOUT, O_BINARY);  }#endif    if (pnm2png (fp_rd, fp_wr, fp_al, interlace, alpha) == FALSE)  {    fprintf (stderr, \"PNM2PNG\\n\");    fprintf (stderr, \"Error:  unsuccessful converting to PNG-image\\n\");    exit (1);  }    fclose (fp_rd);    fclose (fp_wr);    if (alpha)    fclose (fp_al);  return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidbad_parameter_count(png_const_charp what, int nparams){   fprintf(stderr, \"--insert %s: bad parameter count %d\\n\", what, nparams);   exit(1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_flush(png_structp png_ptr){   if (png_ptr->output_flush_fn != NULL)      (*(png_ptr->output_flush_fn))(png_ptr);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voiddisplay_clean(struct display *dp){#  ifdef PNG_WRITE_SUPPORTED      display_clean_write(dp);#  endif   display_clean_read(dp);   dp->original_rowbytes = 0;   dp->original_rows = NULL;   dp->chunks = 0;   png_destroy_read_struct(&dp->original_pp, &dp->original_ip, NULL);      dp->results = 0; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidinsert_zTXt(png_structp png_ptr, png_infop info_ptr, int nparams,   png_charpp params){   png_text text;   check_param_count(nparams, 2);   clear_text(&text, params[0]);   text.compression = 0;    set_text(png_ptr, info_ptr, &text, params[1]);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_write_iCCP(png_structp png_ptr, png_const_charp name, int compression_type,    png_const_charp profile, int profile_len){   PNG_iCCP;   png_size_t name_len;   png_charp new_name;   compression_state comp;   int embedded_profile_len = 0;   png_debug(1, \"in png_write_iCCP\");   comp.num_output_ptr = 0;   comp.max_output_ptr = 0;   comp.output_ptr = NULL;   comp.input = NULL;   comp.input_len = 0;   if ((name_len = png_check_keyword(png_ptr, name, &new_name)) == 0)      return;   if (compression_type != PNG_COMPRESSION_TYPE_BASE)      png_warning(png_ptr, \"Unknown compression type in iCCP chunk\");   if (profile == NULL)      profile_len = 0;   if (profile_len > 3)      embedded_profile_len =          ((*( (png_const_bytep)profile    ))<<24) |          ((*( (png_const_bytep)profile + 1))<<16) |          ((*( (png_const_bytep)profile + 2))<< 8) |          ((*( (png_const_bytep)profile + 3))    );   if (embedded_profile_len < 0)   {      png_warning(png_ptr,          \"Embedded profile length in iCCP chunk is negative\");      png_free(png_ptr, new_name);      return;   }   if (profile_len < embedded_profile_len)   {      png_warning(png_ptr,          \"Embedded profile length too large in iCCP chunk\");      png_free(png_ptr, new_name);      return;   }   if (profile_len > embedded_profile_len)   {      png_warning(png_ptr,          \"Truncating profile to actual length in iCCP chunk\");      profile_len = embedded_profile_len;   }   if (profile_len)      profile_len = png_text_compress(png_ptr, profile,          (png_size_t)profile_len, PNG_COMPRESSION_TYPE_BASE, &comp);      png_write_chunk_start(png_ptr, png_iCCP,       (png_uint_32)(name_len + profile_len + 2));   new_name[name_len + 1] = 0x00;   png_write_chunk_data(png_ptr, (png_bytep)new_name,       (png_size_t)(name_len + 2));   if (profile_len)      png_write_compressed_data_out(png_ptr, &comp);   png_write_chunk_end(png_ptr);   png_free(png_ptr, new_name);}#endif",
        "label": 1,
        "cve": "cve-2009-5063"
    },
    {
        "code": "static voidinit_sRGB_to_d(void){   int i;   sRGB_to_d[0] = 0;   for (i=1; i<255; ++i)      sRGB_to_d[i] = linear_from_sRGB(i/255.);   sRGB_to_d[255] = 1;   g22_to_d[0] = 0;   for (i=1; i<255; ++i)      g22_to_d[i] = pow(i/255., 1/.45455);   g22_to_d[255] = 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int rpng_win_display_image(){    uch *src, *dest;    uch r, g, b, a;    ulg i, row, lastrow;    RECT rect;    Trace((stderr, \"beginning display loop (image_channels == %d)\\n\",      image_channels))    Trace((stderr, \"(width = %ld, rowbytes = %ld, wimage_rowbytes = %d)\\n\",      image_width, image_rowbytes, wimage_rowbytes))    for (lastrow = row = 0;  row < image_height;  ++row) {        src = image_data + row*image_rowbytes;        dest = wimage_data + row*wimage_rowbytes;        if (image_channels == 3) {            for (i = image_width;  i > 0;  --i) {                r = *src++;                g = *src++;                b = *src++;                *dest++ = b;                *dest++ = g;                   *dest++ = r;            }        } else  {            for (i = image_width;  i > 0;  --i) {                r = *src++;                g = *src++;                b = *src++;                a = *src++;                if (a == 255) {                    *dest++ = b;                    *dest++ = g;                    *dest++ = r;                } else if (a == 0) {                    *dest++ = bg_blue;                    *dest++ = bg_green;                    *dest++ = bg_red;                } else {                                        alpha_composite(*dest++, b, a, bg_blue);                    alpha_composite(*dest++, g, a, bg_green);                    alpha_composite(*dest++, r, a, bg_red);                }            }        }                if (((row+1) & 0xf) == 0) {            rect.left = 0L;            rect.top = (LONG)lastrow;            rect.right = (LONG)image_width;                  rect.bottom = (LONG)lastrow + 16L;               InvalidateRect(global_hwnd, &rect, FALSE);            UpdateWindow(global_hwnd);                 lastrow = row + 1;        }    }    Trace((stderr, \"calling final image-flush routine\\n\"))    if (lastrow < image_height) {        rect.left = 0L;        rect.top = (LONG)lastrow;        rect.right = (LONG)image_width;              rect.bottom = (LONG)image_height;            InvalidateRect(global_hwnd, &rect, FALSE);        UpdateWindow(global_hwnd);         }    return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_16ilinear_g22(int fixed_srgb){   return u16d(65535 * g22_to_d[fixed_srgb]);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static unsigned intsample(png_const_bytep row, png_byte colour_type, png_byte bit_depth,    png_uint_32 x, unsigned int sample_index){   png_uint_32 bit_index, result;      x *= bit_depth;   bit_index = x;   if ((colour_type & 1) == 0)    {      if (colour_type & 2)         bit_index *= 3;      if (colour_type & 4)         bit_index += x;             if (colour_type & (2+4))         bit_index += sample_index * bit_depth;   }      row += bit_index >> 3;   result = *row;   if (bit_depth == 8)      return result;   else if (bit_depth > 8)      return (result << 8) + *++row;      bit_index &= 7;   return (result >> (8-bit_index-bit_depth)) & ((1U<<bit_depth)-1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidprint_pixel(char string[64], const Pixel *pixel, png_uint_32 format){   switch (format & (PNG_FORMAT_FLAG_ALPHA|PNG_FORMAT_FLAG_COLOR))   {      case 0:         sprintf(string, \"%s(%d)\", format_names[format], pixel->g);         break;      case PNG_FORMAT_FLAG_ALPHA:         sprintf(string, \"%s(%d,%d)\", format_names[format], pixel->g,            pixel->a);         break;      case PNG_FORMAT_FLAG_COLOR:         sprintf(string, \"%s(%d,%d,%d)\", format_names[format],            pixel->r, pixel->g, pixel->b);         break;      case PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_ALPHA:         sprintf(string, \"%s(%d,%d,%d,%d)\", format_names[format],            pixel->r, pixel->g, pixel->b, pixel->a);         break;      default:         sprintf(string, \"invalid-format\");         break;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidpng_handle_tRNS(png_structp png_ptr, png_infop info_ptr, png_uint_32 length){   png_debug(1, \"in png_handle_tRNS\\n\");   if (!(png_ptr->mode & PNG_HAVE_IHDR))      png_error(png_ptr, \"Missing IHDR before tRNS\");   else if (png_ptr->mode & PNG_HAVE_IDAT)   {      png_warning(png_ptr, \"Invalid tRNS after IDAT\");      png_crc_finish(png_ptr, length);      return;   }   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_tRNS)   {      png_warning(png_ptr, \"Duplicate tRNS chunk\");      png_crc_finish(png_ptr, length);      return;   }   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)   {      if (!(png_ptr->mode & PNG_HAVE_PLTE))      {                  png_warning(png_ptr, \"Missing PLTE before tRNS\");      }      else if (length > png_ptr->num_palette)      {         png_warning(png_ptr, \"Incorrect tRNS chunk length\");         png_crc_finish(png_ptr, length);         return;      }      png_ptr->trans = (png_bytep)png_malloc(png_ptr, length);      png_ptr->flags |= PNG_FLAG_FREE_TRANS;      png_crc_read(png_ptr, png_ptr->trans, (png_size_t)length);      png_ptr->num_trans = (png_uint_16)length;   }   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)   {      png_byte buf[6];      if (length != 6)      {         png_warning(png_ptr, \"Incorrect tRNS chunk length\");         png_crc_finish(png_ptr, length);         return;      }      png_crc_read(png_ptr, buf, (png_size_t)length);      png_ptr->num_trans = 1;      png_ptr->trans_values.red = png_get_uint_16(buf);      png_ptr->trans_values.green = png_get_uint_16(buf + 2);      png_ptr->trans_values.blue = png_get_uint_16(buf + 4);   }   else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)   {      png_byte buf[6];      if (length != 2)      {         png_warning(png_ptr, \"Incorrect tRNS chunk length\");         png_crc_finish(png_ptr, length);         return;      }      png_crc_read(png_ptr, buf, 2);      png_ptr->num_trans = 1;      png_ptr->trans_values.gray = png_get_uint_16(buf);   }   else   {      png_warning(png_ptr, \"tRNS chunk not allowed with alpha channel\");      png_crc_finish(png_ptr, length);      return;   }   if (png_crc_finish(png_ptr, 0))      return;   png_set_tRNS(png_ptr, info_ptr, png_ptr->trans, png_ptr->num_trans,      &(png_ptr->trans_values));}#endif",
        "label": 1,
        "cve": "cve-2004-0597-1"
    },
    {
        "code": "static voiddisplay_destroy(struct display *dp){    #  ifdef PNG_WRITE_SUPPORTED      buffer_destroy(&dp->written_file);#  endif   buffer_destroy(&dp->original_file);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "LRESULT CALLBACK rpng2_win_wndproc(HWND hwnd, UINT iMsg, WPARAM wP, LPARAM lP){    HDC         hdc;    PAINTSTRUCT ps;    int rc;    switch (iMsg) {        case WM_CREATE:                        return 0;        case WM_PAINT:            hdc = BeginPaint(hwnd, &ps);            rc = StretchDIBits(hdc, 0, 0, rpng2_info.width, rpng2_info.height,                                    0, 0, rpng2_info.width, rpng2_info.height,                                    wimage_data, (BITMAPINFO *)bmih,                                    0, SRCCOPY);            EndPaint(hwnd, &ps);            return 0;                case WM_CHAR:            switch (wP) {                       case 'q':                case 'Q':                case 0x1B:                          PostQuitMessage(0);            }            return 0;        case WM_LBUTTONDOWN:            case WM_DESTROY:            PostQuitMessage(0);            return 0;    }    return DefWindowProc(hwnd, iMsg, wP, lP);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32crc_init_4(png_uint_32 value){      png_uint_32 crc = crc_table[(~value >> 24)] ^ 0xffffff;   crc = crc_table[(crc ^ (value >> 16)) & 0xff] ^ (crc >> 8);   crc = crc_table[(crc ^ (value >> 8)) & 0xff] ^ (crc >> 8);   return crc_table[(crc ^ value) & 0xff] ^ (crc >> 8);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static size_tstore_read_buffer_avail(png_store *ps){   if (ps->current != NULL && ps->next != NULL)   {      png_store_buffer *next = &ps->current->data;      size_t cbAvail = ps->current->datacount;      while (next != ps->next && next != NULL)      {         next = next->prev;         cbAvail += STORE_BUFFER_SIZE;      }      if (next != ps->next)         png_error(ps->pread, \"buffer read error\");      if (cbAvail > ps->readpos)         return cbAvail - ps->readpos;   }   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_modifier pm;static void signal_handler(int signum){   size_t pos = 0;   char msg[64];   pos = safecat(msg, sizeof msg, pos, \"caught signal: \");   switch (signum)   {      case SIGABRT:         pos = safecat(msg, sizeof msg, pos, \"abort\");         break;      case SIGFPE:         pos = safecat(msg, sizeof msg, pos, \"floating point exception\");         break;      case SIGILL:         pos = safecat(msg, sizeof msg, pos, \"illegal instruction\");         break;      case SIGINT:         pos = safecat(msg, sizeof msg, pos, \"interrupt\");         break;      case SIGSEGV:         pos = safecat(msg, sizeof msg, pos, \"invalid memory access\");         break;      case SIGTERM:         pos = safecat(msg, sizeof msg, pos, \"termination request\");         break;      default:         pos = safecat(msg, sizeof msg, pos, \"unknown \");         pos = safecatn(msg, sizeof msg, pos, signum);         break;   }   store_log(&pm.this, NULL, msg, 1);      if (signum != SIGTERM)   {      struct exception_context *the_exception_context =         &pm.this.exception_context;      Throw &pm.this;   }   else      exit(1);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_glin(Pixel *out, const Pixel *in, const Background *back){   (void)back;   if (in->r == in->g && in->g == in->b)      out->r = out->g = out->b = ilinear(in->g);   else      out->r = out->g = out->b = u16d(65535 *         YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));   out->a = 65535;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static store_palette_entry *store_current_palette(png_store *ps, int *npalette){      if (ps->current == NULL)      store_log(ps, ps->pread, \"no current stream for palette\", 1);      *npalette = ps->current->npalette;   return ps->current->palette;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_g16q(Pixel *out, const Pixel *in, const Background *back){   (void)back;   out->r = out->g = out->b = u16d(YfromRGBint(in->r, in->g, in->b));   out->a = in->a;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(void){   unsigned int i;   unsigned char buf[MAX_LENGTH];   unsigned long crc;   unsigned char c;   int inchar;   for (i=8; i; i--)   {      c=GETBREAK;      putchar(c);   }if (inchar != EOF)for (;;) {      unsigned long length;    c=GETBREAK; buf[0] = c; length  = c; length <<= 8;   c=GETBREAK; buf[1] = c; length += c; length <<= 8;   c=GETBREAK; buf[2] = c; length += c; length <<= 8;   c=GETBREAK; buf[3] = c; length += c;      c=GETBREAK; buf[4] = c;   c=GETBREAK; buf[5] = c;   c=GETBREAK; buf[6] = c;   c=GETBREAK; buf[7] = c;      if (buf[4] == 105 && buf[5] == 84 && buf[6] == 88 && buf[7] == 116)   {      if (length >= MAX_LENGTH-12)         break;              crc = crc32(0, Z_NULL, 0);            for (i=8; i < length + 12; i++)      {         c=GETBREAK; buf[i] = c;      }            crc = crc32(crc, buf+4, (uInt)length+4);      for (;;)      {                if (((crc >> 24) & 0xff) == buf[length+8] &&            ((crc >> 16) & 0xff) == buf[length+9] &&            ((crc >>  8) & 0xff) == buf[length+10] &&            ((crc      ) & 0xff) == buf[length+11])           break;        length++;        if (length >= MAX_LENGTH-12)           break;        c=GETBREAK;        buf[length+11]=c;                crc = crc32(crc, buf+7+length, 1);      }            buf[0] = (unsigned char)((length << 24) & 0xff);      buf[1] = (unsigned char)((length << 16) & 0xff);      buf[2] = (unsigned char)((length <<  8) & 0xff);      buf[3] = (unsigned char)((length      ) & 0xff);            for (i=0; i<length+12; i++)         putchar(buf[i]);   }   else   {            for (i=0; i<8; i++)         putchar(buf[i]);            for (i=8; i< length+12; i++)      {         c=GETBREAK;         putchar(c);      }      if (inchar == EOF)      {         break;      }         if (buf[4] == 73 && buf[5] == 69 && buf[6] == 78 && buf[7] == 68)         break;   }   if (inchar == EOF)      break;   if (buf[4] == 73 && buf[5] == 69 && buf[6] == 78 && buf[7] == 68)     break; } return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static chunk_insert *find_insert(png_const_charp what, png_charp param){   png_uint_32 chunk = 0;   png_charp parameter_list[1024];   int i, nparams;      for (i=0; i<4; ++i)   {      char ch = what[i];      if ((ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122))         chunk = (chunk << 8) + what[i];      else         break;   }   if (i < 4 || what[4] != 0)   {      fprintf(stderr, \"makepng --insert \\\"%s\\\": invalid chunk name\\n\", what);      exit(1);   }      nparams = find_parameters(what, param, parameter_list, 1024);#  define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d))   switch (chunk)   {      case CHUNK(105,67,67,80):           if (nparams == 2)            return make_insert(what, insert_iCCP, nparams, parameter_list);         break;      case CHUNK(116,69,88,116):          if (nparams == 2)            return make_insert(what, insert_tEXt, nparams, parameter_list);         break;      case CHUNK(122,84,88,116):          if (nparams == 2)            return make_insert(what, insert_zTXt, nparams, parameter_list);         break;      case CHUNK(105,84,88,116):          if (nparams == 4)            return make_insert(what, insert_iTXt, nparams, parameter_list);         break;      case CHUNK(104,73,83,84):           if (nparams <= 256)            return make_insert(what, insert_hIST, nparams, parameter_list);         break;#if 0      case CHUNK(115,80,76,84):           return make_insert(what, insert_sPLT, nparams, parameter_list);#endif      default:         fprintf(stderr, \"makepng --insert \\\"%s\\\": unrecognized chunk name\\n\",            what);         exit(1);   }   bad_parameter_count(what, nparams);   return NULL;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int validation_checkfp(int count, int argc, char **argv){   int result;   checkfp_command command;   checkfp_control control;   command.number[0] = 0;   command.limit = 3;   command.verbose = verbose;   command.ctimes = 0;   command.cmillions = 0;   command.cinvalid = 0;   command.cnoaccept = 0;   while (--argc > 0)   {      ++argv;      if (argc > 1 && strcmp(*argv, \"-l\") == 0)      {         --argc;         command.limit = atoi(*++argv);      }      else      {         fprintf(stderr, \"unknown argument %s\\n\", *argv);         return 1;      }   }   control.cnumber = 0;   control.check_state = start;   control.at_start = 1;   control.cdigits_in_state = 0;   control.limit = command.limit;   control.state = 0;   control.is_negative = 0;   control.is_zero = 1;   control.number_was_valid = 0;   result = check_all_characters(&command, control);   printf(\"checkfp: %s: checked %d,%.3d,%.3d,%.3d strings (%d invalid)\\n\",      result ? \"pass\" : \"FAIL\", command.cmillions / 1000,      command.cmillions % 1000, command.ctimes / 1000, command.ctimes % 1000,      command.cinvalid);   return result;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static store_palette_entry *make_standard_palette(png_store* ps, int npalette, int do_tRNS){   static png_uint_32 palette_seed[2] = { 0x87654321, 9 };   int i = 0;   png_byte values[256][4];      for (; i<8; ++i)   {      values[i][1] = (png_byte)((i&1) ? 255U : 0U);      values[i][2] = (png_byte)((i&2) ? 255U : 0U);      values[i][3] = (png_byte)((i&4) ? 255U : 0U);   }      {      int j = 0;      png_byte random_bytes[4];      png_byte need[256];      need[0] = 0;       memset(need+1, 1, (sizeof need)-2);       need[255] = 0;       while (i<70)      {         png_byte b;         if (j==0)         {            make_four_random_bytes(palette_seed, random_bytes);            j = 4;         }         b = random_bytes[--j];         if (need[b])         {            values[i][1] = b;            values[i][2] = b;            values[i++][3] = b;         }      }   }      for (; i<256; ++i)      make_four_random_bytes(palette_seed, values[i]);      {      store_palette_entry *palette;      png_byte selector[4];      make_four_random_bytes(palette_seed, selector);      if (do_tRNS)         for (i=0; i<256; ++i)            values[i][0] = (png_byte)(i ^ selector[0]);      else         for (i=0; i<256; ++i)            values[i][0] = 255;             palette = store_write_palette(ps, npalette);      for (i=0; i<npalette; ++i)      {         palette[i].alpha = values[i ^ selector[1]][0];         palette[i].red   = values[i ^ selector[1]][1];         palette[i].green = values[i ^ selector[1]][2];         palette[i].blue  = values[i ^ selector[1]][3];      }      return palette;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "uch *readpng_get_image(double display_exponent, int *pChannels, ulg *pRowbytes){    ulg  rowbytes;            *pRowbytes = rowbytes = channels*width;    *pChannels = channels;    if ((image_data = (uch *)malloc(rowbytes*height)) == NULL) {        return NULL;    }    Trace((stderr, \"readpng_get_image:  rowbytes = %ld, height = %ld\\n\", rowbytes, height));        fread(image_data, 1L, rowbytes*height, saved_infile);    return image_data;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int rpng2_win_create_window(){    uch bg_red   = rpng2_info.bg_red;    uch bg_green = rpng2_info.bg_green;    uch bg_blue  = rpng2_info.bg_blue;    uch *dest;    int extra_width, extra_height;    ulg i, j;    WNDCLASSEX wndclass;    RECT rect;    wimage_rowbytes = ((3*rpng2_info.width + 3L) >> 2) << 2;    if (!(dib = (uch *)malloc(sizeof(BITMAPINFOHEADER) +                              wimage_rowbytes*rpng2_info.height)))    {        return 4;       }    memset(dib, 0, sizeof(BITMAPINFOHEADER));    bmih = (BITMAPINFOHEADER *)dib;    bmih->biSize = sizeof(BITMAPINFOHEADER);    bmih->biWidth = rpng2_info.width;    bmih->biHeight = -((long)rpng2_info.height);    bmih->biPlanes = 1;    bmih->biBitCount = 24;    bmih->biCompression = 0;    wimage_data = dib + sizeof(BITMAPINFOHEADER);    if (bg_image) {           memset(wimage_data, 0, wimage_rowbytes*rpng2_info.height);    } else {        for (j = 0;  j < rpng2_info.height;  ++j) {            dest = wimage_data + j*wimage_rowbytes;            for (i = rpng2_info.width;  i > 0;  --i) {                *dest++ = bg_blue;                *dest++ = bg_green;                *dest++ = bg_red;            }        }    }    memset(&wndclass, 0, sizeof(wndclass));    wndclass.cbSize = sizeof(wndclass);    wndclass.style = CS_HREDRAW | CS_VREDRAW;    wndclass.lpfnWndProc = rpng2_win_wndproc;    wndclass.hInstance = global_hInst;    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);    wndclass.hbrBackground = (HBRUSH)GetStockObject(DKGRAY_BRUSH);    wndclass.lpszMenuName = NULL;    wndclass.lpszClassName = progname;    wndclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);    RegisterClassEx(&wndclass);    extra_width  = 2*(GetSystemMetrics(SM_CXBORDER) +                      GetSystemMetrics(SM_CXDLGFRAME));    extra_height = 2*(GetSystemMetrics(SM_CYBORDER) +                      GetSystemMetrics(SM_CYDLGFRAME)) +                      GetSystemMetrics(SM_CYCAPTION);    global_hwnd = CreateWindow(progname, titlebar, WS_OVERLAPPEDWINDOW,      CW_USEDEFAULT, CW_USEDEFAULT, rpng2_info.width+extra_width,      rpng2_info.height+extra_height, NULL, NULL, global_hInst, NULL);    ShowWindow(global_hwnd, global_showmode);    UpdateWindow(global_hwnd);    if (bg_image) {        static const char *msg = \"Computing background image...\";        int x, y, len = strlen(msg);        HDC hdc = GetDC(global_hwnd);        TEXTMETRIC tm;        GetTextMetrics(hdc, &tm);        x = (rpng2_info.width - len*tm.tmAveCharWidth)/2;        y = (rpng2_info.height - tm.tmHeight)/2;        SetBkMode(hdc, TRANSPARENT);        SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));                TextOut(hdc, ((x < 0)? 0 : x), ((y < 0)? 0 : y), msg, len);        ReleaseDC(global_hwnd, hdc);        rpng2_win_load_bg_image();       }    if (!bg_image) {        for (j = 0;  j < rpng2_info.height;  ++j) {            dest = wimage_data + j*wimage_rowbytes;            for (i = rpng2_info.width;  i > 0;  --i) {                *dest++ = bg_blue;                *dest++ = bg_green;                *dest++ = bg_red;            }        }    }    rect.left = 0L;    rect.top = 0L;    rect.right = (LONG)rpng2_info.width;           rect.bottom = (LONG)rpng2_info.height;         InvalidateRect(global_hwnd, &rect, FALSE);    UpdateWindow(global_hwnd);                     return 0;} ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intread_one_file(FILE *ip, const char *name){   uLong length = 0;   uLong a32 = adler32(0, NULL, 0);   uLong c32 = crc32(0, NULL, 0);   Byte header[132];   for (;;)   {      int ch = getc(ip);      Byte b;      if (ch == EOF) break;      b = (Byte)ch;      if (length < sizeof header)         header[length] = b;      ++length;      a32 = adler32(a32, &b, 1);      c32 = crc32(c32, &b, 1);   }   if (ferror(ip))      return 0;      printf(\"PNG_ICC_CHECKSUM(0x%8.8lx, 0x%8.8lx,\\n   PNG_MD5(\"      \"0x%2.2x%2.2x%2.2x%2.2x, 0x%2.2x%2.2x%2.2x%2.2x, 0x%2.2x%2.2x%2.2x%2.2x,\"      \" 0x%2.2x%2.2x%2.2x%2.2x), %d,\\n\"      \"   \\\"%4.4d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d\\\", %lu, \\\"%s\\\")\\n\",      (unsigned long)a32, (unsigned long)c32,      header[84], header[85], header[86], header[87],      header[88], header[89], header[90], header[91],      header[92], header[93], header[94], header[95],      header[96], header[97], header[98], header[99],#     define u16(x) (header[x] * 256 + header[x+1])#     define u32(x) (u16(x) * 65536 + u16(x+2))      u32(64), u16(24), u16(26), u16(28), u16(30), u16(32), u16(34),      (unsigned long)length, name);   return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPImodifier_read(png_structp ppIn, png_bytep pb, png_size_t st){   png_const_structp pp = ppIn;   png_modifier *pm = voidcast(png_modifier*, png_get_io_ptr(pp));   if (pm == NULL || pm->this.pread != pp)      png_error(pp, \"bad modifier_read call\");   modifier_read_imp(pm, pb, st);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#ifdef PNG_READ_TRANSFORMS_SUPPORTEDstatic size_t safecatd(char *buffer, size_t bufsize, size_t pos, double d,    int precision){   char number[64];   sprintf(number, \"%.*f\", precision, d);   return safecat(buffer, bufsize, pos, number);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmake_error(png_store* volatile psIn, png_byte PNG_CONST colour_type,    png_byte bit_depth, int interlace_type, int test, png_const_charp name){   png_store * volatile ps = psIn;   context(ps, fault);   check_interlace_type(interlace_type);   Try   {      png_structp pp;      png_infop pi;      pp = set_store_for_write(ps, &pi, name);      if (pp == NULL)         Throw ps;      png_set_IHDR(pp, pi, transform_width(pp, colour_type, bit_depth),         transform_height(pp, colour_type, bit_depth), bit_depth, colour_type,         interlace_type, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);      if (colour_type == 3)          init_standard_palette(ps, pp, pi, 1U << bit_depth, 0);      #     define exception__prev exception_prev_1#     define exception__env exception_env_1      Try      {                  ps->expect_error = !error_test[test].warning;         ps->expect_warning = error_test[test].warning;         ps->saw_warning = 0;         error_test[test].fn(pp, pi);                  png_write_info(pp, pi);                  if (ps->expect_warning && ps->saw_warning)            Throw ps;                  store_log(ps, pp, error_test[test].msg, 1 );      }      Catch (fault)         ps = fault; #undef exception__prev#undef exception__env            ps->expect_error = 0;      ps->expect_warning = 0;            if (png_get_rowbytes(pp, pi) !=          transform_rowsize(pp, colour_type, bit_depth))         png_error(pp, \"row size incorrect\");      else      {         png_uint_32 h = transform_height(pp, colour_type, bit_depth);         int npasses = png_set_interlace_handling(pp);         int pass;         if (npasses != npasses_from_interlace_type(pp, interlace_type))            png_error(pp, \"write: png_set_interlace_handling failed\");         for (pass=0; pass<npasses; ++pass)         {            png_uint_32 y;            for (y=0; y<h; ++y)            {               png_byte buffer[TRANSFORM_ROWMAX];               transform_row(pp, buffer, colour_type, bit_depth, y);               png_write_row(pp, buffer);            }         }      }      png_write_end(pp, pi);            store_write_reset(ps);   }   Catch(fault)   {      store_write_reset(fault);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmake_size_images(png_store *ps){      safecat(ps->test, sizeof ps->test, 0, \"make size images\");      make_size(ps, 0, 0, WRITE_BDHI);   make_size(ps, 2, 3, WRITE_BDHI);   make_size(ps, 3, 0, 3 );   make_size(ps, 4, 3, WRITE_BDHI);   make_size(ps, 6, 3, WRITE_BDHI);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_init(png_store* ps){   memset(ps, 0, sizeof *ps);   init_exception_context(&ps->exception_context);   store_pool_init(ps, &ps->read_memory_pool);   store_pool_init(ps, &ps->write_memory_pool);   ps->verbose = 0;   ps->treat_warnings_as_errors = 0;   ps->expect_error = 0;   ps->expect_warning = 0;   ps->saw_warning = 0;   ps->speed = 0;   ps->progressive = 0;   ps->validated = 0;   ps->nerrors = ps->nwarnings = 0;   ps->pread = NULL;   ps->piread = NULL;   ps->saved = ps->current = NULL;   ps->next = NULL;   ps->readpos = 0;   ps->image = NULL;   ps->cb_image = 0;   ps->cb_row = 0;   ps->image_h = 0;   ps->pwrite = NULL;   ps->piwrite = NULL;   ps->writepos = 0;   ps->new.prev = NULL;   ps->palette = NULL;   ps->npalette = 0;   ps->noptions = 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidperform_interlace_macro_validation(void){      int pass;   for (pass=0; pass<7; ++pass)   {      png_uint_32 m, f, v;      m = PNG_PASS_START_ROW(pass);      f = png_pass_start_row(pass);      if (m != f)      {         fprintf(stderr, \"PNG_PASS_START_ROW(%d) = %u != %x\\n\", pass, m, f);         exit(99);      }      m = PNG_PASS_START_COL(pass);      f = png_pass_start_col(pass);      if (m != f)      {         fprintf(stderr, \"PNG_PASS_START_COL(%d) = %u != %x\\n\", pass, m, f);         exit(99);      }      m = PNG_PASS_ROW_SHIFT(pass);      f = png_pass_row_shift(pass);      if (m != f)      {         fprintf(stderr, \"PNG_PASS_ROW_SHIFT(%d) = %u != %x\\n\", pass, m, f);         exit(99);      }      m = PNG_PASS_COL_SHIFT(pass);      f = png_pass_col_shift(pass);      if (m != f)      {         fprintf(stderr, \"PNG_PASS_COL_SHIFT(%d) = %u != %x\\n\", pass, m, f);         exit(99);      }            for (v=0;;)      {                  m = PNG_ROW_FROM_PASS_ROW(v, pass);         f = png_row_from_pass_row(v, pass);         if (m != f)         {            fprintf(stderr, \"PNG_ROW_FROM_PASS_ROW(%u, %d) = %u != %x\\n\",               v, pass, m, f);            exit(99);         }         m = PNG_COL_FROM_PASS_COL(v, pass);         f = png_col_from_pass_col(v, pass);         if (m != f)         {            fprintf(stderr, \"PNG_COL_FROM_PASS_COL(%u, %d) = %u != %x\\n\",               v, pass, m, f);            exit(99);         }         m = PNG_ROW_IN_INTERLACE_PASS(v, pass);         f = png_row_in_interlace_pass(v, pass);         if (m != f)         {            fprintf(stderr, \"PNG_ROW_IN_INTERLACE_PASS(%u, %d) = %u != %x\\n\",               v, pass, m, f);            exit(99);         }         m = PNG_COL_IN_INTERLACE_PASS(v, pass);         f = png_col_in_interlace_pass(v, pass);         if (m != f)         {            fprintf(stderr, \"PNG_COL_IN_INTERLACE_PASS(%u, %d) = %u != %x\\n\",               v, pass, m, f);            exit(99);         }                  ++v;         m = PNG_PASS_ROWS(v, pass);         f = png_pass_rows(v, pass);         if (m != f)         {            fprintf(stderr, \"PNG_PASS_ROWS(%u, %d) = %u != %x\\n\",               v, pass, m, f);            exit(99);         }         m = PNG_PASS_COLS(v, pass);         f = png_pass_cols(v, pass);         if (m != f)         {            fprintf(stderr, \"PNG_PASS_COLS(%u, %d) = %u != %x\\n\",               v, pass, m, f);            exit(99);         }                  if (v > 1024)         {            if (v == PNG_UINT_31_MAX)               break;            v = (v << 1) ^ v;            if (v >= PNG_UINT_31_MAX)               v = PNG_UINT_31_MAX-1;         }      }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIread_function(png_structp pp, png_bytep data, png_size_t size){   buffer_read(get_dp(pp), get_buffer(pp), data, size);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_gb16(Pixel *out, const Pixel *in, const Background *back){   if (in->a <= 0)      out->r = out->g = out->b = back->ig;   else if (in->a >= 65535)      out->r = out->g = out->b = isRGB(in->g);   else   {      double a = in->a / 65535.;      double a1 = 1-a;      a /= 65535;      out->r = out->g = out->b = sRGB(in->g * a + back->dg * a1);   }   out->a = 255;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcheck_interlace_type(int PNG_CONST interlace_type){   if (interlace_type != PNG_INTERLACE_NONE)   {            fprintf(stderr, \"pngvalid: no interlace support\\n\");      exit(99);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcheckopaque(Image *image){   if (image->image.opaque != NULL)   {      png_image_free(&image->image);      return logerror(image, image->file_name, \": opaque not NULL\", \"\");   }   else if (image->image.warning_or_error != 0 && (image->opts & STRICT) != 0)      return logerror(image, image->file_name, \" --strict\", \"\");   else      return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_tRNS_to_alpha_mod(PNG_CONST image_transform *this,   image_pixel *that, png_const_structp pp,   PNG_CONST transform_display *display){      if (that->colour_type == PNG_COLOR_TYPE_PALETTE)      image_pixel_convert_PLTE(that);      if (that->have_tRNS)      image_pixel_add_alpha(that, &display->this);      else   {      if (that->bit_depth < 8)         that->bit_depth =8;      if (that->sample_depth < 8)         that->sample_depth = 8;   }   this->next->mod(this->next, that, pp, display);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intlogclose(Image *image, FILE *f, const char *name, const char *operation){   int e = errno;   fclose(f);   return logerror(image, name, operation, strerror(e));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": " * scales values to 8-bit if necessary */int readpng_get_bgcolor(uch *red, uch *green, uch *blue){    png_color_16p pBackground;        if (setjmp(png_jmpbuf(png_ptr))) {        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);        return 2;    }    if (!png_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD))        return 1;        png_get_bKGD(png_ptr, info_ptr, &pBackground);        if (bit_depth == 16) {        *red   = pBackground->red   >> 8;        *green = pBackground->green >> 8;        *blue  = pBackground->blue  >> 8;    } else if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) {        if (bit_depth == 1)            *red = *green = *blue = pBackground->gray? 255 : 0;        else if (bit_depth == 2)            *red = *green = *blue = (255/3) * pBackground->gray;        else             *red = *green = *blue = (255/15) * pBackground->gray;    } else {        *red   = (uch)pBackground->red;        *green = (uch)pBackground->green;        *blue  = (uch)pBackground->blue;    }    return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidIDAT_list_end(struct IDAT_list *IDAT_list){   struct IDAT_list *list = IDAT_list->next;   CLEAR(*IDAT_list);   while (list != NULL)   {      struct IDAT_list *next = list->next;      clear(list, IDAT_list_size(list, 0));      free(list);      list = next;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidclear_keep(void){   int i = NINFO;   while (--i >= 0)      chunk_info[i].keep = 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voiddisplay_clean_read(struct display *dp){   if (dp->read_pp != NULL)      png_destroy_read_struct(&dp->read_pp, &dp->read_ip, NULL);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int readpng_init(FILE *infile, ulg *pWidth, ulg *pHeight){    uch sig[8];        fread(sig, 1, 8, infile);    if (png_sig_cmp(sig, 0, 8))        return 1;           png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);    if (!png_ptr)        return 4;       info_ptr = png_create_info_struct(png_ptr);    if (!info_ptr) {        png_destroy_read_struct(&png_ptr, NULL, NULL);        return 4;       }            if (setjmp(png_jmpbuf(png_ptr))) {        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);        return 2;    }    png_init_io(png_ptr, infile);    png_set_sig_bytes(png_ptr, 8);      png_read_info(png_ptr, info_ptr);          png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,      NULL, NULL, NULL);    *pWidth = width;    *pHeight = height;        return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidpng_formatted_warning(png_structp png_ptr, png_warning_parameters p,   png_const_charp message){      size_t i;   char msg[128];   for (i=0; i<(sizeof msg)-1 && *message != '\\0'; ++i)   {      if (*message == '@')      {         int parameter = -1;         switch (*++message)         {            case '1':               parameter = 0;               break;            case '2':               parameter = 1;               break;            case '\\0':               continue;             default:               break;         }         if (parameter >= 0 && parameter < PNG_WARNING_PARAMETER_COUNT)         {                        png_const_charp parm = p[parameter];            png_const_charp pend = p[parameter] + (sizeof p[parameter]);                        for (; i<(sizeof msg)-1 && parm != '\\0' && parm < pend; ++i)               msg[i] = *parm++;            ++message;            continue;         }               }            msg[i] = *message++;   }      msg[i] = '\\0';      png_warning(png_ptr, msg);}#endif ",
        "label": 1,
        "cve": "cve-2011-3464"
    },
    {
        "code": "static png_bytepextract(FILE *fp, png_uint_32 *proflen){   png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,0,0,0);   png_infop info_ptr = NULL;   png_bytep result = NULL;      *proflen = 0;   if (png_ptr == NULL)   {      fprintf(stderr, \"iccfrompng: version library mismatch?\\n\");      return 0;   }   if (setjmp(png_jmpbuf(png_ptr)))   {      png_destroy_read_struct(&png_ptr, &info_ptr, NULL);      return 0;   }   png_init_io(png_ptr, fp);   info_ptr = png_create_info_struct(png_ptr);   if (info_ptr == NULL)      png_error(png_ptr, \"OOM allocating info structure\");   png_read_info(png_ptr, info_ptr);   {      png_charp name;      int compression_type;      png_bytep profile;      if (png_get_iCCP(png_ptr, info_ptr, &name, &compression_type, &profile,         proflen) & PNG_INFO_iCCP)      {         result = malloc(*proflen);         if (result != NULL)            memcpy(result, profile, *proflen);         else            png_error(png_ptr, \"OOM allocating profile buffer\");      }      else\tresult = no_profile;   }   png_destroy_read_struct(&png_ptr, &info_ptr, NULL);   return result;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGCBAPIpng_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length){   png_size_t check;   if (png_ptr == NULL)      return;   check = fwrite(data, 1, length, (png_FILE_p)(png_ptr->io_ptr));   if (check != length)      png_error(png_ptr, \"Write Error\");}void PNGCBAPIpng_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length){   png_uint_32 check;   png_byte *near_data;     png_FILE_p io_ptr;   if (png_ptr == NULL)      return;      near_data = (png_byte *)CVT_PTR_NOCHECK(data);   io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);   if ((png_bytep)near_data == data)   {      check = fwrite(near_data, 1, length, io_ptr);   }   else   {      png_byte buf[NEAR_BUF_SIZE];      png_size_t written, remaining, err;      check = 0;      remaining = length;      do      {         written = MIN(NEAR_BUF_SIZE, remaining);         png_memcpy(buf, data, written);          err = fwrite(buf, 1, written, io_ptr);         if (err != written)            break;         else            check += err;         data += written;         remaining -= written;      }      while (remaining != 0);   }   if (check != length)      png_error(png_ptr, \"Write Error\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_rgb_to_gray_set(PNG_CONST image_transform *this,    transform_display *that, png_structp pp, png_infop pi){   PNG_CONST int error_action = 1; #  ifdef PNG_FLOATING_POINT_SUPPORTED      png_set_rgb_to_gray(pp, error_action, data.red_to_set, data.green_to_set);#  else      png_set_rgb_to_gray_fixed(pp, error_action, data.red_to_set,         data.green_to_set);#  endif#  ifdef PNG_READ_cHRM_SUPPORTED      if (that->pm->current_encoding != 0)      {         #        ifdef PNG_FLOATING_POINT_SUPPORTED#           define API_function png_get_cHRM_XYZ#           define API_form \"FP\"#           define API_type double#           define API_cvt(x) (x)#        else#           define API_function png_get_cHRM_XYZ_fixed#           define API_form \"fixed\"#           define API_type png_fixed_point#           define API_cvt(x) ((double)(x)/PNG_FP_1)#        endif         API_type rX, gX, bX;         API_type rY, gY, bY;         API_type rZ, gZ, bZ;         if ((API_function(pp, pi, &rX, &rY, &rZ, &gX, &gY, &gZ, &bX, &bY, &bZ)               & PNG_INFO_cHRM) != 0)         {            double maxe;            PNG_CONST char *el;            color_encoding e, o;                        modifier_current_encoding(that->pm, &o);            normalize_color_encoding(&o);                        if (data.red_to_set == -1 && data.green_to_set == -1 &&               (fabs(o.red.Y - data.red_coefficient) > DBL_EPSILON ||               fabs(o.green.Y - data.green_coefficient) > DBL_EPSILON ||               fabs(o.blue.Y - data.blue_coefficient) > DBL_EPSILON))               png_error(pp, \"internal pngvalid cHRM coefficient error\");                        e.gamma = o.gamma;             e.red.X = API_cvt(rX);            e.red.Y = API_cvt(rY);            e.red.Z = API_cvt(rZ);            e.green.X = API_cvt(gX);            e.green.Y = API_cvt(gY);            e.green.Z = API_cvt(gZ);            e.blue.X = API_cvt(bX);            e.blue.Y = API_cvt(bY);            e.blue.Z = API_cvt(bZ);                        maxe = 0;            el = \"-\"; #           define CHECK(col,x)\\            {\\               double err = fabs(o.col.x - e.col.x);\\               if (err > maxe)\\               {\\                  maxe = err;\\                  el = #col \"(\" #x \")\";\\               }\\            }            CHECK(red,X)            CHECK(red,Y)            CHECK(red,Z)            CHECK(green,X)            CHECK(green,Y)            CHECK(green,Z)            CHECK(blue,X)            CHECK(blue,Y)            CHECK(blue,Z)                        if (maxe >= 1E-5)            {               size_t pos = 0;               char buffer[256];               pos = safecat(buffer, sizeof buffer, pos, API_form);               pos = safecat(buffer, sizeof buffer, pos, \" cHRM \");               pos = safecat(buffer, sizeof buffer, pos, el);               pos = safecat(buffer, sizeof buffer, pos, \" error: \");               pos = safecatd(buffer, sizeof buffer, pos, maxe, 7);               pos = safecat(buffer, sizeof buffer, pos, \" \");                              pos = safecat_color_encoding(buffer, sizeof buffer, pos, &o, 0);               pos = safecat(buffer, sizeof buffer, pos, \" -> \");               pos = safecat_color_encoding(buffer, sizeof buffer, pos, &e, 0);               png_error(pp, buffer);            }         }      }#  endif    this->next->set(this->next, that, pp, pi);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "   const char *tests);static int check_one_character(checkfp_command *co, checkfp_control c, int ch){      png_size_t index = 0;   const char test = (char)ch;   const int number_is_valid = png_check_fp_number(&test, 1, &c.state, &index);   const int character_accepted = (index == 1);   if (c.check_state != exponent && isdigit(ch) && ch != '0')      c.is_zero = 0;   if (c.check_state == start && c.at_start && ch == '-')      c.is_negative = 1;   if (isprint(ch))      co->number[c.cnumber++] = (char)ch;   else   {      co->number[c.cnumber++] = '<';      co->number[c.cnumber++] = hexdigits[(ch >> 4) & 0xf];      co->number[c.cnumber++] = hexdigits[ch & 0xf];      co->number[c.cnumber++] = '>';   }   co->number[c.cnumber] = 0;   if (co->verbose > 1)      fprintf(stderr, \"%s\\n\", co->number);   if (++(co->ctimes) == 1000000)   {      if (co->verbose == 1)         fputc('.', stderr);      co->ctimes = 0;      ++(co->cmillions);   }   if (!number_is_valid)      ++(co->cinvalid);   if (!character_accepted)      ++(co->cnoaccept);      if (index != 0 && index != 1)   {      fprintf(stderr, \"%s: read beyond end of string (%lu)\\n\", co->number,         (unsigned long)index);      return 0;   }      if (PNG_FP_IS_NEGATIVE(c.state) !=      (number_is_valid && !c.is_zero && c.is_negative))   {      fprintf(stderr, \"%s: negative when it is not\\n\", co->number);      return 0;   }   if (PNG_FP_IS_ZERO(c.state) != (number_is_valid && c.is_zero))   {      fprintf(stderr, \"%s: zero when it is not\\n\", co->number);      return 0;   }   if (PNG_FP_IS_POSITIVE(c.state) !=      (number_is_valid && !c.is_zero && !c.is_negative))   {      fprintf(stderr, \"%s: positive when it is not\\n\", co->number);      return 0;   }      if (isdigit(ch))   {      if (!character_accepted)      {         fprintf(stderr, \"%s: digit '%c' not accepted\\n\", co->number, ch);         return 0;      }      if (!number_is_valid)      {         fprintf(stderr, \"%s: saw a digit (%c) but number not valid\\n\",            co->number, ch);         return 0;      }      ++c.cdigits_in_state;      c.at_start = 0;      c.number_was_valid = 1;            if (c.cdigits_in_state < 1)         return check_all_characters(co, c);      else         return check_some_characters(co, c,            state_characters[c.check_state].tests);   }      else if (((ch == '+' || ch == '-') && c.check_state != fraction &&               c.at_start) ||            (ch == '.' && c.check_state == start) ||            ((ch == 'e' || ch == 'E') && c.number_was_valid &&               c.check_state != exponent))   {      if (!character_accepted)      {         fprintf(stderr, \"%s: character '%c' not accepted\\n\", co->number, ch);         return 0;      }            if (number_is_valid && (c.check_state != start || ch != '.'))      {         fprintf(stderr, \"%s: saw a non-digit (%c) but number valid\\n\",            co->number, ch);         return 0;      }      c.number_was_valid = number_is_valid;            if (c.check_state == start && ch == '.')      {         c.check_state = fraction;         c.at_start = !number_is_valid;         c.cdigits_in_state = 0;         c.limit = co->limit;         return check_all_characters(co, c);      }      else if (c.check_state < exponent && (ch == 'e' || ch == 'E'))      {         c.check_state = exponent;         c.at_start = 1;         c.cdigits_in_state = 0;         c.limit = co->limit;         return check_all_characters(co, c);      }            else      {         if (ch != '-' && ch != '+')         {            fprintf(stderr, \"checkfp: internal error (1)\\n\");            return 0;         }         c.at_start = 0;         return check_all_characters(co, c);      }   }      else   {      if (character_accepted)      {         fprintf(stderr, \"%s: character '%c' [0x%.2x] accepted\\n\", co->number,            ch, ch);         return 0;      }      if (number_is_valid != c.number_was_valid)      {         fprintf(stderr,            \"%s: character '%c' [0x%.2x] changed number validity\\n\", co->number,            ch, ch);         return 0;      }         }      return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intuarb_mult32(uarb acc, int a_digits, uarb num, int n_digits, png_uint_32 val)   {   if (n_digits > 0 && val > 0)   {      a_digits = uarb_mult_digit(acc, a_digits, num, n_digits,         (png_uint_16)(val & 0xffff));            assert(a_digits > 0);      val >>= 16;      if (val > 0)         a_digits = uarb_mult_digit(acc+1, a_digits-1, num, n_digits,            (png_uint_16)val) + 1;   }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static unsigned intsample_scale(double sample_value, unsigned int scale){   sample_value = floor(sample_value * scale + .5);      if (!(sample_value > 0))      sample_value = 0;   else if (sample_value > scale)      sample_value = scale;   return (unsigned int)sample_value;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidtransform_set_encoding(transform_display *this){      png_modifier *pm = this->pm;   modifier_set_encoding(pm);   if (modifier_color_encoding_is_set(pm))   {      if (modifier_color_encoding_is_sRGB(pm))         srgb_modification_init(&this->srgb_mod, pm, PNG_sRGB_INTENT_ABSOLUTE);      else      {                  gama_modification_init(&this->gama_mod, pm, pm->current_gamma);         if (pm->current_encoding != 0)            chrm_modification_init(&this->chrm_mod, pm, pm->current_encoding);      }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "   defined(PNG_READ_ALPHA_MODE_SUPPORTED)static void gamma_composition_test(png_modifier *pm,   PNG_CONST png_byte colour_type, PNG_CONST png_byte bit_depth,   PNG_CONST int palette_number,   PNG_CONST int interlace_type, PNG_CONST double file_gamma,   PNG_CONST double screen_gamma,   PNG_CONST int use_input_precision, PNG_CONST int do_background,   PNG_CONST int expand_16){   size_t pos = 0;   png_const_charp base;   double bg;   char name[128];   png_color_16 background;      switch (do_background)   {      default:         base = \"\";         bg = 4;          break;      case PNG_BACKGROUND_GAMMA_SCREEN:         base = \" bckg(Screen):\";         bg = 1/screen_gamma;         break;      case PNG_BACKGROUND_GAMMA_FILE:         base = \" bckg(File):\";         bg = file_gamma;         break;      case PNG_BACKGROUND_GAMMA_UNIQUE:         base = \" bckg(Unique):\";                  bg = (file_gamma + screen_gamma) / 3;         break;#ifdef PNG_READ_ALPHA_MODE_SUPPORTED      case ALPHA_MODE_OFFSET + PNG_ALPHA_PNG:         base = \" alpha(PNG)\";         bg = 4;          break;      case ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD:         base = \" alpha(Porter-Duff)\";         bg = 4;          break;      case ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED:         base = \" alpha(Optimized)\";         bg = 4;          break;      case ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN:         base = \" alpha(Broken)\";         bg = 4;          break;#endif   }      if (expand_16 || bit_depth == 16)   {      png_uint_32 r = random_32();      background.red = (png_uint_16)r;      background.green = (png_uint_16)(r >> 16);      r = random_32();      background.blue = (png_uint_16)r;      background.gray = (png_uint_16)(r >> 16);      #     if DIGITIZE         if (expand_16 && (do_background == PNG_BACKGROUND_GAMMA_UNIQUE ||                           do_background == PNG_BACKGROUND_GAMMA_FILE) &&            fabs(bg*screen_gamma-1) > PNG_GAMMA_THRESHOLD)         {                        background.red = (png_uint_16)((background.red >> 8) * 257);            background.green = (png_uint_16)((background.green >> 8) * 257);            background.blue = (png_uint_16)((background.blue >> 8) * 257);            background.gray = (png_uint_16)((background.gray >> 8) * 257);         }#     endif   }   else    {      png_uint_32 r = random_32();      background.red = (png_byte)r;      background.green = (png_byte)(r >> 8);      background.blue = (png_byte)(r >> 16);      background.gray = (png_byte)(r >> 24);   }   background.index = 193;    if (!(colour_type & PNG_COLOR_MASK_COLOR))   {            background.red = background.green = background.blue = background.gray;   }   pos = safecat(name, sizeof name, pos, \"gamma \");   pos = safecatd(name, sizeof name, pos, file_gamma, 3);   pos = safecat(name, sizeof name, pos, \"->\");   pos = safecatd(name, sizeof name, pos, screen_gamma, 3);   pos = safecat(name, sizeof name, pos, base);   if (do_background < ALPHA_MODE_OFFSET)   {            pos = safecat(name, sizeof name, pos, \"(\");            if (colour_type & PNG_COLOR_MASK_COLOR)      {         pos = safecatn(name, sizeof name, pos, background.red);         pos = safecat(name, sizeof name, pos, \",\");         pos = safecatn(name, sizeof name, pos, background.green);         pos = safecat(name, sizeof name, pos, \",\");         pos = safecatn(name, sizeof name, pos, background.blue);      }      else         pos = safecatn(name, sizeof name, pos, background.gray);      pos = safecat(name, sizeof name, pos, \")^\");      pos = safecatd(name, sizeof name, pos, bg, 3);   }   gamma_test(pm, colour_type, bit_depth, palette_number, interlace_type,      file_gamma, screen_gamma, 0, 0, name, use_input_precision,      0, expand_16, do_background, &background, bg);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidperform_gamma_test(png_modifier *pm, int summary){         unsigned int calculations_use_input_precision =      pm->calculations_use_input_precision;#  ifdef PNG_READ_BACKGROUND_SUPPORTED      double maxout8 = pm->maxout8;#  endif      if (!pm->this.speed && pm->test_gamma_threshold)   {      perform_gamma_threshold_tests(pm);      if (fail(pm))         return;   }      if (pm->test_gamma_transform)   {      if (summary)      {         fflush(stderr);         printf(\"Gamma correction error summary\\n\\n\");         printf(\"The printed value is the maximum error in the pixel values\\n\");         printf(\"calculated by the libpng gamma correction code.  The error\\n\");         printf(\"is calculated as the difference between the output pixel\\n\");         printf(\"value (always an integer) and the ideal value from the\\n\");         printf(\"libpng specification (typically not an integer).\\n\\n\");         printf(\"Expect this value to be less than .5 for 8 bit formats,\\n\");         printf(\"less than 1 for formats with fewer than 8 bits and a small\\n\");         printf(\"number (typically less than 5) for the 16 bit formats.\\n\");         printf(\"For performance reasons the value for 16 bit formats\\n\");         printf(\"increases when the image file includes an sBIT chunk.\\n\");         fflush(stdout);      }      init_gamma_errors(pm);            if (pm->test_gamma_expand16)         pm->calculations_use_input_precision = 1;      perform_gamma_transform_tests(pm);      if (!calculations_use_input_precision)         pm->calculations_use_input_precision = 0;      if (summary)         summarize_gamma_errors(pm, 0, 1, 1);      if (fail(pm))         return;   }      if (pm->test_gamma_sbit)   {      init_gamma_errors(pm);      perform_gamma_sbit_tests(pm);      if (summary)         summarize_gamma_errors(pm, \"sBIT\", pm->sbitlow < 8U, 1);      if (fail(pm))         return;   }#ifdef DO_16BIT    if (pm->test_gamma_scale16)   {            init_gamma_errors(pm);      perform_gamma_scale16_tests(pm);      if (summary)      {         fflush(stderr);         printf(\"\\nGamma correction with 16 to 8 bit reduction:\\n\");         printf(\" 16 bit gray:  %.5f\\n\", pm->error_gray_16);         printf(\" 16 bit color: %.5f\\n\", pm->error_color_16);         fflush(stdout);      }      if (fail(pm))         return;   }#endif#ifdef PNG_READ_BACKGROUND_SUPPORTED   if (pm->test_gamma_background)   {      init_gamma_errors(pm);            if (pm->test_gamma_expand16)      {         pm->calculations_use_input_precision = 1;         pm->maxout8 = .499;       }      perform_gamma_composition_tests(pm, PNG_BACKGROUND_GAMMA_UNIQUE,         pm->test_gamma_expand16);      if (!calculations_use_input_precision)         pm->calculations_use_input_precision = 0;      pm->maxout8 = maxout8;      if (summary)         summarize_gamma_errors(pm, \"background\", 1, 0);      if (fail(pm))         return;   }#endif#ifdef PNG_READ_ALPHA_MODE_SUPPORTED   if (pm->test_gamma_alpha_mode)   {      int do_background;      init_gamma_errors(pm);            if (pm->test_gamma_expand16)         pm->calculations_use_input_precision = 1;      for (do_background = ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD;         do_background <= ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN && !fail(pm);         ++do_background)         perform_gamma_composition_tests(pm, do_background,            pm->test_gamma_expand16);      if (!calculations_use_input_precision)         pm->calculations_use_input_precision = 0;      if (summary)         summarize_gamma_errors(pm, \"alpha mode\", 1, 0);      if (fail(pm))         return;   }#endif}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intimage_transform_png_set_scale_16_add(image_transform *this,    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth){   UNUSED(colour_type)   this->next = *that;   *that = this;   return bit_depth > 8;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static inttest_size(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,    int bdlo, int PNG_CONST bdhi){      static PNG_CONST png_byte hinc[] = {1, 3, 11, 1, 5};   static PNG_CONST png_byte winc[] = {1, 9, 5, 7, 1};   for (; bdlo <= bdhi; ++bdlo)   {      png_uint_32 h, w;      for (h=1; h<=16; h+=hinc[bdlo]) for (w=1; w<=16; w+=winc[bdlo])      {                  standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0,            PNG_INTERLACE_NONE, w, h, 0), 0,            pm->use_update_info);         if (fail(pm))            return 0;         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0,            PNG_INTERLACE_NONE, w, h, 1), 0,            pm->use_update_info);         if (fail(pm))            return 0;#     ifdef PNG_WRITE_INTERLACING_SUPPORTED         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0,            PNG_INTERLACE_ADAM7, w, h, 0), 0,            pm->use_update_info);         if (fail(pm))            return 0;         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0,            PNG_INTERLACE_ADAM7, w, h, 1), 0,            pm->use_update_info);         if (fail(pm))            return 0;#     endif                  standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0,            PNG_INTERLACE_NONE, w, h, 0), 1,            pm->use_update_info);         if (fail(pm))            return 0;#     ifdef PNG_WRITE_INTERLACING_SUPPORTED         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0,            PNG_INTERLACE_ADAM7, w, h, 0), 1,            pm->use_update_info);         if (fail(pm))            return 0;#     endif      }   }   return 1; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char *argv[]){   int multiple = 0;   int ierror = 0;   fprintf(STDERR, \"\\n Testing libpng version %s\\n\", PNG_LIBPNG_VER_STRING);   fprintf(STDERR, \"   with zlib   version %s\\n\", ZLIB_VERSION);   fprintf(STDERR, \"%s\", png_get_copyright(NULL));      fprintf(STDERR, \" library (%lu):%s\",      (unsigned long)png_access_version_number(),      png_get_header_version(NULL));      fprintf(STDERR, \" pngtest (%lu):%s\", (unsigned long)PNG_LIBPNG_VER,      PNG_HEADER_VERSION_STRING);   #if defined(MAXSEG_64K) && !defined(PNG_MAX_MALLOC_64K)      fprintf(STDERR, \" NOTE: Zlib compiled for max 64k, libpng not\\n\");#endif   #if !defined(MAXSEG_64K) && defined(PNG_MAX_MALLOC_64K)      fprintf(STDERR, \" NOTE: libpng compiled for max 64k, zlib not\\n\");#endif   if (strcmp(png_libpng_ver, PNG_LIBPNG_VER_STRING))   {      fprintf(STDERR,         \"Warning: versions are different between png.h and png.c\\n\");      fprintf(STDERR, \"  png.h version: %s\\n\", PNG_LIBPNG_VER_STRING);      fprintf(STDERR, \"  png.c version: %s\\n\\n\", png_libpng_ver);      ++ierror;   }   if (argc > 1)   {      if (strcmp(argv[1], \"-m\") == 0)      {         multiple = 1;         status_dots_requested = 0;      }      else if (strcmp(argv[1], \"-mv\") == 0 ||               strcmp(argv[1], \"-vm\") == 0 )      {         multiple = 1;         verbose = 1;         status_dots_requested = 1;      }      else if (strcmp(argv[1], \"-v\") == 0)      {         verbose = 1;         status_dots_requested = 1;         inname = argv[2];      }      else      {         inname = argv[1];         status_dots_requested = 0;      }   }   if (!multiple && argc == 3 + verbose)     outname = argv[2 + verbose];   if ((!multiple && argc > 3 + verbose) || (multiple && argc < 2))   {     fprintf(STDERR,       \"usage: %s [infile.png] [outfile.png]\\n\\t%s -m {infile.png}\\n\",        argv[0], argv[0]);     fprintf(STDERR,       \"  reads/writes one PNG file (without -m) or multiple files (-m)\\n\");     fprintf(STDERR,       \"  with -m %s is used as a temporary file\\n\", outname);     exit(1);   }   if (multiple)   {      int i;#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG      int allocation_now = current_allocation;#endif      for (i=2; i<argc; ++i)      {         int kerror;         fprintf(STDERR, \"\\n Testing %s:\", argv[i]);         kerror = test_one_file(argv[i], outname);         if (kerror == 0)         {#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED            int k;#endif#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED            fprintf(STDERR, \"\\n PASS (%lu zero samples)\\n\",               (unsigned long)zero_samples);#else            fprintf(STDERR, \" PASS\\n\");#endif#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED            for (k = 0; k<256; k++)               if (filters_used[k])                  fprintf(STDERR, \" Filter %d was used %lu times\\n\",                     k, (unsigned long)filters_used[k]);#endif#ifdef PNG_TIME_RFC1123_SUPPORTED         if (tIME_chunk_present != 0)            fprintf(STDERR, \" tIME = %s\\n\", tIME_string);         tIME_chunk_present = 0;#endif          }         else         {            fprintf(STDERR, \" FAIL\\n\");            ierror += kerror;         }#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG         if (allocation_now != current_allocation)            fprintf(STDERR, \"MEMORY ERROR: %d bytes lost\\n\",               current_allocation - allocation_now);         if (current_allocation != 0)         {            memory_infop pinfo = pinformation;            fprintf(STDERR, \"MEMORY ERROR: %d bytes still allocated\\n\",               current_allocation);            while (pinfo != NULL)            {               fprintf(STDERR, \" %lu bytes at %x\\n\",                 (unsigned long)pinfo->size,                 (unsigned int)pinfo->pointer);               pinfo = pinfo->next;            }         }#endif      }#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG         fprintf(STDERR, \" Current memory allocation: %10d bytes\\n\",            current_allocation);         fprintf(STDERR, \" Maximum memory allocation: %10d bytes\\n\",            maximum_allocation);         fprintf(STDERR, \" Total   memory allocation: %10d bytes\\n\",            total_allocation);         fprintf(STDERR, \"     Number of allocations: %10d\\n\",            num_allocations);#endif   }   else   {      int i;      for (i = 0; i<3; ++i)      {         int kerror;#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG         int allocation_now = current_allocation;#endif         if (i == 1)            status_dots_requested = 1;         else if (verbose == 0)            status_dots_requested = 0;         if (i == 0 || verbose == 1 || ierror != 0)            fprintf(STDERR, \"\\n Testing %s:\", inname);         kerror = test_one_file(inname, outname);         if (kerror == 0)         {            if (verbose == 1 || i == 2)            {#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED                int k;#endif#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED                fprintf(STDERR, \"\\n PASS (%lu zero samples)\\n\",                   (unsigned long)zero_samples);#else                fprintf(STDERR, \" PASS\\n\");#endif#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED                for (k = 0; k<256; k++)                   if (filters_used[k])                      fprintf(STDERR, \" Filter %d was used %lu times\\n\",                         k, (unsigned long)filters_used[k]);#endif#ifdef PNG_TIME_RFC1123_SUPPORTED             if (tIME_chunk_present != 0)                fprintf(STDERR, \" tIME = %s\\n\", tIME_string);#endif             }         }         else         {            if (verbose == 0 && i != 2)               fprintf(STDERR, \"\\n Testing %s:\", inname);            fprintf(STDERR, \" FAIL\\n\");            ierror += kerror;         }#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG         if (allocation_now != current_allocation)             fprintf(STDERR, \"MEMORY ERROR: %d bytes lost\\n\",               current_allocation - allocation_now);         if (current_allocation != 0)         {             memory_infop pinfo = pinformation;             fprintf(STDERR, \"MEMORY ERROR: %d bytes still allocated\\n\",                current_allocation);             while (pinfo != NULL)             {                fprintf(STDERR, \" %lu bytes at %x\\n\",                   (unsigned long)pinfo->size, (unsigned int)pinfo->pointer);                pinfo = pinfo->next;             }          }#endif       }#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG       fprintf(STDERR, \" Current memory allocation: %10d bytes\\n\",          current_allocation);       fprintf(STDERR, \" Maximum memory allocation: %10d bytes\\n\",          maximum_allocation);       fprintf(STDERR, \" Total   memory allocation: %10d bytes\\n\",          total_allocation);       fprintf(STDERR, \"     Number of allocations: %10d\\n\",            num_allocations);#endif   }#ifdef PNGTEST_TIMING   t_stop = (float)clock();   t_misc += (t_stop - t_start);   t_start = t_stop;   fprintf(STDERR, \" CPU time used = %.3f seconds\",      (t_misc+t_decode+t_encode)/(float)CLOCKS_PER_SEC);   fprintf(STDERR, \" (decoding %.3f,\\n\",      t_decode/(float)CLOCKS_PER_SEC);   fprintf(STDERR, \"        encoding %.3f ,\",      t_encode/(float)CLOCKS_PER_SEC);   fprintf(STDERR, \" other %.3f seconds)\\n\\n\",      t_misc/(float)CLOCKS_PER_SEC);#endif   if (ierror == 0)      fprintf(STDERR, \" libpng passes test\\n\");   else      fprintf(STDERR, \" libpng FAILS test\\n\");   return (int)(ierror != 0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidpng_flush(png_structp png_ptr){   FILE *io_ptr;   io_ptr = (FILE *)CVT_PTR((png_ptr->io_ptr));   if (io_ptr != NULL)      fflush(io_ptr);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmodifier_set_encoding(png_modifier *pm){      pm->current_gamma = 0;   pm->current_encoding = 0;   pm->encoding_ignored = 0;       if (pm->encoding_counter > 0)   {            if (pm->encoding_counter <= pm->ngammas)         pm->current_gamma = 1/pm->gammas[pm->encoding_counter-1];      else      {         unsigned int i = pm->encoding_counter - pm->ngammas;         if (i >= pm->nencodings)         {            i %= pm->nencodings;            pm->current_gamma = 1;          }         else            pm->current_gamma = pm->encodings[i].gamma;         pm->current_encoding = pm->encodings + i;      }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_byteu8d(double d){   d = closestinteger(d);   return (png_byte)d;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidset_color(png_colorp color, png_bytep trans, unsigned int red,   unsigned int green, unsigned int blue, unsigned int alpha,   png_const_bytep gamma_table){   color->red = gamma_table[red];   color->green = gamma_table[green];   color->blue = gamma_table[blue];   *trans = (png_byte)alpha;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#define COUNT 1000000000int main(int argc, char **argv){   int count = COUNT;   while (argc > 1)   {      if (argc > 2 && strcmp(argv[1], \"-c\") == 0)      {         count = atoi(argv[2]);         argc -= 2;         argv += 2;      }      else if (strcmp(argv[1], \"-v\") == 0)      {         ++verbose;         --argc;         ++argv;      }      else         break;   }   if (count > 0 && argc > 1)   {      if (strcmp(argv[1], \"ascii\") == 0)         return validation_ascii_to_fp(count, argc-1, argv+1);      else if (strcmp(argv[1], \"checkfp\") == 0)         return validation_checkfp(count, argc-1, argv+1);      else if (strcmp(argv[1], \"muldiv\") == 0)         return validation_muldiv(count, argc-1, argv+1);      else if (strcmp(argv[1], \"gamma\") == 0)         return validation_gamma(argc-1, argv+1);   }      fprintf(stderr,      \"usage: tarith [-v] [-c count] {ascii,muldiv,gamma} [args]\\n\");   fprintf(stderr, \" arguments: ascii [-a (all results)] [-e error%%]\\n\");   fprintf(stderr, \"            checkfp [-l max-number-chars]\\n\");   fprintf(stderr, \"            muldiv\\n\");   fprintf(stderr, \"            gamma -s (silent) -g (only gamma; no log)\\n\");   return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int rpng2_x_load_bg_image(void){    uch *src;    char *dest;    uch r1, r2, g1, g2, b1, b2;    uch r1_inv, r2_inv, g1_inv, g2_inv, b1_inv, b2_inv;    int k, hmax, max;    int xidx, yidx, yidx_max;    int even_odd_vert, even_odd_horiz, even_odd;    int invert_gradient2 = (bg[pat].type & 0x08);    int invert_column;    int ximage_rowbytes = ximage->bytes_per_line;    ulg i, row;    ulg pixel;    bg_rowbytes = 3 * rpng2_info.width;    bg_data = (uch *)malloc(bg_rowbytes * rpng2_info.height);    if (!bg_data) {        fprintf(stderr, PROGNAME          \":  unable to allocate memory for background image\\n\");        bg_image = 0;        return 1;    }    bgscale = (pat == 0)? 8 : bgscale_default;    yidx_max = bgscale - 1;    if ((bg[pat].type & 0x07) == 0) {        uch r1_min  = rgb[bg[pat].rgb1_min].r;        uch g1_min  = rgb[bg[pat].rgb1_min].g;        uch b1_min  = rgb[bg[pat].rgb1_min].b;        uch r2_min  = rgb[bg[pat].rgb2_min].r;        uch g2_min  = rgb[bg[pat].rgb2_min].g;        uch b2_min  = rgb[bg[pat].rgb2_min].b;        int r1_diff = rgb[bg[pat].rgb1_max].r - r1_min;        int g1_diff = rgb[bg[pat].rgb1_max].g - g1_min;        int b1_diff = rgb[bg[pat].rgb1_max].b - b1_min;        int r2_diff = rgb[bg[pat].rgb2_max].r - r2_min;        int g2_diff = rgb[bg[pat].rgb2_max].g - g2_min;        int b2_diff = rgb[bg[pat].rgb2_max].b - b2_min;        for (row = 0;  row < rpng2_info.height;  ++row) {            yidx = (int)(row % bgscale);            even_odd_vert = (int)((row / bgscale) & 1);            r1 = r1_min + (r1_diff * yidx) / yidx_max;            g1 = g1_min + (g1_diff * yidx) / yidx_max;            b1 = b1_min + (b1_diff * yidx) / yidx_max;            r1_inv = r1_min + (r1_diff * (yidx_max-yidx)) / yidx_max;            g1_inv = g1_min + (g1_diff * (yidx_max-yidx)) / yidx_max;            b1_inv = b1_min + (b1_diff * (yidx_max-yidx)) / yidx_max;            r2 = r2_min + (r2_diff * yidx) / yidx_max;            g2 = g2_min + (g2_diff * yidx) / yidx_max;            b2 = b2_min + (b2_diff * yidx) / yidx_max;            r2_inv = r2_min + (r2_diff * (yidx_max-yidx)) / yidx_max;            g2_inv = g2_min + (g2_diff * (yidx_max-yidx)) / yidx_max;            b2_inv = b2_min + (b2_diff * (yidx_max-yidx)) / yidx_max;            dest = (char *)bg_data + row*bg_rowbytes;            for (i = 0;  i < rpng2_info.width;  ++i) {                even_odd_horiz = (int)((i / bgscale) & 1);                even_odd = even_odd_vert ^ even_odd_horiz;                invert_column =                  (even_odd_horiz && (bg[pat].type & 0x10));                if (even_odd == 0) {                            if (invert_column) {                        *dest++ = r1_inv;                        *dest++ = g1_inv;                        *dest++ = b1_inv;                    } else {                        *dest++ = r1;                        *dest++ = g1;                        *dest++ = b1;                    }                } else {                                        if ((invert_column && invert_gradient2) ||                        (!invert_column && !invert_gradient2))                    {                        *dest++ = r2;                               *dest++ = g2;                               *dest++ = b2;                    } else {                        *dest++ = r2_inv;                        *dest++ = g2_inv;                           *dest++ = b2_inv;                    }                }            }        }    } else if ((bg[pat].type & 0x07) == 1) {        hmax = (bgscale-1)/2;           max = 2*hmax;                   r1 = rgb[bg[pat].rgb1_max].r;        g1 = rgb[bg[pat].rgb1_max].g;        b1 = rgb[bg[pat].rgb1_max].b;        r2 = rgb[bg[pat].rgb2_max].r;        g2 = rgb[bg[pat].rgb2_max].g;        b2 = rgb[bg[pat].rgb2_max].b;        for (row = 0;  row < rpng2_info.height;  ++row) {            yidx = (int)(row % bgscale);            if (yidx > hmax)                yidx = bgscale-1 - yidx;            dest = (char *)bg_data + row*bg_rowbytes;            for (i = 0;  i < rpng2_info.width;  ++i) {                xidx = (int)(i % bgscale);                if (xidx > hmax)                    xidx = bgscale-1 - xidx;                k = xidx + yidx;                *dest++ = (k*r1 + (max-k)*r2) / max;                *dest++ = (k*g1 + (max-k)*g2) / max;                *dest++ = (k*b1 + (max-k)*b2) / max;            }        }    } else if ((bg[pat].type & 0x07) == 2) {        uch ch;        int ii, x, y, hw, hh, grayspot;        double freq, rotate, saturate, gray, intensity;        double angle=0.0, aoffset=0.0, maxDist, dist;        double red=0.0, green=0.0, blue=0.0, hue, s, v, f, p, q, t;        fprintf(stderr, \"%s:  computing radial background...\",          PROGNAME);        fflush(stderr);        hh = (int)(rpng2_info.height / 2);        hw = (int)(rpng2_info.width / 2);                angle = CLIP(angle, 0.0, 360.0);        grayspot = CLIP(bg[pat].bg_gray, 1, (hh + hw));        freq = MAX((double)bg[pat].bg_freq, 0.0);        saturate = (double)bg[pat].bg_bsat * 0.1;        rotate = (double)bg[pat].bg_brot * 0.1;        gray = 0.0;        intensity = 0.0;        maxDist = (double)((hw*hw) + (hh*hh));        for (row = 0;  row < rpng2_info.height;  ++row) {            y = (int)(row - hh);            dest = (char *)bg_data + row*bg_rowbytes;            for (i = 0;  i < rpng2_info.width;  ++i) {                x = (int)(i - hw);                angle = (x == 0)? PI_2 : atan((double)y / (double)x);                gray = (double)MAX(ABS(y), ABS(x)) / grayspot;                gray = MIN(1.0, gray);                dist = (double)((x*x) + (y*y)) / maxDist;                intensity = cos((angle+(rotate*dist*PI)) * freq) *                  gray * saturate;                intensity = (MAX(MIN(intensity,1.0),-1.0) + 1.0) * 0.5;                hue = (angle + PI) * INV_PI_360 + aoffset;                s = gray * ((double)(ABS(x)+ABS(y)) / (double)(hw + hh));                s = MIN(MAX(s,0.0), 1.0);                v = MIN(MAX(intensity,0.0), 1.0);                if (s == 0.0) {                    ch = (uch)(v * 255.0);                    *dest++ = ch;                    *dest++ = ch;                    *dest++ = ch;                } else {                    if ((hue < 0.0) || (hue >= 360.0))                        hue -= (((int)(hue / 360.0)) * 360.0);                    hue /= 60.0;                    ii = (int)hue;                    f = hue - (double)ii;                    p = (1.0 - s) * v;                    q = (1.0 - (s * f)) * v;                    t = (1.0 - (s * (1.0 - f))) * v;                    if      (ii == 0) { red = v; green = t; blue = p; }                    else if (ii == 1) { red = q; green = v; blue = p; }                    else if (ii == 2) { red = p; green = v; blue = t; }                    else if (ii == 3) { red = p; green = q; blue = v; }                    else if (ii == 4) { red = t; green = p; blue = v; }                    else if (ii == 5) { red = v; green = p; blue = q; }                    *dest++ = (uch)(red * 255.0);                    *dest++ = (uch)(green * 255.0);                    *dest++ = (uch)(blue * 255.0);                }            }        }        fprintf(stderr, \"done.\\n\");        fflush(stderr);    }    if (depth == 24 || depth == 32) {        ulg red, green, blue;        int bpp = ximage->bits_per_pixel;        for (row = 0;  row < rpng2_info.height;  ++row) {            src = bg_data + row*bg_rowbytes;            dest = ximage->data + row*ximage_rowbytes;            if (bpp == 32) {                    for (i = rpng2_info.width;  i > 0;  --i) {                    red   = *src++;                    green = *src++;                    blue  = *src++;                    pixel = (red   << RShift) |                            (green << GShift) |                            (blue  << BShift);                                        *dest++ = (char)((pixel >> 24) & 0xff);                    *dest++ = (char)((pixel >> 16) & 0xff);                    *dest++ = (char)((pixel >>  8) & 0xff);                    *dest++ = (char)( pixel        & 0xff);                }            } else {                for (i = rpng2_info.width;  i > 0;  --i) {                    red   = *src++;                    green = *src++;                    blue  = *src++;                    pixel = (red   << RShift) |                            (green << GShift) |                            (blue  << BShift);                                                                                *dest++ = (char)((pixel >> 16) & 0xff);                    *dest++ = (char)((pixel >>  8) & 0xff);                    *dest++ = (char)( pixel        & 0xff);                }            }        }    } else if (depth == 16) {        ush red, green, blue;        for (row = 0;  row < rpng2_info.height;  ++row) {            src = bg_data + row*bg_rowbytes;            dest = ximage->data + row*ximage_rowbytes;            for (i = rpng2_info.width;  i > 0;  --i) {                red   = ((ush)(*src) << 8);  ++src;                green = ((ush)(*src) << 8);  ++src;                blue  = ((ush)(*src) << 8);  ++src;                pixel = ((red   >> RShift) & RMask) |                        ((green >> GShift) & GMask) |                        ((blue  >> BShift) & BMask);                                *dest++ = (char)((pixel >>  8) & 0xff);                *dest++ = (char)( pixel        & 0xff);            }        }    } else  {            }    XPutImage(display, window, gc, ximage, 0, 0, 0, 0, rpng2_info.width,      rpng2_info.height);    return 0;} ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intstore_read_buffer_next(png_store *ps){   png_store_buffer *pbOld = ps->next;   png_store_buffer *pbNew = &ps->current->data;   if (pbOld != pbNew)   {      while (pbNew != NULL && pbNew->prev != pbOld)         pbNew = pbNew->prev;      if (pbNew != NULL)      {         ps->next = pbNew;         ps->readpos = 0;         return 1;      }      png_error(ps->pread, \"buffer lost\");   }   return 0; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int PNGCBAPIread_callback(png_structp pp, png_unknown_chunkp pc){      display *d = voidcast(display*, png_get_user_chunk_ptr(pp));   int chunk = findb(pc->name);   int keep, discard;   if (chunk < 0)       keep = d->keep;   else   {      keep = chunk_info[chunk].keep;      if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT)      {                  if (chunk_info[chunk].unknown)            keep = d->keep;         else            keep = PNG_HANDLE_CHUNK_NEVER;      }   }   switch (keep)   {      default:         fprintf(stderr, \"%s(%s): %d: unrecognized chunk option\\n\", d->file,            d->test, chunk_info[chunk].keep);         display_exit(d);      case PNG_HANDLE_CHUNK_AS_DEFAULT:      case PNG_HANDLE_CHUNK_NEVER:         discard = 1;         break;      case PNG_HANDLE_CHUNK_IF_SAFE:      case PNG_HANDLE_CHUNK_ALWAYS:         discard = 0;         break;   }      if (chunk >= 0) if (!discard)    {      png_uint_32 flag = chunk_info[chunk].flag;      if (pc->location & PNG_AFTER_IDAT)         d->after_IDAT |= flag;      else         d->before_IDAT |= flag;   }   #  ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED      return discard;#  else      return 1; #  endif}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static const char *zlib_flevel(struct zlib *zlib){   switch (zlib->header[1] >> 6)   {      case 0:  return \"supfast\";      case 1:  return \"stdfast\";      case 2:  return \"default\";      case 3:  return \"maximum\";      default: assert(UNREACHED);   }   return \"COMPILER BUG\";}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGAPIpng_set_read_fn(png_structrp png_ptr, png_voidp io_ptr,   png_rw_ptr read_data_fn){   if (png_ptr == NULL)      return;   png_ptr->io_ptr = io_ptr;   if (read_data_fn != NULL)      png_ptr->read_data_fn = read_data_fn;   else      png_ptr->read_data_fn = png_default_read_data;   png_ptr->read_data_fn = read_data_fn;      if (png_ptr->write_data_fn != NULL)   {      png_ptr->write_data_fn = NULL;      png_warning(png_ptr,          \"Can't set both read_data_fn and write_data_fn in the\"          \" same structure\");   }   png_ptr->output_flush_fn = NULL;#endif}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void rpng2_win_display_row(ulg row){    uch bg_red   = rpng2_info.bg_red;    uch bg_green = rpng2_info.bg_green;    uch bg_blue  = rpng2_info.bg_blue;    uch *src, *src2=NULL, *dest;    uch r, g, b, a;    ulg i;    static int rows=0;    static ulg firstrow;    Trace((stderr, \"beginning rpng2_win_display_row()\\n\"))    if (rows == 0)        firstrow = row;       ++rows;       src = rpng2_info.image_data + row*rpng2_info.rowbytes;    if (bg_image)        src2 = bg_data + row*bg_rowbytes;    dest = wimage_data + row*wimage_rowbytes;    if (rpng2_info.channels == 3) {        for (i = rpng2_info.width;  i > 0;  --i) {            r = *src++;            g = *src++;            b = *src++;            *dest++ = b;            *dest++ = g;               *dest++ = r;        }    } else  {        for (i = rpng2_info.width;  i > 0;  --i) {            r = *src++;            g = *src++;            b = *src++;            a = *src++;            if (bg_image) {                bg_red   = *src2++;                bg_green = *src2++;                bg_blue  = *src2++;            }            if (a == 255) {                *dest++ = b;                *dest++ = g;                *dest++ = r;            } else if (a == 0) {                *dest++ = bg_blue;                *dest++ = bg_green;                *dest++ = bg_red;            } else {                                alpha_composite(*dest++, b, a, bg_blue);                alpha_composite(*dest++, g, a, bg_green);                alpha_composite(*dest++, r, a, bg_red);            }        }    }    if ((rows & 0xf) == 0 || row == rpng2_info.height-1) {        RECT rect;        rect.left = 0L;        rect.top = (LONG)firstrow;        rect.right = (LONG)rpng2_info.width;               rect.bottom = (LONG)row + 1L;                      InvalidateRect(global_hwnd, &rect, FALSE);        UpdateWindow(global_hwnd);                         rows = 0;    }} ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static chartype_char(png_uint_32 v){      if (v & 32)      return \"!abcdefghijklmnopqrstuvwxyz56789\"[(v-96)&31];   else      return \"@ABCDEFGHIJKLMNOPQRSTUVWXYZ01234\"[(v-64)&31];}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_byte png_exp8bit(png_uint_32 log){   return (png_byte)floor(.5 + exp(log * -LN2) * 255);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_unpc(Pixel *out, const Pixel *in, const Background *back){   (void)back;   if (in->a <= 128)   {      out->r = out->g = out->b = 255;      out->a = 0;   }   else   {      out->r = sRGB((double)in->r / in->a);      out->g = sRGB((double)in->g / in->a);      out->b = sRGB((double)in->b / in->a);      out->a = u8d(in->a / 257.);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, char **argv){   unsigned int i, i16, ibase;   double min_error = 0;   double max_error = 0;   double min_error16 = 0;   double max_error16 = 0;   double adjust;   double adjust_lo = 0.4, adjust_hi = 0.6, adjust_mid = 0.5;   unsigned int ec_lo = 0, ec_hi = 0, ec_mid = 0;   unsigned int error_count = 0;   unsigned int error_count16 = 0;   int test_only = 0;   if (argc > 1)      test_only = strcmp(\"--test\", argv[1]) == 0;      for (i=0; i<256; ++i)   {      png_sRGB_table[i] = invsRGB(i);   }      for (;;)   {      if (ec_lo == 0)         adjust = adjust_lo;      else if (ec_hi == 0)         adjust = adjust_hi;      else if (ec_mid == 0)         adjust = adjust_mid;      else if (ec_mid < ec_hi)         adjust = (adjust_mid + adjust_hi)/2;      else if (ec_mid < ec_lo)         adjust = (adjust_mid + adjust_lo)/2;      else      {         fprintf(stderr, \"not reached: %u .. %u .. %u\\n\", ec_lo, ec_mid, ec_hi);         exit(1);      }            for (i=0; i<=511; ++i)      {         double lo = 255 * sRGB(i << 15);         double hi = 255 * sRGB((i+1) << 15);         unsigned int calc;         calc = nearbyint((lo+adjust) * 256);         if (calc > 65535)         {            fprintf(stderr, \"table[%d][0]: overflow %08x (%d)\\n\", i, calc,               calc);            exit(1);         }         png_sRGB_base[i] = calc;         calc = nearbyint((hi-lo) * 32);         if (calc > 255)         {            fprintf(stderr, \"table[%d][1]: overflow %08x (%d)\\n\", i, calc,               calc);            exit(1);         }         png_sRGB_delta[i] = calc;      }            error_count16 = 0;      for (i16=0; i16 <= 65535; ++i16)      {         unsigned int i = 255*i16;         unsigned int iexact = nearbyint(255*sRGB(i));         unsigned int icalc = PNG_sRGB_FROM_LINEAR(i);         if (icalc != iexact)            ++error_count16;      }            if (ec_lo == 0)         ec_lo = error_count16;      else if (ec_hi == 0)         ec_hi = error_count16;      else if (ec_mid == 0)      {         ec_mid = error_count16;         printf(\"/* initial error counts: %u .. %u .. %u */\\n\", ec_lo, ec_mid,            ec_hi);      }      else if (error_count16 < ec_mid)      {         printf(\"/* adjust (mid ): %f: %u -> %u */\\n\", adjust, ec_mid,            error_count16);         ec_mid = error_count16;         adjust_mid = adjust;      }      else if (adjust < adjust_mid && error_count16 < ec_lo)      {         printf(\"/* adjust (low ): %f: %u -> %u */\\n\", adjust, ec_lo,            error_count16);         ec_lo = error_count16;         adjust_lo = adjust;      }      else if (adjust > adjust_mid && error_count16 < ec_hi)      {         printf(\"/* adjust (high): %f: %u -> %u */\\n\", adjust, ec_hi,            error_count16);         ec_hi = error_count16;         adjust_hi = adjust;      }      else      {         adjust = adjust_mid;         printf(\"/* adjust: %f: %u */\\n\", adjust, ec_mid);         break;      }   }      for (ibase=0; ibase<65536; ibase+=128)   {      png_uint_16 base = png_sRGB_base[ibase >> 7], trybase = base, ob=base;      png_byte delta = png_sRGB_delta[ibase >> 7], trydelta = delta, od=delta;      unsigned int ecbase = 0, eco;      for (;;)      {         png_sRGB_base[ibase >> 7] = trybase;         png_sRGB_delta[ibase >> 7] = trydelta;                  error_count16 = 0;         for (i16=ibase; i16 < ibase+128; ++i16)         {            unsigned int i = 255*i16;            unsigned int iexact = nearbyint(255*sRGB(i));            unsigned int icalc = PNG_sRGB_FROM_LINEAR(i);            if (icalc != iexact)               ++error_count16;         }         if (error_count16 == 0)            break;         if (ecbase == 0)         {            eco = ecbase = error_count16;            ++trybase;          }         else if (error_count16 < ecbase)         {            if (trybase > base)            {               base = trybase;               ++trybase;            }            else if (trybase < base)            {               base = trybase;               --trybase;            }            else if (trydelta > delta)            {               delta = trydelta;               ++trydelta;            }            else if (trydelta < delta)            {               delta = trydelta;               --trydelta;            }            else            {               fprintf(stderr, \"makesRGB: impossible\\n\");               exit(1);            }            ecbase = error_count16;         }         else         {            if (trybase > base)               trybase = base-1;            else if (trybase < base)            {               trybase = base;               ++trydelta;            }            else if (trydelta > delta)               trydelta = delta-1;            else if (trydelta < delta)               break;          }      }      png_sRGB_base[ibase >> 7] = base;      png_sRGB_delta[ibase >> 7] = delta;      if (base != ob || delta != od)      {         printf(\"/* table[%u]={%u,%u} -> {%u,%u} %u -> %u errors */\\n\",            ibase>>7, ob, od, base, delta, eco, ecbase);      }      else if (0)         printf(\"/* table[%u]={%u,%u} %u errors */\\n\", ibase>>7, ob, od,            ecbase);   }      min_error = -.4999;   max_error = .4999;   error_count = 0;   for (i=0; i <= max_input; ++i)   {      unsigned int iexact = nearbyint(255*sRGB(i));      unsigned int icalc = PNG_sRGB_FROM_LINEAR(i);      if (icalc != iexact)      {         double err = 255*sRGB(i) - icalc;         if (err > (max_error+.001) || err < (min_error-.001))         {            printf(               \"/* 0x%08x: exact: %3d, got: %3d [tables: %08x, %08x] (%f) */\\n\",               i, iexact, icalc, png_sRGB_base[i>>15],               png_sRGB_delta[i>>15], err);         }         ++error_count;         if (err > max_error)            max_error = err;         else if (err < min_error)            min_error = err;      }   }      error_count16 = 0;   max_error16 = 0;   min_error16 = 0;   for (i16=0; i16 <= 65535; ++i16)   {      unsigned int i = 255*i16;      unsigned int iexact = nearbyint(255*sRGB(i));      unsigned int icalc = PNG_sRGB_FROM_LINEAR(i);      if (icalc != iexact)      {         double err = 255*sRGB(i) - icalc;         ++error_count16;         if (err > max_error16)            max_error16 = err;         else if (err < min_error16)            min_error16 = err;         if (abs(icalc - iexact) > 1)            printf(               \"/* 0x%04x: exact: %3d, got: %3d [tables: %08x, %08x] (%f) */\\n\",               i16, iexact, icalc, png_sRGB_base[i>>15],               png_sRGB_delta[i>>15], err);      }   }      for (i16=0; i16 <= 255; ++i16)   {      unsigned int i = 255 * png_sRGB_table[i16];      unsigned int iexact = nearbyint(255*sRGB(i));      unsigned int icalc = PNG_sRGB_FROM_LINEAR(i);      if (i16 != iexact)      {         fprintf(stderr, \"8-bit rounding error: %d -> %d\\n\", i16, iexact);         exit(1);      }      if (icalc != i16)      {         double finv = finvsRGB(i16);         printf(\"/* 8-bit roundtrip error: %d -> %f -> %d(%f) */\\n\",            i16, finv, icalc, fsRGB(255*finv));      }   }   printf(\"/* error: %g - %g, %u (%g%%) of readings inexact */\\n\",      min_error, max_error, error_count, (100.*error_count)/max_input);   printf(\"/* 16-bit error: %g - %g, %u (%g%%) of readings inexact */\\n\",      min_error16, max_error16, error_count16, (100.*error_count16)/65535);   if (!test_only)   {      printf(\"PNG_CONST png_uint_16 png_sRGB_table[256] =\\n{\\n   \");      for (i=0; i<255; )      {         do         {            printf(\"%d,\", png_sRGB_table[i++]);         }         while ((i & 0x7) != 0 && i<255);         if (i<255) printf(\"\\n   \");      }      printf(\"%d\\n};\\n\\n\", png_sRGB_table[i]);      printf(\"PNG_CONST png_uint_16 png_sRGB_base[512] =\\n{\\n   \");      for (i=0; i<511; )      {         do         {            printf(\"%d,\", png_sRGB_base[i++]);         }         while ((i & 0x7) != 0 && i<511);         if (i<511) printf(\"\\n   \");      }      printf(\"%d\\n};\\n\\n\", png_sRGB_base[i]);      printf(\"PNG_CONST png_byte png_sRGB_delta[512] =\\n{\\n   \");      for (i=0; i<511; )      {         do         {            printf(\"%d,\", png_sRGB_delta[i++]);         }         while ((i & 0xf) != 0 && i<511);         if (i<511) printf(\"\\n   \");      }      printf(\"%d\\n};\\n\\n\", png_sRGB_delta[i]);   }   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_mod_end(PNG_CONST image_transform *this, image_pixel *that,    png_const_structp pp, PNG_CONST transform_display *display){   PNG_CONST unsigned int scale = (1U<<that->sample_depth)-1;   UNUSED(this)   UNUSED(pp)   UNUSED(display)      that->red = sample_scale(that->redf, scale);      that->rede += 1./(2*((1U<<that->red_sBIT)-1));   if (that->colour_type & PNG_COLOR_MASK_COLOR)   {      that->green = sample_scale(that->greenf, scale);      that->blue = sample_scale(that->bluef, scale);      that->greene += 1./(2*((1U<<that->green_sBIT)-1));      that->bluee += 1./(2*((1U<<that->blue_sBIT)-1));   }   else   {      that->blue = that->green = that->red;      that->bluef = that->greenf = that->redf;      that->bluee = that->greene = that->rede;   }   if ((that->colour_type & PNG_COLOR_MASK_ALPHA) ||      that->colour_type == PNG_COLOR_TYPE_PALETTE)   {      that->alpha = sample_scale(that->alphaf, scale);      that->alphae += 1./(2*((1U<<that->alpha_sBIT)-1));   }   else   {      that->alpha = scale;       that->alpha = 1;           that->alphae = 0;       }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIdisplay_error(png_structp pp, png_const_charp error){   struct display *dp = get_dp(pp);   display_log(dp, LIBPNG_ERROR, \"%s\", error);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "BOOL SearchPngList (        TCHAR *pFileList, int FileCount, int *pFileIndex,        PTSTR pstrPrevName, PTSTR pstrNextName){    if (FileCount > 0)    {                if (pstrPrevName != NULL)        {            if (*pFileIndex > 0)                *pFileIndex -= 1;            else                *pFileIndex = FileCount - 1;            strcpy (pstrPrevName, pFileList + (*pFileIndex * MAX_PATH));        }                if (pstrNextName != NULL)        {            if (*pFileIndex < FileCount - 1)                *pFileIndex += 1;            else                *pFileIndex = 0;            strcpy (pstrNextName, pFileList + (*pFileIndex * MAX_PATH));        }        return TRUE;    }    else    {        return FALSE;    }} */BOOL SearchPngList (        TCHAR *pFileList, int FileCount, int *pFileIndex,        PTSTR pstrPrevName, PTSTR pstrNextName){    if (FileCount > 0)    {                if (pstrPrevName != NULL)        {            if (*pFileIndex > 0)                *pFileIndex -= 1;            else                *pFileIndex = FileCount - 1;            strcpy (pstrPrevName, pFileList + (*pFileIndex * MAX_PATH));        }                if (pstrNextName != NULL)        {            if (*pFileIndex < FileCount - 1)                *pFileIndex += 1;            else                *pFileIndex = 0;            strcpy (pstrNextName, pFileList + (*pFileIndex * MAX_PATH));        }        return TRUE;    }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIgamma_end(png_structp ppIn, png_infop pi){   png_const_structp pp = ppIn;   gamma_display *dp = voidcast(gamma_display*, png_get_progressive_ptr(pp));   if (!dp->this.speed)      gamma_image_validate(dp, pp, pi);   else      dp->this.ps->validated = 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intpng_pass_row_shift(int pass){   int x, y, base=(-1), inc=8;   ++pass;   for (y=0; y<8; ++y) for (x=0; x<8; ++x) if (adam7[y][x] == pass)   {      if (base == (-1))         base = y;      else if (base == y)         {}      else if (inc == y-base)         base=y;      else if (inc == 8)         inc = y-base, base=y;      else if (inc != y-base)         return 0xff;    }   if (base == (-1)) return 0xfe;       switch (inc)   {case 2: return 1;case 4: return 2;case 8: return 3;default: break;   }      return (inc << 8) + 0xfd;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int readpng2_check_sig(uch *sig, int num){    return !png_sig_cmp(sig, 0, num);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidchunk_end(struct chunk **chunk_var){   struct chunk *chunk = *chunk_var;   *chunk_var = NULL;   CLEAR(*chunk);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void rpng2_win_finish_display(){    Trace((stderr, \"beginning rpng2_win_finish_display()\\n\"))        rpng2_info.state = kDone;    printf(#ifndef __CYGWIN__      \"Done.  Press Q, Esc or mouse button 1 (within image window) to quit.\\n\"#else      \"Done.  Press mouse button 1 (within image window) to quit.\\n\"#endif    );    fflush(stdout);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidtype_sep(FILE *out){   putc(':', out);   putc(' ', out);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGCBAPIpng_debug_free(png_structp png_ptr, png_voidp ptr){   if (png_ptr == NULL)      fprintf(STDERR, \"NULL pointer to png_debug_free.\\n\");   if (ptr == 0)   {#if 0       fprintf(STDERR, \"WARNING: freeing NULL pointer\\n\");#endif      return;   }      {      memory_infop FAR *ppinfo = &pinformation;      for (;;)      {         memory_infop pinfo = *ppinfo;         if (pinfo->pointer == ptr)         {            *ppinfo = pinfo->next;            current_allocation -= pinfo->size;            if (current_allocation < 0)               fprintf(STDERR, \"Duplicate free of memory\\n\");                        png_memset(ptr, 0x55, pinfo->size);            png_free_default(png_ptr, pinfo);            pinfo = NULL;            break;         }         if (pinfo->next == NULL)         {            fprintf(STDERR, \"Pointer %x not found\\n\", (unsigned int)ptr);            break;         }         ppinfo = &pinfo->next;      }   }      if (verbose)      printf(\"Freeing %p\\n\", ptr);   png_free_default(png_ptr, ptr);   ptr = NULL;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgamma_display_init(gamma_display *dp, png_modifier *pm, png_uint_32 id,    double file_gamma, double screen_gamma, png_byte sbit, int threshold_test,    int use_input_precision, int scale16, int expand16,    int do_background, PNG_CONST png_color_16 *pointer_to_the_background_color,    double background_gamma){      standard_display_init(&dp->this, &pm->this, id, 0,      pm->use_update_info);      dp->pm = pm;   dp->file_gamma = file_gamma;   dp->screen_gamma = screen_gamma;   dp->background_gamma = background_gamma;   dp->sbit = sbit;   dp->threshold_test = threshold_test;   dp->use_input_precision = use_input_precision;   dp->scale16 = scale16;   dp->expand16 = expand16;   dp->do_background = do_background;   if (do_background && pointer_to_the_background_color != 0)      dp->background_color = *pointer_to_the_background_color;   else      memset(&dp->background_color, 0, sizeof dp->background_color);      dp->maxerrout = dp->maxerrpc = dp->maxerrabs = 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidset_value(png_bytep row, size_t rowbytes, png_uint_32 x, unsigned int bit_depth,   png_uint_32 value, png_const_bytep gamma_table, double conv){   unsigned int mask = (1U << bit_depth)-1;   x *= bit_depth;     if (value <= mask)   {      png_uint_32 offset = x >> 3;      if (offset < rowbytes && (bit_depth < 16 || offset+1 < rowbytes))      {         row += offset;         switch (bit_depth)         {            case 1:            case 2:            case 4:                              {                  unsigned int shift = (8 - bit_depth) - (x & 0x7U);                  mask <<= shift;                  value = (value << shift) & mask;                  *row = (png_byte)((*row & ~mask) | value);               }               return;            default:               fprintf(stderr, \"makepng: bad bit depth (internal error)\\n\");               exit(1);            case 16:               value = (unsigned int)floor(65535*pow(value/65535.,conv)+.5);               *row++ = (png_byte)(value >> 8);               *row = (png_byte)value;               return;            case 8:               *row = gamma_table[value];               return;         }      }      else      {         fprintf(stderr, \"makepng: row buffer overflow (internal error)\\n\");         exit(1);      }   }   else   {      fprintf(stderr, \"makepng: component overflow (internal error)\\n\");      exit(1);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIstore_warning(png_structp ppIn, png_const_charp message){   png_const_structp pp = ppIn;   png_store *ps = voidcast(png_store*, png_get_error_ptr(pp));   if (!ps->expect_warning)      store_log(ps, pp, message, 0 );   else      ps->saw_warning = 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_pool_error(png_store *ps, png_const_structp pp, PNG_CONST char *msg){   if (pp != NULL)      png_error(pp, msg);      store_log(ps, pp, msg, 1 );}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void  png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length){   png_alloc_size_t limit = PNG_UINT_31_MAX;# ifdef PNG_SET_USER_LIMITS_SUPPORTED   if (png_ptr->user_chunk_malloc_max > 0 &&       png_ptr->user_chunk_malloc_max < limit)      limit = png_ptr->user_chunk_malloc_max;# elif PNG_USER_CHUNK_MALLOC_MAX > 0   if (PNG_USER_CHUNK_MALLOC_MAX < limit)      limit = PNG_USER_CHUNK_MALLOC_MAX;# endif   if (png_ptr->chunk_name == png_IDAT)   {      png_alloc_size_t idat_limit = PNG_UINT_31_MAX;      size_t row_factor =         (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)          + 1 + (png_ptr->interlaced? 6: 0));      if (png_ptr->height > PNG_UINT_32_MAX/row_factor)         idat_limit=PNG_UINT_31_MAX;      else         idat_limit = png_ptr->height * row_factor;      row_factor = row_factor > 32566? 32566 : row_factor;      idat_limit += 6 + 5*(idat_limit/row_factor+1);        idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;      limit = limit < idat_limit? idat_limit : limit;   }   if (length > limit)   {      png_debug2(0,\" length = %lu, limit = %lu\",         (unsigned long)length,(unsigned long)limit);      png_chunk_error(png_ptr, \"chunk data is too large\");   }}",
        "label": 1,
        "cve": "CVE-2018-13785"
    },
    {
        "code": "static voidimage_transform_png_set_scale_16_mod(PNG_CONST image_transform *this,    image_pixel *that, png_const_structp pp,    PNG_CONST transform_display *display){   if (that->bit_depth == 16)   {      that->sample_depth = that->bit_depth = 8;      if (that->red_sBIT > 8) that->red_sBIT = 8;      if (that->green_sBIT > 8) that->green_sBIT = 8;      if (that->blue_sBIT > 8) that->blue_sBIT = 8;      if (that->alpha_sBIT > 8) that->alpha_sBIT = 8;   }   this->next->mod(this->next, that, pp, display);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int main(int argc, char *argv[]){  FILE *fp_rd = stdin;  FILE *fp_wr = stdout;  FILE *fp_al = NULL;  BOOL raw = TRUE;  BOOL alpha = FALSE;  int argi;  for (argi = 1; argi < argc; argi++)  {    if (argv[argi][0] == '-')    {      switch (argv[argi][1])      {        case 'n':          raw = FALSE;          break;        case 'r':          raw = TRUE;          break;        case 'a':          alpha = TRUE;          argi++;          if ((fp_al = fopen (argv[argi], \"wb\")) == NULL)          {            fprintf (stderr, \"PNM2PNG\\n\");            fprintf (stderr, \"Error:  can not create alpha-channel file %s\\n\",               argv[argi]);            exit (1);          }          break;        case 'h':        case '?':          usage();          exit(0);          break;        default:          fprintf (stderr, \"PNG2PNM\\n\");          fprintf (stderr, \"Error:  unknown option %s\\n\", argv[argi]);          usage();          exit(1);          break;      }     }    else if (fp_rd == stdin)    {      if ((fp_rd = fopen (argv[argi], \"rb\")) == NULL)      {             fprintf (stderr, \"PNG2PNM\\n\");            fprintf (stderr, \"Error:  file %s does not exist\\n\", argv[argi]);            exit (1);      }    }    else if (fp_wr == stdout)    {      if ((fp_wr = fopen (argv[argi], \"wb\")) == NULL)      {        fprintf (stderr, \"PNG2PNM\\n\");        fprintf (stderr, \"Error:  can not create file %s\\n\", argv[argi]);        exit (1);      }    }    else    {      fprintf (stderr, \"PNG2PNM\\n\");      fprintf (stderr, \"Error:  too many parameters\\n\");      usage();      exit(1);    }  } #ifdef __TURBOC__    if (fp_rd == stdin)  {    setmode (STDIN, O_BINARY);  }  if ((raw) && (fp_wr == stdout))  {    setmode (STDOUT, O_BINARY);  }#endif    if (png2pnm (fp_rd, fp_wr, fp_al, raw, alpha) == FALSE)  {    fprintf (stderr, \"PNG2PNM\\n\");    fprintf (stderr, \"Error:  unsuccessful conversion of PNG-image\\n\");    exit(1);  }    fclose (fp_rd);    fclose (fp_wr);    if (alpha)    fclose (fp_al);  return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int global_showmode;int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, PSTR cmd, int showmode){    char *args[1024];                     char **argv = args;    char *p, *q, *bgstr = NULL;    int argc = 0;    int rc, alen, flen;    int error = 0;    int timing = FALSE;    int have_bg = FALSE;    double LUT_exponent;                  double CRT_exponent = 2.2;            double default_display_exponent;      MSG msg;        global_hInst = hInst;    global_showmode = showmode;    filename = (char *)NULL;    memset(&rpng2_info, 0, sizeof(mainprog_info));#ifndef __CYGWIN__        AllocConsole();    freopen(\"CONOUT$\", \"a\", stderr);    freopen(\"CONOUT$\", \"a\", stdout);#endif    #if defined(NeXT)        LUT_exponent = 1.0 / 2.2;    #elif defined(sgi)    LUT_exponent = 1.0 / 1.7;        infile = fopen(\"/etc/config/system.glGammaVal\", \"r\");    if (infile) {        double sgi_gamma;        fgets(tmpline, 80, infile);        fclose(infile);        sgi_gamma = atof(tmpline);        if (sgi_gamma > 0.0)            LUT_exponent = 1.0 / sgi_gamma;    }#elif defined(Macintosh)    LUT_exponent = 1.8 / 2.61;    #else    LUT_exponent = 1.0;   #endif        default_display_exponent = LUT_exponent * CRT_exponent;        if ((p = getenv(\"SCREEN_GAMMA\")) != NULL)        rpng2_info.display_exponent = atof(p);    else        rpng2_info.display_exponent = default_display_exponent;        argv[argc++] = PROGNAME;    p = cmd;    for (;;) {        if (*p == ' ')            while (*++p == ' ')                ;                if (*p == '\\0')            break;            argv[argc++] = q = p;        while (*q && *q != ' ')            ++q;                if (*q == '\\0')            break;            *q = '\\0';            p = q + 1;    }    argv[argc] = NULL;           while (*++argv && !error) {        if (!strncmp(*argv, \"-gamma\", 2)) {            if (!*++argv)                ++error;            else {                rpng2_info.display_exponent = atof(*argv);                if (rpng2_info.display_exponent <= 0.0)                    ++error;            }        } else if (!strncmp(*argv, \"-bgcolor\", 4)) {            if (!*++argv)                ++error;            else {                bgstr = *argv;                if (strlen(bgstr) != 7 || bgstr[0] != '#')                    ++error;                else {                    have_bg = TRUE;                    bg_image = FALSE;                }            }        } else if (!strncmp(*argv, \"-bgpat\", 4)) {            if (!*++argv)                ++error;            else {                pat = atoi(*argv) - 1;                if (pat < 0 || pat >= num_bgpat)                    ++error;                else {                    bg_image = TRUE;                    have_bg = FALSE;                }            }        } else if (!strncmp(*argv, \"-timing\", 2)) {            timing = TRUE;        } else {            if (**argv != '-') {                filename = *argv;                if (argv[1])                       ++error;            } else                ++error;           }    }    if (!filename)        ++error;        if (error) {#ifndef __CYGWIN__        int ch;#endif        fprintf(stderr, \"\\n%s %s:  %s\\n\\n\", PROGNAME, VERSION, appname);        readpng2_version_info();        fprintf(stderr, \"\\n\"          \"Usage:  %s [-gamma exp] [-bgcolor bg | -bgpat pat] [-timing]\\n\"          \"        %*s file.png\\n\\n\"          \"    exp \\ttransfer-function exponent (``gamma'') of the display\\n\"          \"\\t\\t  system in floating-point format (e.g., ``%.1f''); equal\\n\"          \"\\t\\t  to the product of the lookup-table exponent (varies)\\n\"          \"\\t\\t  and the CRT exponent (usually 2.2); must be positive\\n\"          \"    bg  \\tdesired background color in 7-character hex RGB format\\n\"          \"\\t\\t  (e.g., ``#ff7700'' for orange:  same as HTML colors);\\n\"          \"\\t\\t  used with transparent images; overrides -bgpat option\\n\"          \"    pat \\tdesired background pattern number (1-%d); used with\\n\"          \"\\t\\t  transparent images; overrides -bgcolor option\\n\"          \"    -timing\\tenables delay for every block read, to simulate modem\\n\"          \"\\t\\t  download of image (~36 Kbps)\\n\"          \"\\nPress Q, Esc or mouse button 1 after image is displayed to quit.\\n\"#ifndef __CYGWIN__          \"Press Q or Esc to quit this usage screen. \",#else          ,#endif          PROGNAME,#if (defined(__i386__) || defined(_M_IX86) || defined(__x86_64__)) && \\    !(defined(__CYGWIN__) || defined(__MINGW32__))          (int)strlen(PROGNAME), \" \",#endif          (int)strlen(PROGNAME), \" \", default_display_exponent, num_bgpat);        fflush(stderr);#ifndef __CYGWIN__        do            ch = _getch();        while (ch != 'q' && ch != 'Q' && ch != 0x1B);#endif        exit(1);    }    if (!(infile = fopen(filename, \"rb\"))) {        fprintf(stderr, PROGNAME \":  can't open PNG file [%s]\\n\", filename);        ++error;    } else {        incount = fread(inbuf, 1, INBUFSIZE, infile);        if (incount < 8 || !readpng2_check_sig(inbuf, 8)) {            fprintf(stderr, PROGNAME              \":  [%s] is not a PNG file: incorrect signature\\n\",              filename);            ++error;        } else if ((rc = readpng2_init(&rpng2_info)) != 0) {            switch (rc) {                case 2:                    fprintf(stderr, PROGNAME                      \":  [%s] has bad IHDR (libpng longjmp)\\n\", filename);                    break;                case 4:                    fprintf(stderr, PROGNAME \":  insufficient memory\\n\");                    break;                default:                    fprintf(stderr, PROGNAME                      \":  unknown readpng2_init() error\\n\");                    break;            }            ++error;        }        if (error)            fclose(infile);    }    if (error) {#ifndef __CYGWIN__        int ch;#endif        fprintf(stderr, PROGNAME \":  aborting.\\n\");#ifndef __CYGWIN__        do            ch = _getch();        while (ch != 'q' && ch != 'Q' && ch != 0x1B);#endif        exit(2);    } else {        fprintf(stderr, \"\\n%s %s:  %s\\n\", PROGNAME, VERSION, appname);#ifndef __CYGWIN__        fprintf(stderr,          \"\\n   [console window:  closing this window will terminate %s]\\n\\n\",          PROGNAME);#endif        fflush(stderr);    }        alen = strlen(appname);    flen = strlen(filename);    if (alen + flen + 3 > 1023)        sprintf(titlebar, \"%s:  ...%s\", appname, filename+(alen+flen+6-1023));    else        sprintf(titlebar, \"%s:  %s\", appname, filename);        if (have_bg) {        unsigned r, g, b;           sscanf(bgstr+1, \"%2x%2x%2x\", &r, &g, &b);        rpng2_info.bg_red   = (uch)r;        rpng2_info.bg_green = (uch)g;        rpng2_info.bg_blue  = (uch)b;    } else        rpng2_info.need_bgcolor = TRUE;    rpng2_info.state = kPreInit;    rpng2_info.mainprog_init = rpng2_win_init;    rpng2_info.mainprog_display_row = rpng2_win_display_row;    rpng2_info.mainprog_finish_display = rpng2_win_finish_display;        for (;;) {        Trace((stderr, \"about to call readpng2_decode_data()\\n\"))        if (readpng2_decode_data(&rpng2_info, inbuf, incount))            ++error;        Trace((stderr, \"done with readpng2_decode_data()\\n\"))        if (error || incount != INBUFSIZE || rpng2_info.state == kDone) {            if (rpng2_info.state == kDone) {                Trace((stderr, \"done decoding PNG image\\n\"))            } else if (ferror(infile)) {                fprintf(stderr, PROGNAME                  \":  error while reading PNG image file\\n\");                exit(3);            } else if (feof(infile)) {                fprintf(stderr, PROGNAME \":  end of file reached \"                  \"(unexpectedly) while reading PNG image file\\n\");                exit(3);            } else  {                            }            break;        }        if (timing)            Sleep(1000L);        incount = fread(inbuf, 1, INBUFSIZE, infile);    }        fclose(infile);    Trace((stderr, \"about to call readpng2_cleanup()\\n\"))    readpng2_cleanup(&rpng2_info);    if (error) {        fprintf(stderr, PROGNAME \":  libpng error while decoding PNG image\\n\");        exit(3);    }        while (GetMessage(&msg, NULL, 0, 0)) {        TranslateMessage(&msg);        DispatchMessage(&msg);    }        Trace((stderr, \"about to call rpng2_win_cleanup()\\n\"))    rpng2_win_cleanup();    return msg.wParam;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intmodifier_color_encoding_is_sRGB(PNG_CONST png_modifier *pm){   return pm->current_encoding != 0 && pm->current_encoding == pm->encodings &&      pm->current_encoding->gamma == pm->current_gamma;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidset_text(png_structp png_ptr, png_infop info_ptr, png_textp text,   png_charp param){   switch (param[0])   {      case '<':         {            png_bytep file = NULL;            text->text_length = load_file(param+1, &file);            text->text = (png_charp)file;         }         break;      case '0': case '1': case '2': case '3': case '4':      case '5': case '6': case '7': case '8': case '9':         {            png_bytep data = NULL;            png_size_t fake_len = load_fake(param, &data);            if (fake_len > 0)             {               text->text_length = fake_len;               text->text = (png_charp)data;               break;            }         }      default:         text->text = param;         break;   }   png_set_text(png_ptr, info_ptr, text, 1);   if (text->text != param)      free(text->text);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_read_imp(png_store *ps, png_bytep pb, png_size_t st){   if (ps->current == NULL || ps->next == NULL)      png_error(ps->pread, \"store state damaged\");   while (st > 0)   {      size_t cbAvail = store_read_buffer_size(ps) - ps->readpos;      if (cbAvail > 0)      {         if (cbAvail > st) cbAvail = st;         memcpy(pb, ps->next->buffer + ps->readpos, cbAvail);         st -= cbAvail;         pb += cbAvail;         ps->readpos += cbAvail;      }      else if (!store_read_buffer_next(ps))         png_error(ps->pread, \"read beyond end of file\");   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_pixel_add_alpha(image_pixel *this, PNG_CONST standard_display *display){   if (this->colour_type == PNG_COLOR_TYPE_PALETTE)      image_pixel_convert_PLTE(this);   if ((this->colour_type & PNG_COLOR_MASK_ALPHA) == 0)   {      if (this->colour_type == PNG_COLOR_TYPE_GRAY)      {         if (this->bit_depth < 8)            this->bit_depth = 8;         if (this->have_tRNS)         {            this->have_tRNS = 0;                        if (this->red == display->transparent.red)               this->alphaf = 0;            else               this->alphaf = 1;         }         else            this->alphaf = 1;         this->colour_type = PNG_COLOR_TYPE_GRAY_ALPHA;      }      else if (this->colour_type == PNG_COLOR_TYPE_RGB)      {         if (this->have_tRNS)         {            this->have_tRNS = 0;                        if (this->red == display->transparent.red &&               this->green == display->transparent.green &&               this->blue == display->transparent.blue)               this->alphaf = 0;            else               this->alphaf = 1;            this->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;         }      }            this->alphae = 0;      this->alpha_sBIT = display->alpha_sBIT;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": " *  unexpected pnmtype; note that outfile might be stdout */int writepng_init(mainprog_info *mainprog_ptr){    png_structp  png_ptr;           png_infop  info_ptr;    int color_type, interlace_type;        png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,      writepng_error_handler, NULL);    if (!png_ptr)        return 4;       info_ptr = png_create_info_struct(png_ptr);    if (!info_ptr) {        png_destroy_write_struct(&png_ptr, NULL);        return 4;       }        if (setjmp(mainprog_ptr->jmpbuf)) {        png_destroy_write_struct(&png_ptr, &info_ptr);        return 2;    }        png_init_io(png_ptr, mainprog_ptr->outfile);        png_set_compression_level(png_ptr, Z_BEST_COMPRESSION);        if (mainprog_ptr->pnmtype == 5)        color_type = PNG_COLOR_TYPE_GRAY;    else if (mainprog_ptr->pnmtype == 6)        color_type = PNG_COLOR_TYPE_RGB;    else if (mainprog_ptr->pnmtype == 8)        color_type = PNG_COLOR_TYPE_RGB_ALPHA;    else {        png_destroy_write_struct(&png_ptr, &info_ptr);        return 11;    }    interlace_type = mainprog_ptr->interlaced? PNG_INTERLACE_ADAM7 :                                               PNG_INTERLACE_NONE;    png_set_IHDR(png_ptr, info_ptr, mainprog_ptr->width, mainprog_ptr->height,      mainprog_ptr->sample_depth, color_type, interlace_type,      PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);    if (mainprog_ptr->gamma > 0.0)        png_set_gAMA(png_ptr, info_ptr, mainprog_ptr->gamma);    if (mainprog_ptr->have_bg) {           png_color_16  background;        background.red = mainprog_ptr->bg_red;        background.green = mainprog_ptr->bg_green;        background.blue = mainprog_ptr->bg_blue;        png_set_bKGD(png_ptr, info_ptr, &background);    }    if (mainprog_ptr->have_time) {        png_time  modtime;        png_convert_from_time_t(&modtime, mainprog_ptr->modtime);        png_set_tIME(png_ptr, info_ptr, &modtime);    }    if (mainprog_ptr->have_text) {        png_text  text[6];        int  num_text = 0;        if (mainprog_ptr->have_text & TEXT_TITLE) {            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;            text[num_text].key = \"Title\";            text[num_text].text = mainprog_ptr->title;            ++num_text;        }        if (mainprog_ptr->have_text & TEXT_AUTHOR) {            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;            text[num_text].key = \"Author\";            text[num_text].text = mainprog_ptr->author;            ++num_text;        }        if (mainprog_ptr->have_text & TEXT_DESC) {            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;            text[num_text].key = \"Description\";            text[num_text].text = mainprog_ptr->desc;            ++num_text;        }        if (mainprog_ptr->have_text & TEXT_COPY) {            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;            text[num_text].key = \"Copyright\";            text[num_text].text = mainprog_ptr->copyright;            ++num_text;        }        if (mainprog_ptr->have_text & TEXT_EMAIL) {            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;            text[num_text].key = \"E-mail\";            text[num_text].text = mainprog_ptr->email;            ++num_text;        }        if (mainprog_ptr->have_text & TEXT_URL) {            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;            text[num_text].key = \"URL\";            text[num_text].text = mainprog_ptr->url;            ++num_text;        }        png_set_text(png_ptr, info_ptr, text, num_text);    }        png_write_info(png_ptr, info_ptr);            png_set_packing(png_ptr);        mainprog_ptr->png_ptr = png_ptr;    mainprog_ptr->info_ptr = info_ptr;        return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_pool_init(png_store *ps, store_pool *pool){   memset(pool, 0, sizeof *pool);   pool->store = ps;   pool->list = NULL;   pool->max = pool->current = pool->limit = pool->total = 0;   pool->max_max = pool->max_limit = pool->max_total = 0;   store_pool_mark(pool->mark);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intimage_transform_test_counter(png_uint_32 counter, unsigned int max){      image_transform *next = image_transform_first;   while (next != &image_transform_end)   {            counter >>= 1;            if (max > 1 && next->local_use < max)         return 1;      next = next->list;   }   return max <= 1 && counter == 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_handle_sCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length){   png_size_t slength, index;   int state;   png_debug(1, \"in png_handle_sCAL\");   if (!(png_ptr->mode & PNG_HAVE_IHDR))      png_error(png_ptr, \"Missing IHDR before sCAL\");   else if (png_ptr->mode & PNG_HAVE_IDAT)   {      png_warning(png_ptr, \"Invalid sCAL after IDAT\");      png_crc_finish(png_ptr, length);      return;   }   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL))   {      png_warning(png_ptr, \"Duplicate sCAL chunk\");      png_crc_finish(png_ptr, length);      return;   }   png_debug1(2, \"Allocating and reading sCAL chunk data (%u bytes)\",      length + 1);   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);   if (png_ptr->chunkdata == NULL)   {      png_warning(png_ptr, \"Out of memory while processing sCAL chunk\");      png_crc_finish(png_ptr, length);      return;   }   slength = (png_size_t)length;   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);   png_ptr->chunkdata[slength] = 0x00;    if (png_crc_finish(png_ptr, 0))   {      png_free(png_ptr, png_ptr->chunkdata);      png_ptr->chunkdata = NULL;      return;   }      if (png_ptr->chunkdata[0] != 1 && png_ptr->chunkdata[0] != 2)   {      png_warning(png_ptr, \"Invalid sCAL ignored: invalid unit\");      png_free(png_ptr, png_ptr->chunkdata);      png_ptr->chunkdata = NULL;      return;   }      index = 0;   state = 0;   if (png_ptr->chunkdata[1] == 45  ||       !png_check_fp_number(png_ptr->chunkdata, slength, &state, &index) ||       index >= slength || png_ptr->chunkdata[index++] != 0)      png_warning(png_ptr, \"Invalid sCAL chunk ignored: bad width format\");   else   {      png_size_t heighti = index;      if (png_ptr->chunkdata[index] == 45  ||          !png_check_fp_number(png_ptr->chunkdata, slength, &state, &index) ||          index != slength)         png_warning(png_ptr, \"Invalid sCAL chunk ignored: bad height format\");      else                  png_set_sCAL_s(png_ptr, info_ptr, png_ptr->chunkdata[0],            png_ptr->chunkdata+1, png_ptr->chunkdata+heighti);   }      png_free(png_ptr, png_ptr->chunkdata);   png_ptr->chunkdata = NULL;}#endif",
        "label": 1,
        "cve": "cve-2011-2692"
    },
    {
        "code": "static voidmake_random_bytes(png_uint_32* seed, void* pv, size_t size){   png_uint_32 u0 = seed[0], u1 = seed[1];   png_bytep bytes = voidcast(png_bytep, pv);      size_t i;   for (i=0; i<size; ++i)   {            png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;      u1 <<= 8;      u1 |= u0 >> 24;      u0 <<= 8;      u0 |= u;      *bytes++ = (png_byte)u;   }   seed[0] = u0;   seed[1] = u1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_bgr16(Pixel *p, png_const_voidp pb){   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);   p->r = pp[2];   p->g = pp[1];   p->b = pp[0];   p->a = 65535;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "png_size_t png_check_keyword(png_structp png_ptr, png_charp key, png_charpp new_key){   png_size_t key_len;   png_charp kp, dp;   int kflag;   int kwarn=0;   png_debug(1, \"in png_check_keyword\\n\");   *new_key = NULL;   if (key == NULL || (key_len = png_strlen(key)) == 0)   {      png_warning(png_ptr, \"zero length keyword\");      return ((png_size_t)0);   }   png_debug1(2, \"Keyword to be checked is '%s'\\n\", key);   *new_key = (png_charp)png_malloc_warn(png_ptr, (png_uint_32)(key_len + 2));   if (*new_key == NULL)   {      png_warning(png_ptr, \"Out of memory while procesing keyword\");      return ((png_size_t)0);   }      for (kp = key, dp = *new_key; *kp != '\\0'; kp++, dp++)   {      if ((png_byte)*kp < 0x20 ||         ((png_byte)*kp > 0x7E && (png_byte)*kp < 0xA1))      {#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)         char msg[40];         png_snprintf(msg, 40,           \"invalid keyword character 0x%02X\", (png_byte)*kp);         png_warning(png_ptr, msg);#else         png_warning(png_ptr, \"invalid character in keyword\");#endif         *dp = ' ';      }      else      {         *dp = *kp;      }   }   *dp = '\\0';      kp = *new_key + key_len - 1;   if (*kp == ' ')   {      png_warning(png_ptr, \"trailing spaces removed from keyword\");      while (*kp == ' ')      {        *(kp--) = '\\0';        key_len--;      }   }      kp = *new_key;   if (*kp == ' ')   {      png_warning(png_ptr, \"leading spaces removed from keyword\");      while (*kp == ' ')      {        kp++;        key_len--;      }   }   png_debug1(2, \"Checking for multiple internal spaces in '%s'\\n\", kp);      for (kflag = 0, dp = *new_key; *kp != '\\0'; kp++)   {      if (*kp == ' ' && kflag == 0)      {         *(dp++) = *kp;         kflag = 1;      }      else if (*kp == ' ')      {         key_len--;         kwarn=1;      }      else      {         *(dp++) = *kp;         kflag = 0;      }   }   *dp = '\\0';   if (kwarn)      png_warning(png_ptr, \"extra interior spaces removed from keyword\");   if (key_len == 0)   {      png_free(png_ptr, *new_key);       *new_key=NULL;      png_warning(png_ptr, \"Zero length keyword\");   }   if (key_len > 79)   {      png_warning(png_ptr, \"keyword length must be 1 - 79 characters\");      new_key[79] = '\\0';      key_len = 79;   }   return (key_len);}#endif",
        "label": 1,
        "cve": "cve-2008-5907"
    },
    {
        "code": "static PNG_NORETURN voidusage(const char *program, const char *reason){   fprintf(stderr, \"pngunknown: %s: usage:\\n %s [--strict] \"      \"--default|{(CHNK|default|all)=(default|discard|if-safe|save)} \"      \"testfile.png\\n\", reason, program);   exit(99);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidtransform_test(png_modifier *pmIn, PNG_CONST png_uint_32 idIn,    PNG_CONST image_transform* transform_listIn, PNG_CONST char * volatile name){   transform_display d;   context(&pmIn->this, fault);   transform_display_init(&d, pmIn, idIn, transform_listIn);   Try   {      size_t pos = 0;      png_structp pp;      png_infop pi;      char full_name[256];            transform_set_encoding(&d);            d.transform_list->ini(d.transform_list, &d);            pos = safecat(full_name, sizeof full_name, pos, name);      pos = safecat_current_encoding(full_name, sizeof full_name, pos, d.pm);            pp = set_modifier_for_read(d.pm, &pi, d.this.id, full_name);      standard_palette_init(&d.this);#     if 0                  {            char buffer[256];            (void)store_message(&d.pm->this, pp, buffer, sizeof buffer, 0,               \"running test\");            fprintf(stderr, \"%s\\n\", buffer);         }#     endif            if (d.pm->this.progressive)      {                  png_set_progressive_read_fn(pp, &d, transform_info, progressive_row,            transform_end);                  modifier_progressive_read(d.pm, pp, pi);      }      else      {                  png_set_read_fn(pp, d.pm, modifier_read);                  png_read_info(pp, pi);                  transform_info_imp(&d, pp, pi);         sequential_row(&d.this, pp, pi, -1, 0);         if (!d.this.speed)            transform_image_validate(&d, pp, pi);         else            d.this.ps->validated = 1;      }      modifier_reset(d.pm);   }   Catch(fault)   {      modifier_reset(voidcast(png_modifier*,(void*)fault));   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "png_uint_32 get_data (FILE *pnm_file, int depth){  static int bits_left = 0;  static int old_value = 0;  static int mask = 0;  int i;  png_uint_32 ret_value;  if (mask == 0)    for (i = 0; i < depth; i++)      mask = (mask >> 1) | 0x80;  if (bits_left <= 0)  {    old_value = fgetc (pnm_file);    bits_left = 8;  }  ret_value = old_value & mask;  for (i = 1; i < (8 / depth); i++)    ret_value = ret_value || (ret_value >> depth);  old_value = (old_value << depth) & 0xFF;  bits_left -= depth;  return ret_value;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_do_expand_palette(png_row_infop row_info, png_bytep row,   png_const_colorp palette, png_const_bytep trans_alpha, int num_trans){   int shift, value;   png_bytep sp, dp;   png_uint_32 i;   png_uint_32 row_width=row_info->width;   png_debug(1, \"in png_do_expand_palette\");   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)   {      if (row_info->bit_depth < 8)      {         switch (row_info->bit_depth)         {            case 1:            {               sp = row + (png_size_t)((row_width - 1) >> 3);               dp = row + (png_size_t)row_width - 1;               shift = 7 - (int)((row_width + 7) & 0x07);               for (i = 0; i < row_width; i++)               {                  if ((*sp >> shift) & 0x01)                     *dp = 1;                  else                     *dp = 0;                  if (shift == 7)                  {                     shift = 0;                     sp--;                  }                  else                     shift++;                  dp--;               }               break;            }            case 2:            {               sp = row + (png_size_t)((row_width - 1) >> 2);               dp = row + (png_size_t)row_width - 1;               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);               for (i = 0; i < row_width; i++)               {                  value = (*sp >> shift) & 0x03;                  *dp = (png_byte)value;                  if (shift == 6)                  {                     shift = 0;                     sp--;                  }                  else                     shift += 2;                  dp--;               }               break;            }            case 4:            {               sp = row + (png_size_t)((row_width - 1) >> 1);               dp = row + (png_size_t)row_width - 1;               shift = (int)((row_width & 0x01) << 2);               for (i = 0; i < row_width; i++)               {                  value = (*sp >> shift) & 0x0f;                  *dp = (png_byte)value;                  if (shift == 4)                  {                     shift = 0;                     sp--;                  }                  else                     shift += 4;                  dp--;               }               break;            }            default:               break;         }         row_info->bit_depth = 8;         row_info->pixel_depth = 8;         row_info->rowbytes = row_width;      }      else if (row_info->bit_depth == 8)      {         {            if (trans_alpha != NULL)            {               sp = row + (png_size_t)row_width - 1;               dp = row + (png_size_t)(row_width << 2) - 1;               for (i = 0; i < row_width; i++)               {                  if ((int)(*sp) >= num_trans)                     *dp-- = 0xff;                  else                     *dp-- = trans_alpha[*sp];                  *dp-- = palette[*sp].blue;                  *dp-- = palette[*sp].green;                  *dp-- = palette[*sp].red;                  sp--;               }               row_info->bit_depth = 8;               row_info->pixel_depth = 32;               row_info->rowbytes = row_width * 4;               row_info->color_type = 6;               row_info->channels = 4;            }            else            {               sp = row + (png_size_t)row_width - 1;               dp = row + (png_size_t)(row_width * 3) - 1;               for (i = 0; i < row_width; i++)               {                  *dp-- = palette[*sp].blue;                  *dp-- = palette[*sp].green;                  *dp-- = palette[*sp].red;                  sp--;               }               row_info->bit_depth = 8;               row_info->pixel_depth = 24;               row_info->rowbytes = row_width * 3;               row_info->color_type = 2;               row_info->channels = 3;            }         }      }   }}",
        "label": 1,
        "cve": "cve-2011-0408-1"
    },
    {
        "code": "static voidgpc_bckg(Pixel *out, const Pixel *in, const Background *back){   if (in->a <= 0)      out->r = out->g = out->b = back->ig;   else if (in->a >= 255)      out->r = out->g = out->b = in->g;   else   {      double a = in->a / 255.;      out->r = out->g = out->b = sRGB(sRGB_to_d[in->g] * a + back->dg * (1-a));   }   out->a = 255;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_b16c(Pixel *out, const Pixel *in, const Background *back){   if (in->a <= 0)   {      out->r = back->ir;      out->g = back->ig;      out->b = back->ib;   }   else   {      double a = in->a/65535.;      double a1 = 1-a;      a /= 65535;      out->r = sRGB(in->r * a + back->dr * a1);      out->g = sRGB(in->g * a + back->dg * a1);      out->b = sRGB(in->b * a + back->db * a1);   }   out->a = 255;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static double outlog(PNG_CONST png_modifier *pm, int in_depth, int out_depth){      if (out_depth <= 8)   {      if (pm->log8 == 0)          return 256;      if (out_depth < 8)         return pm->log8 / 255 * ((1<<out_depth)-1);      return pm->log8;   }   if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16)   {      if (pm->log16 == 0)         return 65536;      return pm->log16;   }      if (pm->log8 == 0)      return 65536;   return pm->log8 * 257;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_rgba8(Pixel *p, png_const_voidp pb){   png_const_bytep pp = voidcast(png_const_bytep, pb);   p->r = pp[0];   p->g = pp[1];   p->b = pp[2];   p->a = pp[3];}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPItransform_end(png_structp ppIn, png_infop pi){   png_const_structp pp = ppIn;   transform_display *dp = voidcast(transform_display*,      png_get_progressive_ptr(pp));   if (!dp->this.speed)      transform_image_validate(dp, pp, pi);   else      dp->this.ps->validated = 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_rgb16(Pixel *p, png_const_voidp pb){   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);   p->r = pp[0];   p->g = pp[1];   p->b = pp[2];   p->a = 65535;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIwarning(png_structp png_ptr, const char *message){   display *d = (display*)png_get_error_ptr(png_ptr);   fprintf(stderr, \"%s(%s): libpng warning: %s\\n\", d->file, d->test, message);   ++(d->warning_count);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmodification_init(png_modification *pmm){   memset(pmm, 0, sizeof *pmm);   pmm->next = NULL;   pmm->chunk = 0;   pmm->modify_fn = NULL;   pmm->add = 0;   modification_reset(pmm);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGAPIpng_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,    png_const_colorp palette, int num_palette){   png_debug1(1, \"in %s storage function\", \"PLTE\");   if (png_ptr == NULL || info_ptr == NULL)      return;   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)   {      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)         png_error(png_ptr, \"Invalid palette length\");      else      {         png_warning(png_ptr, \"Invalid palette length\");         return;      }   }   if ((num_palette > 0 && palette == NULL) ||      (num_palette == 0#        ifdef PNG_MNG_FEATURES_SUPPORTED            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0#        endif      ))   {      png_error(png_ptr, \"Invalid palette\");      return;   }      png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);      png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));   if (num_palette > 0)      memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color)));   info_ptr->palette = png_ptr->palette;   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;   info_ptr->free_me |= PNG_FREE_PLTE;   info_ptr->valid |= PNG_INFO_PLTE;}",
        "label": 1,
        "cve": "cve-2015-8472"
    },
    {
        "code": "static intlogerror(Image *image, const char *a1, const char *a2, const char *a3){   fflush(stdout);   if (image->image.warning_or_error)      fprintf(stderr, \"%s%s%s: %s\\n\", a1, a2, a3, image->image.message);   else      fprintf(stderr, \"%s%s%s\\n\", a1, a2, a3);   if (image->image.opaque != NULL)   {      fprintf(stderr, \"%s: image opaque pointer non-NULL on error\\n\",         image->file_name);      png_image_free(&image->image);   }   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#endifstatic int read_png(FILE *fp){   png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,0,0,0);   png_infop info_ptr = NULL;   png_bytep row = NULL, display = NULL;   if (png_ptr == NULL)      return 0;   if (setjmp(png_jmpbuf(png_ptr)))   {      png_destroy_read_struct(&png_ptr, &info_ptr, NULL);      if (row != NULL) free(row);      if (display != NULL) free(display);      return 0;   }   png_init_io(png_ptr, fp);   info_ptr = png_create_info_struct(png_ptr);   if (info_ptr == NULL)      png_error(png_ptr, \"OOM allocating info structure\");   png_read_info(png_ptr, info_ptr);   {      png_size_t rowbytes = png_get_rowbytes(png_ptr, info_ptr);      row = malloc(rowbytes);      display = malloc(rowbytes);      if (row == NULL || display == NULL)         png_error(png_ptr, \"OOM allocating row buffers\");      {         png_uint_32 height = png_get_image_height(png_ptr, info_ptr);         int passes = png_set_interlace_handling(png_ptr);         int pass;         png_start_read_image(png_ptr);         for (pass = 0; pass < passes; ++pass)         {            png_uint_32 y = height;                        while (y-- > 0)               png_read_row(png_ptr, row, display);         }      }   }      png_read_end(png_ptr, info_ptr);   png_destroy_read_struct(&png_ptr, &info_ptr, NULL);   free(row);   free(display);   return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int rpng2_x_msb(ulg u32val){    int i;    for (i = 31;  i >= 0;  --i) {        if (u32val & 0x80000000L)            break;        u32val <<= 1;    }    return i;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int png_do_rgb_to_gray(png_structp png_ptr, png_row_infop row_info, png_bytep row){   png_uint_32 i;   png_uint_32 row_width = row_info->width;   int rgb_error = 0;   png_debug(1, \"in png_do_rgb_to_gray\");   if (       (row_info->color_type & PNG_COLOR_MASK_COLOR))   {      png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff;      png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff;      png_uint_32 bc = png_ptr->rgb_to_gray_blue_coeff;      if (row_info->color_type == PNG_COLOR_TYPE_RGB)      {         if (row_info->bit_depth == 8)         {#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)            if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)            {               png_bytep sp = row;               png_bytep dp = row;               for (i = 0; i < row_width; i++)               {                  png_byte red   = png_ptr->gamma_to_1[*(sp++)];                  png_byte green = png_ptr->gamma_to_1[*(sp++)];                  png_byte blue  = png_ptr->gamma_to_1[*(sp++)];                  if (red != green || red != blue)                  {                     rgb_error |= 1;                     *(dp++) = png_ptr->gamma_from_1[                         (rc*red + gc*green + bc*blue)>>15];                  }                  else                     *(dp++) = *(sp - 1);               }            }            else#endif            {               png_bytep sp = row;               png_bytep dp = row;               for (i = 0; i < row_width; i++)               {                  png_byte red   = *(sp++);                  png_byte green = *(sp++);                  png_byte blue  = *(sp++);                  if (red != green || red != blue)                  {                     rgb_error |= 1;                     *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);                  }                  else                     *(dp++) = *(sp - 1);               }            }         }         else          {#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)            if (png_ptr->gamma_16_to_1 != NULL &&                png_ptr->gamma_16_from_1 != NULL)            {               png_bytep sp = row;               png_bytep dp = row;               for (i = 0; i < row_width; i++)               {                  png_uint_16 red, green, blue, w;                  red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;                  green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;                  if (red == green && red == blue)                     w = red;                  else                  {                     png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff)                         >> png_ptr->gamma_shift][red>>8];                     png_uint_16 green_1 =                         png_ptr->gamma_16_to_1[(green&0xff) >>                         png_ptr->gamma_shift][green>>8];                     png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff)                         >> png_ptr->gamma_shift][blue>>8];                     png_uint_16 gray16  = (png_uint_16)((rc*red_1 + gc*green_1                         + bc*blue_1)>>15);                     w = png_ptr->gamma_16_from_1[(gray16&0xff) >>                         png_ptr->gamma_shift][gray16 >> 8];                     rgb_error |= 1;                  }                  *(dp++) = (png_byte)((w>>8) & 0xff);                  *(dp++) = (png_byte)(w & 0xff);               }            }            else#endif            {               png_bytep sp = row;               png_bytep dp = row;               for (i = 0; i < row_width; i++)               {                  png_uint_16 red, green, blue, gray16;                  red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;                  green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;                  if (red != green || red != blue)                     rgb_error |= 1;                  gray16  = (png_uint_16)((rc*red + gc*green + bc*blue)>>15);                  *(dp++) = (png_byte)((gray16>>8) & 0xff);                  *(dp++) = (png_byte)(gray16 & 0xff);               }            }         }      }      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)      {         if (row_info->bit_depth == 8)         {#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)            if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)            {               png_bytep sp = row;               png_bytep dp = row;               for (i = 0; i < row_width; i++)               {                  png_byte red   = png_ptr->gamma_to_1[*(sp++)];                  png_byte green = png_ptr->gamma_to_1[*(sp++)];                  png_byte blue  = png_ptr->gamma_to_1[*(sp++)];                  if (red != green || red != blue)                     rgb_error |= 1;                  *(dp++) =  png_ptr->gamma_from_1                      [(rc*red + gc*green + bc*blue)>>15];                  *(dp++) = *(sp++);                 }            }            else#endif            {               png_bytep sp = row;               png_bytep dp = row;               for (i = 0; i < row_width; i++)               {                  png_byte red   = *(sp++);                  png_byte green = *(sp++);                  png_byte blue  = *(sp++);                  if (red != green || red != blue)                     rgb_error |= 1;                  *(dp++) =  (png_byte)((rc*red + gc*green + bc*blue)>>15);                  *(dp++) = *(sp++);                 }            }         }         else          {#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)            if (png_ptr->gamma_16_to_1 != NULL &&                png_ptr->gamma_16_from_1 != NULL)            {               png_bytep sp = row;               png_bytep dp = row;               for (i = 0; i < row_width; i++)               {                  png_uint_16 red, green, blue, w;                  red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;                  green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;                  if (red == green && red == blue)                     w = red;                  else                  {                     png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff) >>                         png_ptr->gamma_shift][red>>8];                     png_uint_16 green_1 =                         png_ptr->gamma_16_to_1[(green&0xff) >>                         png_ptr->gamma_shift][green>>8];                     png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff) >>                         png_ptr->gamma_shift][blue>>8];                     png_uint_16 gray16  = (png_uint_16)((rc * red_1                         + gc * green_1 + bc * blue_1)>>15);                     w = png_ptr->gamma_16_from_1[(gray16&0xff) >>                         png_ptr->gamma_shift][gray16 >> 8];                     rgb_error |= 1;                  }                  *(dp++) = (png_byte)((w>>8) & 0xff);                  *(dp++) = (png_byte)(w & 0xff);                  *(dp++) = *(sp++);                    *(dp++) = *(sp++);               }            }            else#endif            {               png_bytep sp = row;               png_bytep dp = row;               for (i = 0; i < row_width; i++)               {                  png_uint_16 red, green, blue, gray16;                  red   = (png_uint_16)((*(sp)<<8) | *(sp + 1)); sp += 2;                  green = (png_uint_16)((*(sp)<<8) | *(sp + 1)); sp += 2;                  blue  = (png_uint_16)((*(sp)<<8) | *(sp + 1)); sp += 2;                  if (red != green || red != blue)                     rgb_error |= 1;                  gray16  = (png_uint_16)((rc*red + gc*green + bc*blue)>>15);                  *(dp++) = (png_byte)((gray16>>8) & 0xff);                  *(dp++) = (png_byte)(gray16 & 0xff);                  *(dp++) = *(sp++);                    *(dp++) = *(sp++);               }            }         }      }      row_info->channels -= 2;      row_info->color_type = (png_byte)(row_info->color_type &          ~PNG_COLOR_MASK_COLOR);      row_info->pixel_depth = (png_byte)(row_info->channels *          row_info->bit_depth);      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);   }   return rgb_error;}#endif",
        "label": 1,
        "cve": "cve-2011-0408-2"
    },
    {
        "code": "static chunk_insert *make_insert(png_const_charp what,   void (*insert)(png_structp, png_infop, int, png_charpp),   int nparams, png_charpp list){   int i;   chunk_insert *cip;   cip = malloc(offsetof(chunk_insert,parameters) +      nparams * sizeof (png_charp));   if (cip == NULL)   {      fprintf(stderr, \"--insert %s: out of memory allocating %d parameters\\n\",         what, nparams);      exit(1);   }   cip->next = NULL;   cip->insert = insert;   cip->nparams = nparams;   for (i=0; i<nparams; ++i)      cip->parameters[i] = list[i];   return cip;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intpixel_depth_of_type(int color_type, int bit_depth){   return channels_of_type(color_type) * bit_depth;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidpng_cexcept_error(png_structp png_ptr, png_const_charp msg){   if(png_ptr)     ;#ifdef PNG_CONSOLE_IO_SUPPORTED   fprintf(stderr, \"libpng error: %s\\n\", msg);#endif   {      Throw msg;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "PNG_NORETURN static voidstop_invalid(struct file *file, const char *what){   stop(file, INVALID_ERROR_CODE, what);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_argb16(Pixel *p, png_const_voidp pb){   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);   p->r = pp[1];   p->g = pp[2];   p->b = pp[3];   p->a = pp[0];}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_bgra8(Pixel *p, png_const_voidp pb){   png_const_bytep pp = voidcast(png_const_bytep, pb);   p->r = pp[2];   p->g = pp[1];   p->b = pp[0];   p->a = pp[3];}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidresetimage(Image *image){   if (image->input_file != NULL)      rewind(image->input_file);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidchunk_message(struct chunk *chunk, const char *message){   type_message(chunk->file, chunk->chunk_type, message);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidclean_display(display *d){   png_destroy_read_struct(&d->png_ptr, &d->info_ptr, &d->end_ptr);      if (d->png_ptr != NULL || d->info_ptr != NULL || d->end_ptr != NULL)   {      fprintf(stderr, \"%s(%s): png_destroy_read_struct error\\n\", d->file,         d->test);      exit(1);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32standard_width(png_const_structp pp, png_uint_32 id){   png_uint_32 width = WIDTH_FROM_ID(id);   UNUSED(pp)   if (width == 0)      width = transform_width(pp, COL_FROM_ID(id), DEPTH_FROM_ID(id));   return width;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int check_some_characters(checkfp_command *co, checkfp_control c,   const char *tests){   int i;   --(c.limit);   if (c.cnumber+4 < sizeof co->number && c.limit >= 0)   {      if (c.limit > 0) for (i=0; tests[i]; ++i)      {         if (!check_one_character(co, c, tests[i]))               return 0;      }            else         return check_all_characters(co, c);   }   return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intpng_pass_col_shift(int pass){   int x, y, base=(-1), inc=8;   ++pass;   for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass)   {      if (base == (-1))         base = x;      else if (base == x)         {}      else if (inc == x-base)         base=x;      else if (inc == 8)         inc = x-base, base=x;      else if (inc != x-base)         return 0xff;    }   if (base == (-1)) return 0xfe;       switch (inc)   {case 1: return 0; case 2: return 1;case 4: return 2;case 8: return 3;default: break;   }      return (inc << 8) + 0xfd;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIstore_write(png_structp ppIn, png_bytep pb, png_size_t st){   png_const_structp pp = ppIn;   png_store *ps = voidcast(png_store*, png_get_io_ptr(pp));   if (ps->pwrite != pp)      png_error(pp, \"store state damaged\");   while (st > 0)   {      size_t cb;      if (ps->writepos >= STORE_BUFFER_SIZE)         store_storenew(ps);      cb = st;      if (cb > STORE_BUFFER_SIZE - ps->writepos)         cb = STORE_BUFFER_SIZE - ps->writepos;      memcpy(ps->new.buffer + ps->writepos, pb, cb);      pb += cb;      st -= cb;      ps->writepos += cb;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidcheck_param_count(int nparams, int expect){   if (nparams != expect)   {      fprintf(stderr, \"bad parameter count (internal error)\\n\");      exit(1);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_delete(png_store *ps){   store_write_reset(ps);   store_read_reset(ps);   store_freefile(&ps->saved);   store_image_free(ps, NULL);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32get_valid(display *d, png_infop info_ptr){   png_uint_32 flags = png_get_valid(d->png_ptr, info_ptr, (png_uint_32)~0);      {      png_textp text;      png_uint_32 ntext = png_get_text(d->png_ptr, info_ptr, &text, NULL);      while (ntext-- > 0) switch (text[ntext].compression)      {         case -1:            flags |= PNG_INFO_tEXt;            break;         case 0:            flags |= PNG_INFO_zTXt;            break;         case 1:         case 2:            flags |= PNG_INFO_iTXt;            break;         default:            fprintf(stderr, \"%s(%s): unknown text compression %d\\n\", d->file,               d->test, text[ntext].compression);            display_exit(d);      }   }   return flags;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32crc_one_byte(png_uint_32 crc, int b){   return crc_table[(crc ^ b) & 0xff] ^ (crc >> 8);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmake_transform_images(png_store *ps){   png_byte colour_type = 0;   png_byte bit_depth = 0;   unsigned int palette_number = 0;      safecat(ps->test, sizeof ps->test, 0, \"make standard images\");      while (next_format(&colour_type, &bit_depth, &palette_number, 0))   {      int interlace_type;      for (interlace_type = PNG_INTERLACE_NONE;           interlace_type < INTERLACE_LAST; ++interlace_type)      {         char name[FILE_NAME_SIZE];         standard_name(name, sizeof name, 0, colour_type, bit_depth,            palette_number, interlace_type, 0, 0, 0);         make_transform_image(ps, colour_type, bit_depth, palette_number,            interlace_type, name);      }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int png_set_text_2(png_structp png_ptr, png_infop info_ptr,    png_const_textp text_ptr, int num_text){   int i;   png_debug1(1, \"in %s storage function\", ((png_ptr == NULL ||       png_ptr->chunk_name[0] == '\\0') ?       \"text\" : (png_const_charp)png_ptr->chunk_name));   if (png_ptr == NULL || info_ptr == NULL || num_text == 0)      return(0);      if (info_ptr->num_text + num_text > info_ptr->max_text)   {      if (info_ptr->text != NULL)      {         png_textp old_text;         int old_max;         old_max = info_ptr->max_text;         info_ptr->max_text = info_ptr->num_text + num_text + 8;         old_text = info_ptr->text;         info_ptr->text = (png_textp)png_malloc_warn(png_ptr,            (png_size_t)(info_ptr->max_text * png_sizeof(png_text)));         if (info_ptr->text == NULL)         {            png_free(png_ptr, old_text);            return(1);         }         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max *             png_sizeof(png_text)));         png_free(png_ptr, old_text);      }      else      {         info_ptr->max_text = num_text + 8;         info_ptr->num_text = 0;         info_ptr->text = (png_textp)png_malloc_warn(png_ptr,             (png_size_t)(info_ptr->max_text * png_sizeof(png_text)));         if (info_ptr->text == NULL)            return(1);         info_ptr->free_me |= PNG_FREE_TEXT;      }      png_debug1(3, \"allocated %d entries for info_ptr->text\",          info_ptr->max_text);   }   for (i = 0; i < num_text; i++)   {      png_size_t text_length, key_len;      png_size_t lang_len, lang_key_len;      png_textp textp = &(info_ptr->text[info_ptr->num_text]);      if (text_ptr[i].key == NULL)          continue;      if (text_ptr[i].compression < PNG_TEXT_COMPRESSION_NONE ||          text_ptr[i].compression >= PNG_TEXT_COMPRESSION_LAST)      {         png_warning(png_ptr, \"text compression mode is out of range\");         continue;      }      key_len = png_strlen(text_ptr[i].key);      if (text_ptr[i].compression <= 0)      {         lang_len = 0;         lang_key_len = 0;      }      else#  ifdef PNG_iTXt_SUPPORTED      {                  if (text_ptr[i].lang != NULL)            lang_len = png_strlen(text_ptr[i].lang);         else            lang_len = 0;         if (text_ptr[i].lang_key != NULL)            lang_key_len = png_strlen(text_ptr[i].lang_key);         else            lang_key_len = 0;      }#  else       {         png_warning(png_ptr, \"iTXt chunk not supported\");         continue;      }#  endif      if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\\0')      {         text_length = 0;#  ifdef PNG_iTXt_SUPPORTED         if (text_ptr[i].compression > 0)            textp->compression = PNG_ITXT_COMPRESSION_NONE;         else#  endif            textp->compression = PNG_TEXT_COMPRESSION_NONE;      }      else      {         text_length = png_strlen(text_ptr[i].text);         textp->compression = text_ptr[i].compression;      }      textp->key = (png_charp)png_malloc_warn(png_ptr,          (png_size_t)          (key_len + text_length + lang_len + lang_key_len + 4));      if (textp->key == NULL)         return(1);      png_debug2(2, \"Allocated %lu bytes at %p in png_set_text\",          (unsigned long)(png_uint_32)          (key_len + lang_len + lang_key_len + text_length + 4),          textp->key);      png_memcpy(textp->key, text_ptr[i].key,(png_size_t)(key_len));      *(textp->key + key_len) = '\\0';      if (text_ptr[i].compression > 0)      {         textp->lang = textp->key + key_len + 1;         png_memcpy(textp->lang, text_ptr[i].lang, lang_len);         *(textp->lang + lang_len) = '\\0';         textp->lang_key = textp->lang + lang_len + 1;         png_memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);         *(textp->lang_key + lang_key_len) = '\\0';         textp->text = textp->lang_key + lang_key_len + 1;      }      else      {         textp->lang=NULL;         textp->lang_key=NULL;         textp->text = textp->key + key_len + 1;      }      if (text_length)         png_memcpy(textp->text, text_ptr[i].text,             (png_size_t)(text_length));      *(textp->text + text_length) = '\\0';#  ifdef PNG_iTXt_SUPPORTED      if (textp->compression > 0)      {         textp->text_length = 0;         textp->itxt_length = text_length;      }      else#  endif      {         textp->text_length = text_length;         textp->itxt_length = 0;      }      info_ptr->num_text++;      png_debug1(3, \"transferred text chunk %d\", info_ptr->num_text);   }   return(0);}#endif",
        "label": 1,
        "cve": "cve-2011-3048"
    },
    {
        "code": "static void readpng2_info_callback(png_structp png_ptr, png_infop info_ptr){    mainprog_info  *mainprog_ptr;    int  color_type, bit_depth;    png_uint_32 width, height;#ifdef PNG_FLOATING_POINT_SUPPORTED    double  gamma;#else    png_fixed_point gamma;#endif            mainprog_ptr = png_get_progressive_ptr(png_ptr);    if (mainprog_ptr == NULL) {                 fprintf(stderr,          \"readpng2 error:  main struct not recoverable in info_callback.\\n\");        fflush(stderr);        return;            }        png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,       NULL, NULL, NULL);    mainprog_ptr->width = (ulg)width;    mainprog_ptr->height = (ulg)height;        if (mainprog_ptr->need_bgcolor &&        png_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD))    {        png_color_16p pBackground;                png_get_bKGD(png_ptr, info_ptr, &pBackground);                if (bit_depth == 16) {            mainprog_ptr->bg_red   = pBackground->red   >> 8;            mainprog_ptr->bg_green = pBackground->green >> 8;            mainprog_ptr->bg_blue  = pBackground->blue  >> 8;        } else if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) {            if (bit_depth == 1)                mainprog_ptr->bg_red = mainprog_ptr->bg_green =                  mainprog_ptr->bg_blue = pBackground->gray? 255 : 0;            else if (bit_depth == 2)                mainprog_ptr->bg_red = mainprog_ptr->bg_green =                  mainprog_ptr->bg_blue = (255/3) * pBackground->gray;            else                 mainprog_ptr->bg_red = mainprog_ptr->bg_green =                  mainprog_ptr->bg_blue = (255/15) * pBackground->gray;        } else {            mainprog_ptr->bg_red   = (uch)pBackground->red;            mainprog_ptr->bg_green = (uch)pBackground->green;            mainprog_ptr->bg_blue  = (uch)pBackground->blue;        }    }        if (color_type == PNG_COLOR_TYPE_PALETTE)        png_set_expand(png_ptr);    if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)        png_set_expand(png_ptr);    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))        png_set_expand(png_ptr);#ifdef PNG_READ_16_TO_8_SUPPORTED    if (bit_depth == 16)#  ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED        png_set_scale_16(png_ptr);#  else        png_set_strip_16(png_ptr);#  endif#endif    if (color_type == PNG_COLOR_TYPE_GRAY ||        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)        png_set_gray_to_rgb(png_ptr);    #ifdef PNG_FLOATING_POINT_SUPPORTED    if (png_get_gAMA(png_ptr, info_ptr, &gamma))        png_set_gamma(png_ptr, mainprog_ptr->display_exponent, gamma);    else        png_set_gamma(png_ptr, mainprog_ptr->display_exponent, 0.45455);#else    if (png_get_gAMA_fixed(png_ptr, info_ptr, &gamma))        png_set_gamma_fixed(png_ptr,            (png_fixed_point)(100000*mainprog_ptr->display_exponent+.5), gamma);    else        png_set_gamma_fixed(png_ptr,            (png_fixed_point)(100000*mainprog_ptr->display_exponent+.5), 45455);#endif        mainprog_ptr->passes = png_set_interlace_handling(png_ptr);        png_read_update_info(png_ptr, info_ptr);    mainprog_ptr->rowbytes = (int)png_get_rowbytes(png_ptr, info_ptr);    mainprog_ptr->channels = png_get_channels(png_ptr, info_ptr);        (*mainprog_ptr->mainprog_init)();        return;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_ga16(Pixel *p, png_const_voidp pb){   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);   p->r = p->g = p->b = pp[0];   p->a = pp[1];}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_handle_pCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length){   png_charp purpose;   png_int_32 X0, X1;   png_byte type, nparams;   png_charp buf, units, endptr;   png_charpp params;   png_size_t slength;   int i;   png_debug(1, \"in png_handle_pCAL\\n\");   if (!(png_ptr->mode & PNG_HAVE_IHDR))      png_error(png_ptr, \"Missing IHDR before pCAL\");   else if (png_ptr->mode & PNG_HAVE_IDAT)   {      png_warning(png_ptr, \"Invalid pCAL after IDAT\");      png_crc_finish(png_ptr, length);      return;   }   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL))   {      png_warning(png_ptr, \"Duplicate pCAL chunk\");      png_crc_finish(png_ptr, length);      return;   }   png_debug1(2, \"Allocating and reading pCAL chunk data (%lu bytes)\\n\",      length + 1);   purpose = (png_charp)png_malloc_warn(png_ptr, length + 1);   if (purpose == NULL)     {       png_warning(png_ptr, \"No memory for pCAL purpose.\");       return;     }   slength = (png_size_t)length;   png_crc_read(png_ptr, (png_bytep)purpose, slength);   if (png_crc_finish(png_ptr, 0))   {      png_free(png_ptr, purpose);      return;   }   purpose[slength] = 0x00;    png_debug(3, \"Finding end of pCAL purpose string\\n\");   for (buf = purpose; *buf; buf++)       ;   endptr = purpose + slength;      if (endptr <= buf + 12)   {      png_warning(png_ptr, \"Invalid pCAL data\");      png_free(png_ptr, purpose);      return;   }   png_debug(3, \"Reading pCAL X0, X1, type, nparams, and units\\n\");   X0 = png_get_int_32((png_bytep)buf+1);   X1 = png_get_int_32((png_bytep)buf+5);   type = buf[9];   nparams = buf[10];   units = buf + 11;   png_debug(3, \"Checking pCAL equation type and number of parameters\\n\");      if ((type == PNG_EQUATION_LINEAR && nparams != 2) ||       (type == PNG_EQUATION_BASE_E && nparams != 3) ||       (type == PNG_EQUATION_ARBITRARY && nparams != 3) ||       (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))   {      png_warning(png_ptr, \"Invalid pCAL parameters for equation type\");      png_free(png_ptr, purpose);      return;   }   else if (type >= PNG_EQUATION_LAST)   {      png_warning(png_ptr, \"Unrecognized equation type for pCAL chunk\");   }   for (buf = units; *buf; buf++)       ;   png_debug(3, \"Allocating pCAL parameters array\\n\");   params = (png_charpp)png_malloc_warn(png_ptr, (png_uint_32)(nparams      *png_sizeof(png_charp))) ;   if (params == NULL)     {       png_free(png_ptr, purpose);       png_warning(png_ptr, \"No memory for pCAL params.\");       return;     }      for (i = 0; i < (int)nparams; i++)   {      buf++;       png_debug1(3, \"Reading pCAL parameter %d\\n\", i);      for (params[i] = buf; *buf != 0x00 && buf <= endptr; buf++)          ;            if (buf > endptr)      {         png_warning(png_ptr, \"Invalid pCAL data\");         png_free(png_ptr, purpose);         png_free(png_ptr, params);         return;      }   }   png_set_pCAL(png_ptr, info_ptr, purpose, X0, X1, type, nparams,      units, params);   png_free(png_ptr, purpose);   png_free(png_ptr, params);}#endif",
        "label": 1,
        "cve": "cve-2007-5269-1"
    },
    {
        "code": "static voidperform_standard_test(png_modifier *pm){      if (!test_standard(pm, 0, 0, READ_BDHI))      return;   if (!test_standard(pm, 2, 3, READ_BDHI))      return;   if (!test_standard(pm, 3, 0, 3))      return;   if (!test_standard(pm, 4, 3, READ_BDHI))      return;   if (!test_standard(pm, 6, 3, READ_BDHI))      return;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_scale_16_set(PNG_CONST image_transform *this,    transform_display *that, png_structp pp, png_infop pi){   png_set_scale_16(pp);   this->next->set(this->next, that, pp, pi);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "BOOL LoadImageFile (HWND hwnd, PTSTR pstrPathName,                png_byte **ppbImage, int *pxImgSize, int *pyImgSize,                int *piChannels, png_color *pBkgColor){    static TCHAR szTmp [MAX_PATH];        if (*ppbImage)    {        free (*ppbImage);        *ppbImage = NULL;    }        SetCursor (LoadCursor (NULL, IDC_WAIT));    ShowCursor (TRUE);    PngLoadImage (pstrPathName, ppbImage, pxImgSize, pyImgSize, piChannels,                  pBkgColor);    ShowCursor (FALSE);    SetCursor (LoadCursor (NULL, IDC_ARROW));    if (*ppbImage != NULL)    {        sprintf (szTmp, \"VisualPng - %s\", strrchr(pstrPathName, '\\\\') + 1);        SetWindowText (hwnd, szTmp);    }    else    {        MessageBox (hwnd, TEXT (\"Error in loading the PNG image\"),            szProgName, MB_ICONEXCLAMATION | MB_OK);        return FALSE;    }    return TRUE;} */BOOL LoadImageFile (HWND hwnd, PTSTR pstrPathName,                png_byte **ppbImage, int *pxImgSize, int *pyImgSize,                int *piChannels, png_color *pBkgColor){    static TCHAR szTmp [MAX_PATH];        if (*ppbImage)    {        free (*ppbImage);        *ppbImage = NULL;    }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32transform_height(png_const_structp pp, png_byte colour_type, png_byte bit_depth){   switch (bit_size(pp, colour_type, bit_depth))   {      case 1:      case 2:      case 4:         return 1;         case 8:         return 2;         case 16:         return 512;       case 24:      case 32:         return 512;       case 48:      case 64:         return 2048;#        define TRANSFORM_HEIGHTMAX 2048      default:         return 0;      }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int main(int argc, char **argv){#ifndef DOS_OS2_W32    FILE *keybd;#endif#ifdef sgi    FILE *tmpfile;          char tmpline[80];#endif    char *inname = NULL, outname[256];    char *p, pnmchar, pnmline[256];    char *bgstr, *textbuf = NULL;    ulg rowbytes;    int rc, len = 0;    int error = 0;    int text = FALSE;    int maxval;    double LUT_exponent;                    double CRT_exponent = 2.2;              double default_display_exponent;        double default_gamma = 0.0;    wpng_info.infile = NULL;    wpng_info.outfile = NULL;    wpng_info.image_data = NULL;    wpng_info.row_pointers = NULL;    wpng_info.filter = FALSE;    wpng_info.interlaced = FALSE;    wpng_info.have_bg = FALSE;    wpng_info.have_time = FALSE;    wpng_info.have_text = 0;    wpng_info.gamma = 0.0;    #if defined(NeXT)        LUT_exponent = 1.0 / 2.2;    #elif defined(sgi)    LUT_exponent = 1.0 / 1.7;        tmpfile = fopen(\"/etc/config/system.glGammaVal\", \"r\");    if (tmpfile) {        double sgi_gamma;        fgets(tmpline, 80, tmpfile);        fclose(tmpfile);        sgi_gamma = atof(tmpline);        if (sgi_gamma > 0.0)            LUT_exponent = 1.0 / sgi_gamma;    }#elif defined(Macintosh)    LUT_exponent = 1.8 / 2.61;    #else    LUT_exponent = 1.0;   #endif        default_display_exponent = LUT_exponent * CRT_exponent;        if ((p = getenv(\"SCREEN_GAMMA\")) != NULL) {        double exponent = atof(p);        if (exponent > 0.0)            default_gamma = 1.0 / exponent;    }    if (default_gamma == 0.0)        default_gamma = 1.0 / default_display_exponent;        while (*++argv && !error) {        if (!strncmp(*argv, \"-i\", 2)) {            wpng_info.interlaced = TRUE;        } else if (!strncmp(*argv, \"-time\", 3)) {            wpng_info.modtime = time(NULL);            wpng_info.have_time = TRUE;        } else if (!strncmp(*argv, \"-text\", 3)) {            text = TRUE;        } else if (!strncmp(*argv, \"-gamma\", 2)) {            if (!*++argv)                ++error;            else {                wpng_info.gamma = atof(*argv);                if (wpng_info.gamma <= 0.0)                    ++error;                else if (wpng_info.gamma > 1.01)                    fprintf(stderr, PROGNAME                      \" warning:  file gammas are usually less than 1.0\\n\");            }        } else if (!strncmp(*argv, \"-bgcolor\", 4)) {            if (!*++argv)                ++error;            else {                bgstr = *argv;                if (strlen(bgstr) != 7 || bgstr[0] != '#')                    ++error;                else {                    unsigned r, g, b;                      sscanf(bgstr+1, \"%2x%2x%2x\", &r, &g, &b);                    wpng_info.bg_red   = (uch)r;                    wpng_info.bg_green = (uch)g;                    wpng_info.bg_blue  = (uch)b;                    wpng_info.have_bg = TRUE;                }            }        } else {            if (**argv != '-') {                inname = *argv;                if (argv[1])                       ++error;            } else                ++error;           }    }        if (!inname) {        if (isatty(0)) {            fprintf(stderr, PROGNAME              \":  must give input filename or provide image data via stdin\\n\");            ++error;        } else {#ifdef DOS_OS2_W32                        setmode(fileno(stdin), O_BINARY);            setmode(fileno(stdout), O_BINARY);#endif            if ((wpng_info.infile = fdopen(fileno(stdin), \"rb\")) == NULL) {                fprintf(stderr, PROGNAME                  \":  unable to reopen stdin in binary mode\\n\");                ++error;            } else            if ((wpng_info.outfile = fdopen(fileno(stdout), \"wb\")) == NULL) {                fprintf(stderr, PROGNAME                  \":  unable to reopen stdout in binary mode\\n\");                fclose(wpng_info.infile);                ++error;            } else                wpng_info.filter = TRUE;        }    } else if ((len = strlen(inname)) > 250) {        fprintf(stderr, PROGNAME \":  input filename is too long [%d chars]\\n\",          len);        ++error;    } else if (!(wpng_info.infile = fopen(inname, \"rb\"))) {        fprintf(stderr, PROGNAME \":  can't open input file [%s]\\n\", inname);        ++error;    }    if (!error) {        fgets(pnmline, 256, wpng_info.infile);        if (pnmline[0] != 'P' || ((pnmchar = pnmline[1]) != '5' &&            pnmchar != '6' && pnmchar != '8'))        {            fprintf(stderr, PROGNAME              \":  input file [%s] is not a binary PGM, PPM or PAM file\\n\",              inname);            ++error;        } else {            wpng_info.pnmtype = (int)(pnmchar - '0');            if (wpng_info.pnmtype != 8)                wpng_info.have_bg = FALSE;              do {                fgets(pnmline, 256, wpng_info.infile);              } while (pnmline[0] == '#');            sscanf(pnmline, \"%ld %ld\", &wpng_info.width, &wpng_info.height);            do {                fgets(pnmline, 256, wpng_info.infile);              } while (pnmline[0] == '#');            sscanf(pnmline, \"%d\", &maxval);            if (wpng_info.width <= 0L || wpng_info.height <= 0L ||                maxval != 255)            {                fprintf(stderr, PROGNAME                  \":  only positive width/height, maxval == 255 allowed \\n\");                ++error;            }            wpng_info.sample_depth = 8;              if (!wpng_info.filter) {                                if ((p = strrchr(inname, '.')) == NULL ||                    (p - inname) != (len - 4))                {                    strcpy(outname, inname);                    strcpy(outname+len, \".png\");                } else {                    len -= 4;                    strncpy(outname, inname, len);                    strcpy(outname+len, \".png\");                }                                if ((wpng_info.outfile = fopen(outname, \"rb\")) != NULL) {                    fprintf(stderr, PROGNAME \":  output file exists [%s]\\n\",                      outname);                    fclose(wpng_info.outfile);                    ++error;                } else if (!(wpng_info.outfile = fopen(outname, \"wb\"))) {                    fprintf(stderr, PROGNAME \":  can't open output file [%s]\\n\",                      outname);                    ++error;                }            }        }        if (error) {            fclose(wpng_info.infile);            wpng_info.infile = NULL;            if (wpng_info.filter) {                fclose(wpng_info.outfile);                wpng_info.outfile = NULL;            }        }    }        if (error) {        fprintf(stderr, \"\\n%s %s:  %s\\n\", PROGNAME, VERSION, APPNAME);        writepng_version_info();        fprintf(stderr, \"\\n\"\"Usage:  %s [-gamma exp] [-bgcolor bg] [-text] [-time] [-interlace] pnmfile\\n\"\"or: ... | %s [-gamma exp] [-bgcolor bg] [-text] [-time] [-interlace] | ...\\n\"         \"    exp \\ttransfer-function exponent (``gamma'') of the image in\\n\"         \"\\t\\t  floating-point format (e.g., ``%.5f''); if image looks\\n\"         \"\\t\\t  correct on given display system, image gamma is equal to\\n\"         \"\\t\\t  inverse of display-system exponent, i.e., 1 / (LUT * CRT)\\n\"         \"\\t\\t  (where LUT = lookup-table exponent and CRT = CRT exponent;\\n\"         \"\\t\\t  first varies, second is usually 2.2, all are positive)\\n\"         \"    bg  \\tdesired background color for alpha-channel images, in\\n\"         \"\\t\\t  7-character hex RGB format (e.g., ``#ff7700'' for orange:\\n\"         \"\\t\\t  same as HTML colors)\\n\"         \"    -text\\tprompt interactively for text info (tEXt chunks)\\n\"         \"    -time\\tinclude a tIME chunk (last modification time)\\n\"         \"    -interlace\\twrite interlaced PNG image\\n\"         \"\\n\"\"pnmfile or stdin must be a binary PGM (`P5'), PPM (`P6') or (extremely\\n\"\"unofficial and unsupported!) PAM (`P8') file.  Currently it is required\\n\"\"to have maxval == 255 (i.e., no scaling).  If pnmfile is specified, it\\n\"\"is converted to the corresponding PNG file with the same base name but a\\n\"\"``.png'' extension; files read from stdin are converted and sent to stdout.\\n\"\"The conversion is progressive (low memory usage) unless interlacing is\\n\"\"requested; in that case the whole image will be buffered in memory and\\n\"\"written in one call.\\n\"         \"\\n\", PROGNAME, PROGNAME, default_gamma);        exit(1);    }        if (text &&#ifndef DOS_OS2_W32        (keybd = fdopen(fileno(stderr), \"r\")) != NULL &&#endif        (textbuf = (char *)malloc((5 + 9)*75)) != NULL)    {        int i, valid, result;        fprintf(stderr,          \"Enter text info (no more than 72 characters per line);\\n\");        fprintf(stderr, \"to skip a field, hit the <Enter> key.\\n\");                do {            valid = TRUE;            p = textbuf + TEXT_TITLE_OFFSET;            fprintf(stderr, \"  Title: \");            fflush(stderr);            if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) {                if (p[len-1] == '\\n')                    p[--len] = '\\0';                wpng_info.title = p;                wpng_info.have_text |= TEXT_TITLE;                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {                    fprintf(stderr, \"    \" PROGNAME \" warning:  character code\"                      \" %u is %sdiscouraged by the PNG\\n    specification \"                      \"[first occurrence was at character position #%d]\\n\",                      (unsigned)p[result], (p[result] == 27)? \"strongly \" : \"\",                      result+1);                    fflush(stderr);#ifdef FORBID_LATIN1_CTRL                    wpng_info.have_text &= ~TEXT_TITLE;                    valid = FALSE;#else                    if (p[result] == 27) {                            wpng_info.have_text &= ~TEXT_TITLE;                        valid = FALSE;                    }#endif                }            }        } while (!valid);        do {            valid = TRUE;            p = textbuf + TEXT_AUTHOR_OFFSET;            fprintf(stderr, \"  Author: \");            fflush(stderr);            if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) {                if (p[len-1] == '\\n')                    p[--len] = '\\0';                wpng_info.author = p;                wpng_info.have_text |= TEXT_AUTHOR;                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {                    fprintf(stderr, \"    \" PROGNAME \" warning:  character code\"                      \" %u is %sdiscouraged by the PNG\\n    specification \"                      \"[first occurrence was at character position #%d]\\n\",                      (unsigned)p[result], (p[result] == 27)? \"strongly \" : \"\",                      result+1);                    fflush(stderr);#ifdef FORBID_LATIN1_CTRL                    wpng_info.have_text &= ~TEXT_AUTHOR;                    valid = FALSE;#else                    if (p[result] == 27) {                            wpng_info.have_text &= ~TEXT_AUTHOR;                        valid = FALSE;                    }#endif                }            }        } while (!valid);        do {            valid = TRUE;            p = textbuf + TEXT_DESC_OFFSET;            fprintf(stderr, \"  Description (up to 9 lines):\\n\");            for (i = 1;  i < 10;  ++i) {                fprintf(stderr, \"    [%d] \", i);                fflush(stderr);                if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1)                    p += len;                   else                    break;            }            if ((len = p - (textbuf + TEXT_DESC_OFFSET)) > 1) {                if (p[-1] == '\\n') {                    p[-1] = '\\0';                    --len;                }                wpng_info.desc = textbuf + TEXT_DESC_OFFSET;                wpng_info.have_text |= TEXT_DESC;                p = textbuf + TEXT_DESC_OFFSET;                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {                    fprintf(stderr, \"    \" PROGNAME \" warning:  character code\"                      \" %u is %sdiscouraged by the PNG\\n    specification \"                      \"[first occurrence was at character position #%d]\\n\",                      (unsigned)p[result], (p[result] == 27)? \"strongly \" : \"\",                      result+1);                    fflush(stderr);#ifdef FORBID_LATIN1_CTRL                    wpng_info.have_text &= ~TEXT_DESC;                    valid = FALSE;#else                    if (p[result] == 27) {                            wpng_info.have_text &= ~TEXT_DESC;                        valid = FALSE;                    }#endif                }            }        } while (!valid);        do {            valid = TRUE;            p = textbuf + TEXT_COPY_OFFSET;            fprintf(stderr, \"  Copyright: \");            fflush(stderr);            if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) {                if (p[len-1] == '\\n')                    p[--len] = '\\0';                wpng_info.copyright = p;                wpng_info.have_text |= TEXT_COPY;                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {                    fprintf(stderr, \"    \" PROGNAME \" warning:  character code\"                      \" %u is %sdiscouraged by the PNG\\n    specification \"                      \"[first occurrence was at character position #%d]\\n\",                      (unsigned)p[result], (p[result] == 27)? \"strongly \" : \"\",                      result+1);                    fflush(stderr);#ifdef FORBID_LATIN1_CTRL                    wpng_info.have_text &= ~TEXT_COPY;                    valid = FALSE;#else                    if (p[result] == 27) {                            wpng_info.have_text &= ~TEXT_COPY;                        valid = FALSE;                    }#endif                }            }        } while (!valid);        do {            valid = TRUE;            p = textbuf + TEXT_EMAIL_OFFSET;            fprintf(stderr, \"  E-mail: \");            fflush(stderr);            if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) {                if (p[len-1] == '\\n')                    p[--len] = '\\0';                wpng_info.email = p;                wpng_info.have_text |= TEXT_EMAIL;                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {                    fprintf(stderr, \"    \" PROGNAME \" warning:  character code\"                      \" %u is %sdiscouraged by the PNG\\n    specification \"                      \"[first occurrence was at character position #%d]\\n\",                      (unsigned)p[result], (p[result] == 27)? \"strongly \" : \"\",                      result+1);                    fflush(stderr);#ifdef FORBID_LATIN1_CTRL                    wpng_info.have_text &= ~TEXT_EMAIL;                    valid = FALSE;#else                    if (p[result] == 27) {                            wpng_info.have_text &= ~TEXT_EMAIL;                        valid = FALSE;                    }#endif                }            }        } while (!valid);        do {            valid = TRUE;            p = textbuf + TEXT_URL_OFFSET;            fprintf(stderr, \"  URL: \");            fflush(stderr);            if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) {                if (p[len-1] == '\\n')                    p[--len] = '\\0';                wpng_info.url = p;                wpng_info.have_text |= TEXT_URL;                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {                    fprintf(stderr, \"    \" PROGNAME \" warning:  character code\"                      \" %u is %sdiscouraged by the PNG\\n    specification \"                      \"[first occurrence was at character position #%d]\\n\",                      (unsigned)p[result], (p[result] == 27)? \"strongly \" : \"\",                      result+1);                    fflush(stderr);#ifdef FORBID_LATIN1_CTRL                    wpng_info.have_text &= ~TEXT_URL;                    valid = FALSE;#else                    if (p[result] == 27) {                            wpng_info.have_text &= ~TEXT_URL;                        valid = FALSE;                    }#endif                }            }        } while (!valid);#ifndef DOS_OS2_W32        fclose(keybd);#endif    } else if (text) {        fprintf(stderr, PROGNAME \":  unable to allocate memory for text\\n\");        text = FALSE;        wpng_info.have_text = 0;    }        if ((rc = writepng_init(&wpng_info)) != 0) {        switch (rc) {            case 2:                fprintf(stderr, PROGNAME                  \":  libpng initialization problem (longjmp)\\n\");                break;            case 4:                fprintf(stderr, PROGNAME \":  insufficient memory\\n\");                break;            case 11:                fprintf(stderr, PROGNAME                  \":  internal logic error (unexpected PNM type)\\n\");                break;            default:                fprintf(stderr, PROGNAME                  \":  unknown writepng_init() error\\n\");                break;        }        exit(rc);    }        if (text && textbuf) {        free(textbuf);        textbuf = NULL;    }        if (wpng_info.pnmtype == 5)        rowbytes = wpng_info.width;    else if (wpng_info.pnmtype == 6)        rowbytes = wpng_info.width * 3;    else         rowbytes = wpng_info.width * 4;        fprintf(stderr, \"Encoding image data...\\n\");    fflush(stderr);    if (wpng_info.interlaced) {        long i;        ulg bytes;        ulg image_bytes = rowbytes * wpng_info.height;           wpng_info.image_data = (uch *)malloc(image_bytes);        wpng_info.row_pointers = (uch **)malloc(wpng_info.height*sizeof(uch *));        if (wpng_info.image_data == NULL || wpng_info.row_pointers == NULL) {            fprintf(stderr, PROGNAME \":  insufficient memory for image data\\n\");            writepng_cleanup(&wpng_info);            wpng_cleanup();            exit(5);        }        for (i = 0;  i < wpng_info.height;  ++i)            wpng_info.row_pointers[i] = wpng_info.image_data + i*rowbytes;        bytes = fread(wpng_info.image_data, 1, image_bytes, wpng_info.infile);        if (bytes != image_bytes) {            fprintf(stderr, PROGNAME \":  expected %lu bytes, got %lu bytes\\n\",              image_bytes, bytes);            fprintf(stderr, \"  (continuing anyway)\\n\");        }        if (writepng_encode_image(&wpng_info) != 0) {            fprintf(stderr, PROGNAME              \":  libpng problem (longjmp) while writing image data\\n\");            writepng_cleanup(&wpng_info);            wpng_cleanup();            exit(2);        }    } else  {        long j;        ulg bytes;        wpng_info.image_data = (uch *)malloc(rowbytes);        if (wpng_info.image_data == NULL) {            fprintf(stderr, PROGNAME \":  insufficient memory for row data\\n\");            writepng_cleanup(&wpng_info);            wpng_cleanup();            exit(5);        }        error = 0;        for (j = wpng_info.height;  j > 0L;  --j) {            bytes = fread(wpng_info.image_data, 1, rowbytes, wpng_info.infile);            if (bytes != rowbytes) {                fprintf(stderr, PROGNAME                  \":  expected %lu bytes, got %lu bytes (row %ld)\\n\", rowbytes,                  bytes, wpng_info.height-j);                ++error;                break;            }            if (writepng_encode_row(&wpng_info) != 0) {                fprintf(stderr, PROGNAME                  \":  libpng problem (longjmp) while writing row %ld\\n\",                  wpng_info.height-j);                ++error;                break;            }        }        if (error) {            writepng_cleanup(&wpng_info);            wpng_cleanup();            exit(2);        }        if (writepng_encode_finish(&wpng_info) != 0) {            fprintf(stderr, PROGNAME \":  error on final libpng call\\n\");            writepng_cleanup(&wpng_info);            wpng_cleanup();            exit(2);        }    }        fprintf(stderr, \"Done.\\n\");    fflush(stderr);    writepng_cleanup(&wpng_info);    wpng_cleanup();    return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_strip_alpha_set(PNG_CONST image_transform *this,    transform_display *that, png_structp pp, png_infop pi){   png_set_strip_alpha(pp);   this->next->set(this->next, that, pp, pi);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void readpng2_end_callback(png_structp png_ptr, png_infop info_ptr){    mainprog_info  *mainprog_ptr;        mainprog_ptr = png_get_progressive_ptr(png_ptr);        (*mainprog_ptr->mainprog_finish_display)();        return;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void gamma_transform_test(png_modifier *pm,   PNG_CONST png_byte colour_type, PNG_CONST png_byte bit_depth,   PNG_CONST int palette_number,   PNG_CONST int interlace_type, PNG_CONST double file_gamma,   PNG_CONST double screen_gamma, PNG_CONST png_byte sbit,   PNG_CONST int use_input_precision, PNG_CONST int scale16){   size_t pos = 0;   char name[64];   if (sbit != bit_depth && sbit != 0)   {      pos = safecat(name, sizeof name, pos, \"sbit(\");      pos = safecatn(name, sizeof name, pos, sbit);      pos = safecat(name, sizeof name, pos, \") \");   }   else      pos = safecat(name, sizeof name, pos, \"gamma \");   if (scale16)      pos = safecat(name, sizeof name, pos, \"16to8 \");   pos = safecatd(name, sizeof name, pos, file_gamma, 3);   pos = safecat(name, sizeof name, pos, \"->\");   pos = safecatd(name, sizeof name, pos, screen_gamma, 3);   gamma_test(pm, colour_type, bit_depth, palette_number, interlace_type,      file_gamma, screen_gamma, sbit, 0, name, use_input_precision,      scale16, pm->test_gamma_expand16, 0 , 0, 0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static struct buffer_list *buffer_extend(struct buffer_list *current){   struct buffer_list *add;   assert(current->next == NULL);   add = NEW(struct buffer_list);   if (add == NULL)      return NULL;   add->next = NULL;   current->next = add;   return add;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intgama_modify(png_modifier *pm, png_modification *me, int add){   UNUSED(add)      png_save_uint_32(pm->buffer, 4);   png_save_uint_32(pm->buffer+4, CHUNK_gAMA);   png_save_uint_32(pm->buffer+8, ((gama_modification*)me)->gamma);   return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidinsert_iTXt(png_structp png_ptr, png_infop info_ptr, int nparams,   png_charpp params){   png_text text;   check_param_count(nparams, 4);   clear_text(&text, params[0]);   text.compression = 2;    text.lang = params[1];   text.lang_key = params[2];    set_text(png_ptr, info_ptr, &text, params[3]);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGCBAPIcount_filters(png_structp png_ptr, png_row_infop row_info, png_bytep data){   if (png_ptr != NULL && row_info != NULL)      ++filters_used[*(data - 1)];}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIgamma_info(png_structp pp, png_infop pi){   gamma_info_imp(voidcast(gamma_display*, png_get_progressive_ptr(pp)), pp,      pi);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidprint_opts(png_uint_32 opts){   if (opts & READ_FILE)      printf(\" --file\");   if (opts & USE_STDIO)      printf(\" --stdio\");   if (opts & STRICT)      printf(\" --strict\");   if (opts & VERBOSE)      printf(\" --verbose\");   if (opts & KEEP_TMPFILES)      printf(\" --preserve\");   if (opts & KEEP_GOING)      printf(\" --keep-going\");   if (opts & ACCUMULATE)      printf(\" --accumulate\");   if (!(opts & FAST_WRITE))       printf(\" --slow\");   if (opts & sRGB_16BIT)      printf(\" --sRGB-16bit\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static size_tstandard_name(char *buffer, size_t bufsize, size_t pos, png_byte colour_type,    int bit_depth, unsigned int npalette, int interlace_type,    png_uint_32 w, png_uint_32 h, int do_interlace){   pos = safecat(buffer, bufsize, pos, colour_types[colour_type]);   if (npalette > 0)   {      pos = safecat(buffer, bufsize, pos, \"[\");      pos = safecatn(buffer, bufsize, pos, npalette);      pos = safecat(buffer, bufsize, pos, \"]\");   }   pos = safecat(buffer, bufsize, pos, \" \");   pos = safecatn(buffer, bufsize, pos, bit_depth);   pos = safecat(buffer, bufsize, pos, \" bit\");   if (interlace_type != PNG_INTERLACE_NONE)   {      pos = safecat(buffer, bufsize, pos, \" interlaced\");      if (do_interlace)         pos = safecat(buffer, bufsize, pos, \"(pngvalid)\");      else         pos = safecat(buffer, bufsize, pos, \"(libpng)\");   }   if (w > 0 || h > 0)   {      pos = safecat(buffer, bufsize, pos, \" \");      pos = safecatn(buffer, bufsize, pos, w);      pos = safecat(buffer, bufsize, pos, \"x\");      pos = safecatn(buffer, bufsize, pos, h);   }   return pos;}static size_tstandard_name(char *buffer, size_t bufsize, size_t pos, png_byte colour_type,    int bit_depth, unsigned int npalette, int interlace_type,    png_uint_32 w, png_uint_32 h, int do_interlace){   pos = safecat(buffer, bufsize, pos, colour_types[colour_type]);   if (npalette > 0)   {      pos = safecat(buffer, bufsize, pos, \"[\");      pos = safecatn(buffer, bufsize, pos, npalette);      pos = safecat(buffer, bufsize, pos, \"]\");   }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static doubleYfromRGBint(int ir, int ig, int ib){   double r = ir;   double g = ig;   double b = ib;   return YfromRGB(r, g, b);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_structpset_modifier_for_read(png_modifier *pm, png_infopp ppi, png_uint_32 id,    PNG_CONST char *name){      pm->state = modifier_start;   pm->bit_depth = 0;   pm->colour_type = 255;   pm->pending_len = 0;   pm->pending_chunk = 0;   pm->flush = 0;   pm->buffer_count = 0;   pm->buffer_position = 0;   return set_store_for_read(&pm->this, ppi, id, name);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "inttest_one_file(PNG_CONST char *inname, PNG_CONST char *outname){   static png_FILE_p fpin;   static png_FILE_p fpout;     png_structp read_ptr;   png_infop read_info_ptr, end_info_ptr;#ifdef PNG_WRITE_SUPPORTED   png_structp write_ptr;   png_infop write_info_ptr;   png_infop write_end_info_ptr;#else   png_structp write_ptr = NULL;   png_infop write_info_ptr = NULL;   png_infop write_end_info_ptr = NULL;#endif   png_bytep row_buf;   png_uint_32 y;   png_uint_32 width, height;   int num_pass, pass;   int bit_depth, color_type;#ifdef PNG_SETJMP_SUPPORTED#ifdef USE_FAR_KEYWORD   jmp_buf png_jmpbuf;#endif#endif   char inbuf[256], outbuf[256];   row_buf = NULL;   if ((fpin = fopen(inname, \"rb\")) == NULL)   {      fprintf(STDERR, \"Could not find input file %s\\n\", inname);      return (1);   }   if ((fpout = fopen(outname, \"wb\")) == NULL)   {      fprintf(STDERR, \"Could not open output file %s\\n\", outname);      FCLOSE(fpin);      return (1);   }   pngtest_debug(\"Allocating read and write structures\");#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG   read_ptr =      png_create_read_struct_2(PNG_LIBPNG_VER_STRING, NULL,      NULL, NULL, NULL, png_debug_malloc, png_debug_free);#else   read_ptr =      png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);#endif#ifndef PNG_STDIO_SUPPORTED   png_set_error_fn(read_ptr, (png_voidp)inname, pngtest_error,       pngtest_warning);#endif#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED   user_chunk_data[0] = 0;   user_chunk_data[1] = 0;   user_chunk_data[2] = 0;   user_chunk_data[3] = 0;   png_set_read_user_chunk_fn(read_ptr, user_chunk_data,     read_user_chunk_callback);#endif#ifdef PNG_WRITE_SUPPORTED#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG   write_ptr =      png_create_write_struct_2(PNG_LIBPNG_VER_STRING, NULL,      NULL, NULL, NULL, png_debug_malloc, png_debug_free);#else   write_ptr =      png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);#endif#ifndef PNG_STDIO_SUPPORTED   png_set_error_fn(write_ptr, (png_voidp)inname, pngtest_error,       pngtest_warning);#endif#endif   pngtest_debug(\"Allocating read_info, write_info and end_info structures\");   read_info_ptr = png_create_info_struct(read_ptr);   end_info_ptr = png_create_info_struct(read_ptr);#ifdef PNG_WRITE_SUPPORTED   write_info_ptr = png_create_info_struct(write_ptr);   write_end_info_ptr = png_create_info_struct(write_ptr);#endif#ifdef PNG_SETJMP_SUPPORTED   pngtest_debug(\"Setting jmpbuf for read struct\");#ifdef USE_FAR_KEYWORD   if (setjmp(png_jmpbuf))#else   if (setjmp(png_jmpbuf(read_ptr)))#endif   {      fprintf(STDERR, \"%s -> %s: libpng read error\\n\", inname, outname);      png_free(read_ptr, row_buf);      row_buf = NULL;      png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);#ifdef PNG_WRITE_SUPPORTED      png_destroy_info_struct(write_ptr, &write_end_info_ptr);      png_destroy_write_struct(&write_ptr, &write_info_ptr);#endif      FCLOSE(fpin);      FCLOSE(fpout);      return (1);   }#ifdef USE_FAR_KEYWORD   png_memcpy(png_jmpbuf(read_ptr), png_jmpbuf, png_sizeof(jmp_buf));#endif#ifdef PNG_WRITE_SUPPORTED   pngtest_debug(\"Setting jmpbuf for write struct\");#ifdef USE_FAR_KEYWORD   if (setjmp(png_jmpbuf))#else   if (setjmp(png_jmpbuf(write_ptr)))#endif   {      fprintf(STDERR, \"%s -> %s: libpng write error\\n\", inname, outname);      png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);      png_destroy_info_struct(write_ptr, &write_end_info_ptr);#ifdef PNG_WRITE_SUPPORTED      png_destroy_write_struct(&write_ptr, &write_info_ptr);#endif      FCLOSE(fpin);      FCLOSE(fpout);      return (1);   }#ifdef USE_FAR_KEYWORD   png_memcpy(png_jmpbuf(write_ptr), png_jmpbuf, png_sizeof(jmp_buf));#endif#endif#endif   pngtest_debug(\"Initializing input and output streams\");#ifdef PNG_STDIO_SUPPORTED   png_init_io(read_ptr, fpin);#  ifdef PNG_WRITE_SUPPORTED   png_init_io(write_ptr, fpout);#  endif#else   png_set_read_fn(read_ptr, (png_voidp)fpin, pngtest_read_data);#  ifdef PNG_WRITE_SUPPORTED   png_set_write_fn(write_ptr, (png_voidp)fpout,  pngtest_write_data,#    ifdef PNG_WRITE_FLUSH_SUPPORTED      pngtest_flush);#    else      NULL);#    endif#  endif#endif   if (status_dots_requested == 1)   {#ifdef PNG_WRITE_SUPPORTED      png_set_write_status_fn(write_ptr, write_row_callback);#endif      png_set_read_status_fn(read_ptr, read_row_callback);   }   else   {#ifdef PNG_WRITE_SUPPORTED      png_set_write_status_fn(write_ptr, NULL);#endif      png_set_read_status_fn(read_ptr, NULL);   }#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED   {      int i;      for (i = 0; i<256; i++)         filters_used[i] = 0;      png_set_read_user_transform_fn(read_ptr, count_filters);   }#endif#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED   zero_samples = 0;   png_set_write_user_transform_fn(write_ptr, count_zero_samples);#endif#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED#  ifndef PNG_HANDLE_CHUNK_ALWAYS#    define PNG_HANDLE_CHUNK_ALWAYS       3#  endif   png_set_keep_unknown_chunks(read_ptr, PNG_HANDLE_CHUNK_ALWAYS,      NULL, 0);#endif#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED#  ifndef PNG_HANDLE_CHUNK_IF_SAFE#    define PNG_HANDLE_CHUNK_IF_SAFE      2#  endif   png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_IF_SAFE,      NULL, 0);#endif   pngtest_debug(\"Reading info struct\");   png_read_info(read_ptr, read_info_ptr);   pngtest_debug(\"Transferring info struct\");   {      int interlace_type, compression_type, filter_type;      if (png_get_IHDR(read_ptr, read_info_ptr, &width, &height, &bit_depth,          &color_type, &interlace_type, &compression_type, &filter_type))      {         png_set_IHDR(write_ptr, write_info_ptr, width, height, bit_depth,#ifdef PNG_WRITE_INTERLACING_SUPPORTED            color_type, interlace_type, compression_type, filter_type);#else            color_type, PNG_INTERLACE_NONE, compression_type, filter_type);#endif      }   }#ifdef PNG_FIXED_POINT_SUPPORTED#ifdef PNG_cHRM_SUPPORTED   {      png_fixed_point white_x, white_y, red_x, red_y, green_x, green_y, blue_x,         blue_y;      if (png_get_cHRM_fixed(read_ptr, read_info_ptr, &white_x, &white_y,         &red_x, &red_y, &green_x, &green_y, &blue_x, &blue_y))      {         png_set_cHRM_fixed(write_ptr, write_info_ptr, white_x, white_y, red_x,            red_y, green_x, green_y, blue_x, blue_y);      }   }#endif#ifdef PNG_gAMA_SUPPORTED   {      png_fixed_point gamma;      if (png_get_gAMA_fixed(read_ptr, read_info_ptr, &gamma))         png_set_gAMA_fixed(write_ptr, write_info_ptr, gamma);   }#endif#else #ifdef PNG_FLOATING_POINT_SUPPORTED#ifdef PNG_cHRM_SUPPORTED   {      double white_x, white_y, red_x, red_y, green_x, green_y, blue_x,         blue_y;      if (png_get_cHRM(read_ptr, read_info_ptr, &white_x, &white_y, &red_x,         &red_y, &green_x, &green_y, &blue_x, &blue_y))      {         png_set_cHRM(write_ptr, write_info_ptr, white_x, white_y, red_x,            red_y, green_x, green_y, blue_x, blue_y);      }   }#endif#ifdef PNG_gAMA_SUPPORTED   {      double gamma;      if (png_get_gAMA(read_ptr, read_info_ptr, &gamma))         png_set_gAMA(write_ptr, write_info_ptr, gamma);   }#endif#endif #endif #ifdef PNG_iCCP_SUPPORTED   {      png_charp name;      png_bytep profile;      png_uint_32 proflen;      int compression_type;      if (png_get_iCCP(read_ptr, read_info_ptr, &name, &compression_type,                      &profile, &proflen))      {         png_set_iCCP(write_ptr, write_info_ptr, name, compression_type,                      profile, proflen);      }   }#endif#ifdef PNG_sRGB_SUPPORTED   {      int intent;      if (png_get_sRGB(read_ptr, read_info_ptr, &intent))         png_set_sRGB(write_ptr, write_info_ptr, intent);   }#endif   {      png_colorp palette;      int num_palette;      if (png_get_PLTE(read_ptr, read_info_ptr, &palette, &num_palette))         png_set_PLTE(write_ptr, write_info_ptr, palette, num_palette);   }#ifdef PNG_bKGD_SUPPORTED   {      png_color_16p background;      if (png_get_bKGD(read_ptr, read_info_ptr, &background))      {         png_set_bKGD(write_ptr, write_info_ptr, background);      }   }#endif#ifdef PNG_hIST_SUPPORTED   {      png_uint_16p hist;      if (png_get_hIST(read_ptr, read_info_ptr, &hist))         png_set_hIST(write_ptr, write_info_ptr, hist);   }#endif#ifdef PNG_oFFs_SUPPORTED   {      png_int_32 offset_x, offset_y;      int unit_type;      if (png_get_oFFs(read_ptr, read_info_ptr, &offset_x, &offset_y,          &unit_type))      {         png_set_oFFs(write_ptr, write_info_ptr, offset_x, offset_y, unit_type);      }   }#endif#ifdef PNG_pCAL_SUPPORTED   {      png_charp purpose, units;      png_charpp params;      png_int_32 X0, X1;      int type, nparams;      if (png_get_pCAL(read_ptr, read_info_ptr, &purpose, &X0, &X1, &type,         &nparams, &units, &params))      {         png_set_pCAL(write_ptr, write_info_ptr, purpose, X0, X1, type,            nparams, units, params);      }   }#endif#ifdef PNG_pHYs_SUPPORTED   {      png_uint_32 res_x, res_y;      int unit_type;      if (png_get_pHYs(read_ptr, read_info_ptr, &res_x, &res_y, &unit_type))         png_set_pHYs(write_ptr, write_info_ptr, res_x, res_y, unit_type);   }#endif#ifdef PNG_sBIT_SUPPORTED   {      png_color_8p sig_bit;      if (png_get_sBIT(read_ptr, read_info_ptr, &sig_bit))         png_set_sBIT(write_ptr, write_info_ptr, sig_bit);   }#endif#ifdef PNG_sCAL_SUPPORTED#ifdef PNG_FLOATING_POINT_SUPPORTED   {      int unit;      double scal_width, scal_height;      if (png_get_sCAL(read_ptr, read_info_ptr, &unit, &scal_width,         &scal_height))      {         png_set_sCAL(write_ptr, write_info_ptr, unit, scal_width, scal_height);      }   }#else#ifdef PNG_FIXED_POINT_SUPPORTED   {      int unit;      png_charp scal_width, scal_height;      if (png_get_sCAL_s(read_ptr, read_info_ptr, &unit, &scal_width,          &scal_height))      {         png_set_sCAL_s(write_ptr, write_info_ptr, unit, scal_width,             scal_height);      }   }#endif#endif#endif#ifdef PNG_TEXT_SUPPORTED   {      png_textp text_ptr;      int num_text;      if (png_get_text(read_ptr, read_info_ptr, &text_ptr, &num_text) > 0)      {         pngtest_debug1(\"Handling %d iTXt/tEXt/zTXt chunks\", num_text);         png_set_text(write_ptr, write_info_ptr, text_ptr, num_text);      }   }#endif#ifdef PNG_tIME_SUPPORTED   {      png_timep mod_time;      if (png_get_tIME(read_ptr, read_info_ptr, &mod_time))      {         png_set_tIME(write_ptr, write_info_ptr, mod_time);#ifdef PNG_TIME_RFC1123_SUPPORTED                  png_memcpy(tIME_string,                    png_convert_to_rfc1123(read_ptr, mod_time),                    png_sizeof(tIME_string));         tIME_string[png_sizeof(tIME_string) - 1] = '\\0';         tIME_chunk_present++;#endif       }   }#endif#ifdef PNG_tRNS_SUPPORTED   {      png_bytep trans_alpha;      int num_trans;      png_color_16p trans_color;      if (png_get_tRNS(read_ptr, read_info_ptr, &trans_alpha, &num_trans,         &trans_color))      {         int sample_max = (1 << bit_depth);                  if (!((color_type == PNG_COLOR_TYPE_GRAY &&             (int)trans_color->gray > sample_max) ||             (color_type == PNG_COLOR_TYPE_RGB &&             ((int)trans_color->red > sample_max ||             (int)trans_color->green > sample_max ||             (int)trans_color->blue > sample_max))))            png_set_tRNS(write_ptr, write_info_ptr, trans_alpha, num_trans,               trans_color);      }   }#endif#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED   {      png_unknown_chunkp unknowns;      int num_unknowns = png_get_unknown_chunks(read_ptr, read_info_ptr,         &unknowns);      if (num_unknowns)      {         int i;         png_set_unknown_chunks(write_ptr, write_info_ptr, unknowns,           num_unknowns);                  for (i = 0; i < num_unknowns; i++)           png_set_unknown_chunk_location(write_ptr, write_info_ptr, i,             unknowns[i].location);      }   }#endif#ifdef PNG_WRITE_SUPPORTED   pngtest_debug(\"Writing info struct\");   png_write_info(write_ptr, write_info_ptr);#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED   if (user_chunk_data[0] != 0)   {      png_byte png_sTER[5] = {115,  84,  69,  82, '\\0'};      unsigned char        ster_chunk_data[1];      if (verbose)         fprintf(STDERR, \"\\n stereo mode = %lu\\n\",           (unsigned long)(user_chunk_data[0] - 1));      ster_chunk_data[0]=(unsigned char)(user_chunk_data[0] - 1);      png_write_chunk(write_ptr, png_sTER, ster_chunk_data, 1);   }   if (user_chunk_data[1] != 0 || user_chunk_data[2] != 0)   {      png_byte png_vpAg[5] = {118, 112,  65, 103, '\\0'};      unsigned char        vpag_chunk_data[9];      if (verbose)         fprintf(STDERR, \" vpAg = %lu x %lu, units = %lu\\n\",           (unsigned long)user_chunk_data[1],           (unsigned long)user_chunk_data[2],           (unsigned long)user_chunk_data[3]);      png_save_uint_32(vpag_chunk_data, user_chunk_data[1]);      png_save_uint_32(vpag_chunk_data + 4, user_chunk_data[2]);      vpag_chunk_data[8] = (unsigned char)(user_chunk_data[3] & 0xff);      png_write_chunk(write_ptr, png_vpAg, vpag_chunk_data, 9);   }#endif#endif#ifdef SINGLE_ROWBUF_ALLOC   pngtest_debug(\"Allocating row buffer...\");   row_buf = (png_bytep)png_malloc(read_ptr,      png_get_rowbytes(read_ptr, read_info_ptr));   pngtest_debug1(\"\\t0x%08lx\", (unsigned long)row_buf);#endif    pngtest_debug(\"Writing row data\");#if defined(PNG_READ_INTERLACING_SUPPORTED) || \\  defined(PNG_WRITE_INTERLACING_SUPPORTED)   num_pass = png_set_interlace_handling(read_ptr);#  ifdef PNG_WRITE_SUPPORTED   png_set_interlace_handling(write_ptr);#  endif#else   num_pass = 1;#endif#ifdef PNGTEST_TIMING   t_stop = (float)clock();   t_misc += (t_stop - t_start);   t_start = t_stop;#endif   for (pass = 0; pass < num_pass; pass++)   {      pngtest_debug1(\"Writing row data for pass %d\", pass);      for (y = 0; y < height; y++)      {#ifndef SINGLE_ROWBUF_ALLOC         pngtest_debug2(\"Allocating row buffer (pass %d, y = %u)...\", pass, y);         row_buf = (png_bytep)png_malloc(read_ptr,            png_get_rowbytes(read_ptr, read_info_ptr));         pngtest_debug2(\"\\t0x%08lx (%u bytes)\", (unsigned long)row_buf,            png_get_rowbytes(read_ptr, read_info_ptr));#endif          png_read_rows(read_ptr, (png_bytepp)&row_buf, NULL, 1);#ifdef PNG_WRITE_SUPPORTED#ifdef PNGTEST_TIMING         t_stop = (float)clock();         t_decode += (t_stop - t_start);         t_start = t_stop;#endif         png_write_rows(write_ptr, (png_bytepp)&row_buf, 1);#ifdef PNGTEST_TIMING         t_stop = (float)clock();         t_encode += (t_stop - t_start);         t_start = t_stop;#endif#endif #ifndef SINGLE_ROWBUF_ALLOC         pngtest_debug2(\"Freeing row buffer (pass %d, y = %u)\", pass, y);         png_free(read_ptr, row_buf);         row_buf = NULL;#endif       }   }#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED   png_free_data(read_ptr, read_info_ptr, PNG_FREE_UNKN, -1);#endif#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED   png_free_data(write_ptr, write_info_ptr, PNG_FREE_UNKN, -1);#endif   pngtest_debug(\"Reading and writing end_info data\");   png_read_end(read_ptr, end_info_ptr);#ifdef PNG_TEXT_SUPPORTED   {      png_textp text_ptr;      int num_text;      if (png_get_text(read_ptr, end_info_ptr, &text_ptr, &num_text) > 0)      {         pngtest_debug1(\"Handling %d iTXt/tEXt/zTXt chunks\", num_text);         png_set_text(write_ptr, write_end_info_ptr, text_ptr, num_text);      }   }#endif#ifdef PNG_tIME_SUPPORTED   {      png_timep mod_time;      if (png_get_tIME(read_ptr, end_info_ptr, &mod_time))      {         png_set_tIME(write_ptr, write_end_info_ptr, mod_time);#ifdef PNG_TIME_RFC1123_SUPPORTED                  png_memcpy(tIME_string,                    png_convert_to_rfc1123(read_ptr, mod_time),                    png_sizeof(tIME_string));         tIME_string[png_sizeof(tIME_string) - 1] = '\\0';         tIME_chunk_present++;#endif       }   }#endif#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED   {      png_unknown_chunkp unknowns;      int num_unknowns = png_get_unknown_chunks(read_ptr, end_info_ptr,         &unknowns);      if (num_unknowns)      {         int i;         png_set_unknown_chunks(write_ptr, write_end_info_ptr, unknowns,           num_unknowns);                  for (i = 0; i < num_unknowns; i++)           png_set_unknown_chunk_location(write_ptr, write_end_info_ptr, i,             unknowns[i].location);      }   }#endif#ifdef PNG_WRITE_SUPPORTED   png_write_end(write_ptr, write_end_info_ptr);#endif#ifdef PNG_EASY_ACCESS_SUPPORTED   if (verbose)   {      png_uint_32 iwidth, iheight;      iwidth = png_get_image_width(write_ptr, write_info_ptr);      iheight = png_get_image_height(write_ptr, write_info_ptr);      fprintf(STDERR, \"\\n Image width = %lu, height = %lu\\n\",         (unsigned long)iwidth, (unsigned long)iheight);   }#endif   pngtest_debug(\"Destroying data structs\");#ifdef SINGLE_ROWBUF_ALLOC   pngtest_debug(\"destroying row_buf for read_ptr\");   png_free(read_ptr, row_buf);   row_buf = NULL;#endif    pngtest_debug(\"destroying read_ptr, read_info_ptr, end_info_ptr\");   png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);#ifdef PNG_WRITE_SUPPORTED   pngtest_debug(\"destroying write_end_info_ptr\");   png_destroy_info_struct(write_ptr, &write_end_info_ptr);   pngtest_debug(\"destroying write_ptr, write_info_ptr\");   png_destroy_write_struct(&write_ptr, &write_info_ptr);#endif   pngtest_debug(\"Destruction complete.\");   FCLOSE(fpin);   FCLOSE(fpout);   pngtest_debug(\"Opening files for comparison\");   if ((fpin = fopen(inname, \"rb\")) == NULL)   {      fprintf(STDERR, \"Could not find file %s\\n\", inname);      return (1);   }   if ((fpout = fopen(outname, \"rb\")) == NULL)   {      fprintf(STDERR, \"Could not find file %s\\n\", outname);      FCLOSE(fpin);      return (1);   }   for (;;)   {      png_size_t num_in, num_out;         num_in = fread(inbuf, 1, 1, fpin);         num_out = fread(outbuf, 1, 1, fpout);      if (num_in != num_out)      {         fprintf(STDERR, \"\\nFiles %s and %s are of a different size\\n\",                 inname, outname);         if (wrote_question == 0)         {            fprintf(STDERR,         \"   Was %s written with the same maximum IDAT chunk size (%d bytes),\",              inname, PNG_ZBUF_SIZE);            fprintf(STDERR,              \"\\n   filtering heuristic (libpng default), compression\");            fprintf(STDERR,              \" level (zlib default),\\n   and zlib version (%s)?\\n\\n\",              ZLIB_VERSION);            wrote_question = 1;         }         FCLOSE(fpin);         FCLOSE(fpout);         return (0);      }      if (!num_in)         break;      if (png_memcmp(inbuf, outbuf, num_in))      {         fprintf(STDERR, \"\\nFiles %s and %s are different\\n\", inname, outname);         if (wrote_question == 0)         {            fprintf(STDERR,         \"   Was %s written with the same maximum IDAT chunk size (%d bytes),\",                 inname, PNG_ZBUF_SIZE);            fprintf(STDERR,              \"\\n   filtering heuristic (libpng default), compression\");            fprintf(STDERR,              \" level (zlib default),\\n   and zlib version (%s)?\\n\\n\",              ZLIB_VERSION);            wrote_question = 1;         }         FCLOSE(fpin);         FCLOSE(fpout);         return (0);      }   }   FCLOSE(fpin);   FCLOSE(fpout);   return (0);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIpngtest_write_data(png_structp png_ptr, png_bytep data, png_size_t length){   png_size_t check;   check = fwrite(data, 1, length, (png_FILE_p)png_get_io_ptr(png_ptr));   if (check != length)   {      png_error(png_ptr, \"Write Error\");   }#ifdef PNG_IO_STATE_SUPPORTED   pngtest_check_io_state(png_ptr, length, PNG_IO_WRITING);#endif}static void PNGCBAPIpngtest_write_data(png_structp png_ptr, png_bytep data, png_size_t length){   png_size_t check;   png_byte *near_data;     png_FILE_p io_ptr;      near_data = (png_byte *)CVT_PTR_NOCHECK(data);   io_ptr = (png_FILE_p)CVT_PTR(png_get_io_ptr(png_ptr));   if ((png_bytep)near_data == data)   {      check = fwrite(near_data, 1, length, io_ptr);   }   else   {      png_byte buf[NEAR_BUF_SIZE];      png_size_t written, remaining, err;      check = 0;      remaining = length;      do      {         written = MIN(NEAR_BUF_SIZE, remaining);         png_memcpy(buf, data, written);          err = fwrite(buf, 1, written, io_ptr);         if (err != written)            break;         else            check += err;         data += written;         remaining -= written;      }      while (remaining != 0);   }   if (check != length)   {      png_error(png_ptr, \"Write Error\");   }#ifdef PNG_IO_STATE_SUPPORTED   pngtest_check_io_state(png_ptr, length, PNG_IO_WRITING);#endif}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_abgr8(Pixel *p, png_const_voidp pb){   png_const_bytep pp = voidcast(png_const_bytep, pb);   p->r = pp[3];   p->g = pp[2];   p->b = pp[1];   p->a = pp[0];}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_g8b(Pixel *out, const Pixel *in, const Background *back){   if (in->a <= 0)      out->r = out->g = out->b = back->ig;   else if (in->a >= 255)   {      if (in->r == in->g && in->g == in->b)         out->r = out->g = out->b = in->g;      else         out->r = out->g = out->b = sRGB(YfromRGB(            sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));   }   else   {      double a = in->a/255.;      out->r = out->g = out->b = sRGB(a * YfromRGB(sRGB_to_d[in->r],         sRGB_to_d[in->g], sRGB_to_d[in->b]) + back->dg * (1-a));   }   out->a = 255;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmodifier_init(png_modifier *pm){   memset(pm, 0, sizeof *pm);   store_init(&pm->this);   pm->modifications = NULL;   pm->state = modifier_start;   pm->sbitlow = 1U;   pm->ngammas = 0;   pm->ngamma_tests = 0;   pm->gammas = 0;   pm->current_gamma = 0;   pm->encodings = 0;   pm->nencodings = 0;   pm->current_encoding = 0;   pm->encoding_counter = 0;   pm->encoding_ignored = 0;   pm->repeat = 0;   pm->test_uses_encoding = 0;   pm->maxout8 = pm->maxpc8 = pm->maxabs8 = pm->maxcalc8 = 0;   pm->maxout16 = pm->maxpc16 = pm->maxabs16 = pm->maxcalc16 = 0;   pm->maxcalcG = 0;   pm->limit = 4E-3;   pm->log8 = pm->log16 = 0;    pm->error_gray_2 = pm->error_gray_4 = pm->error_gray_8 = 0;   pm->error_gray_16 = pm->error_color_8 = pm->error_color_16 = 0;   pm->error_indexed = 0;   pm->use_update_info = 0;   pm->interlace_type = PNG_INTERLACE_NONE;   pm->test_standard = 0;   pm->test_size = 0;   pm->test_transform = 0;   pm->use_input_precision = 0;   pm->use_input_precision_sbit = 0;   pm->use_input_precision_16to8 = 0;   pm->calculations_use_input_precision = 0;   pm->assume_16_bit_calculations = 0;   pm->test_gamma_threshold = 0;   pm->test_gamma_transform = 0;   pm->test_gamma_sbit = 0;   pm->test_gamma_scale16 = 0;   pm->test_gamma_background = 0;   pm->test_gamma_alpha_mode = 0;   pm->test_gamma_expand16 = 0;   pm->test_exhaustive = 0;   pm->log = 0;   }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void rpng2_x_redisplay_image(ulg startcol, ulg startrow,                                    ulg width, ulg height){    uch bg_red   = rpng2_info.bg_red;    uch bg_green = rpng2_info.bg_green;    uch bg_blue  = rpng2_info.bg_blue;    uch *src, *src2=NULL;    char *dest;    uch r, g, b, a;    ulg i, row, lastrow = 0;    ulg pixel;    int ximage_rowbytes = ximage->bytes_per_line;    Trace((stderr, \"beginning display loop (image_channels == %d)\\n\",      rpng2_info.channels))    Trace((stderr, \"   (width = %ld, rowbytes = %d, ximage_rowbytes = %d)\\n\",      rpng2_info.width, rpng2_info.rowbytes, ximage_rowbytes))    Trace((stderr, \"   (bpp = %d)\\n\", ximage->bits_per_pixel))    Trace((stderr, \"   (byte_order = %s)\\n\", ximage->byte_order == MSBFirst?      \"MSBFirst\" : (ximage->byte_order == LSBFirst? \"LSBFirst\" : \"unknown\")))    if (depth == 24 || depth == 32) {        ulg red, green, blue;        int bpp = ximage->bits_per_pixel;        for (lastrow = row = startrow;  row < startrow+height;  ++row) {            src = rpng2_info.image_data + row*rpng2_info.rowbytes;            if (bg_image)                src2 = bg_data + row*bg_rowbytes;            dest = ximage->data + row*ximage_rowbytes;            if (rpng2_info.channels == 3) {                for (i = rpng2_info.width;  i > 0;  --i) {                    red   = *src++;                    green = *src++;                    blue  = *src++;#ifdef NO_24BIT_MASKS                    pixel = (red   << RShift) |                            (green << GShift) |                            (blue  << BShift);                                        if (bpp == 32) {                        *dest++ = (char)((pixel >> 24) & 0xff);                        *dest++ = (char)((pixel >> 16) & 0xff);                        *dest++ = (char)((pixel >>  8) & 0xff);                        *dest++ = (char)( pixel        & 0xff);                    } else {                                                                        *dest++ = (char)((pixel >> 16) & 0xff);                        *dest++ = (char)((pixel >>  8) & 0xff);                        *dest++ = (char)( pixel        & 0xff);                    }#else                    red   = (RShift < 0)? red   << (-RShift) : red   >> RShift;                    green = (GShift < 0)? green << (-GShift) : green >> GShift;                    blue  = (BShift < 0)? blue  << (-BShift) : blue  >> BShift;                    pixel = (red & RMask) | (green & GMask) | (blue & BMask);                                        if (bpp == 32) {                        *dest++ = (char)((pixel >> 24) & 0xff);                        *dest++ = (char)((pixel >> 16) & 0xff);                        *dest++ = (char)((pixel >>  8) & 0xff);                        *dest++ = (char)( pixel        & 0xff);                    } else {                                                                                                *dest++ = (char)((pixel >> 16) & 0xff);                        *dest++ = (char)((pixel >>  8) & 0xff);                        *dest++ = (char)( pixel        & 0xff);                    }#endif                }            } else  {                for (i = rpng2_info.width;  i > 0;  --i) {                    r = *src++;                    g = *src++;                    b = *src++;                    a = *src++;                    if (bg_image) {                        bg_red   = *src2++;                        bg_green = *src2++;                        bg_blue  = *src2++;                    }                    if (a == 255) {                        red   = r;                        green = g;                        blue  = b;                    } else if (a == 0) {                        red   = bg_red;                        green = bg_green;                        blue  = bg_blue;                    } else {                                                alpha_composite(red,   r, a, bg_red);                        alpha_composite(green, g, a, bg_green);                        alpha_composite(blue,  b, a, bg_blue);                    }#ifdef NO_24BIT_MASKS                    pixel = (red   << RShift) |                            (green << GShift) |                            (blue  << BShift);                                        if (bpp == 32) {                        *dest++ = (char)((pixel >> 24) & 0xff);                        *dest++ = (char)((pixel >> 16) & 0xff);                        *dest++ = (char)((pixel >>  8) & 0xff);                        *dest++ = (char)( pixel        & 0xff);                    } else {                                                                        *dest++ = (char)((pixel >> 16) & 0xff);                        *dest++ = (char)((pixel >>  8) & 0xff);                        *dest++ = (char)( pixel        & 0xff);                    }#else                    red   = (RShift < 0)? red   << (-RShift) : red   >> RShift;                    green = (GShift < 0)? green << (-GShift) : green >> GShift;                    blue  = (BShift < 0)? blue  << (-BShift) : blue  >> BShift;                    pixel = (red & RMask) | (green & GMask) | (blue & BMask);                                        if (bpp == 32) {                        *dest++ = (char)((pixel >> 24) & 0xff);                        *dest++ = (char)((pixel >> 16) & 0xff);                        *dest++ = (char)((pixel >>  8) & 0xff);                        *dest++ = (char)( pixel        & 0xff);                    } else {                                                                                                *dest++ = (char)((pixel >> 16) & 0xff);                        *dest++ = (char)((pixel >>  8) & 0xff);                        *dest++ = (char)( pixel        & 0xff);                    }#endif                }            }                        if (((row+1) & 0xf) == 0) {                XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,                  (int)lastrow, rpng2_info.width, 16);                XFlush(display);                lastrow = row + 1;            }        }    } else if (depth == 16) {        ush red, green, blue;        for (lastrow = row = startrow;  row < startrow+height;  ++row) {            src = rpng2_info.row_pointers[row];            if (bg_image)                src2 = bg_data + row*bg_rowbytes;            dest = ximage->data + row*ximage_rowbytes;            if (rpng2_info.channels == 3) {                for (i = rpng2_info.width;  i > 0;  --i) {                    red   = ((ush)(*src) << 8);                    ++src;                    green = ((ush)(*src) << 8);                    ++src;                    blue  = ((ush)(*src) << 8);                    ++src;                    pixel = ((red   >> RShift) & RMask) |                            ((green >> GShift) & GMask) |                            ((blue  >> BShift) & BMask);                                        *dest++ = (char)((pixel >>  8) & 0xff);                    *dest++ = (char)( pixel        & 0xff);                }            } else  {                for (i = rpng2_info.width;  i > 0;  --i) {                    r = *src++;                    g = *src++;                    b = *src++;                    a = *src++;                    if (bg_image) {                        bg_red   = *src2++;                        bg_green = *src2++;                        bg_blue  = *src2++;                    }                    if (a == 255) {                        red   = ((ush)r << 8);                        green = ((ush)g << 8);                        blue  = ((ush)b << 8);                    } else if (a == 0) {                        red   = ((ush)bg_red   << 8);                        green = ((ush)bg_green << 8);                        blue  = ((ush)bg_blue  << 8);                    } else {                                                alpha_composite(r, r, a, bg_red);                        alpha_composite(g, g, a, bg_green);                        alpha_composite(b, b, a, bg_blue);                        red   = ((ush)r << 8);                        green = ((ush)g << 8);                        blue  = ((ush)b << 8);                    }                    pixel = ((red   >> RShift) & RMask) |                            ((green >> GShift) & GMask) |                            ((blue  >> BShift) & BMask);                                        *dest++ = (char)((pixel >>  8) & 0xff);                    *dest++ = (char)( pixel        & 0xff);                }            }                        if (((row+1) & 0xf) == 0) {                XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,                  (int)lastrow, rpng2_info.width, 16);                XFlush(display);                lastrow = row + 1;            }        }    } else  {            }    Trace((stderr, \"calling final XPutImage()\\n\"))    if (lastrow < startrow+height) {        XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,          (int)lastrow, rpng2_info.width, rpng2_info.height-lastrow);        XFlush(display);    }} ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int fail(png_modifier *pm){   return !pm->log && !pm->this.verbose && (pm->this.nerrors > 0 ||       (pm->this.treat_warnings_as_errors && pm->this.nwarnings > 0));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidinit_gamma_errors(png_modifier *pm){      pm->error_gray_2 = pm->error_gray_4 = pm->error_gray_8 = -1.;   pm->error_color_8 = -1.;   pm->error_indexed = -1.;   pm->error_gray_16 = pm->error_color_16 = -1.;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32random_32(void){   for (;;)   {      png_byte mark[4];      png_uint_32 result;      store_pool_mark(mark);      result = png_get_uint_32(mark);      if (result != 0)         return result;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int rpng2_win_load_bg_image(){    uch *src, *dest;    uch r1, r2, g1, g2, b1, b2;    uch r1_inv, r2_inv, g1_inv, g2_inv, b1_inv, b2_inv;    int k, hmax, max;    int xidx, yidx, yidx_max = (bgscale-1);    int even_odd_vert, even_odd_horiz, even_odd;    int invert_gradient2 = (bg[pat].type & 0x08);    int invert_column;    ulg i, row;    bg_rowbytes = 3 * rpng2_info.width;    bg_data = (uch *)malloc(bg_rowbytes * rpng2_info.height);    if (!bg_data) {        fprintf(stderr, PROGNAME          \":  unable to allocate memory for background image\\n\");        bg_image = 0;        return 1;    }    if ((bg[pat].type & 0x07) == 0) {        uch r1_min  = rgb[bg[pat].rgb1_min].r;        uch g1_min  = rgb[bg[pat].rgb1_min].g;        uch b1_min  = rgb[bg[pat].rgb1_min].b;        uch r2_min  = rgb[bg[pat].rgb2_min].r;        uch g2_min  = rgb[bg[pat].rgb2_min].g;        uch b2_min  = rgb[bg[pat].rgb2_min].b;        int r1_diff = rgb[bg[pat].rgb1_max].r - r1_min;        int g1_diff = rgb[bg[pat].rgb1_max].g - g1_min;        int b1_diff = rgb[bg[pat].rgb1_max].b - b1_min;        int r2_diff = rgb[bg[pat].rgb2_max].r - r2_min;        int g2_diff = rgb[bg[pat].rgb2_max].g - g2_min;        int b2_diff = rgb[bg[pat].rgb2_max].b - b2_min;        for (row = 0;  row < rpng2_info.height;  ++row) {            yidx = row % bgscale;            even_odd_vert = (row / bgscale) & 1;            r1 = r1_min + (r1_diff * yidx) / yidx_max;            g1 = g1_min + (g1_diff * yidx) / yidx_max;            b1 = b1_min + (b1_diff * yidx) / yidx_max;            r1_inv = r1_min + (r1_diff * (yidx_max-yidx)) / yidx_max;            g1_inv = g1_min + (g1_diff * (yidx_max-yidx)) / yidx_max;            b1_inv = b1_min + (b1_diff * (yidx_max-yidx)) / yidx_max;            r2 = r2_min + (r2_diff * yidx) / yidx_max;            g2 = g2_min + (g2_diff * yidx) / yidx_max;            b2 = b2_min + (b2_diff * yidx) / yidx_max;            r2_inv = r2_min + (r2_diff * (yidx_max-yidx)) / yidx_max;            g2_inv = g2_min + (g2_diff * (yidx_max-yidx)) / yidx_max;            b2_inv = b2_min + (b2_diff * (yidx_max-yidx)) / yidx_max;            dest = bg_data + row*bg_rowbytes;            for (i = 0;  i < rpng2_info.width;  ++i) {                even_odd_horiz = (i / bgscale) & 1;                even_odd = even_odd_vert ^ even_odd_horiz;                invert_column =                  (even_odd_horiz && (bg[pat].type & 0x10));                if (even_odd == 0) {                             if (invert_column) {                        *dest++ = r1_inv;                        *dest++ = g1_inv;                        *dest++ = b1_inv;                    } else {                        *dest++ = r1;                        *dest++ = g1;                        *dest++ = b1;                    }                } else {                                         if ((invert_column && invert_gradient2) ||                        (!invert_column && !invert_gradient2))                    {                        *dest++ = r2;                                *dest++ = g2;                                *dest++ = b2;                    } else {                        *dest++ = r2_inv;                        *dest++ = g2_inv;                            *dest++ = b2_inv;                    }                }            }        }    } else if ((bg[pat].type & 0x07) == 1) {        hmax = (bgscale-1)/2;           max = 2*hmax;                   r1 = rgb[bg[pat].rgb1_max].r;        g1 = rgb[bg[pat].rgb1_max].g;        b1 = rgb[bg[pat].rgb1_max].b;        r2 = rgb[bg[pat].rgb2_max].r;        g2 = rgb[bg[pat].rgb2_max].g;        b2 = rgb[bg[pat].rgb2_max].b;        for (row = 0;  row < rpng2_info.height;  ++row) {            yidx = row % bgscale;            if (yidx > hmax)                yidx = bgscale-1 - yidx;            dest = bg_data + row*bg_rowbytes;            for (i = 0;  i < rpng2_info.width;  ++i) {                xidx = i % bgscale;                if (xidx > hmax)                    xidx = bgscale-1 - xidx;                k = xidx + yidx;                *dest++ = (k*r1 + (max-k)*r2) / max;                *dest++ = (k*g1 + (max-k)*g2) / max;                *dest++ = (k*b1 + (max-k)*b2) / max;            }        }    } else if ((bg[pat].type & 0x07) == 2) {        uch ch;        int ii, x, y, hw, hh, grayspot;        double freq, rotate, saturate, gray, intensity;        double angle=0.0, aoffset=0.0, maxDist, dist;        double red=0.0, green=0.0, blue=0.0, hue, s, v, f, p, q, t;        fprintf(stderr, \"%s:  computing radial background...\",          PROGNAME);        fflush(stderr);        hh = rpng2_info.height / 2;        hw = rpng2_info.width / 2;                angle = CLIP(angle, 0.0, 360.0);        grayspot = CLIP(bg[pat].bg_gray, 1, (hh + hw));        freq = MAX((double)bg[pat].bg_freq, 0.0);        saturate = (double)bg[pat].bg_bsat * 0.1;        rotate = (double)bg[pat].bg_brot * 0.1;        gray = 0.0;        intensity = 0.0;        maxDist = (double)((hw*hw) + (hh*hh));        for (row = 0;  row < rpng2_info.height;  ++row) {            y = row - hh;            dest = bg_data + row*bg_rowbytes;            for (i = 0;  i < rpng2_info.width;  ++i) {                x = i - hw;                angle = (x == 0)? PI_2 : atan((double)y / (double)x);                gray = (double)MAX(ABS(y), ABS(x)) / grayspot;                gray = MIN(1.0, gray);                dist = (double)((x*x) + (y*y)) / maxDist;                intensity = cos((angle+(rotate*dist*PI)) * freq) *                  gray * saturate;                intensity = (MAX(MIN(intensity,1.0),-1.0) + 1.0) * 0.5;                hue = (angle + PI) * INV_PI_360 + aoffset;                s = gray * ((double)(ABS(x)+ABS(y)) / (double)(hw + hh));                s = MIN(MAX(s,0.0), 1.0);                v = MIN(MAX(intensity,0.0), 1.0);                if (s == 0.0) {                    ch = (uch)(v * 255.0);                    *dest++ = ch;                    *dest++ = ch;                    *dest++ = ch;                } else {                    if ((hue < 0.0) || (hue >= 360.0))                        hue -= (((int)(hue / 360.0)) * 360.0);                    hue /= 60.0;                    ii = (int)hue;                    f = hue - (double)ii;                    p = (1.0 - s) * v;                    q = (1.0 - (s * f)) * v;                    t = (1.0 - (s * (1.0 - f))) * v;                    if      (ii == 0) { red = v; green = t; blue = p; }                    else if (ii == 1) { red = q; green = v; blue = p; }                    else if (ii == 2) { red = p; green = v; blue = t; }                    else if (ii == 3) { red = p; green = q; blue = v; }                    else if (ii == 4) { red = t; green = p; blue = v; }                    else if (ii == 5) { red = v; green = p; blue = q; }                    *dest++ = (uch)(red * 255.0);                    *dest++ = (uch)(green * 255.0);                    *dest++ = (uch)(blue * 255.0);                }            }        }        fprintf(stderr, \"done.\\n\");        fflush(stderr);    }    for (row = 0;  row < rpng2_info.height;  ++row) {        src = bg_data + row*bg_rowbytes;        dest = wimage_data + row*wimage_rowbytes;        for (i = rpng2_info.width;  i > 0;  --i) {            r1 = *src++;            g1 = *src++;            b1 = *src++;            *dest++ = b1;            *dest++ = g1;               *dest++ = r1;        }    }    return 0;} ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmodifier_progressive_read(png_modifier *pm, png_structp pp, png_infop pi){   if (pm->this.pread != pp || pm->this.current == NULL ||       pm->this.next == NULL)      png_error(pp, \"store state damaged (progressive)\");      for (;;)   {      static png_uint_32 noise = 1;      png_size_t cb, cbAvail;      png_byte buffer[512];            noise = (noise << 9) | ((noise ^ (noise >> (9-5))) & 0x1ff);      cb = noise & 0x1ff;            cbAvail = store_read_buffer_avail(&pm->this);      if (pm->buffer_count > pm->buffer_position)         cbAvail += pm->buffer_count - pm->buffer_position;      if (cb > cbAvail)      {                  if (cbAvail == 0)            break;         cb = cbAvail;      }      modifier_read_imp(pm, buffer, cb);      png_process_data(pp, pi, buffer, cb);   }      if (pm->buffer_count > pm->buffer_position ||       pm->this.next != &pm->this.current->data ||       pm->this.readpos < pm->this.current->datacount)      png_error(pp, \"progressive read implementation error\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32 png_log16bit(png_uint_32 x){   if (x > 0)      return (png_uint_32)floor(.5-log(x/65535.)*L2INV);   return 0xffffffff;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static size_ttransform_rowsize(png_const_structp pp, png_byte colour_type,   png_byte bit_depth){   return (TRANSFORM_WIDTH * bit_size(pp, colour_type, bit_depth)) / 8;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGAPIpng_read_png(png_structp png_ptr, png_infop info_ptr,                           int transforms,                           voidp params){   int row;   if (png_ptr == NULL) return;#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)      if (transforms & PNG_TRANSFORM_INVERT_ALPHA)       png_set_invert_alpha(png_ptr);#endif      png_read_info(png_ptr, info_ptr);   if (info_ptr->height > PNG_UINT_32_MAX/png_sizeof(png_bytep))      png_error(png_ptr, \"Image is too high to process with png_read_png()\");   #if defined(PNG_READ_16_TO_8_SUPPORTED)      if (transforms & PNG_TRANSFORM_STRIP_16)       png_set_strip_16(png_ptr);#endif#if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)      if (transforms & PNG_TRANSFORM_STRIP_ALPHA)       png_set_strip_alpha(png_ptr);#endif#if defined(PNG_READ_PACK_SUPPORTED) && !defined(PNG_READ_EXPAND_SUPPORTED)      if (transforms & PNG_TRANSFORM_PACKING)       png_set_packing(png_ptr);#endif#if defined(PNG_READ_PACKSWAP_SUPPORTED)      if (transforms & PNG_TRANSFORM_PACKSWAP)       png_set_packswap(png_ptr);#endif#if defined(PNG_READ_EXPAND_SUPPORTED)      if (transforms & PNG_TRANSFORM_EXPAND)       if ((png_ptr->bit_depth < 8) ||           (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ||           (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)))         png_set_expand(png_ptr);#endif   #if defined(PNG_READ_INVERT_SUPPORTED)      if (transforms & PNG_TRANSFORM_INVERT_MONO)       png_set_invert_mono(png_ptr);#endif#if defined(PNG_READ_SHIFT_SUPPORTED)      if ((transforms & PNG_TRANSFORM_SHIFT)       && png_get_valid(png_ptr, info_ptr, PNG_INFO_sBIT))   {      png_color_8p sig_bit;      png_get_sBIT(png_ptr, info_ptr, &sig_bit);      png_set_shift(png_ptr, sig_bit);   }#endif#if defined(PNG_READ_BGR_SUPPORTED)      if (transforms & PNG_TRANSFORM_BGR)       png_set_bgr(png_ptr);#endif#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED)      if (transforms & PNG_TRANSFORM_SWAP_ALPHA)       png_set_swap_alpha(png_ptr);#endif#if defined(PNG_READ_SWAP_SUPPORTED)      if (transforms & PNG_TRANSFORM_SWAP_ENDIAN)       png_set_swap(png_ptr);#endif         png_read_update_info(png_ptr, info_ptr);   #ifdef PNG_FREE_ME_SUPPORTED   png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);#endif   if (info_ptr->row_pointers == NULL)   {      info_ptr->row_pointers = (png_bytepp)png_malloc(png_ptr,         info_ptr->height * png_sizeof(png_bytep));#ifdef PNG_FREE_ME_SUPPORTED      info_ptr->free_me |= PNG_FREE_ROWS;#endif      for (row = 0; row < (int)info_ptr->height; row++)      {         info_ptr->row_pointers[row] = (png_bytep)png_malloc(png_ptr,            png_get_rowbytes(png_ptr, info_ptr));      }   }   png_read_image(png_ptr, info_ptr->row_pointers);   info_ptr->valid |= PNG_INFO_IDAT;      png_read_end(png_ptr, info_ptr);   transforms = transforms;    params = params;}#endif #endif #endif ",
        "label": 1,
        "cve": "cve-2009-0040"
    },
    {
        "code": "static png_uint_32png_col_from_pass_col(png_uint_32 xIn, int pass){      switch (pass)   {case 0: return xIn * 8;case 1: return xIn * 8 + 4;case 2: return xIn * 4;case 3: return xIn * 4 + 2;case 4: return xIn * 2;case 5: return xIn * 2 + 1;case 6: return xIn;default: break;   }   return 0xff; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length){   png_textp text_ptr;   png_charp chunkdata;   png_charp key, lang, text, lang_key;   int comp_flag;   int comp_type = 0;   int ret;   png_size_t slength, prefix_len, data_len;   png_debug(1, \"in png_handle_iTXt\\n\");   if (!(png_ptr->mode & PNG_HAVE_IHDR))      png_error(png_ptr, \"Missing IHDR before iTXt\");   if (png_ptr->mode & PNG_HAVE_IDAT)      png_ptr->mode |= PNG_AFTER_IDAT;#ifdef PNG_MAX_MALLOC_64K      if (length > (png_uint_32)65535L)   {     png_warning(png_ptr,\"iTXt chunk too large to fit in memory\");     png_crc_finish(png_ptr, length);     return;   }#endif   chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);   if (chunkdata == NULL)   {     png_warning(png_ptr, \"No memory to process iTXt chunk.\");     return;   }   slength = (png_size_t)length;   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);   if (png_crc_finish(png_ptr, 0))   {      png_free(png_ptr, chunkdata);      return;   }   chunkdata[slength] = 0x00;   for (lang = chunkdata; *lang; lang++)       ;   lang++;              if (lang >= chunkdata + slength)   {      comp_flag = PNG_TEXT_COMPRESSION_NONE;      png_warning(png_ptr, \"Zero length iTXt chunk\");   }   else   {       comp_flag = *lang++;       comp_type = *lang++;   }   for (lang_key = lang; *lang_key; lang_key++)       ;   lang_key++;           for (text = lang_key; *text; text++)       ;   text++;           prefix_len = text - chunkdata;   key=chunkdata;   if (comp_flag)       chunkdata = png_decompress_chunk(png_ptr, comp_type, chunkdata,          (size_t)length, prefix_len, &data_len);   else       data_len=png_strlen(chunkdata + prefix_len);   text_ptr = (png_textp)png_malloc_warn(png_ptr,      (png_uint_32)png_sizeof(png_text));   if (text_ptr == NULL)   {     png_warning(png_ptr,\"Not enough memory to process iTXt chunk.\");     png_free(png_ptr, chunkdata);     return;   }   text_ptr->compression = (int)comp_flag + 1;   text_ptr->lang_key = chunkdata+(lang_key-key);   text_ptr->lang = chunkdata+(lang-key);   text_ptr->itxt_length = data_len;   text_ptr->text_length = 0;   text_ptr->key = chunkdata;   text_ptr->text = chunkdata + prefix_len;   ret=png_set_text_2(png_ptr, info_ptr, text_ptr, 1);   png_free(png_ptr, text_ptr);   png_free(png_ptr, chunkdata);   if (ret)     png_error(png_ptr, \"Insufficient memory to store iTXt chunk.\");}#endif",
        "label": 1,
        "cve": "cve-2007-5629-3"
    },
    {
        "code": "static size_tsafe_read(png_structp png_ptr, int fd, void *buffer_in, size_t nbytes){   size_t ntotal = 0;   char *buffer = png_voidcast(char*, buffer_in);   while (nbytes > 0)   {      unsigned int nread;      int iread;            if (nbytes > INT_MAX)         nread = INT_MAX;      else         nread = (unsigned int)nbytes;      iread = read(fd, buffer, nread);      if (iread == -1)      {                  if (errno != EINTR)         {            png_warning(png_ptr, \"/proc read failed\");            return 0;          }      }      else if (iread < 0)      {                  png_warning(png_ptr, \"OS /proc read bug\");         return 0;      }      else if (iread > 0)      {                  buffer += iread;         nbytes -= (unsigned int)iread;         ntotal += (unsigned int)iread;      }      else         return ntotal;   }   return ntotal; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_16ilineara(int fixed_srgb, int alpha){   return u16d((257 * alpha) * sRGB_to_d[fixed_srgb]);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_default_ini(PNG_CONST image_transform *this,    transform_display *that){   this->next->ini(this->next, that);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGCBAPIpng_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length){   png_size_t check;   if (png_ptr == NULL)      return;      check = fread(data, 1, length, png_voidcast(png_FILE_p, png_ptr->io_ptr));   if (check != length)      png_error(png_ptr, \"Read Error\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIstore_flush(png_structp ppIn){   UNUSED(ppIn) }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intread_palette(store_palette palette, int *npalette, png_const_structp pp,   png_infop pi){   png_colorp pal;   png_bytep trans_alpha;   int num;   pal = 0;   *npalette = -1;   if (png_get_PLTE(pp, pi, &pal, npalette) & PNG_INFO_PLTE)   {      int i = *npalette;      if (i <= 0 || i > 256)         png_error(pp, \"validate: invalid PLTE count\");      while (--i >= 0)      {         palette[i].red = pal[i].red;         palette[i].green = pal[i].green;         palette[i].blue = pal[i].blue;      }            memset(palette + *npalette, 126, (256-*npalette) * sizeof *palette);   }   else    {      if (*npalette != (-1))         png_error(pp, \"validate: invalid PLTE result\");            *npalette = 0;      memset(palette, 113, sizeof (store_palette));   }   trans_alpha = 0;   num = 2;    if ((png_get_tRNS(pp, pi, &trans_alpha, &num, 0) & PNG_INFO_tRNS) != 0 &&      (trans_alpha != NULL || num != 1) &&            !(trans_alpha != NULL && num == 0))    {      int i;            if (trans_alpha == NULL || num <= 0 || num > 256 || num > *npalette)         png_error(pp, \"validate: unexpected png_get_tRNS (palette) result\");      for (i=0; i<num; ++i)         palette[i].alpha = trans_alpha[i];      for (num=*npalette; i<num; ++i)         palette[i].alpha = 255;      for (; i<256; ++i)         palette[i].alpha = 33;       return 1;    }   else   {            int i;      for (i=0, num=*npalette; i<num; ++i)         palette[i].alpha = 255;      for (; i<256; ++i)         palette[i].alpha = 55;       return 0;    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_background_mod(PNG_CONST image_transform *this,    image_pixel *that, png_const_structp pp,    PNG_CONST transform_display *display){      if (that->have_tRNS && that->colour_type != PNG_COLOR_TYPE_PALETTE)      image_pixel_add_alpha(that, &display->this);      if (that->alphaf < 1)   {            if (that->alphaf <= 0)      {         that->redf = data.redf;         that->greenf = data.greenf;         that->bluef = data.bluef;         that->rede = data.rede;         that->greene = data.greene;         that->bluee = data.bluee;         that->red_sBIT= data.red_sBIT;         that->green_sBIT= data.green_sBIT;         that->blue_sBIT= data.blue_sBIT;      }      else       {         double alf = 1 - that->alphaf;         that->redf = that->redf * that->alphaf + data.redf * alf;         that->rede = that->rede * that->alphaf + data.rede * alf +            DBL_EPSILON;         that->greenf = that->greenf * that->alphaf + data.greenf * alf;         that->greene = that->greene * that->alphaf + data.greene * alf +            DBL_EPSILON;         that->bluef = that->bluef * that->alphaf + data.bluef * alf;         that->bluee = that->bluee * that->alphaf + data.bluee * alf +            DBL_EPSILON;      }            that->alphaf = 1;      that->alphae = 0;      if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)         that->colour_type = PNG_COLOR_TYPE_RGB;      else if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)         that->colour_type = PNG_COLOR_TYPE_GRAY;         }   this->next->mod(this->next, that, pp, display);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intfind_parameters(png_const_charp what, png_charp param, png_charp *list,   int nparams){      int i;   for (i=0; *param && i<nparams; ++i)   {      list[i] = param;      while (*++param) if (*param == '\\n' || *param == ':')      {         *param++ = 0;          break;              }   }   if (*param)   {      fprintf(stderr, \"--insert %s: too many parameters (%s)\\n\", what, param);      exit(1);   }   list[i] = NULL;    return i; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_palette_to_rgb_set(PNG_CONST image_transform *this,    transform_display *that, png_structp pp, png_infop pi){   png_set_palette_to_rgb(pp);   this->next->set(this->next, that, pp, pi);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "doublefinvsRGB(unsigned int i){   return 65535 * linear_from_sRGB(i/255.);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidread_png(struct display *dp, struct buffer *bp, const char *operation,   int transforms){   png_structp pp;   png_infop   ip;      display_clean_read(dp);   if (operation != NULL)    {      dp->operation = operation;      dp->transforms = transforms;   }   dp->read_pp = pp = png_create_read_struct(PNG_LIBPNG_VER_STRING, dp,      display_error, display_warning);   if (pp == NULL)      display_log(dp, LIBPNG_ERROR, \"failed to create read struct\");      dp->read_ip = ip = png_create_info_struct(pp);   if (ip == NULL)      display_log(dp, LIBPNG_ERROR, \"failed to create info struct\");#  ifdef PNG_SET_USER_LIMITS_SUPPORTED            png_set_user_limits(pp, 0x7fffffff, 0x7fffffff);#  endif      buffer_start_read(bp);   png_set_read_fn(pp, bp, read_function);   png_read_png(pp, ip, transforms, NULL);#if 0    {      png_bytep pr = png_get_rows(pp, ip)[0];      size_t rb = png_get_rowbytes(pp, ip);      size_t cb;      char c = ' ';      fprintf(stderr, \"%.4x %2d (%3lu bytes):\", transforms, png_get_bit_depth(pp,ip), (unsigned long)rb);      for (cb=0; cb<rb; ++cb)         fputc(c, stderr), fprintf(stderr, \"%.2x\", pr[cb]), c='.';      fputc('\\n', stderr);   }#endif}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstandard_info_part1(standard_display *dp, png_structp pp, png_infop pi){   if (png_get_bit_depth(pp, pi) != dp->bit_depth)      png_error(pp, \"validate: bit depth changed\");   if (png_get_color_type(pp, pi) != dp->colour_type)      png_error(pp, \"validate: color type changed\");   if (png_get_filter_type(pp, pi) != PNG_FILTER_TYPE_BASE)      png_error(pp, \"validate: filter type changed\");   if (png_get_interlace_type(pp, pi) != dp->interlace_type)      png_error(pp, \"validate: interlacing changed\");   if (png_get_compression_type(pp, pi) != PNG_COMPRESSION_TYPE_BASE)      png_error(pp, \"validate: compression type changed\");   dp->w = png_get_image_width(pp, pi);   if (dp->w != standard_width(pp, dp->id))      png_error(pp, \"validate: image width changed\");   dp->h = png_get_image_height(pp, pi);   if (dp->h != standard_height(pp, dp->id))      png_error(pp, \"validate: image height changed\");      {      png_color_8p sBIT = 0;      if (png_get_sBIT(pp, pi, &sBIT) & PNG_INFO_sBIT)      {         int sBIT_invalid = 0;         if (sBIT == 0)            png_error(pp, \"validate: unexpected png_get_sBIT result\");         if (dp->colour_type & PNG_COLOR_MASK_COLOR)         {            if (sBIT->red == 0 || sBIT->red > dp->bit_depth)               sBIT_invalid = 1;            else               dp->red_sBIT = sBIT->red;            if (sBIT->green == 0 || sBIT->green > dp->bit_depth)               sBIT_invalid = 1;            else               dp->green_sBIT = sBIT->green;            if (sBIT->blue == 0 || sBIT->blue > dp->bit_depth)               sBIT_invalid = 1;            else               dp->blue_sBIT = sBIT->blue;         }         else          {            if (sBIT->gray == 0 || sBIT->gray > dp->bit_depth)               sBIT_invalid = 1;            else               dp->blue_sBIT = dp->green_sBIT = dp->red_sBIT = sBIT->gray;         }                  if (dp->colour_type & PNG_COLOR_MASK_ALPHA)         {            if (sBIT->alpha == 0 || sBIT->alpha > dp->bit_depth)               sBIT_invalid = 1;            else               dp->alpha_sBIT = sBIT->alpha;         }         if (sBIT_invalid)            png_error(pp, \"validate: sBIT value out of range\");      }   }      if (png_get_rowbytes(pp, pi) != standard_rowsize(pp, dp->id))      png_error(pp, \"validate: row size changed\");      standard_palette_validate(dp, pp, pi);      {      png_color_16p trans_color = 0;      if (png_get_tRNS(pp, pi, 0, 0, &trans_color) & PNG_INFO_tRNS)      {         if (trans_color == 0)            png_error(pp, \"validate: unexpected png_get_tRNS (color) result\");         switch (dp->colour_type)         {         case 0:            dp->transparent.red = dp->transparent.green = dp->transparent.blue =               trans_color->gray;            dp->is_transparent = 1;            break;         case 2:            dp->transparent.red = trans_color->red;            dp->transparent.green = trans_color->green;            dp->transparent.blue = trans_color->blue;            dp->is_transparent = 1;            break;         case 3:                        png_error(pp, \"validate: unexpected png_get_tRNS result\");            break;         default:            png_error(pp, \"validate: invalid tRNS chunk with alpha image\");         }      }   }      dp->npasses = npasses_from_interlace_type(pp, dp->interlace_type);   if (!dp->do_interlace && dp->npasses != png_set_interlace_handling(pp))      png_error(pp, \"validate: file changed interlace type\");   }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGAPIpng_read_png(png_structp png_ptr, png_infop info_ptr,                           int transforms,                           voidp params){   int row;   if(png_ptr == NULL) return;#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)      if (transforms & PNG_TRANSFORM_INVERT_ALPHA)       png_set_invert_alpha(png_ptr);#endif      png_read_info(png_ptr, info_ptr);   if (info_ptr->height > PNG_UINT_32_MAX/png_sizeof(png_bytep))      png_error(png_ptr,\"Image is too high to process with png_read_png()\");   #if defined(PNG_READ_16_TO_8_SUPPORTED)      if (transforms & PNG_TRANSFORM_STRIP_16)       png_set_strip_16(png_ptr);#endif#if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)      if (transforms & PNG_TRANSFORM_STRIP_ALPHA)       png_set_strip_alpha(png_ptr);#endif#if defined(PNG_READ_PACK_SUPPORTED) && !defined(PNG_READ_EXPAND_SUPPORTED)      if (transforms & PNG_TRANSFORM_PACKING)       png_set_packing(png_ptr);#endif#if defined(PNG_READ_PACKSWAP_SUPPORTED)      if (transforms & PNG_TRANSFORM_PACKSWAP)       png_set_packswap(png_ptr);#endif#if defined(PNG_READ_EXPAND_SUPPORTED)      if (transforms & PNG_TRANSFORM_EXPAND)       if ((png_ptr->bit_depth < 8) ||           (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ||           (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)))         png_set_expand(png_ptr);#endif   #if defined(PNG_READ_INVERT_SUPPORTED)      if (transforms & PNG_TRANSFORM_INVERT_MONO)       png_set_invert_mono(png_ptr);#endif#if defined(PNG_READ_SHIFT_SUPPORTED)      if ((transforms & PNG_TRANSFORM_SHIFT)       && png_get_valid(png_ptr, info_ptr, PNG_INFO_sBIT))   {      png_color_8p sig_bit;      png_get_sBIT(png_ptr, info_ptr, &sig_bit);      png_set_shift(png_ptr, sig_bit);   }#endif#if defined(PNG_READ_BGR_SUPPORTED)      if (transforms & PNG_TRANSFORM_BGR)       png_set_bgr(png_ptr);#endif#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED)      if (transforms & PNG_TRANSFORM_SWAP_ALPHA)       png_set_swap_alpha(png_ptr);#endif#if defined(PNG_READ_SWAP_SUPPORTED)      if (transforms & PNG_TRANSFORM_SWAP_ENDIAN)       png_set_swap(png_ptr);#endif         png_read_update_info(png_ptr, info_ptr);   #ifdef PNG_FREE_ME_SUPPORTED   png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);#endif   if(info_ptr->row_pointers == NULL)   {      info_ptr->row_pointers = (png_bytepp)png_malloc(png_ptr,         info_ptr->height * png_sizeof(png_bytep));#ifdef PNG_FREE_ME_SUPPORTED      info_ptr->free_me |= PNG_FREE_ROWS;#endif      for (row = 0; row < (int)info_ptr->height; row++)      {         info_ptr->row_pointers[row] = (png_bytep)png_malloc(png_ptr,            png_get_rowbytes(png_ptr, info_ptr));      }   }   png_read_image(png_ptr, info_ptr->row_pointers);   info_ptr->valid |= PNG_INFO_IDAT;      png_read_end(png_ptr, info_ptr);   transforms = transforms;    params = params;}#endif #endif #endif ",
        "label": 1,
        "cve": "cve-2004-0599-2"
    },
    {
        "code": "static intcompare_read(struct display *dp, int applied_transforms){      size_t rowbytes;   png_uint_32 width, height;   int bit_depth, color_type;   int interlace_method, compression_method, filter_method;   const char *e = NULL;   png_get_IHDR(dp->read_pp, dp->read_ip, &width, &height, &bit_depth,      &color_type, &interlace_method, &compression_method, &filter_method);#  define C(item) if (item != dp->item) \\      display_log(dp, APP_WARNING, \"IHDR \" #item \"(%lu) changed to %lu\",\\         (unsigned long)dp->item, (unsigned long)item), e = #item      C(width);   C(height);   C(bit_depth);   C(color_type);   C(interlace_method);   C(compression_method);   C(filter_method);      if (e)      display_log(dp, APP_ERROR, \"IHDR changed (%s)\", e);      {      unsigned long chunks =         png_get_valid(dp->read_pp, dp->read_ip, 0xffffffff);      if (chunks != dp->chunks)         display_log(dp, APP_FAIL, \"PNG chunks changed from 0x%lx to 0x%lx\",            (unsigned long)dp->chunks, chunks);   }      rowbytes = png_get_rowbytes(dp->read_pp, dp->read_ip);      if (rowbytes != dp->original_rowbytes)      display_log(dp, APP_ERROR, \"PNG rowbytes changed from %lu to %lu\",         (unsigned long)dp->original_rowbytes, (unsigned long)rowbytes);      {      png_bytepp rows = png_get_rows(dp->read_pp, dp->read_ip);      unsigned int mask;        if (bit_depth < 8)      {                  mask = 0xff & (0xff00 >> ((bit_depth * width) & 7));      }      else         mask = 0;      if (rows == NULL)         display_log(dp, LIBPNG_BUG, \"png_get_rows returned NULL\");      if ((applied_transforms & PNG_TRANSFORM_SHIFT) == 0 ||         (dp->active_transforms & PNG_TRANSFORM_SHIFT) == 0 ||         color_type == PNG_COLOR_TYPE_PALETTE)      {         unsigned long y;         for (y=0; y<height; ++y)         {            png_bytep row = rows[y];            png_bytep orig = dp->original_rows[y];            if (memcmp(row, orig, rowbytes-(mask != 0)) != 0 || (mask != 0 &&               ((row[rowbytes-1] & mask) != (orig[rowbytes-1] & mask))))            {               size_t x;                              for (x=0; x<rowbytes-1; ++x) if (row[x] != orig[x])                  break;               display_log(dp, APP_FAIL,                  \"byte(%lu,%lu) changed 0x%.2x -> 0x%.2x\",                  (unsigned long)x, (unsigned long)y, orig[x], row[x]);               return 0;             }         }      }      else      {         unsigned long y;         int bpp;                     png_byte sig_bits[8];         png_color_8p sBIT;         if (png_get_sBIT(dp->read_pp, dp->read_ip, &sBIT) != PNG_INFO_sBIT)            display_log(dp, INTERNAL_ERROR,               \"active shift transform but no sBIT in file\");         switch (color_type)         {            case PNG_COLOR_TYPE_GRAY:               sig_bits[0] = sBIT->gray;               bpp = bit_depth;               break;            case PNG_COLOR_TYPE_GA:               sig_bits[0] = sBIT->gray;               sig_bits[1] = sBIT->alpha;               bpp = 2 * bit_depth;               break;            case PNG_COLOR_TYPE_RGB:               sig_bits[0] = sBIT->red;               sig_bits[1] = sBIT->green;               sig_bits[2] = sBIT->blue;               bpp = 3 * bit_depth;               break;            case PNG_COLOR_TYPE_RGBA:               sig_bits[0] = sBIT->red;               sig_bits[1] = sBIT->green;               sig_bits[2] = sBIT->blue;               sig_bits[3] = sBIT->alpha;               bpp = 4 * bit_depth;               break;            default:               display_log(dp, LIBPNG_ERROR, \"invalid colour type %d\",                  color_type);                              bpp = 0;               break;         }         {            int b;            for (b=0; 8*b<bpp; ++b)            {                              if (sig_bits[b] == 0 || sig_bits[b] > bit_depth)                  display_log(dp, LIBPNG_BUG,                     \"invalid sBIT[%u]  value %d returned for PNG bit depth %d\",                     b, sig_bits[b], bit_depth);            }         }         if (bpp < 8 && bpp != bit_depth)         {                        display_log(dp, INTERNAL_ERROR, \"invalid bpp %u for bit_depth %u\",               bpp, bit_depth);         }         switch (bit_depth)         {            int b;            case 16:                for (b = (bpp >> 4); b > 0; )               {                  unsigned int sig = (unsigned int)(0xffff0000 >> sig_bits[b]);                  sig_bits[2*b+1] = (png_byte)sig;                  sig_bits[2*b+0] = (png_byte)(sig >> 8);                }               break;            case 8:                for (b=0; b*8 < bpp; ++b)                  sig_bits[b] = (png_byte)(0xff00 >> sig_bits[b]);               break;            case 1:                               sig_bits[0] = 0xff;               break;            case 2:                               b = 0x3 & ((0x3<<2) >> sig_bits[0]);               b |= b << 2;               b |= b << 4;               sig_bits[0] = (png_byte)b;               break;            case 4:                               b = 0xf & ((0xf << 4) >> sig_bits[0]);               b |= b << 4;               sig_bits[0] = (png_byte)b;               break;            default:               display_log(dp, LIBPNG_BUG, \"invalid bit depth %d\", bit_depth);               break;         }                  bpp = (bpp+7) >> 3;                  if (mask != 0)         {            mask &= sig_bits[0];            if (bpp != 1 || mask == 0)               display_log(dp, INTERNAL_ERROR, \"mask calculation error %u, %u\",                  bpp, mask);         }         for (y=0; y<height; ++y)         {            png_bytep row = rows[y];            png_bytep orig = dp->original_rows[y];            unsigned long x;            for (x=0; x<(width-(mask!=0)); ++x)            {               int b;               for (b=0; b<bpp; ++b)               {                  if ((*row++ & sig_bits[b]) != (*orig++ & sig_bits[b]))                  {                     display_log(dp, APP_FAIL,                        \"significant bits at (%lu[%u],%lu) changed %.2x->%.2x\",                        x, b, y, orig[-1], row[-1]);                     return 0;                  }               }            }            if (mask != 0 && (*row & mask) != (*orig & mask))            {               display_log(dp, APP_FAIL,                  \"significant bits at (%lu[end],%lu) changed\", x, y);               return 0;            }         }       }   }   return 1; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void wpng_cleanup(void){    if (wpng_info.outfile) {        fclose(wpng_info.outfile);        wpng_info.outfile = NULL;    }    if (wpng_info.infile) {        fclose(wpng_info.infile);        wpng_info.infile = NULL;    }    if (wpng_info.image_data) {        free(wpng_info.image_data);        wpng_info.image_data = NULL;    }    if (wpng_info.row_pointers) {        free(wpng_info.row_pointers);        wpng_info.row_pointers = NULL;    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgenerate_row(png_bytep row, size_t rowbytes, unsigned int y, int color_type,   int bit_depth, png_const_bytep gamma_table, double conv,   unsigned int *colors){   png_uint_32 size_max = image_size_of_type(color_type, bit_depth, colors)-1;   png_uint_32 depth_max = (1U << bit_depth)-1;    if (colors[0] == 0) switch (channels_of_type(color_type))   {         case 1:         {            png_uint_32 x;            png_uint_32 base = 2*size_max - abs(2*y-size_max);            for (x=0; x<=size_max; ++x)            {               png_uint_32 luma = base - abs(2*x-size_max);                              luma = (luma*depth_max + size_max) / (2*size_max);               set_value(row, rowbytes, x, bit_depth, luma, gamma_table, conv);            }         }         break;         case 2:         {            png_uint_32 alpha = (depth_max * y * 2 + size_max) / (2 * size_max);            png_uint_32 x;            for (x=0; x<=size_max; ++x)            {               set_value(row, rowbytes, 2*x, bit_depth,                  (depth_max * x * 2 + size_max) / (2 * size_max), gamma_table,                  conv);               set_value(row, rowbytes, 2*x+1, bit_depth, alpha, gamma_table,                  conv);            }         }         break;         case 3:         {                        png_uint_32 Y = (depth_max * y * 2 + size_max) / (2 * size_max);            png_uint_32 x;                        for (x=0; x<=size_max; ++x)            {               set_value(row, rowbytes, 3*x+0, bit_depth,  Y,                     gamma_table, conv);               set_value(row, rowbytes, 3*x+1, bit_depth,                   (depth_max * x * 2 + size_max) / (2 * size_max),                  gamma_table, conv);               set_value(row, rowbytes, 3*x+2, bit_depth,                   (Y * x * 2 + size_max) / (2 * size_max),                  gamma_table, conv);            }         }         break;         case 4:         {                        png_uint_32 Y = (depth_max * y * 2 + size_max) / (2 * size_max);            png_uint_32 x;                        for (x=0; x<=size_max; ++x)            {               set_value(row, rowbytes, 4*x+0, bit_depth,                   ((depth_max-Y) * x * 2 + size_max) / (2 * size_max),                  gamma_table, conv);               set_value(row, rowbytes, 4*x+1, bit_depth,                   (Y * x * 2 + size_max) / (2 * size_max),                  gamma_table, conv);               set_value(row, rowbytes, 4*x+2, bit_depth,                   Y - (Y * x * 2 + size_max) / (2 * size_max),                  gamma_table, conv);               set_value(row, rowbytes, 4*x+3, bit_depth,                   Y + ((depth_max-Y) * x * 2 + size_max) / (2 * size_max),                  gamma_table, conv);            }         }         break;      default:         fprintf(stderr, \"makepng: internal bad channel count\\n\");         exit(2);   }   else if (color_type & PNG_COLOR_MASK_PALETTE)   {            memset(row, 0, rowbytes);   }   else if (colors[0] == channels_of_type(color_type))      switch (channels_of_type(color_type))      {         case 1:            {               const png_uint_32 luma = colors[1];               png_uint_32 x;               for (x=0; x<=size_max; ++x)                  set_value(row, rowbytes, x, bit_depth, luma, gamma_table,                     conv);            }            break;         case 2:            {               const png_uint_32 luma = colors[1];               const png_uint_32 alpha = colors[2];               png_uint_32 x;               for (x=0; x<size_max; ++x)               {                  set_value(row, rowbytes, 2*x, bit_depth, luma, gamma_table,                     conv);                  set_value(row, rowbytes, 2*x+1, bit_depth, alpha, gamma_table,                     conv);               }            }            break;         case 3:            {               const png_uint_32 red = colors[1];               const png_uint_32 green = colors[2];               const png_uint_32 blue = colors[3];               png_uint_32 x;               for (x=0; x<=size_max; ++x)               {                  set_value(row, rowbytes, 3*x+0, bit_depth, red, gamma_table,                     conv);                  set_value(row, rowbytes, 3*x+1, bit_depth, green, gamma_table,                     conv);                  set_value(row, rowbytes, 3*x+2, bit_depth, blue, gamma_table,                     conv);               }            }            break;         case 4:            {               const png_uint_32 red = colors[1];               const png_uint_32 green = colors[2];               const png_uint_32 blue = colors[3];               const png_uint_32 alpha = colors[4];               png_uint_32 x;               for (x=0; x<=size_max; ++x)               {                  set_value(row, rowbytes, 4*x+0, bit_depth, red, gamma_table,                     conv);                  set_value(row, rowbytes, 4*x+1, bit_depth, green, gamma_table,                     conv);                  set_value(row, rowbytes, 4*x+2, bit_depth, blue, gamma_table,                     conv);                  set_value(row, rowbytes, 4*x+3, bit_depth, alpha, gamma_table,                     conv);               }            }         break;         default:            fprintf(stderr, \"makepng: internal bad channel count\\n\");            exit(2);      }   else   {      fprintf(stderr,         \"makepng: --color: count(%u) does not match channels(%u)\\n\",         colors[0], channels_of_type(color_type));      exit(1);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#if DIGITIZEstatic double digitize(double value, int depth, int do_round){      PNG_CONST unsigned int digitization_factor = (1U << depth) -1;      if (value <= 0)      value = 0;   else if (value >= 1)      value = 1;   value *= digitization_factor;   if (do_round) value += .5;   return floor(value)/digitization_factor;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidwrite_png(struct display *dp, png_infop ip, int transforms){   display_clean_write(dp);    buffer_start_write(&dp->written_file);   dp->operation = \"write\";   dp->transforms = transforms;   dp->write_pp = png_create_write_struct(PNG_LIBPNG_VER_STRING, dp,      display_error, display_warning);   if (dp->write_pp == NULL)      display_log(dp, APP_ERROR, \"failed to create write png_struct\");   png_set_write_fn(dp->write_pp, &dp->written_file, write_function,      NULL);#  ifdef PNG_SET_USER_LIMITS_SUPPORTED            png_set_user_limits(dp->write_pp, 0x7fffffff, 0x7fffffff);#  endif      if (transforms & (PNG_TRANSFORM_PACKING|                     PNG_TRANSFORM_STRIP_FILLER|                     PNG_TRANSFORM_STRIP_FILLER_BEFORE))   {      int ct = dp->color_type;      if (transforms & (PNG_TRANSFORM_STRIP_FILLER|                        PNG_TRANSFORM_STRIP_FILLER_BEFORE))         ct &= ~PNG_COLOR_MASK_ALPHA;      png_set_IHDR(dp->write_pp, ip, dp->width, dp->height, dp->bit_depth, ct,         dp->interlace_method, dp->compression_method, dp->filter_method);   }   png_write_png(dp->write_pp, ip, transforms, NULL);      display_clean_write(dp);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "BOOL CenterAbout (HWND hwndChild, HWND hwndParent){   RECT    rChild, rParent, rWorkArea;   int     wChild, hChild, wParent, hParent;   int     xNew, yNew;   BOOL  bResult;      GetWindowRect (hwndChild, &rChild);   wChild = rChild.right - rChild.left;   hChild = rChild.bottom - rChild.top;      GetWindowRect (hwndParent, &rParent);   wParent = rParent.right - rParent.left;   hParent = rParent.bottom - rParent.top;      bResult = SystemParametersInfo(      SPI_GETWORKAREA,        sizeof(RECT),      &rWorkArea,      0);   if (!bResult) {      rWorkArea.left = rWorkArea.top = 0;      rWorkArea.right = GetSystemMetrics(SM_CXSCREEN);      rWorkArea.bottom = GetSystemMetrics(SM_CYSCREEN);   }      xNew = rParent.left + ((wParent - wChild) /2);   if (xNew < rWorkArea.left) {      xNew = rWorkArea.left;   } else if ((xNew+wChild) > rWorkArea.right) {      xNew = rWorkArea.right - wChild;   }      yNew = rParent.top  + ((hParent - hChild) /2);   if (yNew < rWorkArea.top) {      yNew = rWorkArea.top;   } else if ((yNew+hChild) > rWorkArea.bottom) {      yNew = rWorkArea.bottom - hChild;   }      return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE |          SWP_NOZORDER);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intpixel_cmp(png_const_bytep pa, png_const_bytep pb, png_uint_32 bit_width){#if PNG_LIBPNG_VER < 10506   if (memcmp(pa, pb, bit_width>>3) == 0)   {      png_uint_32 p;      if ((bit_width & 7) == 0) return 0;            p = pa[bit_width >> 3];      p ^= pb[bit_width >> 3];      if (p == 0) return 0;            bit_width &= 7;      p >>= 8-bit_width;      if (p == 0) return 0;   }#else      if (memcmp(pa, pb, (bit_width+7)>>3) == 0)      return 0;#endif      {      png_uint_32 where = 0;      while (pa[where] == pb[where]) ++where;      return 1+where;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int readpng2_decode_data(mainprog_info *mainprog_ptr, uch *rawbuf, ulg length){    png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr;    png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr;        if (setjmp(mainprog_ptr->jmpbuf)) {        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);        mainprog_ptr->png_ptr = NULL;        mainprog_ptr->info_ptr = NULL;        return 2;    }        png_process_data(png_ptr, info_ptr, rawbuf, length);    return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "BOOL pnm2png (FILE *pnm_file, FILE *png_file, FILE *alpha_file, BOOL interlace,     BOOL alpha){  png_struct    *png_ptr = NULL;  png_info      *info_ptr = NULL;  png_byte      *png_pixels = NULL;  png_byte      **row_pointers = NULL;  png_byte      *pix_ptr = NULL;  volatile png_uint_32   row_bytes;  char          type_token[16];  char          width_token[16];  char          height_token[16];  char          maxval_token[16];  volatile int           color_type;  unsigned long   ul_width=0, ul_alpha_width=0;  unsigned long   ul_height=0, ul_alpha_height=0;  unsigned long   ul_maxval=0;  volatile png_uint_32   width, height;  volatile png_uint_32   alpha_width, alpha_height;  png_uint_32   maxval;  volatile int           bit_depth = 0;  int           channels;  int           alpha_depth = 0;  int           alpha_present;  int           row, col;  BOOL          raw, alpha_raw = FALSE;#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)  BOOL          packed_bitmap = FALSE;#endif  png_uint_32   tmp16;  int           i;    get_token(pnm_file, type_token);  if (type_token[0] != 'P')  {    return FALSE;  }  else if ((type_token[1] == '1') || (type_token[1] == '4'))  {#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)    raw = (type_token[1] == '4');    color_type = PNG_COLOR_TYPE_GRAY;    get_token(pnm_file, width_token);    sscanf (width_token, \"%lu\", &ul_width);    width = (png_uint_32) ul_width;    get_token(pnm_file, height_token);    sscanf (height_token, \"%lu\", &ul_height);    height = (png_uint_32) ul_height;    bit_depth = 1;    packed_bitmap = TRUE;#else    fprintf (stderr, \"PNM2PNG built without PNG_WRITE_INVERT_SUPPORTED and \\n\");    fprintf (stderr, \"PNG_WRITE_PACK_SUPPORTED can't read PBM (P1,P4) files\\n\");#endif  }  else if ((type_token[1] == '2') || (type_token[1] == '5'))  {    raw = (type_token[1] == '5');    color_type = PNG_COLOR_TYPE_GRAY;    get_token(pnm_file, width_token);    sscanf (width_token, \"%lu\", &ul_width);    width = (png_uint_32) ul_width;    get_token(pnm_file, height_token);    sscanf (height_token, \"%lu\", &ul_height);    height = (png_uint_32) ul_height;    get_token(pnm_file, maxval_token);    sscanf (maxval_token, \"%lu\", &ul_maxval);    maxval = (png_uint_32) ul_maxval;    if (maxval <= 1)      bit_depth = 1;    else if (maxval <= 3)      bit_depth = 2;    else if (maxval <= 15)      bit_depth = 4;    else if (maxval <= 255)      bit_depth = 8;    else       bit_depth = 16;  }  else if ((type_token[1] == '3') || (type_token[1] == '6'))  {    raw = (type_token[1] == '6');    color_type = PNG_COLOR_TYPE_RGB;    get_token(pnm_file, width_token);    sscanf (width_token, \"%lu\", &ul_width);    width = (png_uint_32) ul_width;    get_token(pnm_file, height_token);    sscanf (height_token, \"%lu\", &ul_height);    height = (png_uint_32) ul_height;    get_token(pnm_file, maxval_token);    sscanf (maxval_token, \"%lu\", &ul_maxval);    maxval = (png_uint_32) ul_maxval;    if (maxval <= 1)      bit_depth = 1;    else if (maxval <= 3)      bit_depth = 2;    else if (maxval <= 15)      bit_depth = 4;    else if (maxval <= 255)      bit_depth = 8;    else       bit_depth = 16;  }  else  {    return FALSE;  }    if (alpha)  {    if (color_type == PNG_COLOR_TYPE_GRAY)      color_type = PNG_COLOR_TYPE_GRAY_ALPHA;    if (color_type == PNG_COLOR_TYPE_RGB)      color_type = PNG_COLOR_TYPE_RGB_ALPHA;    get_token(alpha_file, type_token);    if (type_token[0] != 'P')    {      return FALSE;    }    else if ((type_token[1] == '2') || (type_token[1] == '5'))    {      alpha_raw = (type_token[1] == '5');      get_token(alpha_file, width_token);      sscanf (width_token, \"%lu\", &ul_alpha_width);      alpha_width=(png_uint_32) ul_alpha_width;      if (alpha_width != width)        return FALSE;      get_token(alpha_file, height_token);      sscanf (height_token, \"%lu\", &ul_alpha_height);      alpha_height = (png_uint_32) ul_alpha_height;      if (alpha_height != height)        return FALSE;      get_token(alpha_file, maxval_token);      sscanf (maxval_token, \"%lu\", &ul_maxval);      maxval = (png_uint_32) ul_maxval;      if (maxval <= 1)        alpha_depth = 1;      else if (maxval <= 3)        alpha_depth = 2;      else if (maxval <= 15)        alpha_depth = 4;      else if (maxval <= 255)        alpha_depth = 8;      else         alpha_depth = 16;      if (alpha_depth != bit_depth)        return FALSE;    }    else    {      return FALSE;    }  }     if (color_type == PNG_COLOR_TYPE_GRAY)    channels = 1;  else if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)    channels = 2;  else if (color_type == PNG_COLOR_TYPE_RGB)    channels = 3;  else if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)    channels = 4;  else    channels = 0;   alpha_present = (channels - 1) % 2;#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)  if (packed_bitmap)        row_bytes = (width * channels * bit_depth + 7) / 8;  else#endif        row_bytes = width * channels * ((bit_depth <= 8) ? 1 : 2);  if ((png_pixels = (png_byte *)     malloc (row_bytes * height * sizeof (png_byte))) == NULL)    return FALSE;    pix_ptr = png_pixels;  for (row = 0; row < (int) height; row++)  {#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)    if (packed_bitmap) {      for (i = 0; i < (int) row_bytes; i++)                *pix_ptr++ = get_data (pnm_file, 8);    } else#endif    {      for (col = 0; col < (int) width; col++)      {        for (i = 0; i < (channels - alpha_present); i++)        {          if (raw)            *pix_ptr++ = get_data (pnm_file, bit_depth);          else            if (bit_depth <= 8)              *pix_ptr++ = get_value (pnm_file, bit_depth);            else            {              tmp16 = get_value (pnm_file, bit_depth);              *pix_ptr = (png_byte) ((tmp16 >> 8) & 0xFF);              pix_ptr++;              *pix_ptr = (png_byte) (tmp16 & 0xFF);              pix_ptr++;            }        }        if (alpha)         {          if (alpha_raw)            *pix_ptr++ = get_data (alpha_file, alpha_depth);          else            if (alpha_depth <= 8)              *pix_ptr++ = get_value (alpha_file, bit_depth);            else            {              tmp16 = get_value (alpha_file, bit_depth);              *pix_ptr++ = (png_byte) ((tmp16 >> 8) & 0xFF);              *pix_ptr++ = (png_byte) (tmp16 & 0xFF);            }        }       }     }   }     png_ptr = png_create_write_struct (png_get_libpng_ver(NULL), NULL, NULL,      NULL);  if (!png_ptr)  {    return FALSE;  }  info_ptr = png_create_info_struct (png_ptr);  if (!info_ptr)  {    png_destroy_write_struct (&png_ptr, (png_infopp) NULL);    return FALSE;  }#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)  if (packed_bitmap == TRUE)  {    png_set_packing (png_ptr);    png_set_invert_mono (png_ptr);  }#endif    if (setjmp (png_jmpbuf(png_ptr)))  {    png_destroy_write_struct (&png_ptr, (png_infopp) NULL);    return FALSE;  }    png_init_io (png_ptr, png_file);    png_set_IHDR (png_ptr, info_ptr, width, height, bit_depth, color_type,    (!interlace) ? PNG_INTERLACE_NONE : PNG_INTERLACE_ADAM7,    PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);    png_write_info (png_ptr, info_ptr);    if (row_pointers == (unsigned char**) NULL)  {    if ((row_pointers = (png_byte **)        malloc (height * sizeof (png_bytep))) == NULL)    {      png_destroy_write_struct (&png_ptr, (png_infopp) NULL);      return FALSE;    }  }    for (i = 0; i < (int) height; i++)    row_pointers[i] = png_pixels + i * row_bytes;    png_write_image (png_ptr, row_pointers);    png_write_end (png_ptr, info_ptr);    png_destroy_write_struct (&png_ptr, (png_infopp) NULL);  if (row_pointers != (unsigned char**) NULL)    free (row_pointers);  if (png_pixels != (unsigned char*) NULL)    free (png_pixels);  return TRUE;} ",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intrandom_choice(void){   unsigned char x;   RANDOMIZE(x);   return x & 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidIDAT_end(struct IDAT **idat_var){   struct IDAT *idat = *idat_var;   struct file *file = idat->file;   *idat_var = NULL;   CLEAR(*idat);   assert(file->chunk != NULL);   chunk_end(&file->chunk);      file->state = STATE_CHUNKS;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcheck(FILE *fp, int argc, const char **argv, png_uint_32p flags,   display *d, int set_callback){   int i, npasses, ipass;   png_uint_32 height;   d->keep = PNG_HANDLE_CHUNK_AS_DEFAULT;   d->before_IDAT = 0;   d->after_IDAT = 0;      d->png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, d, error,      warning);   if (d->png_ptr == NULL)   {      fprintf(stderr, \"%s(%s): could not allocate png struct\\n\", d->file,         d->test);            exit(1);   }   d->info_ptr = png_create_info_struct(d->png_ptr);   d->end_ptr = png_create_info_struct(d->png_ptr);   if (d->info_ptr == NULL || d->end_ptr == NULL)   {      fprintf(stderr, \"%s(%s): could not allocate png info\\n\", d->file,         d->test);      clean_display(d);      exit(1);   }   png_init_io(d->png_ptr, fp);#  ifdef PNG_READ_USER_CHUNKS_SUPPORTED            if (set_callback)         png_set_read_user_chunk_fn(d->png_ptr, d, read_callback);#  else      UNUSED(set_callback)#  endif      for (i=0; i<argc; ++i)   {      const char *equals = strchr(argv[i], '=');      if (equals != NULL)      {         int chunk, option;         if (strcmp(equals+1, \"default\") == 0)            option = PNG_HANDLE_CHUNK_AS_DEFAULT;         else if (strcmp(equals+1, \"discard\") == 0)            option = PNG_HANDLE_CHUNK_NEVER;         else if (strcmp(equals+1, \"if-safe\") == 0)            option = PNG_HANDLE_CHUNK_IF_SAFE;         else if (strcmp(equals+1, \"save\") == 0)            option = PNG_HANDLE_CHUNK_ALWAYS;         else         {            fprintf(stderr, \"%s(%s): %s: unrecognized chunk option\\n\", d->file,               d->test, argv[i]);            display_exit(d);         }         switch (equals - argv[i])         {            case 4:                chunk = find(argv[i]);               if (chunk >= 0)               {                                    png_byte name[5];                  memcpy(name, chunk_info[chunk].name, 5);                  png_set_keep_unknown_chunks(d->png_ptr, option, name, 1);                  chunk_info[chunk].keep = option;                  continue;               }               break;            case 7:                if (memcmp(argv[i], \"default\", 7) == 0)               {                  png_set_keep_unknown_chunks(d->png_ptr, option, NULL, 0);                  d->keep = option;                  continue;               }               break;            case 3:                if (memcmp(argv[i], \"all\", 3) == 0)               {                  png_set_keep_unknown_chunks(d->png_ptr, option, NULL, -1);                  d->keep = option;                  for (chunk = 0; chunk < NINFO; ++chunk)                     if (chunk_info[chunk].all)                        chunk_info[chunk].keep = option;                  continue;               }               break;            default:                break;         }      }      fprintf(stderr, \"%s(%s): %s: unrecognized chunk argument\\n\", d->file,         d->test, argv[i]);      display_exit(d);   }   png_read_info(d->png_ptr, d->info_ptr);   switch (png_get_interlace_type(d->png_ptr, d->info_ptr))   {      case PNG_INTERLACE_NONE:         npasses = 1;         break;      case PNG_INTERLACE_ADAM7:         npasses = PNG_INTERLACE_ADAM7_PASSES;         break;      default:                  fprintf(stderr, \"%s(%s): invalid interlace type\\n\", d->file, d->test);         clean_display(d);         exit(1);   }      if (chunk_info[0].keep == PNG_HANDLE_CHUNK_AS_DEFAULT)   {      png_start_read_image(d->png_ptr);      height = png_get_image_height(d->png_ptr, d->info_ptr);      if (npasses > 1)      {         png_uint_32 width = png_get_image_width(d->png_ptr, d->info_ptr);         for (ipass=0; ipass<npasses; ++ipass)         {            png_uint_32 wPass = PNG_PASS_COLS(width, ipass);            if (wPass > 0)            {               png_uint_32 y;               for (y=0; y<height; ++y) if (PNG_ROW_IN_INTERLACE_PASS(y, ipass))                  png_read_row(d->png_ptr, NULL, NULL);            }         }      }       else       {         png_uint_32 y;         for (y=0; y<height; ++y)            png_read_row(d->png_ptr, NULL, NULL);      }   }   png_read_end(d->png_ptr, d->end_ptr);   flags[0] = get_valid(d, d->info_ptr);   flags[1] = get_unknown(d, d->info_ptr, 0);      flags[chunk_info[0].keep != PNG_HANDLE_CHUNK_AS_DEFAULT] |=      PNG_INFO_IDAT;   flags[2] = get_valid(d, d->end_ptr);   flags[3] = get_unknown(d, d->end_ptr, 1);   clean_display(d);   return d->keep;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_read_reset(png_store *ps){#  ifdef PNG_READ_SUPPORTED      if (ps->pread != NULL)      {         anon_context(ps);         Try            png_destroy_read_struct(&ps->pread, &ps->piread, NULL);         Catch_anonymous         {                     }         ps->pread = NULL;         ps->piread = NULL;      }#  endif#  ifdef PNG_USER_MEM_SUPPORTED            store_pool_delete(ps, &ps->read_memory_pool);#  endif   ps->current = NULL;   ps->next = NULL;   ps->readpos = 0;   ps->validated = 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intimage_transform_default_add(image_transform *this,    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth){   UNUSED(colour_type)   UNUSED(bit_depth)   this->next = *that;   *that = this;   return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_nop8(Pixel *out, const Pixel *in, const Background *back){   (void)back;   if (in->a == 0)      out->r = out->g = out->b = 255;   else   {      out->r = in->r;      out->g = in->g;      out->b = in->b;   }   out->a = in->a;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIstandard_info(png_structp pp, png_infop pi){   standard_display *dp = voidcast(standard_display*,      png_get_progressive_ptr(pp));      standard_info_imp(dp, pp, pi, 1 );}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32standard_height(png_const_structp pp, png_uint_32 id){   png_uint_32 height = HEIGHT_FROM_ID(id);   if (height == 0)      height = transform_height(pp, COL_FROM_ID(id), DEPTH_FROM_ID(id));   return height;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidsrgb_modification_init(srgb_modification *me, png_modifier *pm, png_byte intent){   modification_init(&me->this);   me->this.chunk = CHUNK_sBIT;   if (intent <= 3)    {      me->this.modify_fn = srgb_modify;      me->this.add = CHUNK_PLTE;      me->intent = intent;   }   else   {      me->this.modify_fn = 0;      me->this.add = 0;      me->intent = 0;   }   me->this.next = pm->modifications;   pm->modifications = &me->this;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidzlib_end(struct zlib *zlib){      if (!zlib->global->quiet)   {      if (zlib->ok_bits < 16)       {         const char *reason;         if (zlib->cksum)            reason = \"CHK\";          else if (zlib->ok_bits > zlib->file_bits)            reason = \"TFB\";          else if (zlib->ok_bits == zlib->file_bits)            reason = \"OK \";         else            reason = \"OPT\";                   type_name(zlib->chunk->chunk_type, stdout);         printf(\" %s %s %d %d \", reason, zlib_flevel(zlib), zlib->file_bits,            zlib->ok_bits);         uarb_print(zlib->compressed_bytes, zlib->compressed_digits, stdout);         putc(' ', stdout);         uarb_print(zlib->uncompressed_bytes, zlib->uncompressed_digits,            stdout);         putc(' ', stdout);         fputs(zlib->file->file_name, stdout);         putc('\\n', stdout);      }      else      {                  type_name(zlib->chunk->chunk_type, stdout);         printf(\" SKP %s %d %s \", zlib_flevel(zlib), zlib->file_bits,            zlib_rc(zlib));         uarb_print(zlib->compressed_bytes, zlib->compressed_digits, stdout);         putc(' ', stdout);         emit_string(zlib->z.msg ? zlib->z.msg : \"[no_message]\", stdout);         putc(' ', stdout);         fputs(zlib->file->file_name, stdout);         putc('\\n', stdout);      }   }   if (zlib->state >= 0)   {      zlib->rc = inflateEnd(&zlib->z);      if (zlib->rc != Z_OK)         zlib_message(zlib, 1);   }   CLEAR(*zlib);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void rpng_win_cleanup(){    if (image_data) {        free(image_data);        image_data = NULL;    }    if (dib) {        free(dib);        dib = NULL;    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_pool_mark(png_bytep mark){   static png_uint_32 store_seed[2] = { 0x12345678, 1};   make_four_random_bytes(store_seed, mark);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstandard_row(png_const_structp pp, png_byte std[STANDARD_ROWMAX],   png_uint_32 id, png_uint_32 y){   if (WIDTH_FROM_ID(id) == 0)      transform_row(pp, std, COL_FROM_ID(id), DEPTH_FROM_ID(id), y);   else      size_row(std, WIDTH_FROM_ID(id) * bit_size(pp, COL_FROM_ID(id),         DEPTH_FROM_ID(id)), y);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidallocbuffer(Image *image){   png_size_t size = PNG_IMAGE_BUFFER_SIZE(image->image, image->stride);   if (size+32 > image->bufsize)   {      freebuffer(image);      image->buffer = voidcast(png_bytep, malloc(size+32));      if (image->buffer == NULL)      {         fflush(stdout);         fprintf(stderr,            \"simpletest: out of memory allocating %lu(+32) byte buffer\\n\",            (unsigned long)size);         exit(1);      }      image->bufsize = size+32;   }   memset(image->buffer, 95, image->bufsize);   memset(image->buffer+16, BUFFER_INIT8, size);   image->allocsize = size;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void get_token(FILE *pnm_file, char *token){  int i = 0;  int ret;    do  {    ret = fgetc(pnm_file);    if (ret == '#') {            do      {        ret = fgetc(pnm_file);      }      while ((ret != '\\n') && (ret != '\\r') && (ret != EOF));    }    if (ret == EOF) break;    token[i] = (unsigned char) ret;  }  while ((token[i] == '\\n') || (token[i] == '\\r') || (token[i] == ' '));    do  {    ret = fgetc(pnm_file);    if (ret == EOF) break;    i++;    token[i] = (unsigned char) ret;  }  while ((token[i] != '\\n') && (token[i] != '\\r') && (token[i] != ' '));  token[i] = '\\0';  return;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static unsigned intrandom_mod(unsigned int max){   unsigned int x;   RANDOMIZE(x);   return x % max; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static unsigned intmodifier_total_encodings(PNG_CONST png_modifier *pm){   return 1 +                       pm->ngammas +                 pm->nencodings +                    ((pm->bit_depth == 16 || pm->assume_16_bit_calculations) ?         pm->nencodings : 0); }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32png_pass_rows(png_uint_32 height, int pass){   png_uint_32 tiles = height>>3;   png_uint_32 rows = 0;   unsigned int x, y;   height &= 7;   ++pass;   for (y=0; y<8; ++y) for (x=0; x<8; ++x) if (adam7[y][x] == pass)   {      rows += tiles;      if (y < height) ++rows;      break;    }   return rows;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static unsigned intimage_size_of_type(int color_type, int bit_depth, unsigned int *colors){   if (*colors)      return 16;   else   {      int pixel_depth = pixel_depth_of_type(color_type, bit_depth);      if (pixel_depth < 8)         return 64;      else if (pixel_depth > 16)         return 1024;      else         return 256;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int output_quantization_factor(PNG_CONST png_modifier *pm, int in_depth,   int out_depth){   if (out_depth == 16 && in_depth != 16 &&      pm->calculations_use_input_precision)      return 257;   else      return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgamma_info_imp(gamma_display *dp, png_structp pp, png_infop pi){      standard_info_part1(&dp->this, pp, pi);      if (dp->scale16)#     ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED         png_set_scale_16(pp);#     else         #        ifdef PNG_READ_16_TO_8_SUPPORTED            png_set_strip_16(pp);#        else            png_error(pp, \"scale16 (16 to 8 bit conversion) not supported\");#        endif#     endif   if (dp->expand16)#     ifdef PNG_READ_EXPAND_16_SUPPORTED         png_set_expand_16(pp);#     else         png_error(pp, \"expand16 (8 to 16 bit conversion) not supported\");#     endif   if (dp->do_background >= ALPHA_MODE_OFFSET)   {#     ifdef PNG_READ_ALPHA_MODE_SUPPORTED      {                  int mode = dp->do_background - ALPHA_MODE_OFFSET;                  PNG_CONST double sg = dp->screen_gamma;#        ifndef PNG_FLOATING_POINT_SUPPORTED            PNG_CONST png_fixed_point g = fix(sg);#        endif#        ifdef PNG_FLOATING_POINT_SUPPORTED            png_set_alpha_mode(pp, mode, sg);#        else            png_set_alpha_mode_fixed(pp, mode, g);#        endif                  if (mode == PNG_ALPHA_STANDARD && sg != 1)         {#           ifdef PNG_FLOATING_POINT_SUPPORTED               png_set_gamma(pp, sg, dp->file_gamma);#           else               png_fixed_point f = fix(dp->file_gamma);               png_set_gamma_fixed(pp, g, f);#           endif         }      }#     else         png_error(pp, \"alpha mode handling not supported\");#     endif   }   else   {      #     ifdef PNG_FLOATING_POINT_SUPPORTED         png_set_gamma(pp, dp->screen_gamma, dp->file_gamma);#     else      {         png_fixed_point s = fix(dp->screen_gamma);         png_fixed_point f = fix(dp->file_gamma);         png_set_gamma_fixed(pp, s, f);      }#     endif      if (dp->do_background)      {#     ifdef PNG_READ_BACKGROUND_SUPPORTED                  PNG_CONST double bg = dp->background_gamma;#        ifndef PNG_FLOATING_POINT_SUPPORTED            PNG_CONST png_fixed_point g = fix(bg);#        endif#        ifdef PNG_FLOATING_POINT_SUPPORTED            png_set_background(pp, &dp->background_color, dp->do_background,               0, bg);#        else            png_set_background_fixed(pp, &dp->background_color,               dp->do_background, 0, g);#        endif#     else         png_error(pp, \"png_set_background not supported\");#     endif      }   }   {      int i = dp->this.use_update_info;            do         png_read_update_info(pp, pi);      while (--i > 0);   }      standard_info_part2(&dp->this, pp, pi, 1 );}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidinit_standard_palette(png_store *ps, png_structp pp, png_infop pi, int npalette,   int do_tRNS){   store_palette_entry *ppal = make_standard_palette(ps, npalette, do_tRNS);   {      int i;      png_color palette[256];            for (i=0; i<npalette; ++i)      {         palette[i].red = ppal[i].red;         palette[i].green = ppal[i].green;         palette[i].blue = ppal[i].blue;      }            for (; i<256; ++i)         palette[i].red = palette[i].green = palette[i].blue = 42;      png_set_PLTE(pp, pi, palette, npalette);   }   if (do_tRNS)   {      int i, j;      png_byte tRNS[256];            for (i=j=0; i<npalette; ++i)         if ((tRNS[i] = ppal[i].alpha) < 255)            j = i+1;            for (; i<256; ++i)         tRNS[i] = 24;#  ifdef PNG_WRITE_tRNS_SUPPORTED         if (j > 0)            png_set_tRNS(pp, pi, tRNS, j, 0);#  endif   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_rgb_to_gray_mod(PNG_CONST image_transform *this,    image_pixel *that, png_const_structp pp,    PNG_CONST transform_display *display){   if ((that->colour_type & PNG_COLOR_MASK_COLOR) != 0)   {      double gray, err;      if (that->colour_type == PNG_COLOR_TYPE_PALETTE)         image_pixel_convert_PLTE(that);      #  if DIGITIZE      {         PNG_CONST png_modifier *pm = display->pm;         const unsigned int sample_depth = that->sample_depth;         const unsigned int calc_depth = (pm->assume_16_bit_calculations ? 16 :            sample_depth);         const unsigned int gamma_depth = (sample_depth == 16 ? 16 :            (pm->assume_16_bit_calculations ? PNG_MAX_GAMMA_8 : sample_depth));         int isgray;         double r, g, b;         double rlo, rhi, glo, ghi, blo, bhi, graylo, grayhi;                  r = rlo = rhi = that->redf;         rlo -= that->rede;         rlo = digitize(rlo, calc_depth, 1);         rhi += that->rede;         rhi = digitize(rhi, calc_depth, 1);         g = glo = ghi = that->greenf;         glo -= that->greene;         glo = digitize(glo, calc_depth, 1);         ghi += that->greene;         ghi = digitize(ghi, calc_depth, 1);         b = blo = bhi = that->bluef;         blo -= that->bluee;         blo = digitize(blo, calc_depth, 1);         bhi += that->greene;         bhi = digitize(bhi, calc_depth, 1);         isgray = r==g && g==b;         if (data.gamma != 1)         {            PNG_CONST double power = 1/data.gamma;            PNG_CONST double abse = calc_depth == 16 ? .5/65535 : .5/255;                        r = pow(r, power);            rlo = digitize(pow(rlo, power)-abse, calc_depth, 1);            rhi = digitize(pow(rhi, power)+abse, calc_depth, 1);            g = pow(g, power);            glo = digitize(pow(glo, power)-abse, calc_depth, 1);            ghi = digitize(pow(ghi, power)+abse, calc_depth, 1);            b = pow(b, power);            blo = digitize(pow(blo, power)-abse, calc_depth, 1);            bhi = digitize(pow(bhi, power)+abse, calc_depth, 1);         }                  gray = r * data.red_coefficient + g * data.green_coefficient +            b * data.blue_coefficient;         {            PNG_CONST int do_round = data.gamma != 1 || calc_depth == 16;            PNG_CONST double ce = 1. / 32768;            graylo = digitize(rlo * (data.red_coefficient-ce) +               glo * (data.green_coefficient-ce) +               blo * (data.blue_coefficient-ce), gamma_depth, do_round);            if (graylo <= 0)               graylo = 0;            grayhi = digitize(rhi * (data.red_coefficient+ce) +               ghi * (data.green_coefficient+ce) +               bhi * (data.blue_coefficient+ce), gamma_depth, do_round);            if (grayhi >= 1)               grayhi = 1;         }                  if (data.gamma != 1)         {            PNG_CONST double power = data.gamma;            gray = pow(gray, power);            graylo = digitize(pow(graylo, power), sample_depth, 1);            grayhi = digitize(pow(grayhi, power), sample_depth, 1);         }                  if (isgray)            err = (that->rede + that->greene + that->bluee)/3;         else         {            err = fabs(grayhi-gray);            if (fabs(gray - graylo) > err)               err = fabs(graylo-gray);                        if (err > pm->limit)            {               size_t pos = 0;               char buffer[128];               pos = safecat(buffer, sizeof buffer, pos, \"rgb_to_gray error \");               pos = safecatd(buffer, sizeof buffer, pos, err, 6);               pos = safecat(buffer, sizeof buffer, pos, \" exceeds limit \");               pos = safecatd(buffer, sizeof buffer, pos, pm->limit, 6);               png_error(pp, buffer);            }         }      }#  else        {         double r = that->redf;         double re = that->rede;         double g = that->greenf;         double ge = that->greene;         double b = that->bluef;         double be = that->bluee;                  if (r == g && r == b)         {            gray = r;            err = re;            if (err < ge) err = ge;            if (err < be) err = be;         }         else if (data.gamma == 1)         {                        gray = r * data.red_coefficient + g * data.green_coefficient +               b * data.blue_coefficient;            err = re * data.red_coefficient + ge * data.green_coefficient +               be * data.blue_coefficient + 1./32768 + gray * 5 * DBL_EPSILON;         }         else         {                        PNG_CONST png_modifier *pm = display->pm;            double in_qe = (that->sample_depth > 8 ? .5/65535 : .5/255);            double out_qe = (that->sample_depth > 8 ? .5/65535 :               (pm->assume_16_bit_calculations ? .5/(1<<PNG_MAX_GAMMA_8) :               .5/255));            double rhi, ghi, bhi, grayhi;            double g1 = 1/data.gamma;            rhi = r + re + in_qe; if (rhi > 1) rhi = 1;            r -= re + in_qe; if (r < 0) r = 0;            ghi = g + ge + in_qe; if (ghi > 1) ghi = 1;            g -= ge + in_qe; if (g < 0) g = 0;            bhi = b + be + in_qe; if (bhi > 1) bhi = 1;            b -= be + in_qe; if (b < 0) b = 0;            r = pow(r, g1)*(1-DBL_EPSILON); rhi = pow(rhi, g1)*(1+DBL_EPSILON);            g = pow(g, g1)*(1-DBL_EPSILON); ghi = pow(ghi, g1)*(1+DBL_EPSILON);            b = pow(b, g1)*(1-DBL_EPSILON); bhi = pow(bhi, g1)*(1+DBL_EPSILON);                        gray = r * data.red_coefficient + g * data.green_coefficient +               b * data.blue_coefficient - 1./32768 - out_qe;            if (gray <= 0)               gray = 0;            else            {               gray *= (1 - 6 * DBL_EPSILON);               gray = pow(gray, data.gamma) * (1-DBL_EPSILON);            }            grayhi = rhi * data.red_coefficient + ghi * data.green_coefficient +               bhi * data.blue_coefficient + 1./32768 + out_qe;            grayhi *= (1 + 6 * DBL_EPSILON);            if (grayhi >= 1)               grayhi = 1;            else               grayhi = pow(grayhi, data.gamma) * (1+DBL_EPSILON);            err = (grayhi - gray) / 2;            gray = (grayhi + gray) / 2;            if (err <= in_qe)               err = gray * DBL_EPSILON;            else               err -= in_qe;                        if (err > pm->limit)            {               size_t pos = 0;               char buffer[128];               pos = safecat(buffer, sizeof buffer, pos, \"rgb_to_gray error \");               pos = safecatd(buffer, sizeof buffer, pos, err, 6);               pos = safecat(buffer, sizeof buffer, pos, \" exceeds limit \");               pos = safecatd(buffer, sizeof buffer, pos, pm->limit, 6);               png_error(pp, buffer);            }         }      }#  endif       that->bluef = that->greenf = that->redf = gray;      that->bluee = that->greene = that->rede = err;            if (that->red_sBIT > that->green_sBIT)         that->red_sBIT = that->green_sBIT;      if (that->red_sBIT > that->blue_sBIT)         that->red_sBIT = that->blue_sBIT;      that->blue_sBIT = that->green_sBIT = that->red_sBIT;            if (that->colour_type == PNG_COLOR_TYPE_RGB)         that->colour_type = PNG_COLOR_TYPE_GRAY;      else if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)         that->colour_type = PNG_COLOR_TYPE_GRAY_ALPHA;   }   this->next->mod(this->next, that, pp, display);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstandard_image_validate(standard_display *dp, png_const_structp pp, int iImage,    int iDisplay){   png_uint_32 y;   if (iImage >= 0)      store_image_check(dp->ps, pp, iImage);   if (iDisplay >= 0)      store_image_check(dp->ps, pp, iDisplay);   for (y=0; y<dp->h; ++y)      standard_row_validate(dp, pp, iImage, iDisplay, y);      dp->ps->validated = 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "png_charp png_decompress_chunk(png_structp png_ptr, int comp_type,                              png_charp chunkdata, png_size_t chunklength,                              png_size_t prefix_size, png_size_t *newlength){   static char msg[] = \"Error decoding compressed text\";   png_charp text;   png_size_t text_size;   if (comp_type == PNG_COMPRESSION_TYPE_BASE)   {      int ret = Z_OK;      png_ptr->zstream.next_in = (png_bytep)(chunkdata + prefix_size);      png_ptr->zstream.avail_in = (uInt)(chunklength - prefix_size);      png_ptr->zstream.next_out = png_ptr->zbuf;      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;      text_size = 0;      text = NULL;      while (png_ptr->zstream.avail_in)      {         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);         if (ret != Z_OK && ret != Z_STREAM_END)         {            if (png_ptr->zstream.msg != NULL)               png_warning(png_ptr, png_ptr->zstream.msg);            else               png_warning(png_ptr, msg);            inflateReset(&png_ptr->zstream);            png_ptr->zstream.avail_in = 0;            if (text ==  NULL)            {               text_size = prefix_size + png_sizeof(msg) + 1;               text = (png_charp)png_malloc_warn(png_ptr, text_size);               if (text ==  NULL)                 {                    png_free(png_ptr,chunkdata);                    png_error(png_ptr,\"Not enough memory to decompress chunk\");                 }               png_memcpy(text, chunkdata, prefix_size);            }            text[text_size - 1] = 0x00;                        text_size = (png_size_t)(chunklength - (text - chunkdata) - 1);            text_size = png_sizeof(msg) > text_size ? text_size :               png_sizeof(msg);            png_memcpy(text + prefix_size, msg, text_size + 1);            break;         }         if (!png_ptr->zstream.avail_out || ret == Z_STREAM_END)         {            if (text == NULL)            {               text_size = prefix_size +                   png_ptr->zbuf_size - png_ptr->zstream.avail_out;               text = (png_charp)png_malloc_warn(png_ptr, text_size + 1);               if (text ==  NULL)                 {                    png_free(png_ptr,chunkdata);                    png_error(png_ptr,\"Not enough memory to decompress chunk.\");                 }               png_memcpy(text + prefix_size, png_ptr->zbuf,                    text_size - prefix_size);               png_memcpy(text, chunkdata, prefix_size);               *(text + text_size) = 0x00;            }            else            {               png_charp tmp;               tmp = text;               text = (png_charp)png_malloc_warn(png_ptr,                  (png_uint_32)(text_size +                  png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1));               if (text == NULL)               {                  png_free(png_ptr, tmp);                  png_free(png_ptr, chunkdata);                  png_error(png_ptr,\"Not enough memory to decompress chunk..\");               }               png_memcpy(text, tmp, text_size);               png_free(png_ptr, tmp);               png_memcpy(text + text_size, png_ptr->zbuf,                  (png_ptr->zbuf_size - png_ptr->zstream.avail_out));               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;               *(text + text_size) = 0x00;            }            if (ret == Z_STREAM_END)               break;            else            {               png_ptr->zstream.next_out = png_ptr->zbuf;               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;            }         }      }      if (ret != Z_STREAM_END)      {#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)         char umsg[50];         if (ret == Z_BUF_ERROR)            sprintf(umsg,\"Buffer error in compressed datastream in %s chunk\",                png_ptr->chunk_name);         else if (ret == Z_DATA_ERROR)            sprintf(umsg,\"Data error in compressed datastream in %s chunk\",                png_ptr->chunk_name);         else            sprintf(umsg,\"Incomplete compressed datastream in %s chunk\",                png_ptr->chunk_name);         png_warning(png_ptr, umsg);#else         png_warning(png_ptr,            \"Incomplete compressed datastream in chunk other than IDAT\");#endif         text_size=prefix_size;         if (text ==  NULL)         {            text = (png_charp)png_malloc_warn(png_ptr, text_size+1);            if (text == NULL)              {                png_free(png_ptr, chunkdata);                png_error(png_ptr,\"Not enough memory for text.\");              }            png_memcpy(text, chunkdata, prefix_size);         }         *(text + text_size) = 0x00;      }      inflateReset(&png_ptr->zstream);      png_ptr->zstream.avail_in = 0;      png_free(png_ptr, chunkdata);      chunkdata = text;      *newlength=text_size;   }   else    {#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)      char umsg[50];      sprintf(umsg, \"Unknown zTXt compression type %d\", comp_type);      png_warning(png_ptr, umsg);#else      png_warning(png_ptr, \"Unknown zTXt compression type\");#endif      *(chunkdata + prefix_size) = 0x00;      *newlength=prefix_size;   }   return chunkdata;}#endif",
        "label": 1,
        "cve": "cve-2010-0205"
    },
    {
        "code": "static intgenerate_palette(png_colorp palette, png_bytep trans, int bit_depth,   png_const_bytep gamma_table, unsigned int *colors){      switch (colors[0])   {      default:         fprintf(stderr, \"makepng: --colors=...: invalid count %u\\n\",            colors[0]);         exit(1);      case 1:         set_color(palette+0, trans+0, colors[1], colors[1], colors[1], 255,            gamma_table);         return 1;      case 2:         set_color(palette+0, trans+0, colors[1], colors[1], colors[1],            colors[2], gamma_table);         return 1;      case 3:         set_color(palette+0, trans+0, colors[1], colors[2], colors[3], 255,            gamma_table);         return 1;      case 4:         set_color(palette+0, trans+0, colors[1], colors[2], colors[3],            colors[4], gamma_table);         return 1;      case 0:         if (bit_depth == 1)         {            set_color(palette+0, trans+0, 255, 0, 0, 0, gamma_table);            set_color(palette+1, trans+1, 255, 255, 255, 255, gamma_table);            return 2;         }         else         {            unsigned int size = 1U << (bit_depth/2);             unsigned int x, y, ip;            for (x=0; x<size; ++x) for (y=0; y<size; ++y)            {               ip = x + (size * y);               #              define interp(pos, c1, c2) ((pos * c1) + ((size-pos) * c2))#              define xyinterp(x, y, c1, c2, c3, c4) (((size * size / 2) +\\                  (interp(x, c1, c2) * y + (size-y) * interp(x, c3, c4))) /\\                  (size*size))               set_color(palette+ip, trans+ip,                                    xyinterp(x, y,   0, 255,   0, 255),                  xyinterp(x, y, 255,   0,   0, 255),                  xyinterp(x, y,   0,   0, 255, 255),                                    xyinterp(x, y,   0, 102, 204, 255),                  gamma_table);            }            return ip+1;         }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intchannels_of_type(int color_type){   if (color_type & PNG_COLOR_MASK_PALETTE)      return 1;   else   {      int channels = 1;      if (color_type & PNG_COLOR_MASK_COLOR)         channels = 3;      if (color_type & PNG_COLOR_MASK_ALPHA)         return channels + 1;      else         return channels;   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGCBAPIread_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass){   if (png_ptr == NULL || row_number > PNG_UINT_31_MAX)      return;   if (status_pass != pass)   {      fprintf(stdout, \"\\n Pass %d: \", pass);      status_pass = pass;      status_dots = 31;   }   status_dots--;   if (status_dots == 0)   {      fprintf(stdout, \"\\n         \");      status_dots=30;   }   fprintf(stdout, \"r\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIwrite_function(png_structp pp, png_bytep data, png_size_t size){   buffer_write(get_dp(pp), get_buffer(pp), data, size);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidinsert_tEXt(png_structp png_ptr, png_infop info_ptr, int nparams,   png_charpp params){   png_text text;   check_param_count(nparams, 2);   clear_text(&text, params[0]);   set_text(png_ptr, info_ptr, &text, params[1]);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "#endif static void rpng2_x_cleanup(void){    if (bg_image && bg_data) {        free(bg_data);        bg_data = NULL;    }    if (rpng2_info.image_data) {        free(rpng2_info.image_data);        rpng2_info.image_data = NULL;    }    if (rpng2_info.row_pointers) {        free(rpng2_info.row_pointers);        rpng2_info.row_pointers = NULL;    }    if (ximage) {        if (ximage->data) {            free(ximage->data);                       ximage->data = (char *)NULL;          }        XDestroyImage(ximage);        ximage = NULL;    }    if (have_gc)        XFreeGC(display, gc);    if (have_window)        XDestroyWindow(display, window);    if (have_colormap)        XFreeColormap(display, colormap);    if (have_nondefault_visual)        XFree(visual_list);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "png_size_t png_check_keyword(png_structp png_ptr, png_const_charp key, png_charpp new_key){   png_size_t key_len;   png_const_charp ikp;   png_charp kp, dp;   int kflag;   int kwarn=0;   png_debug(1, \"in png_check_keyword\");   *new_key = NULL;   if (key == NULL || (key_len = png_strlen(key)) == 0)   {      png_warning(png_ptr, \"zero length keyword\");      return ((png_size_t)0);   }   png_debug1(2, \"Keyword to be checked is '%s'\", key);   *new_key = (png_charp)png_malloc_warn(png_ptr, (png_uint_32)(key_len + 2));   if (*new_key == NULL)   {      png_warning(png_ptr, \"Out of memory while procesing keyword\");      return ((png_size_t)0);   }      for (ikp = key, dp = *new_key; *ikp != '\\0'; ikp++, dp++)   {      if ((png_byte)*ikp < 0x20 ||         ((png_byte)*ikp > 0x7E && (png_byte)*ikp < 0xA1))      {         PNG_WARNING_PARAMETERS(p)         png_warning_parameter_unsigned(p, 1, PNG_NUMBER_FORMAT_02x,            (png_byte)*ikp);         png_formatted_warning(png_ptr, p, \"invalid keyword character 0x@1\");         *dp = ' ';      }      else      {         *dp = *ikp;      }   }   *dp = '\\0';      kp = *new_key + key_len - 1;   if (*kp == ' ')   {      png_warning(png_ptr, \"trailing spaces removed from keyword\");      while (*kp == ' ')      {         *(kp--) = '\\0';         key_len--;      }   }      kp = *new_key;   if (*kp == ' ')   {      png_warning(png_ptr, \"leading spaces removed from keyword\");      while (*kp == ' ')      {         kp++;         key_len--;      }   }   png_debug1(2, \"Checking for multiple internal spaces in '%s'\", kp);      for (kflag = 0, dp = *new_key; *kp != '\\0'; kp++)   {      if (*kp == ' ' && kflag == 0)      {         *(dp++) = *kp;         kflag = 1;      }      else if (*kp == ' ')      {         key_len--;         kwarn = 1;      }      else      {         *(dp++) = *kp;         kflag = 0;      }   }   *dp = '\\0';   if (kwarn)      png_warning(png_ptr, \"extra interior spaces removed from keyword\");   if (key_len == 0)   {      png_free(png_ptr, *new_key);      png_warning(png_ptr, \"Zero length keyword\");   }   if (key_len > 79)   {      png_warning(png_ptr, \"keyword length must be 1 - 79 characters\");      (*new_key)[79] = '\\0';      key_len = 79;   }   return (key_len);}",
        "label": 1,
        "cve": "cve-2015-8540"
    },
    {
        "code": "void PNGCBAPIpng_default_flush(png_structp png_ptr){   png_FILE_p io_ptr;   if (png_ptr == NULL)      return;   io_ptr = (png_FILE_p)CVT_PTR((png_ptr->io_ptr));   fflush(io_ptr);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGAPIpng_set_sPLT(png_structp png_ptr,    png_infop info_ptr, png_const_sPLT_tp entries, int nentries){   png_sPLT_tp np;   int i;   if (png_ptr == NULL || info_ptr == NULL)      return;   np = (png_sPLT_tp)png_malloc_warn(png_ptr,       (info_ptr->splt_palettes_num + nentries) *       (png_size_t)png_sizeof(png_sPLT_t));   if (np == NULL)   {      png_warning(png_ptr, \"No memory for sPLT palettes\");      return;   }   png_memcpy(np, info_ptr->splt_palettes,       info_ptr->splt_palettes_num * png_sizeof(png_sPLT_t));   png_free(png_ptr, info_ptr->splt_palettes);   info_ptr->splt_palettes=NULL;   for (i = 0; i < nentries; i++)   {      png_sPLT_tp to = np + info_ptr->splt_palettes_num + i;      png_const_sPLT_tp from = entries + i;      png_size_t length;      length = png_strlen(from->name) + 1;      to->name = (png_charp)png_malloc_warn(png_ptr, length);      if (to->name == NULL)      {         png_warning(png_ptr,             \"Out of memory while processing sPLT chunk\");         continue;      }      png_memcpy(to->name, from->name, length);      to->entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,          from->nentries * png_sizeof(png_sPLT_entry));      if (to->entries == NULL)      {         png_warning(png_ptr,             \"Out of memory while processing sPLT chunk\");         png_free(png_ptr, to->name);         to->name = NULL;         continue;      }      png_memcpy(to->entries, from->entries,          from->nentries * png_sizeof(png_sPLT_entry));      to->nentries = from->nentries;      to->depth = from->depth;   }   info_ptr->splt_palettes = np;   info_ptr->splt_palettes_num += nentries;   info_ptr->valid |= PNG_INFO_sPLT;   info_ptr->free_me |= PNG_FREE_SPLT;}#endif ",
        "label": 1,
        "cve": "cve-2013-7354-1"
    },
    {
        "code": "static voidtransform_from_formats(Transform *result, Image *in_image,   const Image *out_image, png_const_colorp background, int via_linear){   png_uint_32 in_format, out_format;   png_uint_32 in_base, out_base;   memset(result, 0, sizeof *result);      result->in_image = in_image;   result->out_image = out_image;   in_format = in_image->image.format;   out_format = out_image->image.format;   if (in_format & PNG_FORMAT_FLAG_LINEAR)      result->in_opaque = 65535;   else      result->in_opaque = 255;   result->output_8bit = (out_format & PNG_FORMAT_FLAG_LINEAR) == 0;   result->is_palette = 0;    result->accumulate = (in_image->opts & ACCUMULATE) != 0;      result->in_gp = get_pixel(in_format);   result->out_gp = get_pixel(out_format);      in_format &= BASE_FORMATS | PNG_FORMAT_FLAG_COLORMAP;   in_base = in_format & BASE_FORMATS;   out_format &= BASE_FORMATS | PNG_FORMAT_FLAG_COLORMAP;   out_base = out_format & BASE_FORMATS;   if (via_linear)   {            if (out_format & (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLORMAP))      {         fprintf(stderr, \"internal transform via linear error 0x%x->0x%x\\n\",            in_format, out_format);         exit(1);      }      result->transform = gpc_fn[in_base][out_base | PNG_FORMAT_FLAG_LINEAR];      result->from_linear = gpc_fn[out_base | PNG_FORMAT_FLAG_LINEAR][out_base];      result->error_ptr = gpc_error_via_linear[in_format][out_format];   }   else if (~in_format & out_format & PNG_FORMAT_FLAG_COLORMAP)   {            result->transform = gpc_fn[in_base][out_base];      result->from_linear = NULL;      result->error_ptr = gpc_error_to_colormap[in_base][out_base];   }   else   {            if (in_format & out_format & PNG_FORMAT_FLAG_COLORMAP)         result->transform = gpc_fn_colormapped[in_base][out_base];      else         result->transform = gpc_fn[in_base][out_base];      result->from_linear = NULL;      result->error_ptr = gpc_error[in_format][out_format];   }      result->background = NULL;       if (in_format & ~out_format & PNG_FORMAT_FLAG_ALPHA)   {            result->background = &result->background_color;      if (out_format & PNG_FORMAT_FLAG_LINEAR || via_linear)      {         if (out_format & PNG_FORMAT_FLAG_COLORMAP)         {            result->background_color.ir =               result->background_color.ig =               result->background_color.ib = 0;            result->background_color.dr =               result->background_color.dg =               result->background_color.db = 0;         }         else         {            result->background_color.ir =               result->background_color.ig =               result->background_color.ib = BUFFER_INIT8 * 257;            result->background_color.dr =               result->background_color.dg =               result->background_color.db = 0;         }      }      else       {         if (background != NULL)         {            if (out_format & PNG_FORMAT_FLAG_COLOR)            {               result->background_color.ir = background->red;               result->background_color.ig = background->green;               result->background_color.ib = background->blue;                              result->background_color.dr = sRGB_to_d[background->red];               result->background_color.dg = sRGB_to_d[background->green];               result->background_color.db = sRGB_to_d[background->blue];            }            else             {               result->background_color.ir =                  result->background_color.ig =                  result->background_color.ib = background->green;                              result->background_color.dr =                  result->background_color.dg =                  result->background_color.db = sRGB_to_d[background->green];            }         }         else if ((out_format & PNG_FORMAT_FLAG_COLORMAP) == 0)         {            result->background_color.ir =               result->background_color.ig =               result->background_color.ib = BUFFER_INIT8;                        result->background_color.dr =               result->background_color.dg =               result->background_color.db = sRGB_to_d[BUFFER_INIT8];         }                  else            result->background = NULL;      }   }   if (result->background == NULL)   {      result->background_color.ir =         result->background_color.ig =         result->background_color.ib = -1;       result->background_color.dr =         result->background_color.dg =         result->background_color.db = 1E30;    }      result->error[0] = result->error_ptr[0];   result->error[1] = result->error_ptr[1];   result->error[2] = result->error_ptr[2];   result->error[3] = result->error_ptr[3];}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intimage_transform_png_set_tRNS_to_alpha_add(image_transform *this,    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth){   UNUSED(bit_depth)   this->next = *that;   *that = this;      return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidpngtest_check_io_state(png_structp png_ptr, png_size_t data_length,   png_uint_32 io_op){   png_uint_32 io_state = png_get_io_state(png_ptr);   int err = 0;      if ((io_state & PNG_IO_MASK_OP) != io_op)      png_error(png_ptr, \"Incorrect operation in I/O state\");      switch (io_state & PNG_IO_MASK_LOC)   {   case PNG_IO_SIGNATURE:      if (data_length > 8)         err = 1;      break;   case PNG_IO_CHUNK_HDR:      if (data_length != 8)         err = 1;      break;   case PNG_IO_CHUNK_DATA:      break;     case PNG_IO_CHUNK_CRC:      if (data_length != 4)         err = 1;      break;   default:      err = 1;     }   if (err)      png_error(png_ptr, \"Bad I/O state or buffer size\");}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static inttestimage(Image *image, png_uint_32 opts, format_list *pf){   int result;   Image copy;      checkopaque(image);   copy = *image;   copy.opts = opts;   copy.buffer = NULL;   copy.bufsize = 0;   copy.allocsize = 0;   image->input_file = NULL;   image->input_memory = NULL;   image->input_memory_size = 0;   image->tmpfile_name[0] = 0;   {      png_uint_32 counter;      Image output;      newimage(&output);      result = 1;            for (counter=0; counter<2*FORMAT_COUNT; ++counter)         if (format_isset(pf, counter >> 1))      {         png_uint_32 format = counter >> 1;         png_color background_color;         png_colorp background = NULL;                  if ((counter & 1) == 0)         {            if ((format & PNG_FORMAT_FLAG_ALPHA) == 0 &&               (image->image.format & PNG_FORMAT_FLAG_ALPHA) != 0)            {                              random_color(&background_color);               background = &background_color;                              if ((format & PNG_FORMAT_FLAG_COLORMAP) != 0 &&                  (format & PNG_FORMAT_FLAG_LINEAR) == 0)                  ++counter;            }                        else               ++counter;         }                  resetimage(&copy);         copy.opts = opts;          result = read_file(&copy, format, background);         if (!result)            break;                  result = compare_two_images(image, &copy, 0, background);         if (!result)            break;#        ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED                        output.opts = opts;            result = write_one_file(&output, &copy, 0);            if (!result)               break;                        result = compare_two_images(image, &output, 0, background);            if (!result)               break;            if ((format & PNG_FORMAT_FLAG_LINEAR) != 0 &&               (format & PNG_FORMAT_FLAG_COLORMAP) == 0)            {                              output.opts = opts;               result = write_one_file(&output, &copy, 1);               if (!result)                  break;                              result = compare_two_images(image, &output, 1,                  background);               if (!result)                  break;            }#        endif       }      freeimage(&output);   }   freeimage(&copy);   return result;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intpng_col_in_interlace_pass(png_uint_32 x, int pass){      int y;   x &= 7;   ++pass;   for (y=0; y<8; ++y) if (adam7[y][x] == pass)      return 1;   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidtransform_enable(PNG_CONST char *name){      static int all_disabled = 0;   int found_it = 0;   image_transform *list = image_transform_first;   while (list != &image_transform_end)   {      if (strcmp(list->name, name) == 0)      {         list->enable = 1;         found_it = 1;      }      else if (!all_disabled)         list->enable = 0;      list = list->list;   }   all_disabled = 1;   if (!found_it)   {      fprintf(stderr, \"pngvalid: --transform-enable=%s: unknown transform\\n\",         name);      exit(99);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(int argc, const char **argv){   const char *prog = *argv++;   int to_linear = 0, to_gray = 0, to_color = 0;   int channels = 0;   double c[4];      fesetround(FE_TONEAREST);   c[3] = c[2] = c[1] = c[0] = 0;   while (--argc > 0 && **argv == '-')   {      const char *arg = 1+*argv++;      if (strcmp(arg, \"sRGB\") == 0)         to_linear = 0;      else if (strcmp(arg, \"linear\") == 0)         to_linear = 1;      else if (strcmp(arg, \"gray\") == 0)         to_gray = 1, to_color = 0;      else if (strcmp(arg, \"color\") == 0)         to_gray = 0, to_color = 1;      else         usage(prog);   }   switch (argc)   {      default:         usage(prog);         break;      case 4:         c[3] = component(prog, argv[3], to_linear);         ++channels;      case 3:         c[2] = component(prog, argv[2], to_linear);         ++channels;      case 2:         c[1] = component(prog, argv[1], to_linear);         ++channels;      case 1:         c[0] = component(prog, argv[0], to_linear);         ++channels;         break;      }   if (to_linear)   {      int i;      int components = channels;      if ((components & 1) == 0)         --components;      for (i=0; i<components; ++i) c[i] = linear_from_sRGB(c[i] / 255);      if (components < channels)         c[components] = c[components] / 255;   }   else   {      int i;      for (i=0; i<4; ++i) c[i] /= 65535;      if ((channels & 1) == 0)      {         double alpha = c[channels-1];         if (alpha > 0)            for (i=0; i<channels-1; ++i) c[i] /= alpha;         else            for (i=0; i<channels-1; ++i) c[i] = 1;      }   }   if (to_gray)   {      if (channels < 3)      {         fprintf(stderr, \"%s: too few channels (%d) for -gray\\n\",            prog, channels);         usage(prog);      }      c[0] = YfromRGB(c[0], c[1], c[2]);      channels -= 2;   }   if (to_color)   {      if (channels > 2)      {         fprintf(stderr, \"%s: too many channels (%d) for -color\\n\",            prog, channels);         usage(prog);      }      c[3] = c[1];       c[2] = c[1] = c[0];   }   if (to_linear)   {      int i;      if ((channels & 1) == 0)      {         double alpha = c[channels-1];         for (i=0; i<channels-1; ++i) c[i] *= alpha;      }      for (i=0; i<channels; ++i) c[i] = nearbyint(c[i] * 65535);   }   else    {      int i = (channels+1)&~1;      while (--i >= 0)         c[i] = sRGB_from_linear(c[i]);      for (i=0; i<channels; ++i) c[i] = nearbyint(c[i] * 255);   }   {      int i;      for (i=0; i<channels; ++i) printf(\" %g\", c[i]);   }   printf(\"\\n\");   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intread_file(Image *image, png_uint_32 format, png_const_colorp background){   memset(&image->image, 0, sizeof image->image);   image->image.version = PNG_IMAGE_VERSION;   if (image->input_memory != NULL)   {      if (!png_image_begin_read_from_memory(&image->image, image->input_memory,         image->input_memory_size))         return logerror(image, \"memory init: \", image->file_name, \"\");   }#  ifdef PNG_STDIO_SUPPORTED      else if (image->input_file != NULL)      {         if (!png_image_begin_read_from_stdio(&image->image, image->input_file))            return logerror(image, \"stdio init: \", image->file_name, \"\");      }      else      {         if (!png_image_begin_read_from_file(&image->image, image->file_name))            return logerror(image, \"file init: \", image->file_name, \"\");      }#  else      else      {         return logerror(image, \"unsupported file/stdio init: \",            image->file_name, \"\");      }#  endif      if (image->opts & sRGB_16BIT)      image->image.flags |= PNG_IMAGE_FLAG_16BIT_sRGB;      {      int result;      png_uint_32 image_format;            image_format = image->image.format;      if (image->opts & VERBOSE)      {         printf(\"%s %lu x %lu %s -> %s\", image->file_name,            (unsigned long)image->image.width,            (unsigned long)image->image.height,            format_names[image_format & FORMAT_MASK],            (format & FORMAT_NO_CHANGE) != 0 || image->image.format == format            ? \"no change\" : format_names[format & FORMAT_MASK]);         if (background != NULL)            printf(\" background(%d,%d,%d)\\n\", background->red,               background->green, background->blue);         else            printf(\"\\n\");         fflush(stdout);      }            if ((format & FORMAT_NO_CHANGE) != 0)      {         if ((format & PNG_FORMAT_FLAG_COLORMAP) != 0 &&            (image_format & PNG_FORMAT_FLAG_COLORMAP) != 0)            format = (image_format & ~BASE_FORMATS) | (format & BASE_FORMATS);         else            format = image_format;      }      image->image.format = format;      image->stride = PNG_IMAGE_ROW_STRIDE(image->image) + image->stride_extra;      allocbuffer(image);      result = png_image_finish_read(&image->image, background,         image->buffer+16, (png_int_32)image->stride, image->colormap);      checkbuffer(image, image->file_name);      if (result)         return checkopaque(image);      else         return logerror(image, image->file_name, \": image read failed\", \"\");   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void readpng_cleanup(int free_image_data){    if (free_image_data && image_data) {        free(image_data);        image_data = NULL;    }    if (png_ptr && info_ptr) {        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);        png_ptr = NULL;        info_ptr = NULL;    }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32current_type(struct file *file, int code)   {      if (file->chunk != NULL)   {      png_uint_32 type = file->chunk->chunk_type;            if (code <= LIBPNG_ERROR_CODE && type == png_IDAT &&         file->write_count == 8)         type = 0;       return type;   }   else      return file->type;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_gray_to_rgb_set(PNG_CONST image_transform *this,    transform_display *that, png_structp pp, png_infop pi){   png_set_gray_to_rgb(pp);   this->next->set(this->next, that, pp, pi);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "voidpng_handle_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_32 length){   int num, i;   png_debug(1, \"in png_handle_hIST\\n\");   if (!(png_ptr->mode & PNG_HAVE_IHDR))      png_error(png_ptr, \"Missing IHDR before hIST\");   else if (png_ptr->mode & PNG_HAVE_IDAT)   {      png_warning(png_ptr, \"Invalid hIST after IDAT\");      png_crc_finish(png_ptr, length);      return;   }   else if (!(png_ptr->mode & PNG_HAVE_PLTE))   {      png_warning(png_ptr, \"Missing PLTE before hIST\");      png_crc_finish(png_ptr, length);      return;   }   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_hIST)   {      png_warning(png_ptr, \"Duplicate hIST chunk\");      png_crc_finish(png_ptr, length);      return;   }   if (length != (png_uint_32)(2 * png_ptr->num_palette))   {      png_warning(png_ptr, \"Incorrect hIST chunk length\");      png_crc_finish(png_ptr, length);      return;   }   num = (int)length / 2;   png_ptr->hist = (png_uint_16p)png_malloc(png_ptr,      (png_uint_32)(num * sizeof (png_uint_16)));   png_ptr->flags |= PNG_FLAG_FREE_HIST;   for (i = 0; i < num; i++)   {      png_byte buf[2];      png_crc_read(png_ptr, buf, 2);      png_ptr->hist[i] = png_get_uint_16(buf);   }   if (png_crc_finish(png_ptr, 0))      return;   png_set_hIST(png_ptr, info_ptr, png_ptr->hist);}#endif",
        "label": 1,
        "cve": "cve-2004-0597-3"
    },
    {
        "code": "static intimage_transform_png_set_strip_alpha_add(image_transform *this,    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth){   UNUSED(bit_depth)   this->next = *that;   *that = this;   return (colour_type & PNG_COLOR_MASK_ALPHA) != 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstandard_info_part2(standard_display *dp, png_const_structp pp,    png_const_infop pi, int nImages){      dp->pixel_size = bit_size(pp, png_get_color_type(pp, pi),      png_get_bit_depth(pp, pi));   dp->bit_width = png_get_image_width(pp, pi) * dp->pixel_size;   dp->cbRow = png_get_rowbytes(pp, pi);      if (dp->cbRow != (dp->bit_width+7)/8)      png_error(pp, \"bad png_get_rowbytes calculation\");      store_ensure_image(dp->ps, pp, nImages, dp->cbRow, dp->h);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static CIE_colorwhite_point(PNG_CONST color_encoding *encoding){   CIE_color white;   white.X = encoding->red.X + encoding->green.X + encoding->blue.X;   white.Y = encoding->red.Y + encoding->green.Y + encoding->blue.Y;   white.Z = encoding->red.Z + encoding->green.Z + encoding->blue.Z;   return white;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intancillary(const char *name){   return PNG_CHUNK_ANCILLARY(PNG_U32(name[0], name[1], name[2], name[3]));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_bgra16(Pixel *p, png_const_voidp pb){   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);   p->r = pp[2];   p->g = pp[1];   p->b = pp[0];   p->a = pp[3];}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int png_set_text_2(png_const_structrp png_ptr, png_inforp info_ptr,    png_const_textp text_ptr, int num_text){   int i;   png_debug1(1, \"in %lx storage function\", png_ptr == NULL ? \"unexpected\" :      (unsigned long)png_ptr->chunk_name);   if (png_ptr == NULL || info_ptr == NULL || num_text <= 0 || text_ptr == NULL)      return(0);      if (num_text > info_ptr->max_text - info_ptr->num_text)   {      int old_num_text = info_ptr->num_text;      int max_text;      png_textp new_text = NULL;            max_text = old_num_text;      if (num_text <= INT_MAX - max_text)      {         max_text += num_text;                  if (max_text < INT_MAX-8)            max_text = (max_text + 8) & ~0x7;         else            max_text = INT_MAX;                  new_text = png_voidcast(png_textp,png_realloc_array(png_ptr,            info_ptr->text, old_num_text, max_text-old_num_text,            sizeof *new_text));      }      if (new_text == NULL)      {         png_chunk_report(png_ptr, \"too many text chunks\",            PNG_CHUNK_WRITE_ERROR);         return 1;      }      png_free(png_ptr, info_ptr->text);      info_ptr->text = new_text;      info_ptr->free_me |= PNG_FREE_TEXT;      info_ptr->max_text = max_text;            png_debug1(3, \"allocated %d entries for info_ptr->text\", max_text);   }   for (i = 0; i < num_text; i++)   {      size_t text_length, key_len;      size_t lang_len, lang_key_len;      png_textp textp = &(info_ptr->text[info_ptr->num_text]);      if (text_ptr[i].key == NULL)          continue;      if (text_ptr[i].compression < PNG_TEXT_COMPRESSION_NONE ||          text_ptr[i].compression >= PNG_TEXT_COMPRESSION_LAST)      {         png_chunk_report(png_ptr, \"text compression mode is out of range\",            PNG_CHUNK_WRITE_ERROR);         continue;      }      key_len = strlen(text_ptr[i].key);      if (text_ptr[i].compression <= 0)      {         lang_len = 0;         lang_key_len = 0;      }      else#  ifdef PNG_iTXt_SUPPORTED      {                  if (text_ptr[i].lang != NULL)            lang_len = strlen(text_ptr[i].lang);         else            lang_len = 0;         if (text_ptr[i].lang_key != NULL)            lang_key_len = strlen(text_ptr[i].lang_key);         else            lang_key_len = 0;      }#  else       {         png_chunk_report(png_ptr, \"iTXt chunk not supported\",            PNG_CHUNK_WRITE_ERROR);         continue;      }#  endif      if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\\0')      {         text_length = 0;#  ifdef PNG_iTXt_SUPPORTED         if (text_ptr[i].compression > 0)            textp->compression = PNG_ITXT_COMPRESSION_NONE;         else#  endif            textp->compression = PNG_TEXT_COMPRESSION_NONE;      }      else      {         text_length = strlen(text_ptr[i].text);         textp->compression = text_ptr[i].compression;      }      textp->key = png_voidcast(png_charp,png_malloc_base(png_ptr,          key_len + text_length + lang_len + lang_key_len + 4));      if (textp->key == NULL)      {         png_chunk_report(png_ptr, \"text chunk: out of memory\",               PNG_CHUNK_WRITE_ERROR);         return 1;      }      png_debug2(2, \"Allocated %lu bytes at %p in png_set_text\",          (unsigned long)(png_uint_32)          (key_len + lang_len + lang_key_len + text_length + 4),          textp->key);      memcpy(textp->key, text_ptr[i].key, key_len);      *(textp->key + key_len) = '\\0';      if (text_ptr[i].compression > 0)      {         textp->lang = textp->key + key_len + 1;         memcpy(textp->lang, text_ptr[i].lang, lang_len);         *(textp->lang + lang_len) = '\\0';         textp->lang_key = textp->lang + lang_len + 1;         memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);         *(textp->lang_key + lang_key_len) = '\\0';         textp->text = textp->lang_key + lang_key_len + 1;      }      else      {         textp->lang=NULL;         textp->lang_key=NULL;         textp->text = textp->key + key_len + 1;      }      if (text_length != 0)         memcpy(textp->text, text_ptr[i].text, text_length);      *(textp->text + text_length) = '\\0';#  ifdef PNG_iTXt_SUPPORTED      if (textp->compression > 0)      {         textp->text_length = 0;         textp->itxt_length = text_length;      }      else#  endif      {         textp->text_length = text_length;         textp->itxt_length = 0;      }      info_ptr->num_text++;      png_debug1(3, \"transferred text chunk %d\", info_ptr->num_text);   }   return(0);}#endif",
        "label": 1,
        "cve": "cve-2016-10087"
    },
    {
        "code": "static voidimage_transform_png_set_background_set(PNG_CONST image_transform *this,    transform_display *that, png_structp pp, png_infop pi){   png_byte colour_type, bit_depth;   png_byte random_bytes[8];    int expand;   png_color_16 back;      RANDOMIZE(random_bytes);      colour_type = that->this.colour_type;   if (colour_type == 3)   {      colour_type = PNG_COLOR_TYPE_RGB;      bit_depth = 8;      expand = 0;    }   else   {      bit_depth = that->this.bit_depth;      expand = 1;   }   image_pixel_init(&data, random_bytes, colour_type,      bit_depth, 0, 0);      RANDOMIZE(back);   if (colour_type & PNG_COLOR_MASK_COLOR)   {      back.red = (png_uint_16)data.red;      back.green = (png_uint_16)data.green;      back.blue = (png_uint_16)data.blue;   }   else      back.gray = (png_uint_16)data.red;#  ifdef PNG_FLOATING_POINT_SUPPORTED      png_set_background(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0);#  else      png_set_background_fixed(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0);#  endif   this->next->set(this->next, that, pp, pi);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "BOOL InitBitmap (BYTE *pDiData, int cxWinSize, int cyWinSize){    BYTE *dst;    int x, y, col;        dst = pDiData;    for (y = 0; y < cyWinSize; y++)    {        col = 0;        for (x = 0; x < cxWinSize; x++)        {                        *dst++ = 127;            *dst++ = 127;            *dst++ = 127;            col += 3;        }                while ((col % 4) != 0)        {            dst++;            col++;        }    }    return TRUE;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidsBIT0_error_fn(png_structp pp, png_infop pi){      png_color_8 bad;   bad.red = bad.green = bad.blue = bad.gray = bad.alpha = 0;   png_set_sBIT(pp, pi, &bad);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidtransform_info_imp(transform_display *dp, png_structp pp, png_infop pi){      standard_info_part1(&dp->this, pp, pi);      dp->transform_list->set(dp->transform_list, dp, pp, pi);      {      int i = dp->this.use_update_info;            do         png_read_update_info(pp, pi);      while (--i > 0);   }      standard_info_part2(&dp->this, pp, pi, 1);      dp->output_colour_type = png_get_color_type(pp, pi);   dp->output_bit_depth = png_get_bit_depth(pp, pi);      switch (dp->output_colour_type)   {   case PNG_COLOR_TYPE_PALETTE:      if (dp->output_bit_depth > 8) goto error;         case PNG_COLOR_TYPE_GRAY:      if (dp->output_bit_depth == 1 || dp->output_bit_depth == 2 ||         dp->output_bit_depth == 4)         break;         default:      if (dp->output_bit_depth == 8 || dp->output_bit_depth == 16)         break;         error:      {         char message[128];         size_t pos;         pos = safecat(message, sizeof message, 0,            \"invalid final bit depth: colour type(\");         pos = safecatn(message, sizeof message, pos, dp->output_colour_type);         pos = safecat(message, sizeof message, pos, \") with bit depth: \");         pos = safecatn(message, sizeof message, pos, dp->output_bit_depth);         png_error(pp, message);      }   }      {      image_pixel test_pixel;      memset(&test_pixel, 0, sizeof test_pixel);      test_pixel.colour_type = dp->this.colour_type;       test_pixel.bit_depth = dp->this.bit_depth;      if (test_pixel.colour_type == PNG_COLOR_TYPE_PALETTE)         test_pixel.sample_depth = 8;      else         test_pixel.sample_depth = test_pixel.bit_depth;            test_pixel.have_tRNS = dp->this.is_transparent;      test_pixel.red_sBIT = test_pixel.green_sBIT = test_pixel.blue_sBIT =         test_pixel.alpha_sBIT = test_pixel.sample_depth;      dp->transform_list->mod(dp->transform_list, &test_pixel, pp, dp);      if (test_pixel.colour_type != dp->output_colour_type)      {         char message[128];         size_t pos = safecat(message, sizeof message, 0, \"colour type \");         pos = safecatn(message, sizeof message, pos, dp->output_colour_type);         pos = safecat(message, sizeof message, pos, \" expected \");         pos = safecatn(message, sizeof message, pos, test_pixel.colour_type);         png_error(pp, message);      }      if (test_pixel.bit_depth != dp->output_bit_depth)      {         char message[128];         size_t pos = safecat(message, sizeof message, 0, \"bit depth \");         pos = safecatn(message, sizeof message, pos, dp->output_bit_depth);         pos = safecat(message, sizeof message, pos, \" expected \");         pos = safecatn(message, sizeof message, pos, test_pixel.bit_depth);         png_error(pp, message);      }            if (test_pixel.colour_type == PNG_COLOR_TYPE_PALETTE)      {         if (test_pixel.sample_depth != 8)             png_error(pp, \"pngvalid: internal: palette sample depth not 8\");      }      else if (test_pixel.sample_depth != dp->output_bit_depth)      {         char message[128];         size_t pos = safecat(message, sizeof message, 0,            \"internal: sample depth \");         pos = safecatn(message, sizeof message, pos, dp->output_bit_depth);         pos = safecat(message, sizeof message, pos, \" expected \");         pos = safecatn(message, sizeof message, pos, test_pixel.sample_depth);         png_error(pp, message);      }   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static struct IDAT_list *IDAT_list_extend(struct IDAT_list *tail){      struct IDAT_list *next = tail->next;   if (next == NULL)   {            unsigned int length = 2 * tail->length;      if (length < tail->length)          length = tail->length;      next = png_voidcast(IDAT_list*, malloc(IDAT_list_size(NULL, length)));      CLEAR(*next);            if (next == NULL)         return NULL;      next->next = NULL;      next->length = length;      tail->next = next;   }   return next;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmake_transform_image(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type,    png_byte PNG_CONST bit_depth, unsigned int palette_number,    int interlace_type, png_const_charp name){   context(ps, fault);   check_interlace_type(interlace_type);   Try   {      png_infop pi;      png_structp pp = set_store_for_write(ps, &pi, name);      png_uint_32 h;            if (pp == NULL)         Throw ps;      h = transform_height(pp, colour_type, bit_depth);      png_set_IHDR(pp, pi, transform_width(pp, colour_type, bit_depth), h,         bit_depth, colour_type, interlace_type,         PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);#ifdef PNG_TEXT_SUPPORTED#  if defined(PNG_READ_zTXt_SUPPORTED) && defined(PNG_WRITE_zTXt_SUPPORTED)#     define TEXT_COMPRESSION PNG_TEXT_COMPRESSION_zTXt#  else#     define TEXT_COMPRESSION PNG_TEXT_COMPRESSION_NONE#  endif      {         static char key[] = \"image name\";          size_t pos;         png_text text;         char copy[FILE_NAME_SIZE];                  text.compression = TEXT_COMPRESSION;         text.key = key;                  pos = safecat(copy, sizeof copy, 0, ps->wname);         text.text = copy;         text.text_length = pos;         text.itxt_length = 0;         text.lang = 0;         text.lang_key = 0;         png_set_text(pp, pi, &text, 1);      }#endif      if (colour_type == 3)          init_standard_palette(ps, pp, pi, 1U << bit_depth, 1);      png_write_info(pp, pi);      if (png_get_rowbytes(pp, pi) !=          transform_rowsize(pp, colour_type, bit_depth))         png_error(pp, \"row size incorrect\");      else      {                  int npasses = png_set_interlace_handling(pp);         int pass;         if (npasses != npasses_from_interlace_type(pp, interlace_type))            png_error(pp, \"write: png_set_interlace_handling failed\");         for (pass=0; pass<npasses; ++pass)         {            png_uint_32 y;            for (y=0; y<h; ++y)            {               png_byte buffer[TRANSFORM_ROWMAX];               transform_row(pp, buffer, colour_type, bit_depth, y);               png_write_row(pp, buffer);            }         }      }#ifdef PNG_TEXT_SUPPORTED      {         static char key[] = \"end marker\";         static char comment[] = \"end\";         png_text text;                  text.compression = TEXT_COMPRESSION;         text.key = key;         text.text = comment;         text.text_length = (sizeof comment)-1;         text.itxt_length = 0;         text.lang = 0;         text.lang_key = 0;         png_set_text(pp, pi, &text, 1);      }#endif      png_write_end(pp, pi);            store_storefile(ps, FILEID(colour_type, bit_depth, palette_number,         interlace_type, 0, 0, 0));      store_write_reset(ps);   }   Catch(fault)   {            store_write_reset(fault);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidprint_pixel(png_structp png_ptr, png_infop info_ptr, png_const_bytep row,   png_uint_32 x){   PNG_CONST unsigned int bit_depth = png_get_bit_depth(png_ptr, info_ptr);   switch (png_get_color_type(png_ptr, info_ptr))   {      case PNG_COLOR_TYPE_GRAY:         printf(\"GRAY %u\\n\", component(row, x, 0, bit_depth, 1));         return;            case PNG_COLOR_TYPE_PALETTE:         {            PNG_CONST unsigned int index = component(row, x, 0, bit_depth, 1);            png_colorp palette = NULL;            int num_palette = 0;            if ((png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette) &               PNG_INFO_PLTE) && num_palette > 0 && palette != NULL)            {               png_bytep trans_alpha = NULL;               int num_trans = 0;               if ((png_get_tRNS(png_ptr, info_ptr, &trans_alpha, &num_trans,                  NULL) & PNG_INFO_tRNS) && num_trans > 0 &&                  trans_alpha != NULL)                  printf(\"INDEXED %u = %d %d %d %d\\n\", index,                     palette[index].red, palette[index].green,                     palette[index].blue,                     index < num_trans ? trans_alpha[index] : 255);               else                   printf(\"INDEXED %u = %d %d %d\\n\", index,                     palette[index].red, palette[index].green,                     palette[index].blue);            }            else               printf(\"INDEXED %u = invalid index\\n\", index);         }         return;      case PNG_COLOR_TYPE_RGB:         printf(\"RGB %u %u %u\\n\", component(row, x, 0, bit_depth, 3),            component(row, x, 1, bit_depth, 3),            component(row, x, 2, bit_depth, 3));         return;      case PNG_COLOR_TYPE_GRAY_ALPHA:         printf(\"GRAY+ALPHA %u %u\\n\", component(row, x, 0, bit_depth, 2),            component(row, x, 1, bit_depth, 2));         return;      case PNG_COLOR_TYPE_RGB_ALPHA:         printf(\"RGBA %u %u %u %u\\n\", component(row, x, 0, bit_depth, 4),            component(row, x, 1, bit_depth, 4),            component(row, x, 2, bit_depth, 4),            component(row, x, 3, bit_depth, 4));         return;      default:         png_error(png_ptr, \"invalid color type\");   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidIDAT_list_init(struct IDAT_list *list){   CLEAR(*list);   list->next = NULL;   list->length = IDAT_INIT_LENGTH;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_ag8(Pixel *p, png_const_voidp pb){   png_const_bytep pp = voidcast(png_const_bytep, pb);   p->r = p->g = p->b = pp[1];   p->a = pp[0];}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PngFileInitialize (HWND hwnd){    static TCHAR szFilter[] = TEXT (\"PNG Files (*.PNG)\\0*.png\\0\")        TEXT (\"All Files (*.*)\\0*.*\\0\\0\");    ofn.lStructSize       = sizeof (OPENFILENAME);    ofn.hwndOwner         = hwnd;    ofn.hInstance         = NULL;    ofn.lpstrFilter       = szFilter;    ofn.lpstrCustomFilter = NULL;    ofn.nMaxCustFilter    = 0;    ofn.nFilterIndex      = 0;    ofn.lpstrFile         = NULL;              ofn.nMaxFile          = MAX_PATH;    ofn.lpstrFileTitle    = NULL;              ofn.nMaxFileTitle     = MAX_PATH;    ofn.lpstrInitialDir   = NULL;    ofn.lpstrTitle        = NULL;    ofn.Flags             = 0;                 ofn.nFileOffset       = 0;    ofn.nFileExtension    = 0;    ofn.lpstrDefExt       = TEXT (\"png\");    ofn.lCustData         = 0;    ofn.lpfnHook          = NULL;    ofn.lpTemplateName    = NULL;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "LRESULT CALLBACK rpng_win_wndproc(HWND hwnd, UINT iMsg, WPARAM wP, LPARAM lP){    HDC         hdc;    PAINTSTRUCT ps;    int rc;    switch (iMsg) {        case WM_CREATE:                        return 0;        case WM_PAINT:            hdc = BeginPaint(hwnd, &ps);                                rc = StretchDIBits(hdc, 0, 0, image_width, image_height,                                                        0, 0, image_width, image_height,                                    wimage_data, (BITMAPINFO *)bmih,                                                        0, SRCCOPY);            EndPaint(hwnd, &ps);            return 0;                case WM_CHAR:            switch (wP) {                      case 'q':                case 'Q':                case 0x1B:                         PostQuitMessage(0);            }            return 0;        case WM_LBUTTONDOWN:           case WM_DESTROY:            PostQuitMessage(0);            return 0;    }    return DefWindowProc(hwnd, iMsg, wP, lP);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_progressive_read(png_store *ps, png_structp pp, png_infop pi){      if (ps->pread != pp || ps->current == NULL || ps->next == NULL)      png_error(pp, \"store state damaged (progressive)\");   do   {      if (ps->readpos != 0)         png_error(pp, \"store_read called during progressive read\");      png_process_data(pp, pi, ps->next->buffer, store_read_buffer_size(ps));   }   while (store_read_buffer_next(ps));}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidmodifier_setbuffer(png_modifier *pm){   modifier_crc(pm->buffer);   pm->buffer_count = png_get_uint_32(pm->buffer)+12;   pm->buffer_position = 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static double pcerr(PNG_CONST png_modifier *pm, int in_depth, int out_depth){      if (pm->assume_16_bit_calculations ||      (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)      return pm->maxpc16 * .01;   else      return pm->maxpc8 * .01;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int wpng_isvalid_latin1(uch *p, int len){    int i, result = -1;    for (i = 0;  i < len;  ++i) {        if (p[i] == 10 || (p[i] > 31 && p[i] < 127) || p[i] > 160)            continue;                   if (result < 0 || (p[result] != 27 && p[i] == 27))            result = i;             }                               return result;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intsbit_modify(png_modifier *pm, png_modification *me, int add){   png_byte sbit = ((sbit_modification*)me)->sbit;   if (pm->bit_depth > sbit)   {      int cb = 0;      switch (pm->colour_type)      {         case 0:            cb = 1;            break;         case 2:         case 3:            cb = 3;            break;         case 4:            cb = 2;            break;         case 6:            cb = 4;            break;         default:            png_error(pm->this.pread,               \"unexpected colour type in sBIT modification\");      }      png_save_uint_32(pm->buffer, cb);      png_save_uint_32(pm->buffer+4, CHUNK_sBIT);      while (cb > 0)         (pm->buffer+8)[--cb] = sbit;      return 1;   }   else if (!add)   {            pm->buffer_count = pm->buffer_position = 0;      return 1;   }   else      return 0; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static void PNGCBAPIstore_read(png_structp ppIn, png_bytep pb, png_size_t st){   png_const_structp pp = ppIn;   png_store *ps = voidcast(png_store*, png_get_io_ptr(pp));   if (ps == NULL || ps->pread != pp)      png_error(pp, \"bad store read call\");   store_read_imp(ps, pb, st);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstore_storefile(png_store *ps, png_uint_32 id){   png_store_file *pf = voidcast(png_store_file*, malloc(sizeof *pf));   if (pf == NULL)      png_error(ps->pwrite, \"storefile: OOM\");   safecat(pf->name, sizeof pf->name, 0, ps->wname);   pf->id = id;   pf->data = ps->new;   pf->datacount = ps->writepos;   ps->new.prev = NULL;   ps->writepos = 0;   pf->palette = ps->palette;   pf->npalette = ps->npalette;   ps->palette = 0;   ps->npalette = 0;      pf->next = ps->saved;   ps->saved = pf;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "intmain(void){   fwrite(signature, sizeof signature, 1, stdout);   put_chunk(IHDR, sizeof IHDR);   for (;;)      put_chunk(unknown, sizeof unknown);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "int png_set_text_2(png_structp png_ptr, png_infop info_ptr,    png_const_textp text_ptr, int num_text){   int i;   png_debug1(1, \"in %s storage function\", ((png_ptr == NULL ||       png_ptr->chunk_name[0] == '\\0') ?       \"text\" : (png_const_charp)png_ptr->chunk_name));   if (png_ptr == NULL || info_ptr == NULL || num_text == 0)      return(0);      if (info_ptr->num_text + num_text > info_ptr->max_text)   {      if (info_ptr->text != NULL)      {         png_textp old_text;         int old_max;         old_max = info_ptr->max_text;         info_ptr->max_text = info_ptr->num_text + num_text + 8;         old_text = info_ptr->text;         info_ptr->text = (png_textp)png_malloc_warn(png_ptr,            (png_size_t)(info_ptr->max_text * png_sizeof(png_text)));         if (info_ptr->text == NULL)         {            png_free(png_ptr, old_text);            return(1);         }         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max *             png_sizeof(png_text)));         png_free(png_ptr, old_text);      }      else      {         info_ptr->max_text = num_text + 8;         info_ptr->num_text = 0;         info_ptr->text = (png_textp)png_malloc_warn(png_ptr,             (png_size_t)(info_ptr->max_text * png_sizeof(png_text)));         if (info_ptr->text == NULL)            return(1);         info_ptr->free_me |= PNG_FREE_TEXT;      }      png_debug1(3, \"allocated %d entries for info_ptr->text\",          info_ptr->max_text);   }   for (i = 0; i < num_text; i++)   {      png_size_t text_length, key_len;      png_size_t lang_len, lang_key_len;      png_textp textp = &(info_ptr->text[info_ptr->num_text]);      if (text_ptr[i].key == NULL)          continue;      if (text_ptr[i].compression < PNG_TEXT_COMPRESSION_NONE ||          text_ptr[i].compression >= PNG_TEXT_COMPRESSION_LAST)      {         png_warning(png_ptr, \"text compression mode is out of range\");         continue;      }      key_len = png_strlen(text_ptr[i].key);      if (text_ptr[i].compression <= 0)      {         lang_len = 0;         lang_key_len = 0;      }      else#  ifdef PNG_iTXt_SUPPORTED      {                  if (text_ptr[i].lang != NULL)            lang_len = png_strlen(text_ptr[i].lang);         else            lang_len = 0;         if (text_ptr[i].lang_key != NULL)            lang_key_len = png_strlen(text_ptr[i].lang_key);         else            lang_key_len = 0;      }#  else       {         png_warning(png_ptr, \"iTXt chunk not supported\");         continue;      }#  endif      if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\\0')      {         text_length = 0;#  ifdef PNG_iTXt_SUPPORTED         if (text_ptr[i].compression > 0)            textp->compression = PNG_ITXT_COMPRESSION_NONE;         else#  endif            textp->compression = PNG_TEXT_COMPRESSION_NONE;      }      else      {         text_length = png_strlen(text_ptr[i].text);         textp->compression = text_ptr[i].compression;      }      textp->key = (png_charp)png_malloc_warn(png_ptr,          (png_size_t)          (key_len + text_length + lang_len + lang_key_len + 4));      if (textp->key == NULL)         return(1);      png_debug2(2, \"Allocated %lu bytes at %p in png_set_text\",          (unsigned long)(png_uint_32)          (key_len + lang_len + lang_key_len + text_length + 4),          textp->key);      png_memcpy(textp->key, text_ptr[i].key,(png_size_t)(key_len));      *(textp->key + key_len) = '\\0';      if (text_ptr[i].compression > 0)      {         textp->lang = textp->key + key_len + 1;         png_memcpy(textp->lang, text_ptr[i].lang, lang_len);         *(textp->lang + lang_len) = '\\0';         textp->lang_key = textp->lang + lang_len + 1;         png_memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);         *(textp->lang_key + lang_key_len) = '\\0';         textp->text = textp->lang_key + lang_key_len + 1;      }      else      {         textp->lang=NULL;         textp->lang_key=NULL;         textp->text = textp->key + key_len + 1;      }      if (text_length)         png_memcpy(textp->text, text_ptr[i].text,             (png_size_t)(text_length));      *(textp->text + text_length) = '\\0';#  ifdef PNG_iTXt_SUPPORTED      if (textp->compression > 0)      {         textp->text_length = 0;         textp->itxt_length = text_length;      }      else#  endif      {         textp->text_length = text_length;         textp->itxt_length = 0;      }      info_ptr->num_text++;      png_debug1(3, \"transferred text chunk %d\", info_ptr->num_text);   }   return(0);}#endif",
        "label": 1,
        "cve": "cve-2013-7354-2"
    },
    {
        "code": "int main(int argc, const char **argv){      volatile int result = 1;   if (argc == 4)   {      long x = atol(argv[1]);      long y = atol(argv[2]);      FILE *f = fopen(argv[3], \"rb\");      volatile png_bytep row = NULL;      if (f != NULL)      {                  png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,            NULL, NULL, NULL);         if (png_ptr != NULL)         {            png_infop info_ptr = png_create_info_struct(png_ptr);            if (info_ptr != NULL)            {                                             if (setjmp(png_jmpbuf(png_ptr)) == 0)               {                  png_uint_32 width, height;                  int bit_depth, color_type, interlace_method,                     compression_method, filter_method;                  png_bytep row_tmp;                                    png_init_io(png_ptr, f);                                    png_read_info(png_ptr, info_ptr);                                    row = png_malloc(png_ptr, png_get_rowbytes(png_ptr,                     info_ptr));                                    row_tmp = row;                                    if (png_get_IHDR(png_ptr, info_ptr, &width, &height,                     &bit_depth, &color_type, &interlace_method,                     &compression_method, &filter_method))                  {                     int passes, pass;                                          switch (interlace_method)                     {                        case PNG_INTERLACE_NONE:                           passes = 1;                           break;                        case PNG_INTERLACE_ADAM7:                           passes = PNG_INTERLACE_ADAM7_PASSES;                           break;                        default:                           png_error(png_ptr, \"pngpixel: unknown interlace\");                     }                                          png_start_read_image(png_ptr);                     for (pass=0; pass<passes; ++pass)                     {                        png_uint_32 ystart, xstart, ystep, xstep;                        png_uint_32 py;                        if (interlace_method == PNG_INTERLACE_ADAM7)                        {                                                      if (PNG_PASS_COLS(width, pass) == 0)                              continue;                                                      xstart = PNG_PASS_START_COL(pass);                           ystart = PNG_PASS_START_ROW(pass);                           xstep = PNG_PASS_COL_OFFSET(pass);                           ystep = PNG_PASS_ROW_OFFSET(pass);                        }                        else                        {                           ystart = xstart = 0;                           ystep = xstep = 1;                        }                                                for (py = ystart; py < height; py += ystep)                        {                           png_uint_32 px, ppx;                                                      png_read_row(png_ptr, row_tmp, NULL);                                                      if (y == py) for (px = xstart, ppx = 0;                              px < width; px += xstep, ++ppx) if (x == px)                           {                                                            print_pixel(png_ptr, info_ptr, row_tmp, ppx);                                                            goto pass_loop_end;                           }                         }                      }                                        pass_loop_end:                     row = NULL;                     png_free(png_ptr, row_tmp);                  }                  else                     png_error(png_ptr, \"pngpixel: png_get_IHDR failed\");               }               else               {                                    if (row != NULL)                  {                                          png_bytep row_tmp = row;                     row = NULL;                     png_free(png_ptr, row_tmp);                  }               }               png_destroy_info_struct(png_ptr, &info_ptr);            }            else               fprintf(stderr, \"pngpixel: out of memory allocating png_info\\n\");            png_destroy_read_struct(&png_ptr, NULL, NULL);         }         else            fprintf(stderr, \"pngpixel: out of memory allocating png_struct\\n\");      }      else         fprintf(stderr, \"pngpixel: %s: could not open file\\n\", argv[3]);   }   else            fprintf(stderr, \"pngpixel: usage: pngpixel x y png-file\\n\");   return result;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "format_list;static void format_init(format_list *pf){   int i;   for (i=0; i<FORMAT_SET_COUNT; ++i)      pf->bits[i] = 0; }",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static int write_png(const char **name, FILE *fp, int color_type, int bit_depth,   volatile png_fixed_point gamma, chunk_insert * volatile insert,   unsigned int filters, unsigned int *colors){   png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,      name, makepng_error, makepng_warning);   volatile png_infop info_ptr = NULL;   volatile png_bytep row = NULL;   if (png_ptr == NULL)   {      fprintf(stderr, \"makepng: OOM allocating write structure\\n\");      return 1;   }   if (setjmp(png_jmpbuf(png_ptr)))   {      png_structp nv_ptr = png_ptr;      png_infop nv_info = info_ptr;      png_ptr = NULL;      info_ptr = NULL;      png_destroy_write_struct(&nv_ptr, &nv_info);      if (row != NULL) free(row);      return 1;   }      png_set_benign_errors(png_ptr, 1);   png_init_io(png_ptr, fp);   info_ptr = png_create_info_struct(png_ptr);   if (info_ptr == NULL)      png_error(png_ptr, \"OOM allocating info structure\");   {      unsigned int size = image_size_of_type(color_type, bit_depth, colors);      png_fixed_point real_gamma = 45455;       png_byte gamma_table[256];      double conv;            if (gamma == PNG_GAMMA_MAC_18)         gamma = 65909;      else if (gamma > 0 && gamma < 1000)         gamma = PNG_FP_1;      if (gamma > 0)         real_gamma = gamma;      {         unsigned int i;         if (real_gamma == 45455) for (i=0; i<256; ++i)         {            gamma_table[i] = (png_byte)i;            conv = 1.;         }         else         {                        conv = real_gamma;            conv /= 45455;            gamma_table[0] = 0;            for (i=1; i<255; ++i)               gamma_table[i] = (png_byte)floor(pow(i/255.,conv) * 255 + .5);            gamma_table[255] = 255;         }      }      png_set_IHDR(png_ptr, info_ptr, size, size, bit_depth, color_type,         PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);      if (color_type & PNG_COLOR_MASK_PALETTE)      {         int npalette;         png_color palette[256];         png_byte trans[256];         npalette = generate_palette(palette, trans, bit_depth, gamma_table,            colors);         png_set_PLTE(png_ptr, info_ptr, palette, npalette);         png_set_tRNS(png_ptr, info_ptr, trans, npalette-1,            NULL);                  for (npalette=0; npalette<256; ++npalette)            gamma_table[npalette] = (png_byte)npalette;      }      if (gamma == PNG_DEFAULT_sRGB)         png_set_sRGB(png_ptr, info_ptr, PNG_sRGB_INTENT_ABSOLUTE);      else if (gamma > 0)       {         png_set_gAMA_fixed(png_ptr, info_ptr, real_gamma);                  png_set_cHRM_fixed(png_ptr, info_ptr,                         31270, 32900,             64000, 33000,             30000, 60000,             15000,  6000         );      }            while (insert != NULL)      {         insert->insert(png_ptr, info_ptr, insert->nparams, insert->parameters);         insert = insert->next;      }            png_write_info(png_ptr, info_ptr);            png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE, filters);      {         int passes = png_set_interlace_handling(png_ptr);         int pass;         png_size_t rowbytes = png_get_rowbytes(png_ptr, info_ptr);         row = malloc(rowbytes);         if (row == NULL)            png_error(png_ptr, \"OOM allocating row buffer\");         for (pass = 0; pass < passes; ++pass)         {            unsigned int y;            for (y=0; y<size; ++y)            {               generate_row(row, rowbytes, y, color_type, bit_depth,                  gamma_table, conv, colors);               png_write_row(png_ptr, row);            }         }      }   }      png_write_end(png_ptr, info_ptr);   {      png_structp nv_ptr = png_ptr;      png_infop nv_info = info_ptr;      png_ptr = NULL;      info_ptr = NULL;      png_destroy_write_struct(&nv_ptr, &nv_info);   }   free(row);   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_uint_32get_unknown(display *d, png_infop info_ptr, int after_IDAT){      png_uint_32 flags = 0;   UNUSED(after_IDAT)   {      png_unknown_chunkp unknown;      int num_unknown = png_get_unknown_chunks(d->png_ptr, info_ptr, &unknown);      while (--num_unknown >= 0)      {         int chunk = findb(unknown[num_unknown].name);                  if (chunk < 0) switch (d->keep)         {            default:             case PNG_HANDLE_CHUNK_AS_DEFAULT:            case PNG_HANDLE_CHUNK_NEVER:               fprintf(stderr, \"%s(%s): %s: %s: unknown chunk saved\\n\",                  d->file, d->test, d->keep ? \"discard\" : \"default\",                  unknown[num_unknown].name);               ++(d->error_count);               break;            case PNG_HANDLE_CHUNK_IF_SAFE:               if (!ancillaryb(unknown[num_unknown].name))               {                  fprintf(stderr,                     \"%s(%s): if-safe: %s: unknown critical chunk saved\\n\",                     d->file, d->test, unknown[num_unknown].name);                  ++(d->error_count);                  break;               }                           case PNG_HANDLE_CHUNK_ALWAYS:               break;         }         else            flags |= chunk_info[chunk].flag;      }   }   return flags;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voiduarb_printx(uarb num, int digits, FILE *out)   {   while (digits > 0)      if (num[--digits] > 0)      {         fprintf(out, \"0x%x\", num[digits]);         while (digits > 0)            fprintf(out, \"%.4x\", num[--digits]);      }      else if (digits == 0)          fputs(\"0x0\", out);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_strip_16_set(PNG_CONST image_transform *this,    transform_display *that, png_structp pp, png_infop pi){   png_set_strip_16(pp);   this->next->set(this->next, that, pp, pi);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static double calcerr(PNG_CONST png_modifier *pm, int in_depth, int out_depth){      if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16)      return pm->maxcalc16;   else if (pm->assume_16_bit_calculations)      return pm->maxcalcG;   else      return pm->maxcalc8;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidstandard_text_validate(standard_display *dp, png_const_structp pp,   png_infop pi, int check_end){   png_textp tp = NULL;   png_uint_32 num_text = png_get_text(pp, pi, &tp, NULL);   if (num_text == 2 && tp != NULL)   {      standard_check_text(pp, tp, \"image name\", dp->ps->current->name);            if (check_end)         standard_check_text(pp, tp+1, \"end marker\", \"end\");   }   else   {      char msg[64];      sprintf(msg, \"expected two text items, got %lu\",         (unsigned long)num_text);      png_error(pp, msg);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intcmppixel(Transform *transform, png_const_voidp in, png_const_voidp out,   png_uint_32 x, png_uint_32 y){   int maxerr;   png_const_charp errmsg;   Pixel pixel_in, pixel_calc, pixel_out;   transform->in_gp(&pixel_in, in);   if (transform->from_linear == NULL)      transform->transform(&pixel_calc, &pixel_in, transform->background);   else   {      transform->transform(&pixel_out, &pixel_in, transform->background);      transform->from_linear(&pixel_calc, &pixel_out, NULL);   }   transform->out_gp(&pixel_out, out);      if (pixel_calc.a == pixel_out.a && pixel_calc.r == pixel_out.r &&      pixel_calc.g == pixel_out.g && pixel_calc.b == pixel_out.b)      return 1;      if (transform->output_8bit && pixel_calc.a == 0 && pixel_out.a == 0)      return 1;      errmsg = NULL;   {      int err_a = abs(pixel_calc.a-pixel_out.a);      if (err_a > transform->error[3])      {                  if (transform->accumulate)            transform->error[3] = (png_uint_16)err_a;         else            errmsg = \"alpha\";      }   }      if (errmsg == NULL && transform->output_8bit &&      (pixel_calc.a == 0 || pixel_out.a == 0))      return 1;   if (errmsg == NULL)    {      int err_r = abs(pixel_calc.r - pixel_out.r);      int err_g = abs(pixel_calc.g - pixel_out.g);      int err_b = abs(pixel_calc.b - pixel_out.b);      int limit;      if ((err_r | err_g | err_b) == 0)         return 1;             if (pixel_in.a >= transform->in_opaque)      {         errmsg = \"opaque component\";         limit = 2;       }      else if (pixel_in.a > 0)      {         errmsg = \"alpha component\";         limit = 1;       }      else      {         errmsg = \"transparent component (background)\";         limit = 0;       }      maxerr = err_r;      if (maxerr < err_g) maxerr = err_g;      if (maxerr < err_b) maxerr = err_b;      if (maxerr <= transform->error[limit])         return 1;             if (transform->accumulate)      {         transform->error[limit] = (png_uint_16)maxerr;         return 1;       }   }      return logpixel(transform, x, y, &pixel_in, &pixel_calc, &pixel_out, errmsg);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "BOOL PngFileSaveDlg (HWND hwnd, PTSTR pstrFileName, PTSTR pstrTitleName){    ofn.hwndOwner         = hwnd;    ofn.lpstrFile         = pstrFileName;    ofn.lpstrFileTitle    = pstrTitleName;    ofn.Flags             = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;    return GetSaveFileName (&ofn);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_ini_end(PNG_CONST image_transform *this,   transform_display *that){   UNUSED(this)   UNUSED(that)}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgp_ag16(Pixel *p, png_const_voidp pb){   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);   p->r = p->g = p->b = pp[1];   p->a = pp[0];}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void *png_far_to_near(png_structp png_ptr, png_voidp ptr, int check){   void *near_ptr;   void FAR *far_ptr;   FP_OFF(near_ptr) = FP_OFF(ptr);   far_ptr = (void FAR *)near_ptr;   if (check != 0)      if (FP_SEG(ptr) != FP_SEG(far_ptr))         png_error(png_ptr, \"segment lost in conversion\");   return(near_ptr);}}void *png_far_to_near(png_structp png_ptr, png_voidp ptr, int check){   void *near_ptr;   void FAR *far_ptr;   near_ptr = (void FAR *)ptr;   far_ptr = (void FAR *)near_ptr;   if (check != 0)      if (far_ptr != ptr)         png_error(png_ptr, \"segment lost in conversion\");   return(near_ptr);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void PNGAPIpng_read_row(png_structrp png_ptr, png_bytep row, png_bytep dsp_row){   png_row_info row_info;   if (png_ptr == NULL)      return;   png_debug2(1, \"in png_read_row (row %lu, pass %d)\",       (unsigned long)png_ptr->row_number, png_ptr->pass);      if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))      png_read_start_row(png_ptr);      row_info.width = png_ptr->iwidth;    row_info.color_type = png_ptr->color_type;   row_info.bit_depth = png_ptr->bit_depth;   row_info.channels = png_ptr->channels;   row_info.pixel_depth = png_ptr->pixel_depth;   row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width);   if (png_ptr->row_number == 0 && png_ptr->pass == 0)   {   #if defined(PNG_WRITE_INVERT_SUPPORTED) && !defined(PNG_READ_INVERT_SUPPORTED)   if (png_ptr->transformations & PNG_INVERT_MONO)      png_warning(png_ptr, \"PNG_READ_INVERT_SUPPORTED is not defined\");#endif#if defined(PNG_WRITE_FILLER_SUPPORTED) && !defined(PNG_READ_FILLER_SUPPORTED)   if (png_ptr->transformations & PNG_FILLER)      png_warning(png_ptr, \"PNG_READ_FILLER_SUPPORTED is not defined\");#endif#if defined(PNG_WRITE_PACKSWAP_SUPPORTED) && \\    !defined(PNG_READ_PACKSWAP_SUPPORTED)   if (png_ptr->transformations & PNG_PACKSWAP)      png_warning(png_ptr, \"PNG_READ_PACKSWAP_SUPPORTED is not defined\");#endif#if defined(PNG_WRITE_PACK_SUPPORTED) && !defined(PNG_READ_PACK_SUPPORTED)   if (png_ptr->transformations & PNG_PACK)      png_warning(png_ptr, \"PNG_READ_PACK_SUPPORTED is not defined\");#endif#if defined(PNG_WRITE_SHIFT_SUPPORTED) && !defined(PNG_READ_SHIFT_SUPPORTED)   if (png_ptr->transformations & PNG_SHIFT)      png_warning(png_ptr, \"PNG_READ_SHIFT_SUPPORTED is not defined\");#endif#if defined(PNG_WRITE_BGR_SUPPORTED) && !defined(PNG_READ_BGR_SUPPORTED)   if (png_ptr->transformations & PNG_BGR)      png_warning(png_ptr, \"PNG_READ_BGR_SUPPORTED is not defined\");#endif#if defined(PNG_WRITE_SWAP_SUPPORTED) && !defined(PNG_READ_SWAP_SUPPORTED)   if (png_ptr->transformations & PNG_SWAP_BYTES)      png_warning(png_ptr, \"PNG_READ_SWAP_SUPPORTED is not defined\");#endif   }#ifdef PNG_READ_INTERLACING_SUPPORTED      if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE))   {      switch (png_ptr->pass)      {         case 0:            if (png_ptr->row_number & 0x07)            {               if (dsp_row != NULL)                  png_combine_row(png_ptr, dsp_row, 1);               png_read_finish_row(png_ptr);               return;            }            break;         case 1:            if ((png_ptr->row_number & 0x07) || png_ptr->width < 5)            {               if (dsp_row != NULL)                  png_combine_row(png_ptr, dsp_row, 1);               png_read_finish_row(png_ptr);               return;            }            break;         case 2:            if ((png_ptr->row_number & 0x07) != 4)            {               if (dsp_row != NULL && (png_ptr->row_number & 4))                  png_combine_row(png_ptr, dsp_row, 1);               png_read_finish_row(png_ptr);               return;            }            break;         case 3:            if ((png_ptr->row_number & 3) || png_ptr->width < 3)            {               if (dsp_row != NULL)                  png_combine_row(png_ptr, dsp_row, 1);               png_read_finish_row(png_ptr);               return;            }            break;         case 4:            if ((png_ptr->row_number & 3) != 2)            {               if (dsp_row != NULL && (png_ptr->row_number & 2))                  png_combine_row(png_ptr, dsp_row, 1);               png_read_finish_row(png_ptr);               return;            }            break;         case 5:            if ((png_ptr->row_number & 1) || png_ptr->width < 2)            {               if (dsp_row != NULL)                  png_combine_row(png_ptr, dsp_row, 1);               png_read_finish_row(png_ptr);               return;            }            break;         default:         case 6:            if (!(png_ptr->row_number & 1))            {               png_read_finish_row(png_ptr);               return;            }            break;      }   }#endif   if (!(png_ptr->mode & PNG_HAVE_IDAT))      png_error(png_ptr, \"Invalid attempt to read row data\");      png_read_IDAT_data(png_ptr, png_ptr->row_buf, row_info.rowbytes + 1);   if (png_ptr->row_buf[0] > PNG_FILTER_VALUE_NONE)   {      if (png_ptr->row_buf[0] < PNG_FILTER_VALUE_LAST)         png_read_filter_row(png_ptr, &row_info, png_ptr->row_buf + 1,            png_ptr->prev_row + 1, png_ptr->row_buf[0]);      else         png_error(png_ptr, \"bad adaptive filter value\");   }      memcpy(png_ptr->prev_row, png_ptr->row_buf, row_info.rowbytes + 1);#ifdef PNG_MNG_FEATURES_SUPPORTED   if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&       (png_ptr->filter_type == PNG_INTRAPIXEL_DIFFERENCING))   {            png_do_read_intrapixel(&row_info, png_ptr->row_buf + 1);   }#endif#ifdef PNG_READ_TRANSFORMS_SUPPORTED   if (png_ptr->transformations)      png_do_read_transformations(png_ptr, &row_info);#endif      if (png_ptr->transformed_pixel_depth == 0)   {      png_ptr->transformed_pixel_depth = row_info.pixel_depth;      if (row_info.pixel_depth > png_ptr->maximum_pixel_depth)         png_error(png_ptr, \"sequential row overflow\");   }   else if (png_ptr->transformed_pixel_depth != row_info.pixel_depth)      png_error(png_ptr, \"internal sequential row size calculation error\");#ifdef PNG_READ_INTERLACING_SUPPORTED      if (png_ptr->interlaced &&      (png_ptr->transformations & PNG_INTERLACE))   {      if (png_ptr->pass < 6)         png_do_read_interlace(&row_info, png_ptr->row_buf + 1, png_ptr->pass,            png_ptr->transformations);      if (dsp_row != NULL)         png_combine_row(png_ptr, dsp_row, 1);      if (row != NULL)         png_combine_row(png_ptr, row, 0);   }   else#endif   {      if (row != NULL)         png_combine_row(png_ptr, row, -1);      if (dsp_row != NULL)         png_combine_row(png_ptr, dsp_row, -1);   }   png_read_finish_row(png_ptr);   if (png_ptr->read_row_fn != NULL)      (*(png_ptr->read_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);}#endif ",
        "label": 1,
        "cve": "cve-2014-9495"
    },
    {
        "code": "static png_uint_32png_pass_start_row(int pass){   int x, y;   ++pass;   for (y=0; y<8; ++y) for (x=0; x<8; ++x) if (adam7[y][x] == pass)      return y;   return 0xf;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "BOOL PngFileOpenDlg (HWND hwnd, PTSTR pstrFileName, PTSTR pstrTitleName){    ofn.hwndOwner         = hwnd;    ofn.lpstrFile         = pstrFileName;    ofn.lpstrFileTitle    = pstrTitleName;    ofn.Flags             = OFN_HIDEREADONLY;    return GetOpenFileName (&ofn);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidtransform_disable(PNG_CONST char *name){   image_transform *list = image_transform_first;   while (list != &image_transform_end)   {      if (strcmp(list->name, name) == 0)      {         list->enable = 0;         return;      }      list = list->list;   }   fprintf(stderr, \"pngvalid: --transform-disable=%s: unknown transform\\n\",      name);   exit(99);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidrow_copy(png_bytep toBuffer, png_const_bytep fromBuffer, unsigned int bitWidth){   memcpy(toBuffer, fromBuffer, bitWidth >> 3);   if ((bitWidth & 7) != 0)   {      unsigned int mask;      toBuffer += bitWidth >> 3;      fromBuffer += bitWidth >> 3;            mask = 0xff >> (bitWidth & 7);      *toBuffer = (png_byte)((*toBuffer & mask) | (*fromBuffer & ~mask));   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static png_size_tload_fake(png_charp param, png_bytepp profile){   char *endptr = NULL;   unsigned long long int size = strtoull(param, &endptr, 0);      if (endptr != NULL && *endptr == '*')   {      size_t len = strlen(++endptr);      size_t result = (size_t)size;      if (len == 0) len = 1;             if (result == size && (*profile = malloc(result)) != NULL)      {         png_bytep out = *profile;         if (len == 1)            memset(out, *endptr, result);         else         {            while (size >= len)            {               memcpy(out, endptr, len);               out += len;               size -= len;            }            memcpy(out, endptr, size);         }         return result;      }      else      {         fprintf(stderr, \"%s: size exceeds system limits\\n\", param);         exit(1);      }   }   return 0;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": " * scales values to 8-bit if necessary */int readpng_get_bgcolor(uch *red, uch *green, uch *blue){    return 1;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidimage_transform_png_set_@_mod(PNG_CONST image_transform *this,    image_pixel *that, png_const_structp pp,    PNG_CONST transform_display *display){   this->next->mod(this->next, that, pp, display);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidsummarize_gamma_errors(png_modifier *pm, png_const_charp who, int low_bit_depth,   int indexed){   fflush(stderr);   if (who)      printf(\"\\nGamma correction with %s:\\n\", who);   else      printf(\"\\nBasic gamma correction:\\n\");   if (low_bit_depth)   {      print_one(\" 2 bit gray: \", pm->error_gray_2);      print_one(\" 4 bit gray: \", pm->error_gray_4);      print_one(\" 8 bit gray: \", pm->error_gray_8);      print_one(\" 8 bit color:\", pm->error_color_8);      if (indexed)         print_one(\" indexed:    \", pm->error_indexed);   }   print_one(\"16 bit gray: \", pm->error_gray_16);   print_one(\"16 bit color:\", pm->error_color_16);   fflush(stdout);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_preq(Pixel *out, const Pixel *in, const Background *back){   (void)back;   out->r = ilineara(in->r, in->a);   if (in->g == in->r)   {      out->g = out->r;      if (in->b == in->r)         out->b = out->r;      else         out->b = ilineara(in->b, in->a);   }   else   {      out->g = ilineara(in->g, in->a);      if (in->b == in->r)         out->b = out->r;      else if (in->b == in->g)         out->b = out->g;      else         out->b = ilineara(in->b, in->a);   }   out->a = 65535;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_handle_cHRM(png_structp png_ptr, png_infop info_ptr, png_uint_32 length){   png_byte buf[32];   png_fixed_point x_white, y_white, x_red, y_red, x_green, y_green, x_blue,      y_blue;   png_debug(1, \"in png_handle_cHRM\");   if (!(png_ptr->mode & PNG_HAVE_IHDR))      png_error(png_ptr, \"Missing IHDR before cHRM\");   else if (png_ptr->mode & PNG_HAVE_IDAT)   {      png_warning(png_ptr, \"Invalid cHRM after IDAT\");      png_crc_finish(png_ptr, length);      return;   }   else if (png_ptr->mode & PNG_HAVE_PLTE)            png_warning(png_ptr, \"Missing PLTE before cHRM\");   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM)#  ifdef PNG_READ_sRGB_SUPPORTED       && !(info_ptr->valid & PNG_INFO_sRGB)#  endif      )   {      png_warning(png_ptr, \"Duplicate cHRM chunk\");      png_crc_finish(png_ptr, length);      return;   }   if (length != 32)   {      png_warning(png_ptr, \"Incorrect cHRM chunk length\");      png_crc_finish(png_ptr, length);      return;   }   png_crc_read(png_ptr, buf, 32);   if (png_crc_finish(png_ptr, 0))      return;   x_white = png_get_fixed_point(NULL, buf);   y_white = png_get_fixed_point(NULL, buf + 4);   x_red   = png_get_fixed_point(NULL, buf + 8);   y_red   = png_get_fixed_point(NULL, buf + 12);   x_green = png_get_fixed_point(NULL, buf + 16);   y_green = png_get_fixed_point(NULL, buf + 20);   x_blue  = png_get_fixed_point(NULL, buf + 24);   y_blue  = png_get_fixed_point(NULL, buf + 28);   if (x_white == PNG_FIXED_ERROR ||       y_white == PNG_FIXED_ERROR ||       x_red   == PNG_FIXED_ERROR ||       y_red   == PNG_FIXED_ERROR ||       x_green == PNG_FIXED_ERROR ||       y_green == PNG_FIXED_ERROR ||       x_blue  == PNG_FIXED_ERROR ||       y_blue  == PNG_FIXED_ERROR)   {      png_warning(png_ptr, \"Ignoring cHRM chunk with negative chromaticities\");      return;   }#ifdef PNG_READ_sRGB_SUPPORTED   if ((info_ptr != NULL) && (info_ptr->valid & PNG_INFO_sRGB))   {      if (PNG_OUT_OF_RANGE(x_white, 31270,  1000) ||          PNG_OUT_OF_RANGE(y_white, 32900,  1000) ||          PNG_OUT_OF_RANGE(x_red,   64000L, 1000) ||          PNG_OUT_OF_RANGE(y_red,   33000,  1000) ||          PNG_OUT_OF_RANGE(x_green, 30000,  1000) ||          PNG_OUT_OF_RANGE(y_green, 60000L, 1000) ||          PNG_OUT_OF_RANGE(x_blue,  15000,  1000) ||          PNG_OUT_OF_RANGE(y_blue,   6000,  1000))      {         PNG_WARNING_PARAMETERS(p)         png_warning_parameter_signed(p, 1, PNG_NUMBER_FORMAT_fixed, x_white);         png_warning_parameter_signed(p, 2, PNG_NUMBER_FORMAT_fixed, y_white);         png_warning_parameter_signed(p, 3, PNG_NUMBER_FORMAT_fixed, x_red);         png_warning_parameter_signed(p, 4, PNG_NUMBER_FORMAT_fixed, y_red);         png_warning_parameter_signed(p, 5, PNG_NUMBER_FORMAT_fixed, x_green);         png_warning_parameter_signed(p, 6, PNG_NUMBER_FORMAT_fixed, y_green);         png_warning_parameter_signed(p, 7, PNG_NUMBER_FORMAT_fixed, x_blue);         png_warning_parameter_signed(p, 8, PNG_NUMBER_FORMAT_fixed, y_blue);         png_formatted_warning(png_ptr, p,             \"Ignoring incorrect cHRM white(@1,@2) r(@3,@4)g(@5,@6)b(@7,@8) \"             \"when sRGB is also present\");      }      return;   }#endif #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED      if ((png_ptr->transformations & PNG_RGB_TO_GRAY) == 0)   {            if (y_red <= (1<<17) && y_green <= (1<<17) && y_blue <= (1<<17))      {                  png_uint_32 w = y_red + y_green + y_blue;         png_ptr->rgb_to_gray_red_coeff   = (png_uint_16)(((png_uint_32)y_red *            32768)/w);         png_ptr->rgb_to_gray_green_coeff = (png_uint_16)(((png_uint_32)y_green            * 32768)/w);         png_ptr->rgb_to_gray_blue_coeff  = (png_uint_16)(((png_uint_32)y_blue *            32768)/w);      }   }#endif   png_set_cHRM_fixed(png_ptr, info_ptr, x_white, y_white, x_red, y_red,      x_green, y_green, x_blue, y_blue);}",
        "label": 1,
        "cve": "cve-2011-3328"
    },
    {
        "code": "static void PNGCBAPItransform_info(png_structp pp, png_infop pi){   transform_info_imp(voidcast(transform_display*, png_get_progressive_ptr(pp)),      pp, pi);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "doublefinvsRGB(unsigned int i){   return 65535 * linear_from_sRGB(i/255.);}png_uint_16invsRGB(unsigned int i){   unsigned int x = nearbyint(finvsRGB(i));   if (x > 65535)   {      fprintf(stderr, \"invsRGB(%u) overflows to %u\\n\", i, x);      exit(1);   }   return (png_uint_16)x;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static voidgpc_sCp(Pixel *out, const Pixel *in, const Background *back){   (void)back;   if (in->a <= 128)   {      out->r = out->g = out->b = 255;      out->a = 0;   }   else   {      out->r = sRGB((double)in->r / in->a);      out->g = sRGB((double)in->g / in->a);      out->b = sRGB((double)in->b / in->a);      out->a = u8d(in->a / 257.);   }}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "void png_do_strip_filler(png_row_infop row_info, png_bytep row, png_uint_32 flags){   png_debug(1, \"in png_do_strip_filler\\n\");#if defined(PNG_USELESS_TESTS_SUPPORTED)   if (row != NULL && row_info != NULL)#endif   {      png_bytep sp=row;      png_bytep dp=row;      png_uint_32 row_width=row_info->width;      png_uint_32 i;      if (row_info->color_type == PNG_COLOR_TYPE_RGB &&         row_info->channels == 4)      {         if (row_info->bit_depth == 8)         {                        if (flags & PNG_FLAG_FILLER_AFTER)            {               dp+=3; sp+=4;               for (i = 1; i < row_width; i++)               {                  *dp++ = *sp++;                  *dp++ = *sp++;                  *dp++ = *sp++;                  sp++;               }            }                        else            {               for (i = 0; i < row_width; i++)               {                  sp++;                  *dp++ = *sp++;                  *dp++ = *sp++;                  *dp++ = *sp++;               }            }            row_info->pixel_depth = 24;            row_info->rowbytes = row_width * 3;         }         else          {            if (flags & PNG_FLAG_FILLER_AFTER)            {                              sp += 8; dp += 6;               for (i = 1; i < row_width; i++)               {                                    *dp++ = *sp++;                  *dp++ = *sp++;                  *dp++ = *sp++;                  *dp++ = *sp++;                  *dp++ = *sp++;                  *dp++ = *sp++;                  sp += 2;               }            }            else            {                              for (i = 0; i < row_width; i++)               {                                    sp+=2;                  *dp++ = *sp++;                  *dp++ = *sp++;                  *dp++ = *sp++;                  *dp++ = *sp++;                  *dp++ = *sp++;                  *dp++ = *sp++;               }            }            row_info->pixel_depth = 48;            row_info->rowbytes = row_width * 6;         }         row_info->channels = 3;      }      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY &&          row_info->channels == 2)      {         if (row_info->bit_depth == 8)         {                        if (flags & PNG_FLAG_FILLER_AFTER)            {               for (i = 0; i < row_width; i++)               {                  *dp++ = *sp++;                  sp++;               }            }                        else            {               for (i = 0; i < row_width; i++)               {                  sp++;                  *dp++ = *sp++;               }            }            row_info->pixel_depth = 8;            row_info->rowbytes = row_width;         }         else          {            if (flags & PNG_FLAG_FILLER_AFTER)            {                              sp += 4; dp += 2;               for (i = 1; i < row_width; i++)               {                  *dp++ = *sp++;                  *dp++ = *sp++;                  sp += 2;               }            }            else            {                              for (i = 0; i < row_width; i++)               {                  sp += 2;                  *dp++ = *sp++;                  *dp++ = *sp++;               }            }            row_info->pixel_depth = 16;            row_info->rowbytes = row_width * 2;         }         row_info->channels = 1;      }   }}",
        "label": 1,
        "cve": "cve-2006-0481"
    },
    {
        "code": "static png_uint_16ilinear(int fixed_srgb){   return u16d(65535 * sRGB_to_d[fixed_srgb]);}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static struct file *get_control(png_const_structrp png_ptr){      struct control *control = png_voidcast(struct control*,      png_get_error_ptr(png_ptr));   return &control->file;}",
        "label": 0,
        "cve": "none"
    },
    {
        "code": "static intsrgb_modify(png_modifier *pm, png_modification *me, int add){   UNUSED(add)      png_save_uint_32(pm->buffer, 1);   png_save_uint_32(pm->buffer+4, CHUNK_sRGB);   pm->buffer[8] = ((srgb_modification*)me)->intent;   return 1;}",
        "label": 0,
        "cve": "none"
    }
]